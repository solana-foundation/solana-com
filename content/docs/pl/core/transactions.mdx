---
title: Transakcje i instrukcje
description:
  Dowiedz się o transakcjach i instrukcjach w Solanie - podstawowych elementach
  interakcji z blockchainem Solana. Zrozum strukturę transakcji i skład
  instrukcji dzięki praktycznym przykładom.
---

W Solanie użytkownicy wysyłają
[transakcje](/docs/core/transactions#transaction), aby wejść w interakcję z
siecią. Transakcje zawierają jedną lub więcej
[instrukcji](/docs/core/transactions#instruction), które określają operacje do
przetworzenia. Logika wykonania instrukcji jest przechowywana w
[programach](/docs/core/programs) wdrożonych w sieci Solana, gdzie każdy program
definiuje własny zestaw instrukcji.

Poniżej znajdują się kluczowe informacje na temat przetwarzania transakcji w
Solanie:

- Jeśli transakcja zawiera wiele instrukcji, instrukcje są wykonywane w
  kolejności, w jakiej zostały dodane do transakcji.
- Transakcje są "atomowe" - wszystkie instrukcje muszą zostać pomyślnie
  przetworzone, w przeciwnym razie cała transakcja kończy się niepowodzeniem i
  żadne zmiany nie są wprowadzane.

Transakcja to w zasadzie żądanie przetworzenia jednej lub więcej instrukcji.

![Transakcja uproszczona](/assets/docs/core/transactions/transaction-simple.svg)

Transakcja jest jak koperta zawierająca formularze. Każdy formularz to
instrukcja, która mówi sieci, co zrobić. Wysłanie transakcji jest jak wysłanie
koperty, aby formularze zostały przetworzone.

## Kluczowe punkty

- Transakcje w Solanie zawierają instrukcje, które wywołują programy w sieci.
- Transakcje są **atomowe** - jeśli jakakolwiek instrukcja zakończy się
  niepowodzeniem, cała transakcja kończy się niepowodzeniem i żadne zmiany nie
  są wprowadzane.
- Instrukcje w transakcji są wykonywane w kolejności sekwencyjnej.
- Limit rozmiaru transakcji wynosi
  [1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
  bajtów.
- Każda instrukcja wymaga trzech elementów informacji:
  1. Adres programu do wywołania
  2. Konta, z których instrukcja odczytuje lub na które zapisuje
  3. Dodatkowe dane wymagane przez instrukcję (np. argumenty funkcji)

## Przykład transferu SOL

Poniższy diagram przedstawia transakcję z pojedynczą instrukcją transferu SOL od
nadawcy do odbiorcy.

Na Solanie "portfele" to konta należące do
[System Program](/docs/core/accounts#system-program). Tylko właściciel programu
może zmieniać dane konta, więc transfer SOL wymaga wysłania transakcji w celu
wywołania System Program.

![Transfer SOL](/assets/docs/core/transactions/sol-transfer.svg)

Konto nadawcy musi podpisać (`is_signer`) transakcję, aby System Program mógł
odjąć saldo lamportów. Konta nadawcy i odbiorcy muszą być zapisywalne
(`is_writable`), ponieważ ich salda lamportów ulegają zmianie.

Po wysłaniu transakcji System Program przetwarza instrukcję transferu. Następnie
System Program aktualizuje salda lamportów zarówno konta nadawcy, jak i
odbiorcy.

![Proces transferu SOL](/assets/docs/core/transactions/sol-transfer-process.svg)

Poniższe przykłady pokazują, jak wysłać transakcję, która przenosi SOL z jednego
konta na drugie.

<CodeTabs flags="r">

---CODE-PLACEHOLDER-43a8318b4ffc43a6d0c4709712111bb5---

---CODE-PLACEHOLDER-d6b767ef1f3eebe9468bd51e8bdbbc4c---

---CODE-PLACEHOLDER-413c9cbe9a8479b9433c8822a8835be8---

</CodeTabs>

Biblioteki klienckie często upraszczają szczegóły budowania instrukcji
programów. Jeśli biblioteka nie jest dostępna, możesz ręcznie zbudować
instrukcję. Wymaga to znajomości szczegółów implementacji instrukcji.

Poniższe przykłady pokazują, jak ręcznie zbudować instrukcję transferu. Zakładka
`Expanded Instruction` jest funkcjonalnie równoważna zakładce `Instruction`.

- Kit

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const TRANSFER_INSTRUCTION_INDEX = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(TRANSFER_INSTRUCTION_INDEX, 0);
instructionData.writeBigUInt64LE(transferAmount * LAMPORTS_PER_SOL, 4);

const SYSTEM_PROGRAM_ADDRESS = "11111111111111111111111111111111" as Address;

// Manually create the transfer instruction
const transferInstruction: IInstruction = {
  programAddress: SYSTEM_PROGRAM_ADDRESS,
  accounts: [
    {
      address: sender.address,
      role: AccountRole.WRITABLE_SIGNER
    },
    {
      address: recipient.address,
      role: AccountRole.WRITABLE
    }
  ],
  data: new Uint8Array(instructionData)
};
```

</CodeTabs>

- Legacy

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const transferInstructionIndex = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(transferInstructionIndex, 0);
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// Manually create a transfer instruction
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true }, // from account, is signer and is writable
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true } // to account, is not signer but is writable
  ],
  programId: SystemProgram.programId,
  data: instructionData
});
```

</CodeTabs>

- Rust

<CodeTabs>

```rs !! title="Instruction"
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

let transfer_instruction =
    system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);
```

```rs !! title="Expanded Instruction"
// Instruction index for the System Program's transfer instruction
let transfer_instruction_index: u32 = 2;

// Define the amount to transfer
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

// Create instruction data manually (12 bytes: 4 for u32 index + 8 for u64 lamports)
let mut instruction_data = Vec::with_capacity(12);
instruction_data.extend_from_slice(&transfer_instruction_index.to_le_bytes());
instruction_data.extend_from_slice(&transfer_amount.to_le_bytes());

// Manually create the transfer instruction
let transfer_instruction = Instruction {
    program_id: system_program::id(),
    accounts: vec![
        AccountMeta::new(sender.pubkey(), true), // from account, is signer and is writable
        AccountMeta::new(recipient.pubkey(), false), // to account, is not signer but is writable
    ],
    data: instruction_data,
};
```

</CodeTabs>

W poniższych sekcjach omówimy szczegóły transakcji i instrukcji.

## Instrukcje

[Instrukcja](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)
w [programie](/docs/core/accounts#program-account) Solana może być traktowana
jako publiczna funkcja, którą każdy może wywołać, korzystając z sieci Solana.

Wywołanie instrukcji programu wymaga trzech kluczowych informacji:

- ID programu: Program zawierający logikę wykonania instrukcji
- Konta: Lista kont, które są potrzebne do wykonania instrukcji
- Instruction Data: Tablica bajtów określająca instrukcję do wywołania w
  programie oraz wszelkie argumenty wymagane przez instrukcję

---CODE-PLACEHOLDER-1e4adb91a4734d62c4431a2f224cd713---

![Transaction Instruction](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

Każde konto wymagane przez instrukcję musi być dostarczone jako
[AccountMeta](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25),
które zawiera:

- ---INLINE-CODE-PLACEHOLDER-a6e536fd2243a28539a4c5e69f9542eb---: Adres konta
- `is_signer`: Czy konto musi podpisać transakcję
- `is_writable`: Czy instrukcja modyfikuje dane konta

---CODE-PLACEHOLDER-926c24c60329ce160b8bc582de7114ac---

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

Określając z góry, które konta są odczytywane lub zapisywane przez instrukcję,
transakcje, które nie modyfikują tych samych kont, mogą być wykonywane
równolegle.

### Przykładowa struktura instrukcji

Uruchom poniższe przykłady, aby zobaczyć strukturę instrukcji transferu SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner, lamports } from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair
} from "@solana/web3.js";

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair, system_instruction,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Define the amount to transfer
    let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = system_instruction::transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        transfer_amount,
    );

    println!("{:#?}", transfer_instruction);

    Ok(())
}
```

</CodeTabs>

Poniższe przykłady pokazują wynik wcześniejszych fragmentów kodu. Dokładny
format różni się w zależności od SDK, ale każda instrukcja Solana wymaga
następujących informacji:

- **Program ID**: Adres programu, który wykona instrukcję.
- **Konta**: Lista kont wymaganych przez instrukcję. Dla każdego konta
  instrukcja musi określić jego adres, czy musi podpisać transakcję oraz czy
  będzie na nie zapisywane.
- **Dane**: Bufor bajtów, który informuje program, którą instrukcję wykonać i
  zawiera wszelkie argumenty wymagane przez instrukcję.

<CodeTabs storage="sol-transfer">

---CODE-PLACEHOLDER-682bbb5d94b69fb6d22e766b4df2c3d6---

---CODE-PLACEHOLDER-8f3e5b627ee74ee104c210def71117b8---

---CODE-PLACEHOLDER-81a265bfced2099680e7db501c33bb80---

</CodeTabs>

## Transakcje

Transakcja w Solana
[transaction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
składa się z:

1. [Podpisy](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30):
   Tablica podpisów dołączonych do transakcji.
2. [Wiadomość](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131):
   Lista instrukcji przetwarzanych atomowo.

---CODE-PLACEHOLDER-da471115476bbae8ff5ccc76e3326c7a---

![Format transakcji](/assets/docs/core/transactions/tx_format.png)

Struktura wiadomości transakcji składa się z:

- [Nagłówek wiadomości](/docs/core/transactions#message-header): Określa liczbę
  kont podpisujących i tylko do odczytu.
- [Adresy kont](/docs/core/transactions#array-of-account-addresses): Tablica
  adresów kont wymaganych przez instrukcje w transakcji.
- [Niedawny Blockhash](/docs/core/transactions#recent-blockhash): Działa jako
  znacznik czasu dla transakcji.
- [Instrukcje](/docs/core/transactions#array-of-instructions): Tablica
  instrukcji do wykonania.

---CODE-PLACEHOLDER-7efd2e5f83a361a86e7c5971a6ec2658---

![Wiadomość transakcji](/assets/docs/core/transactions/legacy_message.png)

### Rozmiar transakcji

Transakcje Solana mają limit rozmiaru wynoszący
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
bajtów. Limit ten wynika z maksymalnej jednostki transmisji (MTU) IPv6
wynoszącej 1280 bajtów, minus 48 bajtów na nagłówki sieciowe (40 bajtów IPv6 + 8
bajtów nagłówka fragmentu).

Całkowity rozmiar transakcji (podpisy i wiadomość) musi mieścić się w tym
limicie i obejmuje:

- Podpisy: 64 bajty każdy
- Wiadomość: Nagłówek (3 bajty), klucze kont (32 bajty każdy), niedawny
  blockhash (32 bajty) oraz instrukcje

![Format transakcji](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### Nagłówek wiadomości

[Nagłówek wiadomości](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
używa trzech bajtów do określenia uprawnień kont.

1. Wymagane podpisy
2. Liczba podpisanych kont tylko do odczytu
3. Liczba niepodpisanych kont tylko do odczytu

---CODE-PLACEHOLDER-4594bd3ad711457ca5d767fab2e2cca3---

![Nagłówek wiadomości](/assets/docs/core/transactions/message_header.png)

### Format tablicy kompaktowej

Kompaktowa tablica w wiadomości transakcji to tablica serializowana w
następującym formacie:

1. Długość tablicy (zakodowana jako
   [compact-u16](https://github.com/anza-xyz/agave/blob/v2.1.13/short-vec/src/lib.rs))
2. Elementy tablicy wymienione jeden po drugim

![Format tablicy kompaktowej](/assets/docs/core/transactions/compact_array_format.png)

Ten format jest używany do kodowania długości tablic
[adresów kont](/docs/core/transactions#array-of-account-addresses) oraz
[instrukcji](/docs/core/transactions#array-of-instructions) w wiadomościach
transakcji.

### Tablica adresów kont

Wiadomość transakcji zawiera tablicę
[adresów kont](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
wymaganych przez jej instrukcje. Tablica zaczyna się od liczby
[compact-u16](/docs/core/transactions#compact-array-format), która wskazuje, ile
adresów zawiera. Adresy są następnie uporządkowane według ich uprawnień,
określonych przez nagłówek wiadomości.

- Konta, które są zapisywalne i podpisujące
- Konta, które są tylko do odczytu i podpisujące
- Konta, które są zapisywalne i nie podpisujące
- Konta, które są tylko do odczytu i nie podpisujące

![Kompaktowa tablica adresów kont](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Ostatni Blockhash

Każda transakcja wymaga
[ostatniego blockhash](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L141),
który pełni dwie funkcje:

1. Działa jako znacznik czasu
2. Zapobiega duplikacji transakcji

Blockhash wygasa po
[150](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)
blokach (około 1 minuty przy założeniu czasu bloku wynoszącego 400 ms), po czym
transakcja nie może zostać przetworzona.

Możesz użyć metody RPC
[`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash), aby uzyskać aktualny
blockhash i ostatnią wysokość bloku, przy której blockhash będzie ważny. Oto
przykład na [Solana Playground](https://beta.solpg.io/661a06e1cffcf4b13384d046).

### Tablica instrukcji

Wiadomość transakcji zawiera tablicę
[instrukcji](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
w typie
[CompiledInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22).
Instrukcje są konwertowane na ten typ podczas dodawania do transakcji.

Podobnie jak tablica adresów kont w wiadomości, zaczyna się od długości
[compact-u16](/docs/core/transactions#compact-array-format), a następnie zawiera
dane instrukcji. Każda instrukcja zawiera:

1. Indeks ID programu: Indeks typu u8 wskazujący adres programu w tablicy
   adresów kont. Określa program, który przetworzy instrukcję.
2. Indeksy kont: Tablica indeksów typu u8 wskazujących adresy kont wymagane dla
   tej instrukcji.
3. Dane instrukcji: Tablica bajtów określająca, którą instrukcję wywołać w
   programie oraz wszelkie dodatkowe dane wymagane przez instrukcję (np.
   argumenty funkcji).

---CODE-PLACEHOLDER-504d8853668f48b2c13c960eef4e67ac---

![Kompaktowa tablica instrukcji](/assets/docs/core/transactions/compact_array_of_ixs.png)

### Przykładowa struktura transakcji

Uruchom poniższe przykłady, aby zobaczyć strukturę transakcji z pojedynczą
instrukcją transferu SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, signature::Signer,
    signer::keypair::Keypair, system_instruction, transaction::Transaction,
};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = system_instruction::transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

Poniższe przykłady pokazują wynik wiadomości transakcji z poprzednich fragmentów
kodu. Dokładny format różni się w zależności od SDK, ale zawiera te same
informacje.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>

Gdy pobierzesz transakcję za pomocą jej podpisu po wysłaniu jej do sieci,
otrzymasz odpowiedź o następującej strukturze.

Pole ---INLINE-CODE-PLACEHOLDER-7947c12a0cb1d36ca9b57bde51de9889--- zawiera
następujące pola:

- ---INLINE-CODE-PLACEHOLDER-28289343a245d382223c9dca090af4a5---: Określa
  uprawnienia do odczytu/zapisu i podpisywania dla adresów w tablicy
  ---INLINE-CODE-PLACEHOLDER-8d4960058576495469f38cdaffbefccd---

- ---INLINE-CODE-PLACEHOLDER-8d4960058576495469f38cdaffbefccd---: Tablica
  wszystkich adresów kont używanych w instrukcjach transakcji

- ---INLINE-CODE-PLACEHOLDER-484fd94be3ebc646463aa4da185f718d---: Blockhash
  używany do oznaczania transakcji czasem

- ---INLINE-CODE-PLACEHOLDER-cef0cbeb0aa0415c6c312a6286058bf7---: Tablica
  instrukcji do wykonania. Każdy
  ---INLINE-CODE-PLACEHOLDER-23d00a6ef54005c98c43ed4a47623699--- i
  ---INLINE-CODE-PLACEHOLDER-669c26d6b4d7f017d75ebf197ebb784a--- w instrukcji
  odnosi się do tablicy
  ---INLINE-CODE-PLACEHOLDER-8d4960058576495469f38cdaffbefccd--- za pomocą
  indeksu.

- ---INLINE-CODE-PLACEHOLDER-32f8eb4ecd3b61a207fa77ec4bff1c65---: Tablica
  zawierająca podpisy dla wszystkich kont wymaganych jako podpisujących przez
  instrukcje w transakcji. Podpis jest tworzony przez podpisanie wiadomości
  transakcji za pomocą odpowiadającego klucza prywatnego konta.

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Kompaktowa tablica instrukcji](/assets/docs/core/transactions/compact_array_of_ixs.png)

### Przykładowa struktura transakcji

Uruchom poniższe przykłady, aby zobaczyć strukturę transakcji z pojedynczą
instrukcją transferu SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, signature::Signer,
    signer::keypair::Keypair, system_instruction, transaction::Transaction,
};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = system_instruction::transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

Poniższe przykłady pokazują wynik wiadomości transakcji z poprzednich fragmentów
kodu. Dokładny format różni się w zależności od SDK, ale zawiera te same
informacje.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>

Po przesłaniu transakcji możesz pobrać jej szczegóły za pomocą metody RPC
[getTransaction](/docs/rpc/http/gettransaction). Odpowiedź będzie miała
strukturę podobną do poniższego fragmentu. Alternatywnie możesz sprawdzić
transakcję za pomocą [Solana Explorer](https://explorer.solana.com).

<Callout type="info">

"Podpis transakcji" jednoznacznie identyfikuje transakcję w Solana. Używasz tego
podpisu, aby wyszukać szczegóły transakcji w sieci. Podpis transakcji to po
prostu pierwszy podpis w transakcji. Należy zauważyć, że pierwszy podpis jest
również podpisem płatnika opłaty transakcyjnej.

</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
