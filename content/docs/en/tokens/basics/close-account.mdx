---
title: Close Token Account
description: Learn how to close token accounts.
---

## How to Close Token account

Close a token account by moving all it's Sol to another destination account. Non-native token accounts can only be closed when the balance is zero. This can be done by calling the [CloseAccount](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/program/src/instruction.rs#L212C5-L212C17) instruction on the token program/s. Only the token authority can call this instruction successfully.

<Callout type="info">
  The [Token
  Program](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/program/src/instruction.rs#L212C5-L212C17)
  and [Token Extension
  Program](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/instruction.rs#L274)
  share similar implementations to achieve the same functionality.
</Callout>

### Typescript

<CodeTabs storage="token-ts" flags="r">

```ts !! title="Kit"
import { getCreateAccountInstruction } from "@solana-program/system";
import {
	findAssociatedTokenPda,
	getCloseAccountInstruction,
	getCreateAssociatedTokenInstructionAsync,
	getInitializeMintInstruction,
	getMintSize,
	getRevokeInstruction,
	TOKEN_PROGRAM_ADDRESS,
} from "@solana-program/token";
import {
	airdropFactory,
	appendTransactionMessageInstruction,
	appendTransactionMessageInstructions,
	createSolanaRpc,
	createSolanaRpcSubscriptions,
	createTransactionMessage,
	generateKeyPairSigner,
	getSignatureFromTransaction,
	lamports,
	pipe,
	sendAndConfirmTransactionFactory,
	setTransactionMessageFeePayerSigner,
	setTransactionMessageLifetimeUsingBlockhash,
	signTransactionMessageWithSigners,
	type Commitment,
	type CompilableTransactionMessage,
	type Rpc,
	type RpcSubscriptions,
	type SolanaRpcApi,
	type SolanaRpcSubscriptionsApi,
	type TransactionMessageWithBlockhashLifetime,
	type TransactionSigner,
} from "@solana/kit";

// Create Connection, local validator in this example
const client = createClient();

// Generate keypairs for mint address, fee payer and destination address
const payer = await generateKeyPairSigner(); // will act as mint authority too
const destination = await generateKeyPairSigner();
const mint = await generateKeyPairSigner();

/* constants */
const mintDecimals = 9;

console.log("Fee Payer Address: ", payer.address.toString());
console.log("Destination Address: ", destination.address.toString());
console.log("Mint Address: ", mint.address.toString());

let { payerAssociatedTokenAcc } = await setup();

const closeTokenAccountIx = getCloseAccountInstruction({
	account: payerAssociatedTokenAcc,
	destination: destination.address,
	owner: payer,
});

const txSignature = await pipe(
	await createDefaultTransaction(client, payer),
	(tx) => appendTransactionMessageInstruction(closeTokenAccountIx, tx),
	(tx) => signAndSendTransaction(client, tx)
);
console.log("\nTransaction Signature:", txSignature);

// ------------------------------------------------ helpers

/*
 * The setup function initializes the mint and associated token accounts
 * for the payer
 *
 */
async function setup() {
	// Fund fee payer
	await airdropFactory(client)({
		recipientAddress: payer.address,
		lamports: lamports(5_000_000_000n), // 5 SOL
		commitment: "confirmed",
	});

	// Get default mint account size (in bytes), no extensions enabled
	const space = BigInt(getMintSize());
	const rent = await client.rpc
		.getMinimumBalanceForRentExemption(space)
		.send();

	// Instruction to create new account for mint (token  program)
	// Invokes the system program
	const createAccountInstruction = getCreateAccountInstruction({
		payer,
		newAccount: mint,
		lamports: rent,
		space,
		programAddress: TOKEN_PROGRAM_ADDRESS,
	});

	// Instruction to initialize mint account data
	// Invokes the token program
	const initializeMintInstruction = getInitializeMintInstruction({
		mint: mint.address,
		decimals: mintDecimals,
		mintAuthority: payer.address,
	});

	// Derive the ATA for payer
	const [payerAssociatedTokenAcc] = await findAssociatedTokenPda({
		mint: mint.address,
		owner: payer.address,
		tokenProgram: TOKEN_PROGRAM_ADDRESS,
	});

	// Create instruction for payer ATA
	const cratePayerATAInstruction =
		await getCreateAssociatedTokenInstructionAsync({
			payer: payer,
			mint: mint.address,
			owner: payer.address,
		});

	const instructions = [
		createAccountInstruction, // create mint accounts
		initializeMintInstruction, // initialize mint accounts
		cratePayerATAInstruction, // create payer's ATA
	];

	await pipe(
		await createDefaultTransaction(client, payer),
		(tx) => appendTransactionMessageInstructions(instructions, tx),
		(tx) => signAndSendTransaction(client, tx)
	);

	return {
		payerAssociatedTokenAcc,
	};
}

type Client = {
	rpc: Rpc<SolanaRpcApi>;
	rpcSubscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>;
};

function createClient(): Client {
	const rpc = createSolanaRpc("http://localhost:8899");
	const rpcSubscriptions = createSolanaRpcSubscriptions(
		"ws://localhost:8900"
	);

	return { rpc, rpcSubscriptions };
}

async function createDefaultTransaction(
	client: Client,
	feePayer: TransactionSigner
) {
	const { value: latestBlockhash } = await client.rpc
		.getLatestBlockhash()
		.send();
	return pipe(
		createTransactionMessage({ version: 0 }),
		(tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
		(tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx)
	);
}

async function signAndSendTransaction(
	client: Client,
	transactionMessage: CompilableTransactionMessage &
		TransactionMessageWithBlockhashLifetime,
	commitment: Commitment = "confirmed"
) {
	const signedTransaction = await signTransactionMessageWithSigners(
		transactionMessage
	);
	const signature = getSignatureFromTransaction(signedTransaction);

	await sendAndConfirmTransactionFactory(client)(signedTransaction, {
		commitment,
		skipPreflight: true,
	});
	return signature;
}
```

```ts !! title="Legacy"
import { Connection, Keypair } from "@solana/web3.js";
import {
  createMint,
  getOrCreateAssociatedTokenAccount,
  closeAccount
} from "@solana/spl-token";

// Connect to local Solana node
const connection = new Connection("http://localhost:8899", "confirmed");

// Create a fee payer account
const feePayer = Keypair.generate();

// Request airdrop for fee payer
const airdropSig = await connection.requestAirdrop(
  feePayer.publicKey,
  1000000000
);
await connection.confirmTransaction(airdropSig);

// Step 1: Create a new mint
const mintAuthority = feePayer;
const freezeAuthority = feePayer;
const decimals = 8;

console.log("Creating mint...");
const mint = await createMint(
  connection,
  feePayer,
  mintAuthority.publicKey,
  freezeAuthority.publicKey,
  decimals
);
console.log("Mint created:", mint.toBase58());

// Step 2: Create Associated Token Account
console.log("Creating token account...");
const tokenAccount = await getOrCreateAssociatedTokenAccount(
  connection,
  feePayer,
  mint,
  feePayer.publicKey
);
console.log("Token account:", tokenAccount.address.toBase58());

// Step 3: Close the token account
const txSignature = await closeAccount(
  connection, // connection
  feePayer, // payer
  tokenAccount.address, // token account which you want to close
  feePayer.publicKey, // destination
  feePayer // owner of token account
);
console.log("Close Token Account:", txSignature);
```

</CodeTabs>

### Rust

<CodeTabs storage="token-rs" flags="r">

```rust !! title="Rust Async"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, program_pack::Pack,
    signature::Keypair, signer::Signer, system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address, instruction::create_associated_token_account_idempotent,
};
use spl_token::{
    instruction::{close_account, initialize_mint2},
    state::Mint,
    ID as TOKEN_PROGRAM_ID,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let authority_keypair = Keypair::new(); // will also act as tx fee payer
    let mint_account = Keypair::new();
    let associated_token_account =
        get_associated_token_address(&authority_keypair.pubkey(), &mint_account.pubkey());

    // Airdrop authority, create the mint account and ATA
    setup(&client, &authority_keypair, &mint_account).await?;

    let close_ix = close_account(
        &TOKEN_PROGRAM_ID,
        &associated_token_account,
        &authority_keypair.pubkey(),
        &authority_keypair.pubkey(),
        &[&authority_keypair.pubkey()],
    )?;

    let mut transaction =
        Transaction::new_with_payer(&[close_ix], Some(&authority_keypair.pubkey()));

    transaction.sign(&[&authority_keypair], client.get_latest_blockhash().await?);

    match client.send_and_confirm_transaction(&transaction).await {
        Ok(signature) => println!("Transaction Signature: {}", signature),
        Err(err) => eprintln!("Error closing token account: {}", err),
    }

    Ok(())
}

// Helper function to airdrop, create the mint account and ATA
async fn setup(
    client: &RpcClient,
    authority_keypair: &Keypair,
    mint_account: &Keypair,
) -> anyhow::Result<()> {
    let transaction_signature = client
        .request_airdrop(&authority_keypair.pubkey(), 5 * LAMPORTS_PER_SOL)
        .await?;
    loop {
        if client.confirm_transaction(&transaction_signature).await? {
            break;
        }
    }

    let decimals = 9;
    let mint_account_len = Mint::LEN;
    let mint_account_rent = client
        .get_minimum_balance_for_rent_exemption(mint_account_len)
        .await?;

    let create_mint_account_ix = create_account(
        &authority_keypair.pubkey(),
        &mint_account.pubkey(),
        mint_account_rent,
        mint_account_len as u64,
        &TOKEN_PROGRAM_ID,
    );

    let initialize_mint_ix = initialize_mint2(
        &TOKEN_PROGRAM_ID,
        &mint_account.pubkey(),
        &authority_keypair.pubkey(),
        Some(&authority_keypair.pubkey()),
        decimals,
    )?;

    // Create ATA instruction
    let create_ata_ix = create_associated_token_account_idempotent(
        &authority_keypair.pubkey(), // payer
        &authority_keypair.pubkey(), // wallet address
        &mint_account.pubkey(),      // mint address
        &TOKEN_PROGRAM_ID,
    );

    let mut transaction = Transaction::new_with_payer(
        &[create_mint_account_ix, initialize_mint_ix, create_ata_ix],
        Some(&authority_keypair.pubkey()),
    );

    transaction.sign(
        &[authority_keypair, mint_account],
        client.get_latest_blockhash().await?,
    );

    client.send_and_confirm_transaction(&transaction).await?;
    Ok(())
}
```

```rust !! title="Token Client"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    native_token::LAMPORTS_PER_SOL,
    signature::{ Keypair, Signer },
};
use spl_token::{ id as token_program_id };
use spl_token_client::{
    client::{ ProgramRpcClient, ProgramRpcClientSendTransaction },
    token::{ ExtensionInitializationParams, Token },
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed()
    );
    // Generate keypairs to use for authority, destination and mint
    let mint_keypair = Keypair::new(); // mint keypair
    let authority_keypair = Keypair::new(); // will also act as tx fee payer
    let destination_keypair = Keypair::new(); // will receive SOL from the closed account

    // Number of decimals for the mint
    let decimals = 9;

    println!("Mint Authority Address: {}", authority_keypair.pubkey());
    println!("destination Address: {}", destination_keypair.pubkey());

    // Airdrop 5 SOL to authority keypair
    let transaction_signature = rpc_client.request_airdrop(
        &authority_keypair.pubkey(),
        5 * LAMPORTS_PER_SOL
    ).await?;
    loop {
        if rpc_client.confirm_transaction(&transaction_signature).await? {
            break;
        }
    }

    // Create a new program client
    let program_client = ProgramRpcClient::new(
        Arc::new(
            RpcClient::new_with_commitment(
                String::from("http://localhost:8899"),
                CommitmentConfig::confirmed()
            )
        ),
        ProgramRpcClientSendTransaction
    );

    // Create a token client for Token
    let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &mint_keypair.pubkey(),
        Some(decimals),
        Arc::new(authority_keypair.insecure_clone())
    );

    // Create and initialize the mint
    let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

    let mint_result = token.create_mint(
        &authority_keypair.pubkey(), // mint authority
        Some(&authority_keypair.pubkey()), // freeze authority
        extension_initialization_params, // no extensions
        &[&mint_keypair] // mint keypair needed as signer
    ).await?;

    println!("\nCreating mint {}", mint_keypair.pubkey());
    println!("Transaction Signature: {}", mint_result);

    // Derive mint authority ATA
    let mint_auth_associated_token_acc = token.get_associated_token_address(
        &authority_keypair.pubkey()
    );
    println!("Mint Authority Token Account Address: {}", mint_auth_associated_token_acc);

    // Then, create the associated token account for mint authority
    let create_mint_authority_ata_result = token.create_associated_token_account(
        &authority_keypair.pubkey() // owner
    ).await?;
    println!("Created Source Token Account: {}", create_mint_authority_ata_result);

    let transaction_signature = token.close_account(
        &mint_auth_associated_token_acc,
        &destination_keypair.pubkey(),
        &authority_keypair.pubkey(),
        &[&authority_keypair] // signer keypairs
    ).await?;

    println!("\nSuccessfully close the mint authority token account {}", mint_auth_associated_token_acc);
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

</CodeTabs>
