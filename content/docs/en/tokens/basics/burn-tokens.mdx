---
title: Burn Tokens
description: Learn how to burn tokens.
---

## How to Burn tokens

Burning tokens involves removing tokens from circulation by reducing the amount of tokens inside a token account. This happens when you call the [BurnChecked](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/interface/src/instruction.rs#L359C5-L359C16) instruction on the token program/s. Only the token account authroity is allowed to call this instruction successfully.

<Callout type="info">
  The [Token
  Program](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/interface/src/instruction.rs#L359C5-L359C16)
  and [Token Extension
  Program](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/instruction.rs#L413)
  share similar implementations to achieve the same functionality.
</Callout>

### Typescript

<CodeTabs storage="token-ts" flags="r">

```ts !! title="Kit"
import { getCreateAccountInstruction } from "@solana-program/system";
import {
	findAssociatedTokenPda,
	getApproveCheckedInstruction,
	getBurnCheckedInstruction,
	getCreateAssociatedTokenInstructionAsync,
	getInitializeMintInstruction,
	getMintSize,
	getMintToCheckedInstruction,
	TOKEN_PROGRAM_ADDRESS,
} from "@solana-program/token";
import {
	airdropFactory,
	appendTransactionMessageInstruction,
	appendTransactionMessageInstructions,
	createSolanaRpc,
	createSolanaRpcSubscriptions,
	createTransactionMessage,
	generateKeyPairSigner,
	getSignatureFromTransaction,
	lamports,
	pipe,
	sendAndConfirmTransactionFactory,
	setTransactionMessageFeePayerSigner,
	setTransactionMessageLifetimeUsingBlockhash,
	signTransactionMessageWithSigners,
	type Commitment,
	type CompilableTransactionMessage,
	type Rpc,
	type RpcSubscriptions,
	type SolanaRpcApi,
	type SolanaRpcSubscriptionsApi,
	type TransactionMessageWithBlockhashLifetime,
	type TransactionSigner,
} from "@solana/kit";

// Create Connection, local validator in this example
const client = createClient();

// Generate keypairs for mint address, fee payer and delegate
const payer = await generateKeyPairSigner(); // will act as mint authority too
const delegate = await generateKeyPairSigner();
const mint = await generateKeyPairSigner();

/* constants */
const mintDecimals = 9;

console.log("Fee Payer Address: ", payer.address.toString());
console.log("Delegate Address: ", delegate.address.toString());
console.log("Mint Address: ", mint.address.toString());

let { payerAssociatedTokenAcc } = await setup();

//! mark
const burnIx = getBurnCheckedInstruction({
	account: payerAssociatedTokenAcc,
	mint: mint.address,
	authority: payer.address,
	amount: 10_000_000_000n, // 10 tokens
	decimals: mintDecimals,
});
console.log("\nBurning 10 tokens");

const txSignature = await pipe(
	await createDefaultTransaction(client, payer),
	(tx) => appendTransactionMessageInstruction(burnIx, tx),
	(tx) => signAndSendTransaction(client, tx)
);
console.log("\nTransaction Signature:", txSignature);

// ------------------------------------------------ helpers

/*
 * The setup function initializes the mint and associated token accounts
 * for the payer
 *
 */
async function setup() {
	// Fund fee payer
	await airdropFactory(client)({
		recipientAddress: payer.address,
		lamports: lamports(5_000_000_000n), // 5 SOL
		commitment: "confirmed",
	});

	// Get default mint account size (in bytes), no extensions enabled
	const space = BigInt(getMintSize());
	const rent = await client.rpc
		.getMinimumBalanceForRentExemption(space)
		.send();

	// Instruction to create new account for mint (token  program)
	// Invokes the system program
	const createAccountInstruction = getCreateAccountInstruction({
		payer,
		newAccount: mint,
		lamports: rent,
		space,
		programAddress: TOKEN_PROGRAM_ADDRESS,
	});

	// Instruction to initialize mint account data
	// Invokes the token program
	const initializeMintInstruction = getInitializeMintInstruction({
		mint: mint.address,
		decimals: mintDecimals,
		mintAuthority: payer.address,
	});

	// Derive the ATA for payer
	const [payerAssociatedTokenAcc] = await findAssociatedTokenPda({
		mint: mint.address,
		owner: payer.address,
		tokenProgram: TOKEN_PROGRAM_ADDRESS,
	});

	// Create instruction for payer ATA
	const cratePayerATAInstruction =
		await getCreateAssociatedTokenInstructionAsync({
			payer: payer,
			mint: mint.address,
			owner: payer.address,
		});

	// Create instruction to mint tokens to payer
	const mintToInstruction = await getMintToCheckedInstruction({
		mint: mint.address,
		token: payerAssociatedTokenAcc,
		mintAuthority: payer,
		amount: 1_000_000_000_000n, // 1000
		decimals: mintDecimals,
	});

	// Create instruction to revoke delegate
	const delegateInstruction = getApproveCheckedInstruction({
		source: payerAssociatedTokenAcc,
		mint: mint.address,
		delegate: delegate.address,
		owner: payer,
		amount: 1_000_000_000n, // 1 token
		decimals: mintDecimals,
	});

	const instructions = [
		createAccountInstruction, // create mint accounts
		initializeMintInstruction, // initialize mint accounts
		cratePayerATAInstruction, // create payer's ATA
		mintToInstruction, // mint tokens to payer
		delegateInstruction, // delegate tokens
	];

	await pipe(
		await createDefaultTransaction(client, payer),
		(tx) => appendTransactionMessageInstructions(instructions, tx),
		(tx) => signAndSendTransaction(client, tx)
	);

	return {
		payerAssociatedTokenAcc,
	};
}

type Client = {
	rpc: Rpc<SolanaRpcApi>;
	rpcSubscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>;
};

function createClient(): Client {
	const rpc = createSolanaRpc("http://localhost:8899");
	const rpcSubscriptions = createSolanaRpcSubscriptions(
		"ws://localhost:8900"
	);

	return { rpc, rpcSubscriptions };
}

async function createDefaultTransaction(
	client: Client,
	feePayer: TransactionSigner
) {
	const { value: latestBlockhash } = await client.rpc
		.getLatestBlockhash()
		.send();
	return pipe(
		createTransactionMessage({ version: 0 }),
		(tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
		(tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx)
	);
}

async function signAndSendTransaction(
	client: Client,
	transactionMessage: CompilableTransactionMessage &
		TransactionMessageWithBlockhashLifetime,
	commitment: Commitment = "confirmed"
) {
	const signedTransaction = await signTransactionMessageWithSigners(
		transactionMessage
	);
	const signature = getSignatureFromTransaction(signedTransaction);

	await sendAndConfirmTransactionFactory(client)(signedTransaction, {
		commitment,
		skipPreflight: true,
	});
	return signature;
}
```

```ts !! title="Legacy"
import { Connection, Keypair } from "@solana/web3.js";
import {
  createMint,
  getOrCreateAssociatedTokenAccount,
  mintTo,
  burnChecked
} from "@solana/spl-token";

// Connect to local Solana node
const connection = new Connection("http://localhost:8899", "confirmed");

// Create a fee payer account
const feePayer = Keypair.generate();

// Request airdrop for fee payer
const airdropSig = await connection.requestAirdrop(
  feePayer.publicKey,
  1000000000
);
await connection.confirmTransaction(airdropSig);

// Step 1: Create a new mint
const mintAuthority = feePayer;
const freezeAuthority = feePayer;
const decimals = 2;

console.log("Creating mint...");
const mint = await createMint(
  connection,
  feePayer,
  mintAuthority.publicKey,
  freezeAuthority.publicKey,
  decimals
);
console.log("Mint created:", mint.toBase58());

// Step 2: Create Associated Token Account
console.log("Creating token account...");
const tokenAccount = await getOrCreateAssociatedTokenAccount(
  connection,
  feePayer,
  mint,
  feePayer.publicKey
);
console.log("Token account:", tokenAccount.address.toBase58());

// Step 3: Mint tokens
const amountToMint = 100;
console.log("Minting tokens...");
const mintTx = await mintTo(
  connection,
  feePayer,
  mint,
  tokenAccount.address,
  mintAuthority,
  amountToMint
);
console.log("Mint transaction:", mintTx);

// Step 4: Burn tokens
const amountToBurn = 50;
console.log("Burning tokens...");
const burnTx = await burnChecked(
  connection,
  feePayer,
  tokenAccount.address,
  mint,
  feePayer,
  amountToBurn,
  decimals
);
console.log("Burn transaction:", burnTx);
```

</CodeTabs>

### Rust

<CodeTabs storage="token-rs" flags="r">

```rust !! title="Rust Async"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, program_pack::Pack,
    signature::Keypair, signer::Signer, system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address, instruction::create_associated_token_account_idempotent,
};
use spl_token::{
    instruction::{burn_checked, initialize_mint2, mint_to_checked},
    state::Mint,
    ID as TOKEN_PROGRAM_ID,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let authority_keypair = Keypair::new(); // will also act as tx fee payer
    let mint_account = Keypair::new();
    let associated_token_account =
        get_associated_token_address(&authority_keypair.pubkey(), &mint_account.pubkey());

    // Airdrop authority, create the mint account and ATA, mint tokens to the ATA
    setup(&client, &authority_keypair, &mint_account).await?;

    // Get mint decimals from the ATA
    let mint_decimals = client
        .get_token_account_balance(&associated_token_account)
        .await?
        .decimals;

    let amount_to_burn = 1 * 10_u64.pow(mint_decimals as u32); // 1 token

    let burn_ix = burn_checked(
        &TOKEN_PROGRAM_ID,
        &associated_token_account,
        &mint_account.pubkey(),
        &authority_keypair.pubkey(),
        &[&authority_keypair.pubkey()],
        amount_to_burn,
        mint_decimals,
    )?;

    let mut transaction =
        Transaction::new_with_payer(&[burn_ix], Some(&authority_keypair.pubkey()));

    transaction.sign(&[&authority_keypair], client.get_latest_blockhash().await?);

    match client.send_and_confirm_transaction(&transaction).await {
        Ok(signature) => println!("Transaction Signature: {}", signature),
        Err(err) => eprintln!("Error burning tokens: {}", err),
    }

    Ok(())
}

// Helper function to airdrop, create the mint account and ATA, mint tokens to the ATA
async fn setup(
    client: &RpcClient,
    authority_keypair: &Keypair,
    mint_account: &Keypair,
) -> anyhow::Result<()> {
    let transaction_signature = client
        .request_airdrop(&authority_keypair.pubkey(), 5 * LAMPORTS_PER_SOL)
        .await?;
    loop {
        if client.confirm_transaction(&transaction_signature).await? {
            break;
        }
    }

    let decimals = 9;
    let amount_to_mint = 100 * 10_u64.pow(decimals as u32); // 100 tokens
    let mint_account_len = Mint::LEN;
    let mint_account_rent = client
        .get_minimum_balance_for_rent_exemption(mint_account_len)
        .await?;

    let create_mint_account_ix = create_account(
        &authority_keypair.pubkey(),
        &mint_account.pubkey(),
        mint_account_rent,
        mint_account_len as u64,
        &TOKEN_PROGRAM_ID,
    );

    let initialize_mint_ix = initialize_mint2(
        &TOKEN_PROGRAM_ID,
        &mint_account.pubkey(),
        &authority_keypair.pubkey(),
        Some(&authority_keypair.pubkey()),
        decimals,
    )?;

    let associated_token_account =
        get_associated_token_address(&authority_keypair.pubkey(), &mint_account.pubkey());

    // Create ATA instruction
    let create_ata_ix = create_associated_token_account_idempotent(
        &authority_keypair.pubkey(), // payer
        &authority_keypair.pubkey(), // wallet address
        &mint_account.pubkey(),      // mint address
        &TOKEN_PROGRAM_ID,
    );

    // Mint some initial tokens
    let mint_to_ix = mint_to_checked(
        &TOKEN_PROGRAM_ID,
        &mint_account.pubkey(),
        &associated_token_account,
        &authority_keypair.pubkey(),
        &[&authority_keypair.pubkey()],
        amount_to_mint,
        decimals,
    )?;

    let mut transaction = Transaction::new_with_payer(
        &[
            create_mint_account_ix,
            initialize_mint_ix,
            create_ata_ix,
            mint_to_ix,
        ],
        Some(&authority_keypair.pubkey()),
    );

    transaction.sign(
        &[authority_keypair, mint_account],
        client.get_latest_blockhash().await?,
    );

    client.send_and_confirm_transaction(&transaction).await?;
    Ok(())
}
```

```rust !! title="Token Client"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    native_token::LAMPORTS_PER_SOL,
    signature::{ Keypair, Signer },
};
use spl_token::id as token_program_id;
use spl_token_client::{
    client::{ ProgramRpcClient, ProgramRpcClientSendTransaction },
    token::{ ExtensionInitializationParams, Token },
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed()
    );
    // Generate keypairs to use for authority, delegate and mint
    let authority_keypair = Keypair::new(); // will also act as tx fee payer
    let delegate_keypair = Keypair::new();
    let mint_keypair = Keypair::new();

    // Number of decimals for the mint
    let decimals = 9;

    println!("Mint Authority Address: {}", authority_keypair.pubkey());
    println!("Delegate Address: {}", delegate_keypair.pubkey());

    // Airdrop 5 SOL to authority keypair
    let transaction_signature = rpc_client.request_airdrop(
        &authority_keypair.pubkey(),
        5 * LAMPORTS_PER_SOL
    ).await?;
    loop {
        if rpc_client.confirm_transaction(&transaction_signature).await? {
            break;
        }
    }

    // Create a new program client
    let program_client = ProgramRpcClient::new(
        Arc::new(
            RpcClient::new_with_commitment(
                String::from("http://localhost:8899"),
                CommitmentConfig::confirmed()
            )
        ),
        ProgramRpcClientSendTransaction
    );

    // Create a token client for Token
    let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &mint_keypair.pubkey(),
        Some(decimals),
        Arc::new(authority_keypair.insecure_clone())
    );

    // Create and initialize the mint
    let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

    let mint_result = token.create_mint(
        &authority_keypair.pubkey(), // mint authority
        Some(&authority_keypair.pubkey()), // freeze authority
        extension_initialization_params, // no extensions
        &[&mint_keypair] // mint keypair needed as signer
    ).await?;

    println!("\nCreating mint {}", mint_keypair.pubkey());
    println!("Transaction Signature: {}", mint_result);

    // Derive mint authority ATA
    let mint_auth_associated_token_acc = token.get_associated_token_address(
        &authority_keypair.pubkey()
    );
    println!("Mint Authority Token Account Address: {}", mint_auth_associated_token_acc);

    // Then, create the associated token account for mint authority
    let create_mint_authority_ata_result = token.create_associated_token_account(
        &authority_keypair.pubkey() // owner
    ).await?;
    println!("Created Source Token Account: {}", create_mint_authority_ata_result);

    // Mint tokens to the associated token account
    let mint_amount = 1000 * (10_u64).pow(decimals as u32); // 1000 tokens
    let mint_to_result = token.mint_to(
        &mint_auth_associated_token_acc, // destination
        &authority_keypair.pubkey(), // authority (mint authority)
        mint_amount, // amount
        &[&authority_keypair] // additional signers (providing payer as a signer)
    ).await?;

    println!(
        "Successfully minted {} tokens to the associated token account",
        mint_amount / (10_u64).pow(decimals as u32)
    );
    println!("Transaction Signature: {}", mint_to_result);

    // Burn 10 tokens minted to the mint authority ATA
    let amount_to_burn = 10 * (10_u64).pow(decimals as u32); // 10 tokens
    let transaction_signature = token.burn(
        &mint_auth_associated_token_acc, // source token account
        &authority_keypair.pubkey(), // authority pubkey
        amount_to_burn, // amount
        &[&authority_keypair] // signer keypairs
    ).await?;

    println!("Successfully burned 10 tokens");
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

</CodeTabs>
