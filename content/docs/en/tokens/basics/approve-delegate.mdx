---
title: Approve Delegate
description: Learn how to approve delegates as token authority.
---

## How to Approve delegate

Approving delegates involves giving authority to another authority the ability to spend a specified amount of tokens in your token account. This happens when you call the [`ApproveChecked`](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/program/src/instruction.rs#L295) instruction on the token program/s. Only the authority of the source token account can approve another address can call this instruction.

<Callout type="info">
  The [Token
  Program](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/program/src/instruction.rs#L295)
  and [Token Extension
  Program](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/instruction.rs#L361)
  share similar implementations to achieve the same functionality.
</Callout>

### Typescript

<CodeTabs storage="token-ts" flags="r">

```ts !! title="Kit"
import { getCreateAccountInstruction } from "@solana-program/system";
import {
	findAssociatedTokenPda,
	getApproveCheckedInstruction,
	getCreateAssociatedTokenInstructionAsync,
	getInitializeMintInstruction,
	getMintSize,
	getMintToCheckedInstruction,
	TOKEN_PROGRAM_ADDRESS,
} from "@solana-program/token";
import {
	airdropFactory,
	appendTransactionMessageInstruction,
	appendTransactionMessageInstructions,
	createSolanaRpc,
	createSolanaRpcSubscriptions,
	createTransactionMessage,
	generateKeyPairSigner,
	getSignatureFromTransaction,
	lamports,
	pipe,
	sendAndConfirmTransactionFactory,
	setTransactionMessageFeePayerSigner,
	setTransactionMessageLifetimeUsingBlockhash,
	signTransactionMessageWithSigners,
	type Commitment,
	type CompilableTransactionMessage,
	type Rpc,
	type RpcSubscriptions,
	type SolanaRpcApi,
	type SolanaRpcSubscriptionsApi,
	type TransactionMessageWithBlockhashLifetime,
	type TransactionSigner,
} from "@solana/kit";

// Create Connection, local validator in this example
const client = createClient();

// Generate keypairs for mint address, fee payer and delegate
const payer = await generateKeyPairSigner(); // will act as mint authority too
const delegate = await generateKeyPairSigner();
const mint = await generateKeyPairSigner();

/* constants */
const mintDecimals = 9;

console.log("Fee Payer Address: ", payer.address.toString());
console.log("Delegate Address: ", delegate.address.toString());
console.log("Mint Address: ", mint.address.toString());

let { payerAssociatedTokenAcc } = await setup();

// !mark
const delegateInstruction = getApproveCheckedInstruction({
	source: payerAssociatedTokenAcc,
	mint: mint.address,
	delegate: delegate.address,
	owner: payer,
	amount: 1_000_000_000n, // 1 token
	decimals: mintDecimals,
});

const txSignature = await pipe(
	await createDefaultTransaction(client, payer),
	(tx) => appendTransactionMessageInstruction(delegateInstruction, tx),
	(tx) => signAndSendTransaction(client, tx)
);
console.log("Transaction Signature:", txSignature);

// ------------------------------------------------ helpers

/*
 * The setup function initializes the mint and associated token accounts
 * for the payer
 *
 */
async function setup() {
	// Fund fee payer
	await airdropFactory(client)({
		recipientAddress: payer.address,
		lamports: lamports(5_000_000_000n), // 5 SOL
		commitment: "confirmed",
	});

	// Get default mint account size (in bytes), no extensions enabled
	const space = BigInt(getMintSize());
	const rent = await client.rpc
		.getMinimumBalanceForRentExemption(space)
		.send();

	// Instruction to create new account for mint (token  program)
	// Invokes the system program
	const createAccountInstruction = getCreateAccountInstruction({
		payer,
		newAccount: mint,
		lamports: rent,
		space,
		programAddress: TOKEN_PROGRAM_ADDRESS,
	});

	// Instruction to initialize mint account data
	// Invokes the token program
	const initializeMintInstruction = getInitializeMintInstruction({
		mint: mint.address,
		decimals: mintDecimals,
		mintAuthority: payer.address,
	});

	// Derive the ATA for payer
	const [payerAssociatedTokenAcc] = await findAssociatedTokenPda({
		mint: mint.address,
		owner: payer.address,
		tokenProgram: TOKEN_PROGRAM_ADDRESS,
	});

	// Create instruction for payer ATA
	const cratePayerATAInstruction =
		await getCreateAssociatedTokenInstructionAsync({
			payer: payer,
			mint: mint.address,
			owner: payer.address,
		});

	// Create instruction to mint tokens to payer
	const mintToInstruction = await getMintToCheckedInstruction({
		mint: mint.address,
		token: payerAssociatedTokenAcc,
		mintAuthority: payer,
		amount: 1_000_000_000_000n, // 1000
		decimals: mintDecimals,
	});

	const instructions = [
		createAccountInstruction, // create mint accounts
		initializeMintInstruction, // initialize mint accounts
		cratePayerATAInstruction, // create payer's ATA
		mintToInstruction, // mint tokens to payer
	];

	await pipe(
		await createDefaultTransaction(client, payer),
		(tx) => appendTransactionMessageInstructions(instructions, tx),
		(tx) => signAndSendTransaction(client, tx)
	);

	return {
		payerAssociatedTokenAcc,
	};
}

type Client = {
	rpc: Rpc<SolanaRpcApi>;
	rpcSubscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>;
};

function createClient(): Client {
	const rpc = createSolanaRpc("http://localhost:8899");
	const rpcSubscriptions = createSolanaRpcSubscriptions(
		"ws://localhost:8900"
	);

	return { rpc, rpcSubscriptions };
}

async function createDefaultTransaction(
	client: Client,
	feePayer: TransactionSigner
) {
	const { value: latestBlockhash } = await client.rpc
		.getLatestBlockhash()
		.send();
	return pipe(
		createTransactionMessage({ version: 0 }),
		(tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
		(tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx)
	);
}

async function signAndSendTransaction(
	client: Client,
	transactionMessage: CompilableTransactionMessage &
		TransactionMessageWithBlockhashLifetime,
	commitment: Commitment = "confirmed"
) {
	const signedTransaction = await signTransactionMessageWithSigners(
		transactionMessage
	);
	const signature = getSignatureFromTransaction(signedTransaction);

	await sendAndConfirmTransactionFactory(client)(signedTransaction, {
		commitment,
		skipPreflight: true,
	});
	return signature;
}
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  Transaction,
  sendAndConfirmTransaction,
  SystemProgram,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  approveChecked,
  createApproveCheckedInstruction,
  revoke,
  createRevokeInstruction,
  createMint,
  getOrCreateAssociatedTokenAccount,
  createInitializeMintInstruction,
  createAssociatedTokenAccountInstruction,
  getAssociatedTokenAddress,
  MINT_SIZE,
  TOKEN_PROGRAM_ID
} from "@solana/spl-token";

const connection = new Connection("http://localhost:8899", "confirmed");

const tokenOwner = Keypair.generate();
const airdropSignature = await connection.requestAirdrop(
  tokenOwner.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature);

// Create delegate address
const delegate = Keypair.generate();
console.log(`Delegate pubkey: ${delegate.publicKey.toBase58()}`);

// 1) Create mint using build-in function
console.log("\n1. Creating mint using build-in function...");
const mint = await createMint(
  connection,
  tokenOwner,
  tokenOwner.publicKey, // mint authority
  tokenOwner.publicKey, // freeze authority
  9 // decimals
);
console.log(`Mint created: ${mint.toBase58()}`);

// 2) Create mint by composing transaction
console.log("\n2. Creating mint by composing transaction...");
const mintKeypair = Keypair.generate();
const mintRent = await connection.getMinimumBalanceForRentExemption(MINT_SIZE);

const createMintTx = new Transaction().add(
  // Create account for mint
  SystemProgram.createAccount({
    fromPubkey: tokenOwner.publicKey,
    newAccountPubkey: mintKeypair.publicKey,
    space: MINT_SIZE,
    lamports: mintRent,
    programId: TOKEN_PROGRAM_ID
  }),
  // Initialize mint
  createInitializeMintInstruction(
    mintKeypair.publicKey,
    9, // decimals
    tokenOwner.publicKey, // mint authority
    tokenOwner.publicKey // freeze authority
  )
);

console.log(
  `Create mint txhash: ${await sendAndConfirmTransaction(
    connection,
    createMintTx,
    [tokenOwner, mintKeypair]
  )}`
);

// 3) Create token account using build-in function
console.log("\n3. Creating token account using build-in function...");
const tokenAccount = await getOrCreateAssociatedTokenAccount(
  connection,
  tokenOwner,
  mint, // mint
  tokenOwner.publicKey // owner
);
console.log(`Token account created: ${tokenAccount.address.toBase58()}`);

// 4) Create token account by composing transaction
console.log("\n4. Creating token account by composing transaction...");
const associatedTokenAddress = await getAssociatedTokenAddress(
  mintKeypair.publicKey, // mint
  tokenOwner.publicKey // owner
);

const createTokenAccountTx = new Transaction().add(
  createAssociatedTokenAccountInstruction(
    tokenOwner.publicKey, // payer
    associatedTokenAddress, // token address
    tokenOwner.publicKey, // owner
    mintKeypair.publicKey // mint
  )
);

console.log(
  `Create token account txhash: ${await sendAndConfirmTransaction(
    connection,
    createTokenAccountTx,
    [tokenOwner]
  )}`
);

// Use the created mint and token account for delegation
const mintPubkey = mint;
const tokenAccountPubkey = tokenAccount.address;

// 5) Approve delegation using build-in function
{
  console.log("\n5. Approving delegation with specific amount...");
  const txhash = await approveChecked(
    connection,
    tokenOwner,
    mintPubkey,
    tokenAccountPubkey,
    delegate.publicKey,
    tokenOwner,
    500000000,
    9
  );
  console.log(`Approve delegation txhash: ${txhash}`);
}

// 6) Approve delegation by composing transaction
{
  console.log("\n2. Approving delegation by composing transaction...");
  const tx = new Transaction().add(
    createApproveCheckedInstruction(
      tokenAccountPubkey, // token account
      mintPubkey, // mint
      delegate.publicKey, // delegate
      tokenOwner.publicKey, // owner of token account
      500000000, // amount, if your decimals is 9, 0.5 tokens
      9 // decimals
    )
  );
  console.log(
    `Approve delegation txhash: ${await sendAndConfirmTransaction(
      connection,
      tx,
      [tokenOwner]
    )}`
  );
}
```

</CodeTabs>

### Rust

<CodeTabs storage="token-rs" flags="r">

```rust !! title="Rust Async"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    native_token::LAMPORTS_PER_SOL,
    program_pack::Pack,
    signature::Keypair,
    signer::Signer,
    system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address,
    instruction::create_associated_token_account_idempotent,
};
use spl_token::{
    instruction::{ approve_checked, initialize_mint2 },
    state::Mint,
    ID as TOKEN_PROGRAM_ID,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed()
    );

    // Generate keypairs to use for authority, delegate and mint
    let authority_keypair = Keypair::new(); // will also act as tx fee payer
    let delegate_keypair = Keypair::new();
    let mint_account = Keypair::new();

    println!("Mint Authority Address: {}", authority_keypair.pubkey());
    println!("Delegate Address: {}", delegate_keypair.pubkey());
    println!("Mint Address: {}", mint_account.pubkey());

    // derive the mint authority ATA
    let associated_token_account = get_associated_token_address(
        &authority_keypair.pubkey(),
        &mint_account.pubkey()
    );

    // Airdrop authority, create the mint account and ATA
    setup(&client, &authority_keypair, &mint_account).await?;
    // Get mint decimals from the ATA
    let mint_decimals = client.get_token_account_balance(&associated_token_account).await?.decimals;

    // Amount of tokens to delegate (1 tokens with 9 decimal places)
    let amount_to_delegate = 1 * (10_u64).pow(mint_decimals as u32); // 1 token

    // Instruction to approve delegate
    let approve_delegate_ix = approve_checked(
        &TOKEN_PROGRAM_ID,
        &associated_token_account,
        &mint_account.pubkey(),
        &delegate_keypair.pubkey(),
        &authority_keypair.pubkey(),
        &[&authority_keypair.pubkey()],
        amount_to_delegate,
        mint_decimals
    )?;

    let mut transaction = Transaction::new_with_payer(
        &[approve_delegate_ix],
        Some(&authority_keypair.pubkey())
    );

    transaction.sign(&[&authority_keypair], client.get_latest_blockhash().await?);

    match client.send_and_confirm_transaction(&transaction).await {
        Ok(signature) => println!("Transaction Signature: {}", signature),
        Err(err) => eprintln!("Error approving delegate: {}", err),
    }

    Ok(())
}

// Helper function to airdrop, create the mint account and ATA
async fn setup(
    client: &RpcClient,
    authority_keypair: &Keypair,
    mint_account: &Keypair
) -> anyhow::Result<()> {
    // Airdrop 5 SOL to recipient
    let transaction_signature = client.request_airdrop(
        &authority_keypair.pubkey(),
        5 * LAMPORTS_PER_SOL
    ).await?;
    loop {
        if client.confirm_transaction(&transaction_signature).await? {
            break;
        }
    }

    /* constants */
    let decimals = 9;
    let mint_account_len = Mint::LEN;
    let mint_account_rent = client.get_minimum_balance_for_rent_exemption(mint_account_len).await?;

    // Create mint accounts instruction
    let create_mint_account_ix = create_account(
        &authority_keypair.pubkey(),
        &mint_account.pubkey(),
        mint_account_rent,
        mint_account_len as u64,
        &TOKEN_PROGRAM_ID
    );

    // Initialize mint instruction
    let initialize_mint_ix = initialize_mint2(
        &TOKEN_PROGRAM_ID,
        &mint_account.pubkey(),
        &authority_keypair.pubkey(),
        Some(&authority_keypair.pubkey()),
        decimals
    )?;

    // Create ATA instruction
    let create_ata_ix = create_associated_token_account_idempotent(
        &authority_keypair.pubkey(), // payer
        &authority_keypair.pubkey(), // wallet address
        &mint_account.pubkey(), // mint address
        &TOKEN_PROGRAM_ID
    );

    let mut transaction = Transaction::new_with_payer(
        &[create_mint_account_ix, initialize_mint_ix, create_ata_ix],
        Some(&authority_keypair.pubkey())
    );

    transaction.sign(&[authority_keypair, mint_account], client.get_latest_blockhash().await?);

    client.send_and_confirm_transaction(&transaction).await?;
    Ok(())
}

```

```rust !! title="Token Client"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    native_token::LAMPORTS_PER_SOL,
    signature::{ Keypair, Signer },
};
use spl_token::id as token_program_id;
use spl_token_client::{
    client::{ ProgramRpcClient, ProgramRpcClientSendTransaction },
    token::{ ExtensionInitializationParams, Token },
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed()
    );
    // Generate keypairs to use for authority, delegate and mint
    let authority_keypair = Keypair::new(); // will also act as tx fee payer
    let delegate_keypair = Keypair::new();
    let mint_keypair = Keypair::new();

    // Number of decimals for the mint
    let decimals = 9;

    println!("Mint Authority Address: {}", authority_keypair.pubkey());
    println!("Delegate Address: {}", delegate_keypair.pubkey());
    println!("Mint Address: {}", mint_keypair.pubkey());

    // Airdrop 5 SOL to authority keypair
    let transaction_signature = rpc_client.request_airdrop(
        &authority_keypair.pubkey(),
        5 * LAMPORTS_PER_SOL
    ).await?;
    loop {
        if rpc_client.confirm_transaction(&transaction_signature).await? {
            break;
        }
    }

    // Create a new program client
    let program_client = ProgramRpcClient::new(
        Arc::new(
            RpcClient::new_with_commitment(
                String::from("http://localhost:8899"),
                CommitmentConfig::confirmed()
            )
        ),
        ProgramRpcClientSendTransaction
    );

    // Create a token client for Token
    let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &mint_keypair.pubkey(),
        Some(decimals),
        Arc::new(authority_keypair.insecure_clone())
    );

    // Create and initialize the mint
    let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

    let mint_result = token.create_mint(
        &authority_keypair.pubkey(), // mint authority
        Some(&authority_keypair.pubkey()), // freeze authority
        extension_initialization_params, // no extensions
        &[&mint_keypair] // mint keypair needed as signer
    ).await?;
    println!("Mint Creation Result: {}", mint_result);

    // Derive mint authority ATA
    let mint_auth_associated_token_acc = token.get_associated_token_address(
        &authority_keypair.pubkey()
    );
    println!("Mint Authority Token Account Address: {}", mint_auth_associated_token_acc);

    // Then, create the associated token account for mint authority
    let create_mint_authority_ata_result = token.create_associated_token_account(
        &authority_keypair.pubkey() // owner
    ).await?;
    println!("Created Source Token Account: {}", create_mint_authority_ata_result);

    // Mint tokens to the associated token account
    let mint_amount = 1000 * (10_u64).pow(decimals as u32); // 1000 token
    let mint_to_result = token.mint_to(
        &mint_auth_associated_token_acc, // destination
        &authority_keypair.pubkey(), // authority (mint authority)
        mint_amount, // amount
        &[&authority_keypair] // additional signers (providing payer as a signer)
    ).await?;

    println!("Successfully minted 1.00 tokens to the associated token account");
    println!("Transaction Signature: {}", mint_to_result);

    let amount_to_delegate = 1 * (10_u64).pow(decimals as u32); // 10 tokens with 2 decimals

    let transaction_signature = token.approve(
        &mint_auth_associated_token_acc, // source
        &delegate_keypair.pubkey(), // delegate
        &authority_keypair.pubkey(), // authority
        amount_to_delegate, // amount
        &[&mint_keypair] // signers
    ).await?;

    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

</CodeTabs>
