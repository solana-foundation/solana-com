---
title: 트랜잭션 및 명령어
description:
  솔라나 블록체인과 상호작용하기 위한 기본 구성 요소인 솔라나 트랜잭션과
  명령어에 대해 알아보세요. 실용적인 예제를 통해 트랜잭션 구조와 명령어 구성을
  이해하세요.
---

Solana에서는 네트워크와 상호작용하기 위해
[트랜잭션](/docs/core/transactions#transaction)을 전송합니다. 트랜잭션에는
처리될 작업을 지정하는 하나 이상의
[명령어](/docs/core/transactions#instruction)가 포함됩니다. 명령어의 실행 로직은
Solana 네트워크에 배포된 [프로그램](/docs/core/programs)에 저장되며, 각
프로그램은 자체적인 명령어 세트를 정의합니다.

다음은 트랜잭션이 처리되는 방식에 대한 주요 세부 사항입니다:

- 트랜잭션에 여러 명령어가 포함된 경우, 명령어는 트랜잭션에 추가된 순서대로
  실행됩니다
- 트랜잭션은 "원자적"입니다 - 모든 명령어가 성공적으로 처리되거나, 전체
  트랜잭션이 실패하고 변경 사항이 적용되지 않습니다.

간단히 말해, 트랜잭션은 하나 또는 여러 명령어를 처리하기 위한 요청으로 생각할 수
있습니다.

![트랜잭션 간소화](/assets/docs/core/transactions/transaction-simple.svg)

트랜잭션은 양식이 들어 있는 봉투와 같다고 생각하세요. 각 양식은 네트워크에
무엇을 요청하는지 알려주는 명령어입니다. 트랜잭션을 보내는 것은 양식을 처리하기
위해 봉투를 우편으로 보내는 것과 같습니다.

## 주요 포인트

- Solana 트랜잭션에는 네트워크의 프로그램을 호출하기 위한 요청인 명령어가
  포함됩니다.
- 트랜잭션은 **원자적**입니다 - 어떤 명령어라도 실패하면 전체 트랜잭션이
  실패하고 변경 사항이 발생하지 않습니다.
- 트랜잭션의 명령어는 **순차적으로 처리**됩니다.
- 트랜잭션의 최대 크기는
  [1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
  바이트입니다.
- 각 명령어에는 3가지 정보가 필요합니다:
  1. 호출할 프로그램의 주소
  2. 명령어가 읽거나 쓸 계정
  3. 명령어에 필요한 추가 데이터(예: 함수 인수)

## 기본 예제

아래는 발신자에서 수신자로 SOL을 전송하는 단일 명령어가 있는 트랜잭션을 나타내는
다이어그램입니다.

Solana에서 "지갑"이라고 부르는 계정은
[시스템 프로그램](/docs/core/accounts#system-program)이 소유합니다. 프로그램
소유자만 계정 데이터를 수정할 수 있으므로, SOL을 전송하려면 시스템 프로그램을
호출하는 트랜잭션을 보내야 합니다.

![SOL 전송](/assets/docs/core/transactions/sol-transfer.svg)

송금자 계정은 자신의 lamport 잔액 차감을 승인하기 위해 트랜잭션에
서명(`is_signer`)해야 합니다. 송금자와 수취인 계정 모두 lamport 잔액이
변경되므로 쓰기 가능(`is_writable`)으로 표시되어야 합니다.

트랜잭션이 전송되면 시스템 프로그램이 호출되어 전송 명령을 처리합니다. 그런 다음
시스템 프로그램은 송금자와 수취인 계정의 lamport 잔액을 적절히 업데이트합니다.

![SOL 전송 프로세스](/assets/docs/core/transactions/sol-transfer-process.svg)

### SOL 전송하기

다음은 `SystemProgram.transfer` 메서드를 사용하여 SOL 전송 명령을 구축하는
방법을 보여주는
[Solana Playground](https://beta.solpg.io/656a0ea7fb53fa325bfd0c3e) 예제입니다:

```typescript title="SOL 전송"
// 전송할 금액 정의
const transferAmount = 0.01; // 0.01 SOL

// wallet_1에서 wallet_2로 SOL을 전송하기 위한 전송 명령 생성
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // transferAmount를 lamports로 변환
});

// 새 트랜잭션에 전송 명령 추가
const transaction = new Transaction().add(transferInstruction);
```

Playground 터미널에서 `run` 명령을 사용하거나 "Run" 버튼을 클릭하여 예제를
실행하세요.

<Callout type="info">

Playground 지갑에 devnet SOL이 있는지 확인하세요.
[Solana Faucet](https://faucet.solana.com/)에서 devnet SOL을 받을 수 있습니다.

</Callout>

아래 섹션에서는 트랜잭션과 명령에 대한 세부 사항을 살펴보겠습니다.

## 트랜잭션

솔라나

[트랜잭션](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)

은 다음으로 구성됩니다:

1. [서명](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30):
   트랜잭션에 포함된 서명 배열.
2. [메시지](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131):
   원자적으로 처리될 명령 목록.

```rust title="트랜잭션"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    pub message: Message,
}
```

![트랜잭션 형식](/assets/docs/core/transactions/tx_format.png)

트랜잭션 메시지의 구조는 다음과 같습니다:

- [메시지 헤더](/docs/core/transactions#message-header): 서명자 및 읽기 전용
  계정의 수를 지정합니다.
- [계정 주소](/docs/core/transactions#array-of-account-addresses): 트랜잭션의
  명령에 필요한 계정 주소 배열.
- [최근 블록해시](/docs/core/transactions#recent-blockhash): 트랜잭션의
  타임스탬프 역할을 합니다.
- [명령](/docs/core/transactions#array-of-instructions): 실행될 명령 배열.

```rust title="메시지"
pub struct Message {
    /// 메시지 헤더, 서명된 `account_keys`와 읽기 전용 `account_keys`를 식별합니다.
    pub header: MessageHeader,

    /// 이 트랜잭션에서 사용되는 모든 계정 키.
    #[serde(with = "short_vec")]
    pub account_keys: Vec<Pubkey>,

    /// 최근 원장 항목의 ID.
    pub recent_blockhash: Hash,

    /// 모두 성공하면 순차적으로 실행되고 하나의 원자적 트랜잭션으로 커밋되는 프로그램.
    #[serde(with = "short_vec")]
    pub instructions: Vec<CompiledInstruction>,
}
```

![트랜잭션 메시지](/assets/docs/core/transactions/legacy_message.png)

### 트랜잭션 크기

솔라나 트랜잭션은

[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)

바이트로 제한됩니다. 이 제한은 IPv6 MTU 크기인 1280바이트에서 네트워크 헤더(IPv6
40바이트 + 조각 헤더 8바이트)를 위한 48바이트를 뺀 크기입니다.

트랜잭션의 총 크기(서명과 메시지)는 이 제한 아래로 유지되어야 하며 다음으로
구성됩니다:

- 서명: 각 64바이트
- 메시지: 헤더(3바이트), 계정 키(각 32바이트), 최근 블록해시(32바이트) 및 명령어

![트랜잭션 형식](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### 메시지 헤더

[메시지 헤더](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)

는 계정 권한을 정의하기 위해 세 바이트를 사용합니다:

1. 필요한 서명과
   [메시지 버전](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/versions/mod.rs#L220-L231)
   (예: 레거시 vs v0)
2. 읽기 전용 서명된 계정 수
3. 읽기 전용 서명되지 않은 계정 수

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    pub num_readonly_unsigned_accounts: u8,
}
```

![메시지 헤더](/assets/docs/core/transactions/message_header.png)

### 컴팩트 배열 형식

트랜잭션 메시지의 컴팩트 배열은 다음 형식으로 직렬화된 배열을 의미합니다:

1. 배열
   길이([compact-u16](https://github.com/anza-xyz/agave/blob/v2.1.13/short-vec/src/lib.rs)로
   인코딩됨)
2. 배열 항목들이 하나씩 나열됨

![컴팩트 배열 형식](/assets/docs/core/transactions/compact_array_format.png)

이 형식은 트랜잭션 메시지에서
[계정 주소](/docs/core/transactions#array-of-account-addresses)와
[명령어](/docs/core/transactions#array-of-instructions) 배열의 길이를 인코딩하는
데 사용됩니다.

### 계정 주소 배열

트랜잭션 메시지는 명령어에 필요한

[계정 주소](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)

배열을 포함합니다. 배열은 포함된 주소 수를 나타내는
[compact-u16](/docs/core/transactions#compact-array-format) 숫자로 시작합니다.
그런 다음 주소는 메시지 헤더에 의해 결정되는 권한에 따라 정렬됩니다.

- 쓰기 가능하고 서명자인 계정
- 읽기 전용이고 서명자인 계정
- 쓰기 가능하고 서명자가 아닌 계정
- 읽기 전용이고 서명자가 아닌 계정

![계정 주소의 컴팩트 배열](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### 최근 블록해시

모든 트랜잭션은

[최근 블록해시](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L141)

가 필요하며 이는 두 가지 목적으로 사용됩니다:

1. 타임스탬프 역할을 합니다
2. 중복 트랜잭션을 방지합니다

블록해시는

[150](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)

개의 블록(400ms 블록 시간을 가정할 때 약 1분) 후에 만료되며, 이후에는 트랜잭션을
처리할 수 없습니다.

[`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) RPC 메서드를 사용하여
현재 블록해시와 블록해시가 유효한 마지막 블록 높이를 얻을 수 있습니다. 다음은
[Solana Playground](https://beta.solpg.io/661a06e1cffcf4b13384d046)의
예시입니다.

### 명령어 배열

트랜잭션 메시지는

[명령어](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)

배열을

[CompiledInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)

타입으로 포함합니다. 명령어는 트랜잭션에 추가될 때 이 타입으로 변환됩니다.

메시지의 계정 주소 배열과 마찬가지로,
[compact-u16](/docs/core/transactions#compact-array-format) 길이로 시작하고 그
뒤에 명령어 데이터가 옵니다. 각 명령어는 다음을 포함합니다:

1. 프로그램 ID 인덱스: 계정 주소 배열에서 프로그램의 주소를 가리키는 u8
   인덱스입니다. 이는 명령어를 처리할 프로그램을 지정합니다.
2. 계정 인덱스: 이 명령어에 필요한 계정 주소를 가리키는 u8 인덱스 배열입니다.
3. 명령어 데이터: 프로그램에서 어떤 명령어를 호출할지 지정하고 명령어에 필요한
   추가 데이터(예: 함수 인수)를 포함하는 바이트 배열입니다.

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// 프로그램 계정을 나타내는 트랜잭션 키 배열의 인덱스로, 이 명령어를 실행합니다.
    pub program_id_index: u8,
    /// 프로그램에 전달할 계정을 나타내는 트랜잭션 키 배열의 순서가 지정된 인덱스입니다.
    #[serde(with = "short_vec")]
    pub accounts: Vec<u8>,
    /// 프로그램 입력 데이터입니다.
    #[serde(with = "short_vec")]
    pub data: Vec<u8>,
}
```

![명령어의 컴팩트 배열](/assets/docs/core/transactions/compact_array_of_ixs.png)

### 트랜잭션 구조 예시

아래는 단일 [SOL 전송](/docs/core/transactions#basic-example) 명령어를 포함하는
트랜잭션 예시입니다. 트랜잭션의 구성 요소는 다음과 같습니다:

- `header`: `accountKeys` 배열에 있는 주소에 대한 읽기/쓰기 및 서명자 권한을
  지정합니다

- `accountKeys`: 트랜잭션의 명령어에 사용되는 모든 계정 주소의 배열

- `recentBlockhash`: 트랜잭션의 타임스탬프로 사용되는 블록해시

- `instructions`: 실행할 명령어 배열. 각 명령어의 `account`와 `programIdIndex`는
  인덱스로 `accountKeys` 배열을 참조합니다.

- `signatures`: 트랜잭션의 명령어에 의해 서명자로 요구되는 모든 계정에 대한
  서명을 포함하는 배열. 서명은 계정의 해당 개인 키를 사용하여 트랜잭션 메시지에
  서명함으로써 생성됩니다.

```json
"transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
        "5snoUseZG8s8CDFHrXY2ZHaCrJYsW457piktDmhyb5Jd",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "DzfXchZJoLMG3cNftcf2sw7qatkkuwQf4xH15N5wkKAb",
      "instructions": [
        {
          "accounts": [
            0,
            1
          ],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "5LrcE2f6uvydKRquEJ8xp19heGxSvqsVbcqUeFoiWbXe8JNip7ftPQNTAVPyTK7ijVdpkzmKKaAQR7MWMmujAhXD"
    ]
  }
```

## 명령어

배포된

[명령어](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)

[프로그램](/docs/core/accounts#program-account)에 대한 명령어는 Solana
네트워크를 사용하는 누구나 호출할 수 있는 공개 함수로 생각할 수 있습니다.

프로그램의 명령어를 호출하려면 다음 세 가지 핵심 정보를 제공해야 합니다:

- 프로그램 ID: 명령어를 실행하기 위해 호출되는 프로그램
- 계정: 명령어가 필요로 하는 계정 목록
- 명령어 데이터: 호출할 프로그램의 명령어와 명령어에 필요한 함수 인수를 지정하는
  바이트 배열

```rust title="Instruction"
pub struct Instruction {
    /// 이 명령어를 실행하는 프로그램의 Pubkey.
    pub program_id: Pubkey,
    /// 프로그램에 전달되어야 하는 계정을 설명하는 메타데이터.
    pub accounts: Vec<AccountMeta>,
    /// 프로그램이 자체적으로 해석하기 위한 불투명 데이터.
    pub data: Vec<u8>,
}
```

![트랜잭션 명령어](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

명령어에 필요한 각 계정은

[AccountMeta](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25)

형태로 제공되어야 하며 다음을 포함합니다:

- `pubkey`: 계정의 주소
- `is_signer`: 계정이 트랜잭션에 서명해야 하는지 여부
- `is_writable`: 명령어가 계정의 데이터를 수정할지 여부

```rust title="AccountMeta"
pub struct AccountMeta {
    /// 계정의 공개 키.
    pub pubkey: Pubkey,
    /// `Instruction`이 `pubkey`와 일치하는 `Transaction` 서명을 요구하는 경우 true.
    pub is_signer: bool,
    /// 프로그램 실행 중에 계정 데이터나 메타데이터가 변경될 수 있는 경우 true.
    pub is_writable: bool,
}
```

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

명령어가 어떤 계정에서 읽거나 쓸 것인지 미리 지정함으로써, 동일한 계정을
수정하지 않는 트랜잭션은 병렬로 처리될 수 있습니다.

### 명령어 구조 예시

아래는 SOL 전송 명령어의 구조를 보여주는 간단한 예시입니다:

- `keys`: 명령어에 필요한 각 계정에 대한 `AccountMeta`를 포함합니다.
- `programId`: 호출된 명령어에 대한 실행 로직을 포함하는 프로그램의 주소입니다.
- `data`: 명령어의 데이터를 바이트 버퍼 형태로 제공합니다.

```json
{
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  "programId": "11111111111111111111111111111111",
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

## 확장 예시

프로그램 명령어를 구축하는 세부 사항은 종종 클라이언트 라이브러리에 의해
추상화됩니다. 그러나 사용 가능한 라이브러리가 없는 경우, 항상 수동으로 명령어를
구축하는 방법으로 돌아갈 수 있습니다.

### SOL 전송하기

다음은 SOL 전송 명령어를 수동으로 구축하는 방법을 보여주는
[Solana Playground](https://beta.solpg.io/656a102efb53fa325bfd0c3f) 예시입니다.

내부적으로, `SystemProgram.transfer` 메서드를 사용하는
[간단한 예시](/docs/core/transactions#simple-sol-transfer)는 아래의 더 상세한
예시와 기능적으로 동일합니다. `SystemProgram.transfer` 메서드는 단순히 명령어
데이터 버퍼 생성과 명령어에 필요한 각 계정에 대한 `AccountMeta` 생성의 세부
사항을 추상화합니다.

아래 두 탭의 코드 조각은 기능적으로 동일합니다.

<Tabs items={['Build Instruction Manually', 'Use Library']}>
<Tab value="Build Instruction Manually">

```typescript
// 전송할 금액 정의
const transferAmount = 0.01; // 0.01 SOL

// SystemProgram 전송 명령어의 인덱스
const transferInstructionIndex = 2;

// 전송 명령어에 전달할 데이터 버퍼 생성
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// 버퍼에 명령어 인덱스 작성
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// 버퍼에 전송 금액 작성
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// 발신자에서 수신자로 SOL을 전송하기 위한 전송 명령어 수동 생성
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true }
  ],
  programId: SystemProgram.programId,
  data: instructionData
});

// 새 트랜잭션에 전송 명령어 추가
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
<Tab value="Use Library">

```typescript
// 전송할 금액 정의
const transferAmount = 0.01; // 0.01 SOL

// wallet_1에서 wallet_2로 SOL을 전송하기 위한 전송 명령어 생성
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // transferAmount를 lamports로 변환
});

// 새 트랜잭션에 전송 명령어 추가
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
</Tabs>

다음은 SOL 전송 명령어를 수동으로 구축하는 방법에 대한
[Solana Playground](https://beta.solpg.io/656a102efb53fa325bfd0c3f) 예제입니다.

내부적으로 `SystemProgram.transfer` 메서드를 사용하는
[간단한 예제](/docs/core/transactions#simple-sol-transfer)는 아래의 더 상세한
예제와 기능적으로 동일합니다. `SystemProgram.transfer` 메서드는 단순히 명령어
데이터 버퍼 생성과 명령어에 필요한 각 계정에 대한 `AccountMeta`를 추상화합니다.

아래 두 탭의 코드 조각은 기능적으로 동일합니다.

<Tabs items={['Build Instruction Manually', 'Use Library']}>
<Tab value="Build Instruction Manually">

```typescript
// 전송할 금액 정의
const transferAmount = 0.01; // 0.01 SOL

// SystemProgram 전송 명령어의 인덱스
const transferInstructionIndex = 2;

// 전송 명령어에 전달할 데이터 버퍼 생성
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// 버퍼에 명령어 인덱스 작성
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// 버퍼에 전송 금액 작성
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// 발신자에서 수신자로 SOL을 전송하기 위한 전송 명령어 수동 생성
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true }
  ],
  programId: SystemProgram.programId,
  data: instructionData
});

// 새 트랜잭션에 전송 명령어 추가
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
<Tab value="Use Library">

```typescript
// 전송할 금액 정의
const transferAmount = 0.01; // 0.01 SOL

// wallet_1에서 wallet_2로 SOL을 전송하기 위한 전송 명령어 생성
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // transferAmount를 lamports로 변환
});

// 새 트랜잭션에 전송 명령어 추가
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
</Tabs>

다음은 SOL 전송 명령어를 수동으로 구축하는 방법에 대한
[Solana Playground](https://beta.solpg.io/656a102efb53fa325bfd0c3f) 예제입니다.

내부적으로 `SystemProgram.transfer` 메서드를 사용하는
[간단한 예제](/docs/core/transactions#simple-sol-transfer)는 아래의 더 상세한
예제와 기능적으로 동일합니다. `SystemProgram.transfer` 메서드는 단순히 명령어
데이터 버퍼 생성과 명령어에 필요한 각 계정에 대한 `AccountMeta`를 추상화합니다.

아래 두 탭의 코드 조각은 기능적으로 동일합니다.

<Tabs items={['Build Instruction Manually', 'Use Library']}>
<Tab value="Build Instruction Manually">

```typescript
// 전송할 금액 정의
const transferAmount = 0.01; // 0.01 SOL

// SystemProgram 전송 명령어의 인덱스
const transferInstructionIndex = 2;

// 전송 명령어에 전달할 데이터 버퍼 생성
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// 버퍼에 명령어 인덱스 작성
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// 버퍼에 전송 금액 작성
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// 발신자에서 수신자로 SOL을 전송하기 위한 전송 명령어 수동 생성
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true }
  ],
  programId: SystemProgram.programId,
  data: instructionData
});

// 새 트랜잭션에 전송 명령어 추가
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
<Tab value="Use Library">

```typescript
// 전송할 금액 정의
const transferAmount = 0.01; // 0.01 SOL

// wallet_1에서 wallet_2로 SOL을 전송하기 위한 전송 명령어 생성
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // transferAmount를 lamports로 변환
});

// 새 트랜잭션에 전송 명령어 추가
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
</Tabs>

다음은 SOL 전송 명령어를 수동으로 구축하는 방법에 대한
[Solana Playground](https://beta.solpg.io/656a102efb53fa325bfd0c3f) 예제입니다.

내부적으로 `SystemProgram.transfer` 메서드를 사용하는
[간단한 예제](/docs/core/transactions#simple-sol-transfer)는 아래의 더 상세한
예제와 기능적으로 동일합니다. `SystemProgram.transfer` 메서드는 단순히 명령어
데이터 버퍼 생성과 명령어에 필요한 각 계정에 대한 `AccountMeta`를 추상화합니다.

아래 두 탭의 코드 조각은 기능적으로 동일합니다.

<Tabs items={['Build Instruction Manually', 'Use Library']}>
<Tab value="Build Instruction Manually">

```typescript
// 전송할 금액 정의
const transferAmount = 0.01; // 0.01 SOL

// SystemProgram 전송 명령어의 인덱스
const transferInstructionIndex = 2;

// 전송 명령어에 전달할 데이터 버퍼 생성
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// 버퍼에 명령어 인덱스 작성
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// 버퍼에 전송 금액 작성
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// 발신자에서 수신자로 SOL을 전송하기 위한 전송 명령어 수동 생성
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true }
  ],
  programId: SystemProgram.programId,
  data: instructionData
});

// 새 트랜잭션에 전송 명령어 추가
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
<Tab value="Use Library">

```typescript
// 전송할 금액 정의
const transferAmount = 0.01; // 0.01 SOL

// wallet_1에서 wallet_2로 SOL을 전송하기 위한 전송 명령어 생성
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // transferAmount를 lamports로 변환
});

// 새 트랜잭션에 전송 명령어 추가
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
</Tabs>
