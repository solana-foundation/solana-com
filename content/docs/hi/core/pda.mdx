---
title: प्रोग्राम डिराइव्ड एड्रेस
description:
  सोलाना पर प्रोग्राम डिराइव्ड एड्रेस (PDAs) के बारे में जानें - निर्धारित खाता
  पते जो सुरक्षित प्रोग्राम हस्ताक्षर को सक्षम बनाते हैं। PDA डेरिवेशन, कैनोनिकल
  बम्प्स और PDA खातों को कैसे बनाया जाए, इसे समझें।
h1: प्रोग्राम डिराइव्ड एड्रेस (PDA)
---

## मुख्य बिंदु

![प्रोग्राम डिराइव्ड एड्रेस](/assets/docs/core/pda/pda.svg)

यह समझना महत्वपूर्ण है कि सिर्फ प्रोग्राम डिराइव्ड एड्रेस (पीडीए) को डिराइव करने
से स्वचालित रूप से उस पते पर ऑन-चेन अकाउंट नहीं बनता है। पीडीए को ऑन-चेन पते के
रूप में उपयोग करने वाले अकाउंट्स को उस प्रोग्राम के माध्यम से स्पष्ट रूप से
बनाया जाना चाहिए जिसका उपयोग पते को डिराइव करने के लिए किया गया था। आप पीडीए को
डिराइव करने को मानचित्र पर एक पता खोजने के रूप में सोच सकते हैं। सिर्फ पता होने
का मतलब यह नहीं है कि उस स्थान पर कुछ बनाया गया है।

> इस खंड में पीडीए को डिराइव करने के विवरण को कवर किया जाएगा। प्रोग्राम कैसे
> हस्ताक्षर के लिए पीडीए का उपयोग करते हैं, इसके विवरण
> [क्रॉस प्रोग्राम इनवोकेशन (सीपीआई)](/docs/core/cpi) के खंड में संबोधित किए
> जाएंगे क्योंकि इसके लिए दोनों अवधारणाओं के संदर्भ की आवश्यकता होती है।

## प्रमुख बिंदु

- पीडीए ऐसे पते हैं जो उपयोगकर्ता-परिभाषित बीजों, एक बंप बीज और प्रोग्राम के
  आईडी के संयोजन का उपयोग करके **निर्धारित रूप से डिराइव** किए जाते हैं।
- पीडीए ऐसे पते हैं जो Ed25519 वक्र से बाहर हैं और **जिनकी कोई संबंधित निजी
  कुंजी नहीं है**।
- सोलाना प्रोग्राम **अपने प्रोग्राम आईडी का उपयोग करके डिराइव किए गए पीडीए की ओर
  से हस्ताक्षर कर सकते हैं**।
- पीडीए को डिराइव करने से स्वचालित रूप से ऑन-चेन अकाउंट नहीं बनता है।
- पीडीए को अपने पते के रूप में उपयोग करने वाले अकाउंट को सोलाना प्रोग्राम के
  भीतर एक समर्पित निर्देश के माध्यम से स्पष्ट रूप से बनाया जाना चाहिए।

## पीडीए क्या है

पीडीए ऐसे पते हैं जो निर्धारित रूप से डिराइव किए जाते हैं और मानक पब्लिक की तरह
दिखते हैं, लेकिन उनसे जुड़ी कोई निजी कुंजी नहीं होती है। इसका मतलब है कि कोई भी
बाहरी उपयोगकर्ता पते के लिए एक वैध हस्ताक्षर नहीं बना सकता है। हालांकि, सोलाना
रनटाइम प्रोग्राम को निजी कुंजी की आवश्यकता के बिना पीडीए के लिए प्रोग्रामेटिक
रूप से "हस्ताक्षर" करने में सक्षम बनाता है।

संदर्भ के लिए, सोलाना

[कीपेयर्स](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/src/signer/keypair.rs#L25)

Ed25519 कर्व (एलिप्टिक-कर्व क्रिप्टोग्राफी) पर बिंदु हैं जिनमें एक पब्लिक की और
उसके अनुरूप प्राइवेट की होती है। हम अक्सर नए ऑन-चेन अकाउंट्स के लिए यूनिक आईडी
के रूप में पब्लिक की और साइनिंग के लिए प्राइवेट की का उपयोग करते हैं।

![ऑन कर्व एड्रेस](/assets/docs/core/pda/address-on-curve.svg)

PDA एक ऐसा बिंदु है जो जानबूझकर पूर्वनिर्धारित इनपुट सेट का उपयोग करके Ed25519
कर्व से बाहर निकलने के लिए डिराइव किया जाता है। जो बिंदु Ed25519 कर्व पर नहीं
है, उसके पास कोई वैध प्राइवेट की नहीं होती और क्रिप्टोग्राफिक ऑपरेशन (साइनिंग)
के लिए इसका उपयोग नहीं किया जा सकता।

PDA को फिर एक ऑन-चेन अकाउंट के एड्रेस (यूनिक आइडेंटिफायर) के रूप में उपयोग किया
जा सकता है, जो प्रोग्राम स्टेट को आसानी से स्टोर, मैप और फेच करने का तरीका
प्रदान करता है।

![ऑफ कर्व एड्रेस](/assets/docs/core/pda/address-off-curve.svg)

## PDA कैसे डिराइव करें

PDA की डेरिवेशन के लिए 3 इनपुट की आवश्यकता होती है।

- **वैकल्पिक सीड्स**: पूर्वनिर्धारित इनपुट (जैसे स्ट्रिंग, नंबर, अन्य अकाउंट
  एड्रेस) जिनका उपयोग PDA डिराइव करने के लिए किया जाता है। इन इनपुट को बाइट्स के
  बफर में परिवर्तित किया जाता है।
- **बंप सीड**: एक अतिरिक्त इनपुट (255-0 के बीच मूल्य के साथ) जिसका उपयोग यह
  गारंटी देने के लिए किया जाता है कि एक वैध PDA (ऑफ कर्व) जनरेट किया जाए। इस बंप
  सीड (255 से शुरू) को PDA जनरेट करते समय वैकल्पिक सीड्स के साथ जोड़ा जाता है
  ताकि बिंदु को Ed25519 कर्व से "बंप" किया जा सके। बंप सीड को कभी-कभी "नॉन्स" भी
  कहा जाता है।
- **प्रोग्राम आईडी**: उस प्रोग्राम का एड्रेस जिससे PDA डिराइव किया गया है। यह
  वही प्रोग्राम है जो PDA की ओर से "साइन" कर सकता है

![PDA डेरिवेशन](/assets/docs/core/pda/pda-derivation.svg)

नीचे दिए गए उदाहरणों में सोलाना प्लेग्राउंड के लिंक शामिल हैं, जहां आप
इन-ब्राउज़र एडिटर में उदाहरणों को चला सकते हैं।

### FindProgramAddress

एक PDA प्राप्त करने के लिए, हम उपयोग कर सकते हैं

[`findProgramAddressSync`](https://github.com/solana-labs/solana-web3.js/blob/ca9da583a39cdf8fd874a2e03fccdc849e29de34/packages/library-legacy/src/publickey.ts#L212)

[`@solana/web3.js`](https://www.npmjs.com/package/@solana/web3.js) से विधि। अन्य
प्रोग्रामिंग भाषाओं में इस फ़ंक्शन के समकक्ष हैं (जैसे
[Rust](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/pubkey.rs#L484)),
लेकिन इस खंड में, हम जावास्क्रिप्ट का उपयोग करके उदाहरणों के माध्यम से चलेंगे।

`findProgramAddressSync` विधि का उपयोग करते समय, हम इनपुट करते हैं:

- पूर्वनिर्धारित वैकल्पिक बीज जो बाइट्स के बफर में परिवर्तित किए गए हैं, और
- प्रोग्राम आईडी (पता) जिसका उपयोग PDA प्राप्त करने के लिए किया जाता है

एक बार जब एक वैध PDA मिल जाता है, `findProgramAddressSync` पता (PDA) और बंप सीड
दोनों लौटाता है जिसका उपयोग PDA प्राप्त करने के लिए किया गया था।

नीचे दिया गया उदाहरण बिना किसी वैकल्पिक बीज प्रदान किए एक PDA प्राप्त करता है।

```ts /[]/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");

const [PDA, bump] = PublicKey.findProgramAddressSync([], programId);

console.log(`PDA: ${PDA}`);
console.log(`Bump: ${bump}`);
```

आप इस उदाहरण को
[Solana Playground](https://beta.solpg.io/66031e5acffcf4b13384cfef) पर चला सकते
हैं। PDA और बंप सीड आउटपुट हमेशा समान होंगे:

```
PDA: Cu7NwqCXSmsR5vgGA3Vw9uYVViPi3kQvkbKByVQ8nPY9
Bump: 255
```

अगला उदाहरण एक वैकल्पिक बीज "helloWorld" जोड़ता है।

```ts /string/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";

const [PDA, bump] = PublicKey.findProgramAddressSync(
  [Buffer.from(string)],
  programId
);

console.log(`PDA: ${PDA}`);
console.log(`Bump: ${bump}`);
```

आप इस उदाहरण को भी
[Solana Playground](https://beta.solpg.io/66031ee5cffcf4b13384cff0) पर चला सकते
हैं। PDA और बंप सीड आउटपुट हमेशा समान होंगे:

```
PDA: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
Bump: 254
```

ध्यान दें कि बंप सीड 254 है। इसका मतलब है कि 255 ने Ed25519 वक्र पर एक बिंदु
प्राप्त किया, और यह एक वैध PDA नहीं है।

`findProgramAddressSync` द्वारा लौटाया गया बंप सीड वैकल्पिक बीज और प्रोग्राम
आईडी के दिए गए संयोजन के लिए पहला मान (255-0 के बीच) है जो एक वैध PDA प्राप्त
करता है।

> इस पहले वैध बंप सीड को "कैनोनिकल बंप" कहा जाता है। प्रोग्राम सुरक्षा के लिए,
> PDAs के साथ काम करते समय केवल कैनोनिकल बंप का उपयोग करने की सिफारिश की जाती
> है।

### CreateProgramAddress

अंदर से, `findProgramAddressSync` क्रमिक रूप से एक अतिरिक्त bump सीड (nonce) को
सीड्स बफर में जोड़ेगा और

[`createProgramAddressSync`](https://github.com/solana-labs/solana-web3.js/blob/ca9da583a39cdf8fd874a2e03fccdc849e29de34/packages/library-legacy/src/publickey.ts#L168)

विधि को कॉल करेगा। bump सीड 255 मान से शुरू होता है और एक वैध PDA (ऑफ कर्व)
मिलने तक 1 से घटाया जाता है।

आप पिछले उदाहरण को `createProgramAddressSync` का उपयोग करके और स्पष्ट रूप से 254
के bump सीड को पास करके दोहरा सकते हैं।

```ts /bump/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";
const bump = 254;

const PDA = PublicKey.createProgramAddressSync(
  [Buffer.from(string), Buffer.from([bump])],
  programId
);

console.log(`PDA: ${PDA}`);
```

इस उदाहरण को [Solana Playground](https://beta.solpg.io/66031f8ecffcf4b13384cff1)
पर चलाएँ। समान सीड्स और प्रोग्राम आईडी के साथ, PDA आउटपुट पिछले वाले से मेल
खाएगा:

```
PDA: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
```

### कैनोनिकल बंप

"कैनोनिकल बंप" पहले बंप सीड (255 से शुरू होकर और 1 से घटते हुए) को संदर्भित करता
है जो एक वैध PDA उत्पन्न करता है। प्रोग्राम सुरक्षा के लिए, यह सिफारिश की जाती
है कि केवल कैनोनिकल बंप से उत्पन्न PDA का उपयोग करें।

पिछले उदाहरण का संदर्भ लेते हुए, नीचे दिया गया उदाहरण 255-0 तक हर बंप सीड का
उपयोग करके एक PDA उत्पन्न करने का प्रयास करता है।

```ts
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";

// प्रदर्शन के लिए सभी बंप सीड्स के माध्यम से लूप
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(string), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

उदाहरण को [Solana Playground](https://beta.solpg.io/66032009cffcf4b13384cff2) पर
चलाएँ और आपको निम्न आउटपुट दिखाई देगा:

```
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// शेष बंप आउटपुट
```

जैसा कि अपेक्षित था, बंप सीड 255 एक त्रुटि फेंकता है और वैध PDA उत्पन्न करने
वाला पहला बंप सीड 254 है।

हालांकि, ध्यान दें कि बंप सीड्स 253-251 सभी अलग-अलग पतों के साथ वैध PDA उत्पन्न
करते हैं। इसका मतलब है कि समान वैकल्पिक सीड्स और `programId` के साथ, एक अलग मान
वाला बंप सीड अभी भी एक वैध PDA उत्पन्न कर सकता है।

<Callout type="warn">
  सोलाना प्रोग्राम बनाते समय, यह अनुशंसित है कि सुरक्षा जांच शामिल करें
  जो प्रोग्राम को पास किए गए PDA को सत्यापित करती हैं कि वह कैनोनिकल बंप का उपयोग करके उत्पन्न किया गया है।
  ऐसा करने में विफलता कमजोरियों को पेश कर सकती है जो अप्रत्याशित
  खातों को प्रोग्राम में प्रदान करने की अनुमति देती हैं।
</Callout>

## PDA खाते बनाएँ

यह उदाहरण प्रोग्राम

[Solana Playground](https://beta.solpg.io/github.com/ZYJLiu/doc-examples/tree/main/pda-account)

पर दिखाता है कि कैसे PDA को नए खाते के पते के रूप में उपयोग करके एक खाता बनाया
जाता है। यह उदाहरण प्रोग्राम Anchor फ्रेमवर्क का उपयोग करके लिखा गया है।

`lib.rs` फ़ाइल में, आपको निम्नलिखित प्रोग्राम मिलेगा जिसमें PDA को खाते के पते
के रूप में उपयोग करके एक नया खाता बनाने के लिए एक एकल निर्देश शामिल है। नया खाता
`user` का पता और PDA को प्राप्त करने के लिए उपयोग किए गए `bump` सीड को संग्रहित
करता है।

```rust title="lib.rs" {11-14,26-29}
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        init,
        // set the seeds to derive the PDA
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]

#[derive(InitSpace)]
pub struct DataAccount {
    pub user: Pubkey,
    pub bump: u8,
}
```

PDA प्राप्त करने के लिए उपयोग किए गए सीड्स में हार्डकोडेड स्ट्रिंग `data` और
निर्देश में प्रदान किए गए `user` खाते का पता शामिल है। Anchor फ्रेमवर्क स्वचालित
रूप से कैनोनिकल `bump` सीड प्राप्त करता है।

```rust /data/ /user.key()/ /bump/
#[account(
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

`init` कंस्ट्रेंट Anchor को PDA को पते के रूप में उपयोग करके एक नया खाता बनाने
के लिए सिस्टम प्रोग्राम को इनवोक करने का निर्देश देता है। अंदर से, यह
[CPI](/docs/core/cpi) के माध्यम से किया जाता है।

```rust /init/
#[account(
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

टेस्ट फ़ाइल (`pda-account.test.ts`) में, जो ऊपर दिए गए Solana Playground लिंक के
भीतर स्थित है, आपको PDA प्राप्त करने के लिए Javascript समकक्ष मिलेगा।

```ts /data/ /user.publicKey/
const [PDA] = PublicKey.findProgramAddressSync(
  [Buffer.from("data"), user.publicKey.toBuffer()],
  program.programId
);
```

फिर एक ट्रांजैक्शन भेजा जाता है जो PDA को पते के रूप में उपयोग करके एक नया
ऑन-चेन खाता बनाने के लिए `initialize` निर्देश को इनवोक करता है। ट्रांजैक्शन भेजे
जाने के बाद, PDA का उपयोग उस ऑन-चेन खाते को प्राप्त करने के लिए किया जाता है जो
पते पर बनाया गया था।

```ts /initialize()/ /PDA/  {14}
it("Is initialized!", async () => {
  const transactionSignature = await program.methods
    .initialize()
    .accounts({
      user: user.publicKey,
      pdaAccount: PDA
    })
    .rpc();

  console.log("Transaction Signature:", transactionSignature);
});

it("Fetch Account", async () => {
  const pdaAccount = await program.account.dataAccount.fetch(PDA);
  console.log(JSON.stringify(pdaAccount, null, 2));
});
```

ध्यान दें कि यदि आप एक ही `user` पते को सीड के रूप में उपयोग करके `initialize`
निर्देश को एक से अधिक बार इनवोक करते हैं, तो ट्रांजैक्शन विफल हो जाएगा। ऐसा
इसलिए है क्योंकि प्राप्त पते पर पहले से ही एक खाता मौजूद होगा।
