---
title: Program Derived Address
description:
  सोलाना पर Program Derived Addresses (PDAs) के बारे में जानें - निर्धारित खाता
  पते जो सुरक्षित प्रोग्राम हस्ताक्षर को सक्षम बनाते हैं। PDA डेरिवेशन, कैनोनिकल
  बम्प्स और PDA खातों को कैसे बनाया जाए, इसे समझें।
h1: Program Derived Address (PDA)
---

Program Derived Addresses (PDAs) सोलाना पर डेवलपर्स को दो मुख्य उपयोग के मामले
प्रदान करते हैं:

- **निर्धारित खाता पते**: PDAs वैकल्पिक "seeds" (पूर्वनिर्धारित इनपुट) और एक
  विशिष्ट प्रोग्राम आईडी के संयोजन का उपयोग करके निर्धारित रूप से एक पता बनाने
  का तंत्र प्रदान करते हैं।
- **प्रोग्राम हस्ताक्षर सक्षम करें**: सोलाना रनटाइम प्रोग्राम को प्रोग्राम के
  पते से प्राप्त PDAs के लिए "हस्ताक्षर" करने में सक्षम बनाता है।

आप PDAs को ऑन-चेन हैशमैप जैसी संरचनाओं को बनाने के तरीके के रूप में सोच सकते
हैं, जो पूर्वनिर्धारित इनपुट सेट (जैसे स्ट्रिंग्स, नंबर और अन्य खाता पते) से
बनाई जाती हैं।

इस दृष्टिकोण का लाभ यह है कि इससे सटीक पते को ट्रैक करने की आवश्यकता समाप्त हो
जाती है। इसके बजाय, आपको बस उन विशिष्ट इनपुट को याद रखने की जरूरत है जिनका उपयोग
इसके डेरिवेशन के लिए किया गया था।

![Program Derived Address](/assets/docs/core/pda/pda.svg)

यह समझना महत्वपूर्ण है कि केवल Program Derived Address (PDA) को डेराइव करने से
स्वचालित रूप से उस पते पर ऑन-चेन खाता नहीं बनता है। PDA वाले खातों को ऑन-चेन पते
के रूप में स्पष्ट रूप से उस प्रोग्राम के माध्यम से बनाया जाना चाहिए जिसका उपयोग
पते को डेराइव करने के लिए किया गया था। आप PDA को डेराइव करने को मानचित्र पर एक
पता खोजने के रूप में सोच सकते हैं। सिर्फ पता होने का मतलब यह नहीं है कि वहां कुछ
बनाया गया है।

<Callout type="info">
  यह खंड PDAs को डेराइव करने के विवरण को कवर करता है। [Cross Program Invocations
  (CPIs)](/docs/core/cpi) पर खंड बताता है कि कैसे प्रोग्राम हस्ताक्षर के लिए
  PDAs का उपयोग करते हैं।
</Callout>

## मुख्य बिंदु

- PDAs ऐसे पते हैं जो पूर्वनिर्धारित seeds, एक bump seed और प्रोग्राम के आईडी के
  संयोजन का उपयोग करके **निर्धारित रूप से डेराइव** किए जाते हैं।
- PDAs ऐसे पते हैं जो Ed25519 कर्व से बाहर हैं और **जिनकी कोई संबंधित प्राइवेट
  की नहीं है**।
- सोलाना प्रोग्राम **अपने प्रोग्राम आईडी से डेराइव किए गए PDAs की ओर से
  हस्ताक्षर कर सकते हैं**।
- PDA को डेराइव करने से स्वचालित रूप से ऑन-चेन खाता नहीं बनता है।
- PDA को अपने पते के रूप में उपयोग करने वाले खाते को सोलाना प्रोग्राम के भीतर एक
  निर्देश के माध्यम से बनाया जाना चाहिए।

## PDA क्या है

PDA ऐसे पते हैं जो निश्चित रूप से निकलते हैं और पब्लिक की जैसे दिखते हैं, लेकिन
इनकी कोई प्राइवेट की नहीं होती। इसका मतलब है कि इस पते के लिए एक वैध हस्ताक्षर
बनाना संभव नहीं है। हालांकि, Solana रनटाइम प्रोग्राम्स को प्राइवेट की की
आवश्यकता के बिना PDA के लिए "हस्ताक्षर" करने में सक्षम बनाता है।

संदर्भ के लिए, Solana
[Keypairs](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/keypair/src/lib.rs#L26)
Ed25519 कर्व (एलिप्टिक-कर्व क्रिप्टोग्राफी) पर बिंदु हैं जिनमें एक पब्लिक की और
उसकी संबंधित प्राइवेट की होती है। पब्लिक की को ऑन-चेन अकाउंट्स के लिए पते
(अद्वितीय पहचानकर्ता) के रूप में उपयोग किया जाता है।

![ऑन कर्व एड्रेस](/assets/docs/core/pda/address-on-curve.svg)

PDA एक ऐसा बिंदु है जिसे जानबूझकर पूर्वनिर्धारित इनपुट सेट का उपयोग करके Ed25519
कर्व से बाहर निकालने के लिए डिज़ाइन किया गया है। जो बिंदु Ed25519 कर्व पर नहीं
है, उसकी कोई वैध संबंधित प्राइवेट की नहीं होती और वह क्रिप्टोग्राफिक ऑपरेशन
(साइनिंग) नहीं कर सकता।

PDA एक ऑन-चेन अकाउंट के लिए पते (अद्वितीय पहचानकर्ता) के रूप में काम कर सकता है,
जो प्रोग्राम स्टेट को आसानी से स्टोर, मैप और फेच करने का एक तरीका प्रदान करता
है।

![ऑफ कर्व एड्रेस](/assets/docs/core/pda/address-off-curve.svg)

## PDA कैसे प्राप्त करें

PDA प्राप्त करने के लिए तीन इनपुट की आवश्यकता होती है:

- **वैकल्पिक seed**: PDA प्राप्त करने के लिए पूर्वनिर्धारित इनपुट (जैसे
  स्ट्रिंग्स, नंबर्स, अन्य अकाउंट पते)।
- **bump seed**: वैकल्पिक seed में जोड़ा गया एक अतिरिक्त बाइट जो यह सुनिश्चित
  करता है कि एक वैध PDA (ऑफ कर्व) उत्पन्न हो। bump seed 255 से शुरू होता है और
  एक वैध PDA मिलने तक 1 से घटता जाता है।
- **Program ID**: उस प्रोग्राम का पता जिससे PDA प्राप्त किया जाता है। यह
  प्रोग्राम PDA की ओर से हस्ताक्षर कर सकता है।

![PDA डेरिवेशन](/assets/docs/core/pda/pda-derivation.svg)

PDA प्राप्त करने के लिए संबंधित SDK से निम्नलिखित फंक्शन का उपयोग करें।

| SDK                            | फंक्शन                                                                                                                           |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `@solana/kit` (Typescript)     | [`getProgramDerivedAddress`](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L157) |
| `@solana/web3.js` (Typescript) | [`findProgramAddressSync`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/publickey.ts#L212)               |
| `solana_sdk` (Rust)            | [`find_program_address`](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/pubkey/src/lib.rs#L617)                        |

PDA प्राप्त करने के लिए, SDK फंक्शन में निम्नलिखित इनपुट प्रदान करें:

- बाइट्स में परिवर्तित पूर्वनिर्धारित वैकल्पिक seeds
- डेरिवेशन के लिए उपयोग किया गया प्रोग्राम ID (एड्रेस)

एक वैध PDA मिलने के बाद, फंक्शन एड्रेस (PDA) और डेरिवेशन के लिए उपयोग किए गए
bump seed दोनों को वापस करता है।

### उदाहरण

निम्नलिखित उदाहरण दिखाते हैं कि संबंधित SDK का उपयोग करके PDA कैसे प्राप्त किया
जाए।

कोड को चलाने के लिए "Run" बटन पर क्लिक करें।

#### वैकल्पिक स्ट्रिंग seed के साथ PDA प्राप्त करें

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;

    let seeds: &[&[u8]] = &[b"helloWorld"];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### वैकल्पिक एड्रेस seed के साथ PDA प्राप्त करें

<CodeTabs storage="pda-examples"flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;

    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### कई वैकल्पिक seeds के साथ PDA प्राप्त करें

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const optionalSeedString = "helloWorld";
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedString, optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const optionalSeedString = "helloWorld";
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [Buffer.from(optionalSeedString), optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;

    let optional_seed_bytes = b"helloWorld";
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

### कैनोनिकल बंप

PDA डेरिवेशन के लिए एक "bump seed" की आवश्यकता होती है, जो वैकल्पिक seeds के साथ
जोड़ा गया एक अतिरिक्त बाइट है। डेरिवेशन फंक्शन बंप वैल्यू के माध्यम से
पुनरावृत्ति करता है, 255 से शुरू करके और 1 से घटाते हुए, जब तक कोई वैल्यू एक वैध
ऑफ-कर्व एड्रेस उत्पन्न नहीं करती। पहला बंप वैल्यू जो एक वैध ऑफ-कर्व एड्रेस
उत्पन्न करता है, वह "canonical bump" है।

निम्नलिखित उदाहरण सभी संभावित बंप seeds (255 से 0) का उपयोग करके PDA डेरिवेशन
दिखाते हैं:

<Callout type="info">
  Kit उदाहरण शामिल नहीं किया गया है क्योंकि
  [createProgramDerivedAddress](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L101)
  फंक्शन एक्सपोर्ट नहीं किया गया है।
</Callout>

<CodeTabs flags="r">

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const optionalSeed = "helloWorld";

// Loop through all bump seeds (255 down to 0)
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(optionalSeed), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed = b"helloWorld";

    // Loop through all bump seeds (255 down to 0)
    for bump in (0..=255).rev() {
        match Pubkey::create_program_address(&[optional_seed.as_ref(), &[bump]], &program_id) {
            Ok(pda) => println!("bump {}: {}", bump, pda),
            Err(err) => println!("bump {}: {}", bump, err),
        }
    }

    Ok(())
}
```

</CodeTabs>

<CodeTabs>

```sh !! title="Expected TS Output"
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// remaining bump outputs
```

```sh !! title="Expected Rust Output"
bump 255: Provided seeds do not result in a valid address
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Provided seeds do not result in a valid address
...
// remaining bump outputs
```

</CodeTabs>

बंप seed 255 एक एरर थ्रो करता है और वैध PDA प्राप्त करने वाला पहला बंप seed 254
है।

ध्यान दें कि बंप seeds 253-251 सभी अलग-अलग एड्रेस के साथ वैध PDA प्राप्त करते
हैं। इसका मतलब है कि समान वैकल्पिक seeds और `programId` के साथ, एक अलग मूल्य
वाला बंप seed अभी भी एक वैध PDA प्राप्त कर सकता है।

<Callout type="warn">
  Solana प्रोग्राम बनाते समय, हमेशा यह सुनिश्चित करने के लिए सुरक्षा जांच शामिल
  करें कि प्रोग्राम को पास किया गया PDA कैनोनिकल बंप से प्राप्त किया गया है। इन
  जांचों को शामिल करने में विफलता कमजोरियों को पेश कर सकती है जो अप्रत्याशित
  खातों को प्रोग्राम निर्देशों में उपयोग करने की अनुमति देती हैं। PDA प्राप्त
  करते समय केवल कैनोनिकल बंप का उपयोग करना सबसे अच्छा अभ्यास है।
</Callout>

## PDA खाते बनाएं

नीचे दिया गया उदाहरण प्रोग्राम दिखाता है कि नए खाते के एड्रेस के रूप में PDA का
उपयोग करके एक खाता कैसे बनाया जाए। उदाहरण प्रोग्राम
[Anchor framework](https://www.anchor-lang.com/docs) का उपयोग करता है।

प्रोग्राम में एक एकल `initialize` निर्देश शामिल है जो खाते के एड्रेस के रूप में
PDA का उपयोग करके एक नया खाता बनाता है। नया खाता `user` का एड्रेस और PDA प्राप्त
करने के लिए उपयोग किए गए `bump` seed को स्टोर करता है।

<CodeTabs>

```rs !! title="Program"
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        // !mark
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bump
        // !mark
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        init,
        // define the seeds to derive the PDA
        // !mark
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        // !mark
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]

#[derive(InitSpace)]
pub struct DataAccount {
    pub user: Pubkey,
    pub bump: u8,
}
```

```ts !! title="Test"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PdaAccount } from "../target/types/pda_account";
import { PublicKey } from "@solana/web3.js";

describe("pda-account", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.PdaAccount as Program<PdaAccount>;
  const user = provider.wallet as anchor.Wallet;

  // Derive the PDA address using the seeds specified on the program
  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("data"), user.publicKey.toBuffer()],
    program.programId
  );

  it("Is initialized!", async () => {
    const transactionSignature = await program.methods
      .initialize()
      .accounts({
        user: user.publicKey
      })
      .rpc();

    console.log("Transaction Signature:", transactionSignature);
  });

  it("Fetch Account", async () => {
    const pdaAccount = await program.account.dataAccount.fetch(PDA);
    console.log(JSON.stringify(pdaAccount, null, 2));
  });
});
```

</CodeTabs>

इस उदाहरण में, PDA डेरिवेशन के लिए seeds में फिक्स्ड स्ट्रिंग `data` और निर्देश
में प्रदान किए गए `user` अकाउंट का एड्रेस शामिल है। Anchor फ्रेमवर्क स्वचालित
रूप से कैनोनिकल `bump` seed को खोज लेता है।

```rust title="pda_account"
#[account(
    init,
    // !mark[/seeds/]
    seeds = [b"data", user.key().as_ref()],
    // !mark[/bump/]
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

`init` कंस्ट्रेंट Anchor को निर्देश देता है कि वह PDA को एड्रेस के रूप में उपयोग
करके नया अकाउंट बनाने के लिए सिस्टम प्रोग्राम को इनवोक करे। Anchor यह
[CPI](/docs/core/cpi) के माध्यम से करता है।

```rust title="pda_account"
#[account(
    // !mark[/init/]
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

टेस्ट फाइल में PDA को डेराइव करने के लिए Typescript कोड शामिल है।

```ts title="Derive PDA"
const [PDA] = PublicKey.findProgramAddressSync(
  // !mark
  [Buffer.from("data"), user.publicKey.toBuffer()],
  program.programId
);
```

टेस्ट फाइल में ट्रांजैक्शन `initialize` निर्देश को इनवोक करता है ताकि PDA को
एड्रेस के रूप में उपयोग करके एक नया ऑन-चेन अकाउंट बनाया जा सके। इस उदाहरण में,
Anchor निर्देश अकाउंट्स में PDA एड्रेस का अनुमान लगा सकता है, इसलिए इसे स्पष्ट
रूप से प्रदान करने की आवश्यकता नहीं है।

```ts title="Invoke Initialize Instruction"
it("Is initialized!", async () => {
  const transactionSignature = await program.methods
    // !mark
    .initialize()
    .accounts({
      user: user.publicKey
    })
    .rpc();

  console.log("Transaction Signature:", transactionSignature);
});
```

टेस्ट फाइल यह भी दिखाती है कि ट्रांजैक्शन भेजने के बाद उस एड्रेस पर बनाए गए
ऑन-चेन अकाउंट को कैसे फेच किया जाए।

```ts title="Fetch Account"
it("Fetch Account", async () => {
  // !mark
  const pdaAccount = await program.account.dataAccount.fetch(PDA);
  console.log(JSON.stringify(pdaAccount, null, 2));
});
```

ध्यान दें कि इस उदाहरण में, अगर आप एक ही `user` एड्रेस को seed के रूप में उपयोग
करके `initialize` निर्देश को एक से अधिक बार इनवोक करते हैं, तो ट्रांजैक्शन विफल
हो जाएगा। ऐसा इसलिए होता है क्योंकि डेराइव किए गए एड्रेस पर पहले से ही एक अकाउंट
मौजूद है।
