---
title: प्रोग्राम व्युत्पन्न पता
description:
  सोलाना पर प्रोग्राम व्युत्पन्न पतों (PDAs) के बारे में जानें - निश्चित खाता
  पते जो सुरक्षित प्रोग्राम साइनिंग की अनुमति देते हैं। PDA व्युत्पत्ति,
  मानक बम्प और PDA खातों को बनाने के तरीके को समझें।
h1: प्रोग्राम व्युत्पन्न पता (PDA)
---

प्रोग्राम व्युत्पन्न पते (PDAs) सोलाना पर डेवलपर्स को दो मुख्य उपयोग
केस प्रदान करते हैं:

- **निश्चित खाता पते**: PDAs एक तंत्र प्रदान करते हैं
  एक निश्चित पते को व्युत्पन्न करने के लिए वैकल्पिक "बीजों" (पूर्वनिर्धारित इनपुट)
  और एक विशिष्ट प्रोग्राम आईडी के संयोजन का उपयोग करते हैं।
- **प्रोग्राम साइनिंग सक्षम करें**: सोलाना रनटाइम प्रोग्रामों को PDAs के लिए "साइन" करने की अनुमति देता है
  जो इसके प्रोग्राम आईडी से व्युत्पन्न होते हैं।

आप PDAs के बारे में सोच सकते हैं जैसे कि एक पूर्वनिर्धारित इनपुट सेट (जैसे, स्ट्रिंग, संख्या, और अन्य खाता पते) से ऑन-चेन हैशमैप-जैसी संरचनाएँ बनाने का एक तरीका।

इस दृष्टिकोण का लाभ यह है कि यह एक निश्चित पते को ट्रैक करने की आवश्यकता को समाप्त करता है। इसके बजाय, आपको बस उस व्युत्पत्ति के लिए उपयोग किए गए विशिष्ट इनपुट को याद करने की आवश्यकता है।

![प्रोग्राम व्युत्पन्न पता](/assets/docs/core/pda/pda.svg)

यह समझना महत्वपूर्ण है कि केवल एक प्रोग्राम व्युत्पन्न पता (PDA) व्युत्पन्न करने से स्वचालित रूप से उस पते पर एक ऑन-चेन खाता नहीं बनता है। PDA के रूप में ऑन-चेन पता रखने वाले खातों को स्पष्ट रूप से उस प्रोग्राम के माध्यम से बनाया जाना चाहिए जिसका उपयोग पते को व्युत्पन्न करने के लिए किया गया था। आप PDA को एक मानचित्र पर एक पता खोजने के रूप में सोच सकते हैं। केवल एक पता होना यह नहीं दर्शाता है कि उस स्थान पर कुछ बनाया गया है।

> यह अनुभाग PDAs को व्युत्पन्न करने के विवरण को कवर करेगा। PDAs के लिए साइनिंग के लिए प्रोग्रामों का उपयोग कैसे किया जाता है, इस पर विवरण [क्रॉस प्रोग्राम इनवोकेशंस (CPIs)](/docs/core/cpi) अनुभाग में संबोधित किया जाएगा क्योंकि यह दोनों अवधारणाओं के लिए संदर्भ की आवश्यकता है।

## मुख्य बिंदु

- PDAs वे पते हैं जो **निश्चित रूप से व्युत्पन्न** होते हैं, जो उपयोगकर्ता-परिभाषित बीजों, एक बम्प बीज, और एक प्रोग्राम की आईडी के संयोजन का उपयोग करते हैं।
- PDAs वे पते हैं जो Ed25519 वक्र से बाहर गिरते हैं और **कोई संबंधित निजी कुंजी नहीं होती**।
- सोलाना प्रोग्राम **अपने प्रोग्राम आईडी का उपयोग करके व्युत्पन्न PDAs के लिए प्रतिनिधित्व कर सकते हैं**।
- एक PDA को व्युत्पन्न करने से स्वचालित रूप से एक ऑन-चेन खाता नहीं बनता है।
- PDA के रूप में अपने पते का उपयोग करने वाले खाते को सोलाना प्रोग्राम के भीतर एक समर्पित निर्देश के माध्यम से स्पष्ट रूप से बनाया जाना चाहिए।

## PDA क्या है

PDAs वे पते हैं जो निश्चित रूप से व्युत्पन्न होते हैं और मानक सार्वजनिक कुंजी की तरह दिखते हैं, लेकिन उनके साथ कोई संबंधित निजी कुंजी नहीं होती। इसका मतलब है कि कोई बाहरी उपयोगकर्ता उस पते के लिए एक मान्य हस्ताक्षर उत्पन्न नहीं कर सकता। हालाँकि, सोलाना रनटाइम प्रोग्रामों को बिना किसी निजी कुंजी की आवश्यकता के PDAs के लिए प्रोग्रामेटिक रूप से "साइन" करने की अनुमति देता है।

संदर्भ के लिए, सोलाना
[कीपेयर्स](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/src/signer/keypair.rs#L25)
Ed25519 वक्र (अंडाकार वक्र क्रिप्टोग्राफी) पर बिंदु होते हैं जिनके पास एक सार्वजनिक कुंजी और संबंधित निजी कुंजी होती है। हम अक्सर नए ऑन-चेन खातों के लिए अद्वितीय आईडी के रूप में सार्वजनिक कुंजी और साइनिंग के लिए निजी कुंजी का उपयोग करते हैं।

![वक्र पर पता](/assets/docs/core/pda/address-on-curve.svg)

एक PDA एक बिंदु है जिसे जानबूझकर Ed25519 वक्र से बाहर गिरने के लिए पूर्वनिर्धारित इनपुट सेट का उपयोग करके व्युत्पन्न किया गया है। Ed25519 वक्र पर न होने वाला एक बिंदु मान्य संबंधित निजी कुंजी नहीं रखता है और इसे क्रिप्टोग्राफिक ऑपरेशनों (हस्ताक्षर) के लिए उपयोग नहीं किया जा सकता।

एक PDA को फिर एक ऑन-चेन खाते के लिए पता (अद्वितीय पहचानकर्ता) के रूप में उपयोग किया जा सकता है, जो प्रोग्राम स्थिति को आसानी से संग्रहीत, मानचित्रित और लाने का एक तरीका प्रदान करता है।

![वक्र से बाहर पता](/assets/docs/core/pda/address-off-curve.svg)

## PDA को कैसे व्युत्पन्न करें

एक PDA की व्युत्पत्ति के लिए 3 इनपुट की आवश्यकता होती है।

- **वैकल्पिक बीज**: पूर्वनिर्धारित इनपुट (जैसे, स्ट्रिंग, संख्या, अन्य खाता पते) जो PDA को व्युत्पन्न करने के लिए उपयोग किए जाते हैं। इनपुट को बाइट्स के बफर में परिवर्तित किया जाता है।
- **बम्प बीज**: एक अतिरिक्त इनपुट (जिसका मान 255-0 के बीच होता है) जिसका उपयोग यह सुनिश्चित करने के लिए किया जाता है कि एक मान्य PDA (वक्र से बाहर) उत्पन्न हो। यह बम्प बीज (255 से शुरू) को PDA उत्पन्न करते समय वैकल्पिक बीजों में जोड़ा जाता है ताकि Ed25519 वक्र से बिंदु को "बम्प" किया जा सके। बम्प बीज को कभी-कभी "नॉन्स" के रूप में संदर्भित किया जाता है।
- **प्रोग्राम आईडी**: उस प्रोग्राम का पता जिससे PDA व्युत्पन्न होता है। यह भी वही प्रोग्राम है जो PDA के लिए "साइन" कर सकता है।

![PDA व्युत्पत्ति](/assets/docs/core/pda/pda-derivation.svg)

नीचे दिए गए उदाहरणों में सोलाना प्लेग्राउंड के लिंक शामिल हैं, जहाँ आप इन-ब्राउज़र संपादक में उदाहरण चला सकते हैं।

### FindProgramAddress

PDA को व्युत्पन्न करने के लिए, हम
[`findProgramAddressSync`](https://github.com/solana-labs/solana-web3.js/blob/ca9da583a39cdf8fd874a2e03fccdc849e29de34/packages/library-legacy/src/publickey.ts#L212)
विधि का उपयोग कर सकते हैं [`@solana/web3.js`](https://www.npmjs.com/package/@solana/web3.js)।
अन्य प्रोग्रामिंग भाषाओं में इस फ़ंक्शन के समकक्ष हैं (जैसे,
[Rust](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/pubkey.rs#L484)),
लेकिन इस अनुभाग में, हम जावास्क्रिप्ट का उपयोग करते हुए उदाहरणों के माध्यम से चलेंगे।

जब `findProgramAddressSync` विधि का उपयोग करते हैं, तो हम पास करते हैं:

- पूर्वनिर्धारित वैकल्पिक बीज जो बाइट्स के बफर में परिवर्तित होते हैं, और
- प्रोग्राम आईडी (पता) जिसका उपयोग PDA को व्युत्पन्न करने के लिए किया जाता है।

एक बार जब एक मान्य PDA पाया जाता है, तो `findProgramAddressSync` दोनों पता (PDA) और बम्प बीज लौटाता है जिसका उपयोग PDA को व्युत्पन्न करने के लिए किया गया था।

नीचे दिया गया उदाहरण बिना किसी वैकल्पिक बीज प्रदान किए PDA को व्युत्पन्न करता है।

```ts /[]/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");

const [PDA, bump] = PublicKey.findProgramAddressSync([], programId);

console.log(`PDA: ${PDA}`);
console.log(`Bump: ${bump}`);
```

आप इस उदाहरण को
[सोलाना प्लेग्राउंड](https://beta.solpg.io/66031e5acffcf4b13384cfef) पर चला सकते हैं। PDA और
बम्प बीज आउटपुट हमेशा समान होगा:

```
PDA: Cu7NwqCXSmsR5vgGA3Vw9uYVViPi3kQvkbKByVQ8nPY9
Bump: 255
```

नीचे दिया गया अगला उदाहरण एक वैकल्पिक बीज "helloWorld" जोड़ता है।

```ts /string/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";

const [PDA, bump] = PublicKey.findProgramAddressSync(
  [Buffer.from(string)],
  programId,
);

console.log(`PDA: ${PDA}`);
console.log(`Bump: ${bump}`);
```

आप इस उदाहरण को भी चला सकते हैं
[सोलाना प्लेग्राउंड](https://beta.solpg.io/66031ee5cffcf4b13384cff0) पर। PDA और
बम्प बीज आउटपुट हमेशा समान होगा:

```
PDA: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
Bump: 254
```

ध्यान दें कि बम्प बीज 254 है। इसका मतलब है कि 255 ने Ed25519 वक्र पर एक बिंदु व्युत्पन्न किया, और यह एक मान्य PDA नहीं है।

`findProgramAddressSync` द्वारा लौटाया गया बम्प बीज पहले मान (255-0 के बीच) के लिए दिया गया वैकल्पिक बीजों और प्रोग्राम आईडी के संयोजन के लिए है जो एक मान्य PDA व्युत्पन्न करता है।

> इस पहले मान्य बम्प बीज को "मानक बम्प" कहा जाता है। प्रोग्राम सुरक्षा के लिए, PDAs के साथ काम करते समय केवल मानक बम्प का उपयोग करने की सिफारिश की जाती है।

### CreateProgramAddress

आंतरिक रूप से, `findProgramAddressSync` धीरे-धीरे एक अतिरिक्त बम्प बीज (नॉन्स) को बीज बफर में जोड़ता है और
[`createProgramAddressSync`](https://github.com/solana-labs/solana-web3.js/blob/ca9da583a39cdf8fd874a2e03fccdc849e29de34/packages/library-legacy/src/publickey.ts#L168)
विधि को कॉल करता है। बम्प बीज 255 के मान से शुरू होता है और एक मान्य PDA (वक्र से बाहर) मिलने तक 1 से घटाया जाता है।

आप पिछले उदाहरण को `createProgramAddressSync` का उपयोग करके दोहराकर और बम्प बीज 254 को स्पष्ट रूप से पास करके कर सकते हैं।

```ts /bump/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";
const bump = 254;

const PDA = PublicKey.createProgramAddressSync(
  [Buffer.from(string), Buffer.from([bump])],
  programId,
);

console.log(`PDA: ${PDA}`);
```

ऊपर दिए गए इस उदाहरण को
[सोलाना प्लेग्राउंड](https://beta.solpg.io/66031f8ecffcf4b13384cff1) पर चलाएं। दिए गए
समान बीजों और प्रोग्राम आईडी के साथ, PDA आउटपुट पिछले एक के समान होगा:

```
PDA: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
```

### मानक बम्प

"मानक बम्प" उस पहले बम्प बीज को संदर्भित करता है (जो 255 से शुरू होता है और 1 से घटता है) जो एक मान्य PDA व्युत्पन्न करता है। प्रोग्राम सुरक्षा के लिए, यह सिफारिश की जाती है कि केवल मानक बम्प से व्युत्पन्न PDAs का उपयोग करें।

पिछले उदाहरण को संदर्भ के रूप में लेते हुए, नीचे दिया गया उदाहरण 255-0 के प्रत्येक बम्प बीज का उपयोग करके एक PDA व्युत्पन्न करने का प्रयास करता है।

```ts
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";

// प्रदर्शन के लिए सभी बम्प बीजों के माध्यम से लूप करें
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(string), Buffer.from([bump])],
      programId,
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

उदाहरण को चलाएं
[सोलाना प्लेग्राउंड](https://beta.solpg.io/66032009cffcf4b13384cff2) पर और आपको निम्नलिखित आउटपुट देखना चाहिए:

```
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// शेष बम्प आउटपुट
```

जैसा कि अपेक्षित था, बम्प बीज 255 एक त्रुटि फेंकता है और मान्य PDA व्युत्पन्न करने वाला पहला बम्प बीज 254 है।

हालांकि, ध्यान दें कि बम्प बीज 253-251 सभी विभिन्न पतों के साथ मान्य PDAs व्युत्पन्न करते हैं। इसका मतलब है कि दिए गए समान वैकल्पिक बीजों और `programId` के साथ, एक अलग मान वाला बम्प बीज अभी भी एक मान्य PDA व्युत्पन्न कर सकता है।

<Callout type="warn">
  सोलाना प्रोग्राम बनाते समय, यह सिफारिश की जाती है कि सुरक्षा जांच शामिल करें
  जो यह सत्यापित करती है कि प्रोग्राम में पास किया गया PDA मानक बम्प का उपयोग करके व्युत्पन्न किया गया है।
  ऐसा न करने से संभावित कमजोरियाँ उत्पन्न हो सकती हैं जो प्रोग्राम को अप्रत्याशित खातों को प्रदान करने की अनुमति देती हैं।
</Callout>

## PDA खाते बनाएं

यह उदाहरण प्रोग्राम
[सोलाना प्लेग्राउंड](https://beta.solpg.io/github.com/ZYJLiu/doc-examples/tree/main/pda-account)
एक खाता बनाने का प्रदर्शन करता है जिसका पता नए
खाते के पते के रूप में PDA है। उदाहरण प्रोग्राम एंकर ढांचे का उपयोग करके लिखा गया है।

`lib.rs` फ़ाइल में, आपको निम्नलिखित प्रोग्राम मिलेगा जिसमें एक
एकल निर्देश शामिल है जो PDA को नए खाते के पते के रूप में उपयोग करके एक नया खाता बनाने के लिए है। नया खाता `उपयोगकर्ता` का पता और PDA को व्युत्पन्न करने के लिए उपयोग किया गया `बम्प` बीज संग्रहीत करता है।

```rust title="lib.rs" {11-14,26-29}
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // `उपयोगकर्ता` का पता संग्रहीत करें
        account_data.user = *ctx.accounts.user.key;
        // मानक बम्प संग्रहीत करें
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        init,
        // PDA को व्युत्पन्न करने के लिए बीज सेट करें
        seeds = [b"data", user.key().as_ref()],
        // मानक बम्प का उपयोग करें
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]

#[derive(InitSpace)]
pub struct DataAccount {
    pub user: Pubkey,
    pub bump: u8,
}
```

PDA को व्युत्पन्न करने के लिए उपयोग किए गए बीजों में हार्डकोडेड स्ट्रिंग `data` और निर्देश में प्रदान किए गए `उपयोगकर्ता` खाते का पता शामिल है। एंकर ढांचा स्वचालित रूप से मानक `बम्प` बीज व्युत्पन्न करता है।

```rust /data/ /user.key()/ /bump/
#[account(
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

`init` बाधा एंकर को सिस्टम प्रोग्राम को एक नया खाता बनाने के लिए PDA को पते के रूप में उपयोग करने के लिए निर्देशित करती है। आंतरिक रूप से, यह एक [CPI](/docs/core/cpi) के माध्यम से किया जाता है।

```rust /init/
#[account(
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

उपरोक्त सोलाना प्लेग्राउंड लिंक में स्थित परीक्षण फ़ाइल (`pda-account.test.ts`) में, आपको PDA को व्युत्पन्न करने के लिए जावास्क्रिप्ट समकक्ष मिलेगा।

```ts /data/ /user.publicKey/
const [PDA] = PublicKey.findProgramAddressSync(
  [Buffer.from("data"), user.publicKey.toBuffer()],
  program.programId,
);
```

फिर एक लेनदेन भेजा जाता है ताकि `initialize` निर्देश को कॉल किया जा सके ताकि PDA को नए खाते के पते के रूप में उपयोग करके एक नया ऑन-चेन खाता बनाया जा सके। एक बार लेनदेन भेजे जाने के बाद, PDA का उपयोग उस ऑन-चेन खाते को लाने के लिए किया जाता है जो पते पर बनाया गया था।

```ts /initialize()/ /PDA/  {14}
it("क्या प्रारंभ किया गया है!", async () => {
  const transactionSignature = await program.methods
    .initialize()
    .accounts({
      user: user.publicKey,
      pdaAccount: PDA,
    })
    .rpc();

  console.log("लेनदेन हस्ताक्षर:", transactionSignature);
});

it("खाता लाना", async () => {
  const pdaAccount = await program.account.dataAccount.fetch(PDA);
  console.log(JSON.stringify(pdaAccount, null, 2));
});
```

ध्यान दें कि यदि आप एक ही `उपयोगकर्ता` पते को बीज के रूप में उपयोग करके `initialize` निर्देश को एक से अधिक बार कॉल करते हैं, तो लेनदेन विफल हो जाएगा। इसका कारण यह है कि व्युत्पन्न पते पर पहले से ही एक खाता मौजूद होगा।
