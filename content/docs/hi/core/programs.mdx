---
title: सोलाना पर प्रोग्राम
description:
  सोलाना प्रोग्राम (स्मार्ट कॉन्ट्रैक्ट्स) के बारे में जानें और रस्ट या एंकर
  फ्रेमवर्क का उपयोग करके उन्हें कैसे विकसित करें। सोलाना नेटवर्क पर प्रोग्राम
  डिप्लॉयमेंट, अपग्रेड और सत्यापन को समझें।
h1: प्रोग्राम्स
---

सोलाना पर, "स्मार्ट कॉन्ट्रैक्ट्स" को प्रोग्राम कहा जाता है।
[प्रोग्राम](/docs/core/accounts#program-account) को ऑन-चेन उन खातों में डिप्लॉय
किया जाता है जिनमें प्रोग्राम का कंपाइल किया हुआ एक्जीक्यूटेबल बाइनरी होता है।
उपयोगकर्ता प्रोग्राम के साथ [निर्देशों](/docs/core/transactions#instruction)
वाले लेनदेन भेजकर इंटरैक्ट करते हैं जो प्रोग्राम को बताते हैं कि क्या करना है।

## मुख्य बिंदु

- प्रोग्राम **एक्जीक्यूटेबल कोड** वाले खाते हैं, जिन्हें **निर्देश** नामक फंक्शन
  में व्यवस्थित किया गया है।
- जबकि प्रोग्राम **स्टेटलेस** होते हैं, वे ऐसे निर्देश शामिल कर सकते हैं जो डेटा
  स्टोर करने के लिए अन्य खातों को बनाते और अपडेट करते हैं।
- एक **अपग्रेड अथॉरिटी** प्रोग्राम को अपडेट कर सकती है। एक बार यह अथॉरिटी हटा दी
  जाती है, प्रोग्राम अपरिवर्तनीय हो जाता है।
- उपयोगकर्ता सत्यापन योग्य बिल्ड के माध्यम से यह सत्यापित कर सकते हैं कि ऑन-चेन
  प्रोग्राम खाते का डेटा उसके सार्वजनिक सोर्स कोड से मेल खाता है।

## सोलाना प्रोग्राम लिखना

सोलाना प्रोग्राम मुख्य रूप से
[Rust](https://rust-book.cs.brown.edu/title-page.html) प्रोग्रामिंग भाषा में
लिखे जाते हैं, विकास के लिए दो सामान्य दृष्टिकोण हैं:

- [Anchor](https://www.anchor-lang.com/docs): सोलाना प्रोग्राम विकास के लिए
  डिज़ाइन किया गया एक फ्रेमवर्क। यह प्रोग्राम लिखने का एक तेज़ और सरल तरीका
  प्रदान करता है, जो बॉयलरप्लेट कोड को काफी कम करने के लिए Rust मैक्रोज़ का
  उपयोग करता है। शुरुआती लोगों के लिए, Anchor फ्रेमवर्क से शुरुआत करने की
  सिफारिश की जाती है।

- [नेटिव Rust](/docs/programs/rust): इस दृष्टिकोण में किसी भी फ्रेमवर्क का लाभ
  उठाए बिना Rust में सोलाना प्रोग्राम लिखना शामिल है। यह अधिक लचीलापन प्रदान
  करता है लेकिन अधिक जटिलता के साथ आता है।

## सोलाना प्रोग्राम अपडेट करना

प्रोग्राम डिप्लॉय करने और अपग्रेड करने के बारे में अधिक जानने के लिए,
[प्रोग्राम डिप्लॉय करना](/docs/programs/deploying) पेज देखें।

ऑन-चेन प्रोग्राम को

[सीधे संशोधित](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L704)

किया जा सकता है "अपग्रेड अथॉरिटी" के रूप में नामित खाते द्वारा, जो आमतौर पर वह
खाता होता है जिसने मूल रूप से प्रोग्राम को डिप्लॉय किया था। यदि

[अपग्रेड अथॉरिटी](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L894)

रद्द कर दी जाती है और `None` पर सेट की जाती है, तो प्रोग्राम अपरिवर्तनीय हो जाता
है और इसे अब अपडेट नहीं किया जा सकता है।

## सत्यापन योग्य प्रोग्राम

सत्यापन योग्य बिल्ड किसी को भी यह जांचने की अनुमति देते हैं कि क्या प्रोग्राम का
ऑन-चेन कोड उसके सार्वजनिक सोर्स कोड से मेल खाता है, जिससे सोर्स और डिप्लॉय किए
गए संस्करणों के बीच अंतर का पता लगाना संभव हो जाता है।

सोलाना डेवलपर समुदाय ने सत्यापन योग्य बिल्ड का समर्थन करने के लिए टूल पेश किए
हैं, जिससे डेवलपर्स और उपयोगकर्ता दोनों यह सत्यापित कर सकते हैं कि ऑनचेन
प्रोग्राम उनके सार्वजनिक रूप से साझा किए गए सोर्स कोड को सही ढंग से दर्शाते हैं।

- **सत्यापित प्रोग्राम खोजना**: सत्यापित प्रोग्रामों की त्वरित जांच के लिए,
  उपयोगकर्ता [SolanaFM](https://solana.fm/) एक्सप्लोरर पर प्रोग्राम एड्रेस खोज
  सकते हैं और "वेरिफिकेशन" टैब पर नेविगेट कर सकते हैं। सत्यापित प्रोग्राम का एक
  उदाहरण
  [यहां](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
  देखें।

- **सत्यापन टूल**: एलिप्सिस लैब्स द्वारा
  [सोलाना वेरिफायबल बिल्ड CLI](https://github.com/Ellipsis-Labs/solana-verifiable-build)
  उपयोगकर्ताओं को प्रकाशित सोर्स कोड के खिलाफ स्वतंत्र रूप से ऑनचेन प्रोग्राम
  सत्यापित करने की अनुमति देता है।

- **एंकर में सत्यापन योग्य बिल्ड के लिए समर्थन**: एंकर सत्यापन योग्य बिल्ड के
  लिए अंतर्निहित समर्थन प्रदान करता है। विवरण
  [एंकर दस्तावेज़ीकरण](https://www.anchor-lang.com/docs/verifiable-builds) में
  पाया जा सकता है।

## बर्कले पैकेट फिल्टर (BPF)

सोलाना [LLVM](https://llvm.org/) का उपयोग प्रोग्राम को
[ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) फाइलों में
कंपाइल करने के लिए करता है। इन फाइलों में सोलाना का कस्टम वर्जन
[eBPF](https://en.wikipedia.org/wiki/EBPF) बाइटकोड होता है, जिसे "सोलाना बाइटकोड
फॉर्मेट" (sBPF) कहा जाता है। ELF फाइल में प्रोग्राम का बाइनरी होता है और जब
प्रोग्राम को डिप्लॉय किया जाता है, तो इसे एक एक्जीक्यूटेबल अकाउंट में ऑन-चेन
स्टोर किया जाता है।

## बिल्ट-इन प्रोग्राम्स

### लोडर प्रोग्राम्स

हर प्रोग्राम स्वयं किसी अन्य प्रोग्राम के स्वामित्व में होता है, जो उसका लोडर
है। वर्तमान में पांच लोडर हैं:

1. नेटिव लोडर:

- प्रोग्राम आईडी: `NativeLoader1111111111111111111111111111111`
- अन्य चार लोडर्स का स्वामित्व रखता है

2. लोडर-v1:

- प्रोग्राम आईडी: `BPFLoader1111111111111111111111111111111111`
- प्रबंधन निर्देश अक्षम हैं, लेकिन प्रोग्राम अभी भी निष्पादित होते हैं

3. लोडर-v2:

- प्रोग्राम आईडी: `BPFLoader2111111111111111111111111111111111`
- [निर्देश](https://docs.rs/solana-loader-v2-interface/latest/solana_loader_v2_interface/enum.LoaderInstruction.html)
- प्रबंधन निर्देश अक्षम हैं, लेकिन प्रोग्राम अभी भी निष्पादित होते हैं

4. लोडर-v3:

- प्रोग्राम आईडी: `BPFLoaderUpgradeab1e11111111111111111111111`
- [निर्देश](https://docs.rs/solana-loader-v3-interface/latest/solana_loader_v3_interface/instruction/enum.UpgradeableLoaderInstruction.html)
- इसे चरणबद्ध तरीके से समाप्त किया जा रहा है

5. लोडर-v4:

- प्रोग्राम आईडी: `LoaderV411111111111111111111111111111111111`
- [निर्देश](https://docs.rs/solana-loader-v4-interface/latest/solana_loader_v4_interface/instruction/enum.LoaderV4Instruction.html)
- मानक लोडर बन जाएगा

ये लोडर कस्टम प्रोग्राम बनाने और प्रबंधित करने के लिए आवश्यक हैं:

- नया प्रोग्राम या बफर डिप्लॉय करना
- प्रोग्राम या बफर बंद करना
- मौजूदा प्रोग्राम को रीडिप्लॉय / अपग्रेड करना
- प्रोग्राम पर अधिकार हस्तांतरित करना
- प्रोग्राम को अंतिम रूप देना

लोडर-v3 और लोडर-v4 प्रारंभिक डिप्लॉयमेंट के बाद प्रोग्राम में संशोधन का समर्थन
करते हैं। ऐसा करने की अनुमति प्रोग्राम के अधिकार द्वारा नियंत्रित की जाती है
क्योंकि प्रत्येक प्रोग्राम का खाता स्वामित्व लोडर के पास रहता है।

### प्रीकंपाइल प्रोग्राम्स

#### Ed25519 प्रोग्राम

ed25519 हस्ताक्षरों को सत्यापित करने के लिए प्रोग्राम। यह एक ed25519 हस्ताक्षर,
एक पब्लिक की, और एक संदेश लेता है। कई हस्ताक्षरों को सत्यापित किया जा सकता है।
यदि कोई भी हस्ताक्षर सत्यापित करने में विफल होता है, तो एक त्रुटि लौटाई जाती है।

- प्रोग्राम आईडी: `Ed25519SigVerify111111111111111111111111111`
- [निर्देश](https://docs.rs/solana-ed25519-program/latest/solana_ed25519_program/index.html)

ed25519 प्रोग्राम एक निर्देश को संसाधित करता है। पहला `u8` जांच किए जाने वाले
हस्ताक्षरों की संख्या की गणना है, जिसके बाद एक बाइट पैडिंग होती है। उसके बाद,
निम्नलिखित संरचना सीरियलाइज़ की जाती है, प्रत्येक हस्ताक्षर के लिए एक जांच करने
के लिए।

```
struct Ed25519SignatureOffsets {
    signature_offset: u16,             // 64 बाइट्स के ed25519 हस्ताक्षर का ऑफसेट
    signature_instruction_index: u16,  // हस्ताक्षर खोजने के लिए निर्देश इंडेक्स
    public_key_offset: u16,            // 32 बाइट्स की पब्लिक की का ऑफसेट
    public_key_instruction_index: u16, // पब्लिक की खोजने के लिए निर्देश इंडेक्स
    message_data_offset: u16,          // संदेश डेटा के प्रारंभ का ऑफसेट
    message_data_size: u16,            // संदेश डेटा का आकार
    message_instruction_index: u16,    // संदेश डेटा प्राप्त करने के लिए निर्देश डेटा का इंडेक्स
}
```

हस्ताक्षर सत्यापन का स्यूडो कोड:

```
process_instruction() {
    for i in 0..count {
        // i'th इंडेक्स मान संदर्भित:
        instructions = &transaction.message().instructions
        instruction_index = ed25519_signature_instruction_index != u16::MAX ? ed25519_signature_instruction_index : current_instruction;
        signature = instructions[instruction_index].data[ed25519_signature_offset..ed25519_signature_offset + 64]
        instruction_index = ed25519_pubkey_instruction_index != u16::MAX ? ed25519_pubkey_instruction_index : current_instruction;
        pubkey = instructions[instruction_index].data[ed25519_pubkey_offset..ed25519_pubkey_offset + 32]
        instruction_index = ed25519_message_instruction_index != u16::MAX ? ed25519_message_instruction_index : current_instruction;
        message = instructions[instruction_index].data[ed25519_message_data_offset..ed25519_message_data_offset + ed25519_message_data_size]
        if pubkey.verify(signature, message) != Success {
            return Error
        }
    }
    return Success
}
```

#### Secp256k1 प्रोग्राम

secp256k1 पब्लिक की रिकवरी ऑपरेशन (ecrecover) को सत्यापित करें।

- प्रोग्राम आईडी: `KeccakSecp256k11111111111111111111111111111`
- [निर्देश](https://docs.rs/solana-secp256k1-program/latest/solana_secp256k1_program/index.html)

secp256k1 प्रोग्राम एक निर्देश को संसाधित करता है जिसमें पहले बाइट के रूप में
निर्देश डेटा में सीरियलाइज़ किए गए निम्न स्ट्रक्ट की गणना होती है:

```
struct Secp256k1SignatureOffsets {
    secp_signature_offset: u16,            // offset to [signature,recovery_id] of 64+1 bytes
    secp_signature_instruction_index: u8,  // instruction index to find signature
    secp_pubkey_offset: u16,               // offset to ethereum_address pubkey of 20 bytes
    secp_pubkey_instruction_index: u8,     // instruction index to find pubkey
    secp_message_data_offset: u16,         // offset to start of message data
    secp_message_data_size: u16,           // size of message data
    secp_message_instruction_index: u8,    // instruction index to find message data
}
```

रिकवरी सत्यापन का स्यूडो कोड:

```
process_instruction() {
  for i in 0..count {
      // i'th index values referenced:
      instructions = &transaction.message().instructions
      signature = instructions[secp_signature_instruction_index].data[secp_signature_offset..secp_signature_offset + 64]
      recovery_id = instructions[secp_signature_instruction_index].data[secp_signature_offset + 64]
      ref_eth_pubkey = instructions[secp_pubkey_instruction_index].data[secp_pubkey_offset..secp_pubkey_offset + 20]
      message_hash = keccak256(instructions[secp_message_instruction_index].data[secp_message_data_offset..secp_message_data_offset + secp_message_data_size])
      pubkey = ecrecover(signature, recovery_id, message_hash)
      eth_pubkey = keccak256(pubkey[1..])[12..]
      if eth_pubkey != ref_eth_pubkey {
          return Error
      }
  }
  return Success
}
```

यह उपयोगकर्ता को लेनदेन में किसी भी निर्देश डेटा को हस्ताक्षर और संदेश डेटा के
लिए निर्दिष्ट करने की अनुमति देता है। एक विशेष निर्देश sysvar को निर्दिष्ट करके,
कोई भी लेनदेन से स्वयं डेटा प्राप्त कर सकता है।

लेनदेन की लागत में सत्यापित करने के लिए हस्ताक्षरों की संख्या को हस्ताक्षर लागत
सत्यापन गुणक से गुणा किया जाएगा।

#### Secp256r1 प्रोग्राम

secp256r1 हस्ताक्षरों को सत्यापित करने के लिए प्रोग्राम। यह एक secp256r1
हस्ताक्षर, एक पब्लिक की और एक संदेश लेता है। 8 तक हस्ताक्षरों को सत्यापित किया
जा सकता है। यदि कोई भी हस्ताक्षर सत्यापित करने में विफल रहता है, तो एक त्रुटि
लौटाई जाती है।

- प्रोग्राम आईडी: `Secp256r1SigVerify1111111111111111111111111`
- [निर्देश](https://docs.rs/solana-secp256k1-recover/latest/solana_secp256k1_recover/index.html)

secp256r1 प्रोग्राम एक निर्देश को संसाधित करता है। पहला `u8` जांच करने के लिए
हस्ताक्षरों की संख्या की गणना है, उसके बाद एक बाइट पैडिंग है। उसके बाद, निम्न
स्ट्रक्ट सीरियलाइज़ किया जाता है, प्रत्येक हस्ताक्षर के लिए एक जांच करने के लिए:

```rust
struct Secp256r1SignatureOffsets {
    signature_offset: u16,             // offset to compact secp256r1 signature of 64 bytes
    signature_instruction_index: u16,  // instruction index to find signature
    public_key_offset: u16,            // offset to compressed public key of 33 bytes
    public_key_instruction_index: u16, // instruction index to find public key
    message_data_offset: u16,          // offset to start of message data
    message_data_size: u16,            // size of message data
    message_instruction_index: u16,    // index of instruction data to get message data
}

```

हस्ताक्षर सत्यापन का स्यूडो कोड:

```
process_instruction() {
    if data.len() < SIGNATURE_OFFSETS_START {
        return Error
    }

    num_signatures = data[0] as usize
    if num_signatures == 0 || num_signatures > 8 {
        return Error
    }

    expected_data_size = num_signatures * SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START
    if data.len() < expected_data_size {
        return Error
    }

    for i in 0..num_signatures {
        offsets = parse_signature_offsets(data, i)

        signature = get_data_slice(data, instruction_datas, offsets.signature_instruction_index, offsets.signature_offset, SIGNATURE_SERIALIZED_SIZE)

        if s > half_curve_order {
            return Error
        }

        pubkey = get_data_slice(data, instruction_datas, offsets.public_key_instruction_index, offsets.public_key_offset, COMPRESSED_PUBKEY_SERIALIZED_SIZE)

        message = get_data_slice(data, instruction_datas, offsets.message_instruction_index, offsets.message_data_offset, offsets.message_data_size)

        if !verify_signature(signature, pubkey, message) {
            return Error
        }
    }

    return Success
}
```

नोट: आकस्मिक हस्ताक्षर परिवर्तनीयता से बचने के लिए सभी हस्ताक्षरों के लिए कम S
मान लागू किए जाते हैं।

### मुख्य प्रोग्राम

सोलाना क्लस्टर जेनेसिस में विशेष प्रोग्रामों की एक सूची शामिल है जो नेटवर्क के
लिए विभिन्न मुख्य कार्यक्षमताएँ प्रदान करते हैं। ऐतिहासिक रूप से इन्हें "नेटिव"
प्रोग्राम कहा जाता था और ये वैलिडेटर कोड के साथ वितरित किए जाते थे।

1. सिस्टम प्रोग्राम

- प्रोग्राम आईडी: `11111111111111111111111111111111`
- [निर्देश](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html)
- नए खाते बनाना, खाता डेटा आवंटित करना, खातों को स्वामित्व वाले प्रोग्राम को
  असाइन करना, सिस्टम प्रोग्राम के स्वामित्व वाले खातों से लैमपोर्ट्स ट्रांसफर
  करना और लेनदेन शुल्क का भुगतान करना।

2. वोट प्रोग्राम

- प्रोग्राम आईडी: `Vote111111111111111111111111111111111111111`
- [निर्देश](https://docs.rs/solana-vote-program/latest/solana_vote_program/vote_instruction/enum.VoteInstruction.html)
- वैलिडेटर वोटिंग स्थिति और पुरस्कारों को ट्रैक करने वाले खातों का निर्माण और
  प्रबंधन करना।

3. स्टेक प्रोग्राम

- प्रोग्राम आईडी: `Stake11111111111111111111111111111111111111`
- [निर्देश](https://docs.rs/solana-sdk/latest/solana_sdk/stake/instruction/enum.StakeInstruction.html)
- वैलिडेटर्स को प्रतिनिधिमंडल के लिए स्टेक और पुरस्कार का प्रतिनिधित्व करने वाले
  खातों का निर्माण और प्रबंधन करना।

4. कॉन्फिग प्रोग्राम

- प्रोग्राम आईडी: `Config1111111111111111111111111111111111111`
- [निर्देश](https://docs.rs/solana-config-program/latest/solana_config_program/config_instruction/index.html)
- चेन में कॉन्फिगरेशन डेटा जोड़ना, उसके बाद पब्लिक कीज़ की सूची जो इसे संशोधित
  करने की अनुमति देती हैं। अन्य प्रोग्रामों के विपरीत, कॉन्फिग प्रोग्राम किसी भी
  व्यक्तिगत निर्देश को परिभाषित नहीं करता है। इसमें केवल एक अंतर्निहित निर्देश
  है: "स्टोर"। इसका निर्देश डेटा कीज़ का एक सेट है जो खाते तक पहुंच को नियंत्रित
  करता है और उसके अंदर संग्रहीत करने के लिए डेटा।

5. कंप्यूट बजट प्रोग्राम

- प्रोग्राम आईडी: `ComputeBudget111111111111111111111111111111`
- [निर्देश](https://docs.rs/solana-compute-budget-interface/latest/solana_compute_budget_interface/enum.ComputeBudgetInstruction.html)

6. एड्रेस लुकअप टेबल प्रोग्राम

- प्रोग्राम आईडी: `AddressLookupTab1e1111111111111111111111111`
- [निर्देश](https://docs.rs/solana-sdk/latest/solana_sdk/address_lookup_table/instruction/enum.ProgramInstruction.html)

7. ज़ेड-के टोकन प्रूफ प्रोग्राम

- प्रोग्राम आईडी: `ZkTokenProof1111111111111111111111111111111`

8. ज़ेड-के एलगैमल प्रूफ प्रोग्राम

- प्रोग्राम आईडी: `ZkE1Gama1Proof11111111111111111111111111111`
