---
title: लेनदेन और निर्देश
description:
  सोलाना लेनदेन और निर्देशों के बारे में जानें - सोलाना ब्लॉकचेन के साथ इंटरैक्ट
  करने के लिए मूलभूत बिल्डिंग ब्लॉक्स। व्यावहारिक उदाहरणों के साथ लेनदेन संरचना
  और निर्देश संरचना को समझें।
---

सोलाना पर, हम नेटवर्क के साथ इंटरैक्ट करने के लिए
[ट्रांजैक्शन](/docs/core/transactions#transaction) भेजते हैं। ट्रांजैक्शन में एक
या अधिक [इंस्ट्रक्शन](/docs/core/transactions#instruction) शामिल होते हैं जो
प्रोसेस किए जाने वाले ऑपरेशन को निर्दिष्ट करते हैं। इंस्ट्रक्शन के लिए
एक्जीक्यूशन लॉजिक सोलाना नेटवर्क पर डिप्लॉय किए गए
[प्रोग्राम](/docs/core/programs) में स्टोर किए जाते हैं, जहां प्रत्येक प्रोग्राम
अपने स्वयं के इंस्ट्रक्शन सेट को परिभाषित करता है।

नीचे ट्रांजैक्शन के प्रोसेस होने के बारे में महत्वपूर्ण विवरण दिए गए हैं:

- यदि किसी ट्रांजैक्शन में कई इंस्ट्रक्शन शामिल हैं, तो इंस्ट्रक्शन उसी क्रम में
  एक्जीक्यूट होते हैं जिस क्रम में वे ट्रांजैक्शन में जोड़े गए हैं
- ट्रांजैक्शन "एटॉमिक" होते हैं - या तो सभी इंस्ट्रक्शन सफलतापूर्वक प्रोसेस होते
  हैं, या पूरा ट्रांजैक्शन विफल हो जाता है और कोई परिवर्तन नहीं होता है।

सरलता के लिए, एक ट्रांजैक्शन को एक या कई इंस्ट्रक्शन को प्रोसेस करने के अनुरोध
के रूप में समझा जा सकता है।

![ट्रांजैक्शन सिंप्लिफाइड](/assets/docs/core/transactions/transaction-simple.svg)

एक ट्रांजैक्शन को एक ऐसे लिफाफे की तरह समझें जिसमें फॉर्म होते हैं। प्रत्येक
फॉर्म एक इंस्ट्रक्शन है जो नेटवर्क को बताता है कि हम क्या करना चाहते हैं। जब आप
ट्रांजैक्शन भेजते हैं, तो यह लिफाफे को मेल करने जैसा है ताकि फॉर्म प्रोसेस किए
जा सकें।

## मुख्य बिंदु

- सोलाना ट्रांजैक्शन में इंस्ट्रक्शन शामिल होते हैं जो नेटवर्क पर प्रोग्राम को
  इनवोक करने के अनुरोध हैं।
- ट्रांजैक्शन **एटॉमिक** हैं - यदि कोई भी इंस्ट्रक्शन विफल होता है, तो पूरा
  ट्रांजैक्शन विफल हो जाता है और कोई परिवर्तन नहीं होता है।
- ट्रांजैक्शन पर इंस्ट्रक्शन **क्रमिक क्रम में प्रोसेस** किए जाते हैं।
- ट्रांजैक्शन का अधिकतम आकार
  [1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
  बाइट्स है।
- प्रत्येक इंस्ट्रक्शन के लिए 3 प्रकार की जानकारी आवश्यक है:
  1. इनवोक किए जाने वाले प्रोग्राम का एड्रेस
  2. वे अकाउंट जिन्हें इंस्ट्रक्शन पढ़ेगा या लिखेगा
  3. इंस्ट्रक्शन द्वारा आवश्यक कोई अतिरिक्त डेटा (जैसे फंक्शन आर्गुमेंट्स)

## बेसिक उदाहरण

नीचे एक ट्रांजैक्शन का डायग्राम दिया गया है जिसमें एक सेंडर से रिसीवर को SOL
ट्रांसफर करने के लिए एक इंस्ट्रक्शन है।

सोलाना पर, जिन अकाउंट्स को हम "वॉलेट" कहते हैं, वे
[सिस्टम प्रोग्राम](/docs/core/accounts#system-program) के स्वामित्व में हैं।
केवल प्रोग्राम ओनर ही अकाउंट के डेटा को मॉडिफाई कर सकता है, इसलिए SOL ट्रांसफर
करने के लिए सिस्टम प्रोग्राम को इनवोक करने के लिए एक ट्रांजैक्शन भेजना आवश्यक
है।

![SOL ट्रांसफर](/assets/docs/core/transactions/sol-transfer.svg)

प्रेषक खाते को अपने लैम्पोर्ट बैलेंस से कटौती को अधिकृत करने के लिए लेनदेन पर
हस्ताक्षर (`is_signer`) करना होगा। प्रेषक और प्राप्तकर्ता दोनों खातों को लिखने
योग्य (`is_writable`) के रूप में चिह्नित किया जाना चाहिए क्योंकि इन खातों पर
लैम्पोर्ट बैलेंस बदलेगा।

एक बार लेनदेन भेजा जाता है, ट्रांसफर निर्देश को संसाधित करने के लिए सिस्टम
प्रोग्राम को आमंत्रित किया जाता है। सिस्टम प्रोग्राम तब प्रेषक और प्राप्तकर्ता
दोनों खातों के लैम्पोर्ट बैलेंस को तदनुसार अपडेट करता है।

![SOL ट्रांसफर प्रक्रिया](/assets/docs/core/transactions/sol-transfer-process.svg)

### SOL ट्रांसफर करें

यहां एक [सोलाना प्लेग्राउंड](https://beta.solpg.io/656a0ea7fb53fa325bfd0c3e)
उदाहरण है कि कैसे `SystemProgram.transfer` विधि का उपयोग करके SOL ट्रांसफर
निर्देश बनाया जाए:

```typescript title="SOL ट्रांसफर"
// ट्रांसफर करने की राशि परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// wallet_1 से wallet_2 में SOL ट्रांसफर करने के लिए एक ट्रांसफर निर्देश बनाएं
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // transferAmount को लैम्पोर्ट्स में परिवर्तित करें
});

// ट्रांसफर निर्देश को एक नए लेनदेन में जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

प्लेग्राउंड टर्मिनल में `run` कमांड का उपयोग करके या "Run" बटन पर क्लिक करके
उदाहरण चलाएं।

<Callout type="info">

सुनिश्चित करें कि आपके प्लेग्राउंड वॉलेट में डेवनेट SOL है।
[सोलाना फॉसेट](https://faucet.solana.com/) से डेवनेट SOL प्राप्त करें।

</Callout>

नीचे दिए गए अनुभागों में, हम लेनदेन और निर्देशों के विवरण के माध्यम से चलेंगे।

## लेनदेन

एक सोलाना

[लेनदेन](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)

में शामिल हैं:

1. [हस्ताक्षर](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30):
   लेनदेन पर शामिल हस्ताक्षरों की एक सरणी।
2. [संदेश](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131):
   परमाणु रूप से संसाधित किए जाने वाले निर्देशों की सूची।

```rust title="लेनदेन"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    pub message: Message,
}
```

![लेनदेन प्रारूप](/assets/docs/core/transactions/tx_format.png)

एक लेनदेन संदेश की संरचना में शामिल हैं:

- [संदेश हेडर](/docs/core/transactions#message-header): हस्ताक्षरकर्ता और
  केवल-पठनीय खाते की संख्या निर्दिष्ट करता है।
- [खाता पते](/docs/core/transactions#array-of-account-addresses): लेनदेन पर
  निर्देशों द्वारा आवश्यक खाता पतों की एक सरणी।
- [हालिया ब्लॉकहैश](/docs/core/transactions#recent-blockhash): लेनदेन के लिए एक
  टाइमस्टैम्प के रूप में कार्य करता है।
- [निर्देश](/docs/core/transactions#array-of-instructions): निष्पादित किए जाने
  वाले निर्देशों की एक सरणी।

```rust title="संदेश"
pub struct Message {
    /// संदेश हेडर, हस्ताक्षरित और केवल-पठनीय `account_keys` की पहचान करता है।
    pub header: MessageHeader,

    /// इस लेनदेन द्वारा उपयोग किए गए सभी खाता कुंजियां।
    #[serde(with = "short_vec")]
    pub account_keys: Vec<Pubkey>,

    /// एक हालिया लेजर एंट्री की आईडी।
    pub recent_blockhash: Hash,

    /// प्रोग्राम जो क्रम में निष्पादित किए जाएंगे और
    /// एक परमाणु लेनदेन में प्रतिबद्ध किए जाएंगे यदि सभी सफल होते हैं।
    #[serde(with = "short_vec")]
    pub instructions: Vec<CompiledInstruction>,
}
```

![लेनदेन संदेश](/assets/docs/core/transactions/legacy_message.png)

### लेनदेन का आकार

सोलाना लेनदेन

[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)

बाइट्स तक सीमित हैं। यह सीमा IPv6 MTU आकार 1280 बाइट्स से आती है, जिसमें से
नेटवर्क हेडर्स के लिए 48 बाइट्स (40 बाइट्स IPv6 + 8 बाइट्स फ्रैगमेंट हेडर) कम
किए जाते हैं।

एक लेनदेन का कुल आकार (हस्ताक्षर और संदेश) इस सीमा से कम होना चाहिए और इसमें
शामिल हैं:

- हस्ताक्षर: प्रत्येक 64 बाइट्स
- संदेश: हेडर (3 बाइट्स), अकाउंट कीज़ (प्रत्येक 32 बाइट्स), हालिया ब्लॉकहैश (32
  बाइट्स), और निर्देश

![लेनदेन प्रारूप](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### संदेश हेडर

[संदेश हेडर](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)

अकाउंट विशेषाधिकारों को परिभाषित करने के लिए तीन बाइट्स का उपयोग करता है:

1. आवश्यक हस्ताक्षर और
   [संदेश संस्करण](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/versions/mod.rs#L220-L231)
   (जैसे लेगेसी बनाम v0)
2. केवल-पढ़ने वाले हस्ताक्षरित अकाउंट्स की संख्या
3. केवल-पढ़ने वाले गैर-हस्ताक्षरित अकाउंट्स की संख्या

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    pub num_readonly_unsigned_accounts: u8,
}
```

![संदेश हेडर](/assets/docs/core/transactions/message_header.png)

### कॉम्पैक्ट-एरे प्रारूप

लेनदेन संदेश में एक कॉम्पैक्ट एरे एक ऐसी एरे को संदर्भित करता है जो निम्नलिखित
प्रारूप में सीरियलाइज़ की गई है:

1. एरे की लंबाई
   ([कॉम्पैक्ट-u16](https://github.com/anza-xyz/agave/blob/v2.1.13/short-vec/src/lib.rs)
   के रूप में एनकोडेड)
2. एरे आइटम एक के बाद एक सूचीबद्ध

![कॉम्पैक्ट एरे प्रारूप](/assets/docs/core/transactions/compact_array_format.png)

इस प्रारूप का उपयोग लेनदेन संदेशों में
[अकाउंट एड्रेस](/docs/core/transactions#array-of-account-addresses) और
[निर्देश](/docs/core/transactions#array-of-instructions) एरे की लंबाई को एनकोड
करने के लिए किया जाता है।

### अकाउंट एड्रेस की एरे

एक लेनदेन संदेश में

[अकाउंट एड्रेस](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)

की एक एरे होती है जो उसके निर्देशों द्वारा आवश्यक होती है। एरे एक
[कॉम्पैक्ट-u16](/docs/core/transactions#compact-array-format) संख्या से शुरू
होती है जो बताती है कि इसमें कितने एड्रेस हैं। फिर एड्रेस उनके विशेषाधिकारों के
आधार पर क्रमबद्ध किए जाते हैं, जो संदेश हेडर द्वारा निर्धारित होता है।

- अकाउंट जो लिखने योग्य हैं और हस्ताक्षरकर्ता हैं
- अकाउंट जो केवल-पढ़ने योग्य हैं और हस्ताक्षरकर्ता हैं
- अकाउंट जो लिखने योग्य हैं और हस्ताक्षरकर्ता नहीं हैं
- अकाउंट जो केवल-पढ़ने योग्य हैं और हस्ताक्षरकर्ता नहीं हैं

![खाता पतों की कॉम्पैक्ट अरे](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### हालिया ब्लॉकहैश

हर लेनदेन के लिए एक

[हालिया ब्लॉकहैश](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L141)

की आवश्यकता होती है जो दो उद्देश्यों की पूर्ति करता है:

1. टाइमस्टैम्प के रूप में कार्य करता है
2. डुप्लिकेट लेनदेन को रोकता है

एक ब्लॉकहैश

[150](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)

ब्लॉक्स (लगभग 1 मिनट, 400ms ब्लॉक समय मानते हुए) के बाद समाप्त हो जाता है, जिसके
बाद लेनदेन प्रोसेस नहीं किया जा सकता।

आप वर्तमान ब्लॉकहैश और अंतिम ब्लॉक ऊंचाई प्राप्त करने के लिए
[`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) RPC मेथड का उपयोग कर
सकते हैं, जिस पर ब्लॉकहैश मान्य होगा। यहां
[Solana Playground](https://beta.solpg.io/661a06e1cffcf4b13384d046) पर एक उदाहरण
है।

### निर्देशों की अरे

एक लेनदेन संदेश में

[निर्देशों](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)

की एक अरे होती है जो

[CompiledInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)

प्रकार में होती है। निर्देशों को लेनदेन में जोड़ते समय इस प्रकार में परिवर्तित
किया जाता है।

संदेश में खाता पतों की अरे की तरह, यह एक
[compact-u16](/docs/core/transactions#compact-array-format) लंबाई से शुरू होती
है, उसके बाद निर्देश डेटा आता है। प्रत्येक निर्देश में शामिल होता है:

1. प्रोग्राम आईडी इंडेक्स: एक u8 इंडेक्स जो खाता पतों की अरे में प्रोग्राम के
   पते को इंगित करता है। यह उस प्रोग्राम को निर्दिष्ट करता है जो निर्देश को
   प्रोसेस करेगा।
2. खाता इंडेक्स: u8 इंडेक्स की एक अरे जो इस निर्देश के लिए आवश्यक खाता पतों को
   इंगित करती है।
3. निर्देश डेटा: एक बाइट अरे जो प्रोग्राम पर किस निर्देश को इनवोक करना है और
   निर्देश द्वारा आवश्यक किसी भी अतिरिक्त डेटा (जैसे फंक्शन आर्गुमेंट्स) को
   निर्दिष्ट करता है।

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    pub data: Vec<u8>,
}
```

![निर्देशों की कॉम्पैक्ट अरे](/assets/docs/core/transactions/compact_array_of_ixs.png)

### उदाहरण लेनदेन संरचना

नीचे एक उदाहरण लेनदेन दिया गया है जिसमें एक
[SOL ट्रांसफर](/docs/core/transactions#basic-example) निर्देश शामिल है। लेनदेन
के घटकों में शामिल हैं:

- `header`: `accountKeys` अरे में पतों के लिए पढ़ने/लिखने और हस्ताक्षरकर्ता
  विशेषाधिकारों को निर्दिष्ट करता है

- `accountKeys`: लेनदेन के निर्देशों में उपयोग किए गए सभी खाता पतों की अरे

- `recentBlockhash`: लेनदेन को टाइमस्टैम्प करने के लिए उपयोग किया गया ब्लॉकहैश

- `instructions`: निष्पादित करने के लिए निर्देशों की अरे। एक निर्देश में
  प्रत्येक `account` और `programIdIndex` सूचकांक द्वारा `accountKeys` अरे को
  संदर्भित करता है।

- `signatures`: उन सभी खातों के लिए हस्ताक्षर शामिल करने वाली अरे जिन्हें लेनदेन
  पर निर्देशों द्वारा हस्ताक्षरकर्ता के रूप में आवश्यक है। एक हस्ताक्षर किसी
  खाते के लिए संबंधित निजी कुंजी का उपयोग करके लेनदेन संदेश पर हस्ताक्षर करके
  बनाया जाता है।

```json
"transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
        "5snoUseZG8s8CDFHrXY2ZHaCrJYsW457piktDmhyb5Jd",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "DzfXchZJoLMG3cNftcf2sw7qatkkuwQf4xH15N5wkKAb",
      "instructions": [
        {
          "accounts": [
            0,
            1
          ],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "5LrcE2f6uvydKRquEJ8xp19heGxSvqsVbcqUeFoiWbXe8JNip7ftPQNTAVPyTK7ijVdpkzmKKaAQR7MWMmujAhXD"
    ]
  }
```

## निर्देश

एक

[निर्देश](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)

एक तैनात [प्रोग्राम](/docs/core/accounts#program-account) पर एक सार्वजनिक
फ़ंक्शन के रूप में समझा जा सकता है जिसे सोलाना नेटवर्क का उपयोग करके कोई भी कॉल
कर सकता है।

किसी प्रोग्राम के निर्देश को आमंत्रित करने के लिए तीन महत्वपूर्ण जानकारी प्रदान
करने की आवश्यकता होती है:

- प्रोग्राम आईडी: वह प्रोग्राम जिसे निर्देश निष्पादित करने के लिए आमंत्रित किया
  जा रहा है
- खाते: निर्देश के लिए आवश्यक खातों की सूची
- निर्देश डेटा: बाइट अरे जो प्रोग्राम पर आमंत्रित करने के लिए निर्देश और निर्देश
  द्वारा आवश्यक किसी भी फ़ंक्शन आर्गुमेंट को निर्दिष्ट करता है

```rust title="Instruction"
pub struct Instruction {
    /// Pubkey of the program that executes this instruction.
    pub program_id: Pubkey,
    /// Metadata describing accounts that should be passed to the program.
    pub accounts: Vec<AccountMeta>,
    /// Opaque data passed to the program for its own interpretation.
    pub data: Vec<u8>,
}
```

![लेनदेन निर्देश](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

एक निर्देश द्वारा आवश्यक प्रत्येक खाते को एक

[AccountMeta](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25)

के रूप में प्रदान किया जाना चाहिए जिसमें शामिल हैं:

- `pubkey`: खाते का पता
- `is_signer`: क्या खाते को लेनदेन पर हस्ताक्षर करना होगा
- `is_writable`: क्या निर्देश खाते के डेटा को संशोधित करेगा

```rust title="AccountMeta"
pub struct AccountMeta {
    /// एक खाते की पब्लिक की।
    pub pubkey: Pubkey,
    /// सत्य यदि एक `Instruction` को `Transaction` हस्ताक्षर की आवश्यकता है जो `pubkey` से मेल खाता है।
    pub is_signer: bool,
    /// सत्य यदि प्रोग्राम निष्पादन के दौरान खाता डेटा या मेटाडेटा परिवर्तित किया जा सकता है।
    pub is_writable: bool,
}
```

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

पहले से यह निर्दिष्ट करके कि एक निर्देश किन खातों से पढ़ेगा या लिखेगा, ऐसे
लेनदेन जो समान खातों को संशोधित नहीं करते हैं, उन्हें समानांतर में संसाधित किया
जा सकता है।

### उदाहरण निर्देश संरचना

नीचे एक SOL ट्रांसफर निर्देश की संरचना दिखाने वाला एक सरल उदाहरण है:

- `keys`: निर्देश द्वारा आवश्यक प्रत्येक खाते के लिए `AccountMeta` शामिल करता
  है।
- `programId`: उस प्रोग्राम का पता जिसमें निर्देश के लिए निष्पादन तर्क शामिल है।
- `data`: निर्देश के लिए बाइट्स के बफर के रूप में निर्देश डेटा

```json
{
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  "programId": "11111111111111111111111111111111",
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

## विस्तारित उदाहरण

प्रोग्राम निर्देशों के निर्माण के विवरण अक्सर क्लाइंट लाइब्रेरीज द्वारा अमूर्त
किए जाते हैं। हालांकि, यदि कोई उपलब्ध नहीं है, तो आप हमेशा मैन्युअल रूप से
निर्देश बनाने पर वापस जा सकते हैं।

### SOL ट्रांसफर करें

यहां एक [सोलाना प्लेग्राउंड](https://beta.solpg.io/656a102efb53fa325bfd0c3f)
उदाहरण है कि कैसे मैन्युअल रूप से SOL ट्रांसफर निर्देश बनाया जाए।

अंदर से, `SystemProgram.transfer` विधि का उपयोग करने वाला
[सरल उदाहरण](/docs/core/transactions#simple-sol-transfer) कार्यात्मक रूप से नीचे
दिए गए अधिक विस्तृत उदाहरण के समान है। `SystemProgram.transfer` विधि बस निर्देश
डेटा बफर और निर्देश द्वारा आवश्यक प्रत्येक खाते के लिए `AccountMeta` बनाने के
विवरण को अमूर्त करती है।

नीचे दिए गए दो टैब में स्निपेट कार्यात्मक रूप से समान हैं।

<Tabs items={['Build Instruction Manually', 'Use Library']}>
<Tab value="Build Instruction Manually">

```typescript
// ट्रांसफर की राशि परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// SystemProgram ट्रांसफर निर्देश के लिए निर्देश इंडेक्स
const transferInstructionIndex = 2;

// ट्रांसफर निर्देश को पास किए जाने वाले डेटा के लिए एक बफर बनाएं
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// बफर में निर्देश इंडेक्स लिखें
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// बफर में ट्रांसफर राशि लिखें
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// प्रेषक से प्राप्तकर्ता को SOL ट्रांसफर करने के लिए मैन्युअल रूप से एक ट्रांसफर निर्देश बनाएं
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true }
  ],
  programId: SystemProgram.programId,
  data: instructionData
});

// ट्रांसफर निर्देश को एक नए लेनदेन में जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
<Tab value="Use Library">

```typescript
// ट्रांसफर की राशि परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// wallet_1 से wallet_2 को SOL ट्रांसफर करने के लिए एक ट्रांसफर निर्देश बनाएं
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // transferAmount को lamports में परिवर्तित करें
});

// ट्रांसफर निर्देश को एक नए लेनदेन में जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
</Tabs>

यहां एक [सोलाना प्लेग्राउंड](https://beta.solpg.io/656a102efb53fa325bfd0c3f)
उदाहरण है जो दिखाता है कि SOL ट्रांसफर इंस्ट्रक्शन को मैन्युअली कैसे बनाया जाए।

पर्दे के पीछे, `SystemProgram.transfer` विधि का उपयोग करने वाला
[सरल उदाहरण](/docs/core/transactions#simple-sol-transfer) नीचे दिए गए अधिक
विस्तृत उदाहरण के समान कार्य करता है। `SystemProgram.transfer` विधि बस
इंस्ट्रक्शन डेटा बफर बनाने और प्रत्येक अकाउंट के लिए `AccountMeta` बनाने के
विवरणों को सरल बनाती है जो इंस्ट्रक्शन के लिए आवश्यक हैं।

नीचे दिए गए दो टैब में स्निपेट कार्यात्मक रूप से समान हैं।

<Tabs items={['Build Instruction Manually', 'Use Library']}>
<Tab value="Build Instruction Manually">

```typescript
// ट्रांसफर की राशि परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// SystemProgram ट्रांसफर इंस्ट्रक्शन के लिए इंस्ट्रक्शन इंडेक्स
const transferInstructionIndex = 2;

// ट्रांसफर इंस्ट्रक्शन को पास किए जाने वाले डेटा के लिए एक बफर बनाएं
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// बफर में इंस्ट्रक्शन इंडेक्स लिखें
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// बफर में ट्रांसफर राशि लिखें
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// सेंडर से रिसीवर को SOL ट्रांसफर करने के लिए मैन्युअल रूप से एक ट्रांसफर इंस्ट्रक्शन बनाएं
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true }
  ],
  programId: SystemProgram.programId,
  data: instructionData
});

// ट्रांसफर इंस्ट्रक्शन को एक नए ट्रांजैक्शन में जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
<Tab value="Use Library">

```typescript
// ट्रांसफर की राशि परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// wallet_1 से wallet_2 में SOL ट्रांसफर करने के लिए एक ट्रांसफर इंस्ट्रक्शन बनाएं
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // transferAmount को लैम्पोर्ट्स में बदलें
});

// ट्रांसफर इंस्ट्रक्शन को एक नए ट्रांजैक्शन में जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
</Tabs>

यहां एक [सोलाना प्लेग्राउंड](https://beta.solpg.io/656a102efb53fa325bfd0c3f)
उदाहरण है जो दिखाता है कि SOL ट्रांसफर इंस्ट्रक्शन को मैन्युअली कैसे बनाया जाए।

पर्दे के पीछे, `SystemProgram.transfer` विधि का उपयोग करने वाला
[सरल उदाहरण](/docs/core/transactions#simple-sol-transfer) नीचे दिए गए अधिक
विस्तृत उदाहरण के समान कार्य करता है। `SystemProgram.transfer` विधि बस
इंस्ट्रक्शन डेटा बफर और प्रत्येक अकाउंट के लिए आवश्यक `AccountMeta` बनाने के
विवरणों को सरल बनाती है।

नीचे दिए गए दो टैब में स्निपेट कार्यात्मक रूप से समान हैं।

<Tabs items={['Build Instruction Manually', 'Use Library']}>
<Tab value="Build Instruction Manually">

```typescript
// ट्रांसफर की राशि परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// SystemProgram ट्रांसफर इंस्ट्रक्शन के लिए इंस्ट्रक्शन इंडेक्स
const transferInstructionIndex = 2;

// ट्रांसफर इंस्ट्रक्शन को पास किए जाने वाले डेटा के लिए एक बफर बनाएं
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// बफर में इंस्ट्रक्शन इंडेक्स लिखें
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// बफर में ट्रांसफर राशि लिखें
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// सेंडर से रिसीवर को SOL ट्रांसफर करने के लिए मैन्युअली एक ट्रांसफर इंस्ट्रक्शन बनाएं
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true }
  ],
  programId: SystemProgram.programId,
  data: instructionData
});

// ट्रांसफर इंस्ट्रक्शन को एक नए ट्रांजैक्शन में जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
<Tab value="Use Library">

```typescript
// ट्रांसफर की राशि परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// wallet_1 से wallet_2 को SOL ट्रांसफर करने के लिए एक ट्रांसफर इंस्ट्रक्शन बनाएं
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // transferAmount को लैम्पोर्ट्स में बदलें
});

// ट्रांसफर इंस्ट्रक्शन को एक नए ट्रांजैक्शन में जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
</Tabs>

यहां एक [सोलाना प्लेग्राउंड](https://beta.solpg.io/656a102efb53fa325bfd0c3f)
उदाहरण है जो दिखाता है कि SOL ट्रांसफर इंस्ट्रक्शन को मैन्युअली कैसे बनाया जाए।

पर्दे के पीछे, `SystemProgram.transfer` विधि का उपयोग करने वाला
[सरल उदाहरण](/docs/core/transactions#simple-sol-transfer) नीचे दिए गए अधिक
विस्तृत उदाहरण के समान कार्य करता है। `SystemProgram.transfer` विधि बस
इंस्ट्रक्शन डेटा बफर और प्रत्येक अकाउंट के लिए आवश्यक `AccountMeta` बनाने के
विवरणों को सरल बनाती है।

नीचे दिए गए दो टैब में स्निपेट कार्यात्मक रूप से समान हैं।

<Tabs items={['Build Instruction Manually', 'Use Library']}>
<Tab value="Build Instruction Manually">

```typescript
// ट्रांसफर की राशि परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// SystemProgram ट्रांसफर इंस्ट्रक्शन के लिए इंस्ट्रक्शन इंडेक्स
const transferInstructionIndex = 2;

// ट्रांसफर इंस्ट्रक्शन को पास किए जाने वाले डेटा के लिए एक बफर बनाएं
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// बफर में इंस्ट्रक्शन इंडेक्स लिखें
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// बफर में ट्रांसफर राशि लिखें
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// सेंडर से रिसीवर को SOL ट्रांसफर करने के लिए मैन्युअली एक ट्रांसफर इंस्ट्रक्शन बनाएं
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true }
  ],
  programId: SystemProgram.programId,
  data: instructionData
});

// ट्रांसफर इंस्ट्रक्शन को एक नए ट्रांजैक्शन में जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
<Tab value="Use Library">

```typescript
// ट्रांसफर की राशि परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// wallet_1 से wallet_2 को SOL ट्रांसफर करने के लिए एक ट्रांसफर इंस्ट्रक्शन बनाएं
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // transferAmount को lamports में बदलें
});

// ट्रांसफर इंस्ट्रक्शन को एक नए ट्रांजैक्शन में जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
</Tabs>
