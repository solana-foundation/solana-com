---
title: "लेनदेन और निर्देश"
description:
  सोलाना लेनदेन और निर्देशों के बारे में जानें - सोलाना ब्लॉकचेन के साथ
  बातचीत करने के लिए मौलिक निर्माण खंड। लेनदेन की संरचना और निर्देशों की
  रचना को व्यावहारिक उदाहरणों के साथ समझें। 
---

सोलाना पर, हम नेटवर्क के साथ बातचीत करने के लिए [लेनदेन](/docs/core/transactions#transaction) भेजते हैं।
लेनदेन में एक या अधिक [निर्देश](/docs/core/transactions#instruction) शामिल होते हैं जो
प्रसंस्करण के लिए संचालन निर्दिष्ट करते हैं। निर्देशों के लिए निष्पादन तर्क
[प्रोग्राम](/docs/core/programs) पर संग्रहीत होते हैं जो सोलाना नेटवर्क पर तैनात होते हैं,
जहां प्रत्येक प्रोग्राम अपने स्वयं के निर्देशों का सेट परिभाषित करता है।

नीचे लेनदेन के प्रसंस्करण के बारे में प्रमुख विवरण दिए गए हैं:

- यदि एक लेनदेन में कई निर्देश शामिल हैं, तो निर्देश उस क्रम में निष्पादित होते हैं
  जिसमें उन्हें लेनदेन में जोड़ा गया है। 
- लेनदेन "परमाणु" होते हैं - या तो सभी निर्देश सफलतापूर्वक संसाधित होते हैं, या
  पूरा लेनदेन विफल हो जाता है और कोई परिवर्तन नहीं होता।

सरलता के लिए, एक लेनदेन को एक या कई निर्देशों को संसाधित करने के लिए एक अनुरोध के रूप में
सोचा जा सकता है।

![लेनदेन सरल](/assets/docs/core/transactions/transaction-simple.svg)

एक लेनदेन को एक लिफाफे के रूप में सोचें जिसमें फॉर्म होते हैं। प्रत्येक फॉर्म एक
निर्देश है जो नेटवर्क को बताता है कि हम क्या करने के लिए अनुरोध कर रहे हैं। जब आप
लेनदेन भेजते हैं, तो यह लिफाफे को मेल करने के समान है ताकि फॉर्म संसाधित हो सकें।

## प्रमुख बिंदु

- सोलाना लेनदेन में निर्देश शामिल होते हैं जो नेटवर्क पर प्रोग्राम को सक्रिय करने के लिए अनुरोध होते हैं।
- लेनदेन **परमाणु** होते हैं - यदि कोई भी निर्देश विफल होता है, तो पूरा लेनदेन
  विफल हो जाता है और कोई परिवर्तन नहीं होता।
- लेनदेन पर निर्देश **क्रमबद्ध क्रम में संसाधित** होते हैं। 
- लेनदेन का अधिकतम आकार
  [1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
  बाइट्स है। 
- प्रत्येक निर्देश को 3 जानकारी के टुकड़ों की आवश्यकता होती है:
  1. प्रोग्राम का पता जिसे सक्रिय करना है
  2. खाते जिनसे निर्देश पढ़ेगा या जिनमें लिखा जाएगा
  3. निर्देश द्वारा आवश्यक कोई अतिरिक्त डेटा (जैसे, फ़ंक्शन तर्क)

## बुनियादी उदाहरण

नीचे एक चित्र है जो एक लेनदेन का प्रतिनिधित्व करता है जिसमें एकल निर्देश है
प्रेषक से प्राप्तकर्ता को SOL स्थानांतरित करने के लिए।

सोलाना पर, जिन खातों को हम "वॉलेट" कहते हैं, वे
[सिस्टम प्रोग्राम](/docs/core/accounts#system-program) द्वारा स्वामित्व में हैं। केवल प्रोग्राम का मालिक
खाते के डेटा को संशोधित कर सकता है, इसलिए SOL स्थानांतरित करने के लिए सिस्टम प्रोग्राम को सक्रिय करने के लिए
लेनदेन भेजना आवश्यक है।

![SOL स्थानांतरण](/assets/docs/core/transactions/sol-transfer.svg)

प्रेषक खाते को अपने लमपोर्ट संतुलन को घटाने के लिए लेनदेन पर हस्ताक्षर करना चाहिए (`is_signer`)।
प्रेषक और प्राप्तकर्ता दोनों खातों को लिखने योग्य (`is_writable`) के रूप में चिह्नित किया जाना चाहिए क्योंकि इन खातों पर लमपोर्ट संतुलन बदल जाएगा।

एक बार जब लेनदेन भेजा जाता है, तो स्थानांतरण निर्देश को संसाधित करने के लिए सिस्टम प्रोग्राम को सक्रिय किया जाता है।
फिर सिस्टम प्रोग्राम प्रेषक और प्राप्तकर्ता खातों के लमपोर्ट संतुलन को तदनुसार अपडेट करता है।

![SOL स्थानांतरण प्रक्रिया](/assets/docs/core/transactions/sol-transfer-process.svg)

### SOL स्थानांतरित करें

यहाँ एक [सोलाना प्लेग्राउंड](https://beta.solpg.io/656a0ea7fb53fa325bfd0c3e)
उदाहरण है कि कैसे `SystemProgram.transfer` विधि का उपयोग करके SOL स्थानांतरण निर्देश बनाया जाए:

```typescript title="SOL स्थानांतरित करें"
// स्थानांतरित करने के लिए राशि को परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// वॉलेट_1 से वॉलेट_2 में SOL स्थानांतरित करने के लिए स्थानांतरण निर्देश बनाएं
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL, // transferAmount को लमपोर्ट में परिवर्तित करें
});

// एक नए लेनदेन में स्थानांतरण निर्देश जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

प्लेग्राउंड टर्मिनल में `run` कमांड का उपयोग करके उदाहरण चलाएँ या
"रन" बटन पर क्लिक करें।

<Callout type="info">

सुनिश्चित करें कि आपका प्लेग्राउंड वॉलेट devnet SOL है। devnet SOL प्राप्त करें
[सोलाना फॉसेट](https://faucet.solana.com/) से।

</Callout>

नीचे के अनुभागों में, हम लेनदेन और निर्देशों के विवरण के माध्यम से चलेंगे। 

## लेनदेन

एक सोलाना
[लेनदेन](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
में शामिल होते हैं:

1. [हस्ताक्षर](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30):
   लेनदेन पर शामिल हस्ताक्षरों की एक सूची।
2. [संदेश](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131):
   उन निर्देशों की सूची जिन्हें परमाणु रूप से संसाधित किया जाना है।

```rust title="लेनदेन"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    pub message: Message,
}
```

![लेनदेन प्रारूप](/assets/docs/core/transactions/tx_format.png)

लेनदेन संदेश की संरचना में शामिल होते हैं:

- [संदेश शीर्षक](/docs/core/transactions#message-header): हस्ताक्षरकर्ता और पढ़ने के लिए केवल खाते की संख्या निर्दिष्ट करता है।
- [खाते के पते](/docs/core/transactions#array-of-account-addresses): लेनदेन पर निर्देशों द्वारा आवश्यक खाते के पते की एक सूची।
- [हालिया ब्लॉकहैश](/docs/core/transactions#recent-blockhash): लेनदेन के लिए एक टाइमस्टैम्प के रूप में कार्य करता है।
- [निर्देश](/docs/core/transactions#array-of-instructions): निष्पादित करने के लिए निर्देशों की एक सूची। 

```rust title="संदेश"
pub struct Message {
    /// संदेश शीर्षक, हस्ताक्षरित और पढ़ने के लिए केवल `account_keys` की पहचान करता है।
    pub header: MessageHeader,

    /// इस लेनदेन द्वारा उपयोग किए गए सभी खाता कुंजी।
    #[serde(with = "short_vec")]
    pub account_keys: Vec<Pubkey>,

    /// हाल के लेजर प्रविष्टि की आईडी।
    pub recent_blockhash: Hash,

    /// प्रोग्राम जो अनुक्रम में निष्पादित किए जाएंगे और यदि सभी सफल होते हैं तो एक परमाणु लेनदेन में प्रतिबद्ध किया जाएगा।
    #[serde(with = "short_vec")]
    pub instructions: Vec<CompiledInstruction>,
}
```

![लेनदेन संदेश](/assets/docs/core/transactions/legacy_message.png)

### लेनदेन का आकार

सोलाना लेनदेन की सीमा है
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
बाइट्स। यह सीमा IPv6 MTU आकार 1280 बाइट्स से आती है, जिसमें नेटवर्क हेडर के लिए 48 बाइट्स घटाए जाते हैं (40 बाइट्स IPv6 + 8 बाइट्स फ़्रैगमेंट हेडर)।

एक लेनदेन का कुल आकार (हस्ताक्षर और संदेश) इस सीमा के तहत रहना चाहिए
और इसमें शामिल होते हैं:

- हस्ताक्षर: प्रत्येक 64 बाइट्स
- संदेश: शीर्षक (3 बाइट्स), खाता कुंजी (प्रत्येक 32 बाइट्स), हाल का ब्लॉकहैश (32 बाइट्स), और निर्देश

![लेनदेन प्रारूप](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### संदेश शीर्षक

[संदेश शीर्षक](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
खाते की विशेषताओं को परिभाषित करने के लिए तीन बाइट्स का उपयोग करता है:

1. आवश्यक हस्ताक्षर और
   [संदेश संस्करण](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/versions/mod.rs#L220-L231)
   (जैसे, विरासत बनाम v0)
2. पढ़ने के लिए केवल हस्ताक्षरित खातों की संख्या
3. पढ़ने के लिए केवल बिना हस्ताक्षर वाले खातों की संख्या

```rust title="MessageHeader"
pub struct MessageHeader {
    /// इस संदेश को मान्य माना जाने के लिए आवश्यक हस्ताक्षरों की संख्या। उन हस्ताक्षरों के हस्ताक्षरकर्ता पहले
    /// `num_required_signatures` के [`Message::account_keys`] से मेल खाने चाहिए।
    pub num_required_signatures: u8,

    /// हस्ताक्षरित कुंजियों के अंतिम `num_readonly_signed_accounts` पढ़ने के लिए केवल
    /// खाते हैं।
    pub num_readonly_signed_accounts: u8,

    /// बिना हस्ताक्षर वाली कुंजियों के अंतिम `num_readonly_unsigned_accounts` पढ़ने के लिए केवल
    /// खाते हैं।
    pub num_readonly_unsigned_accounts: u8,
}
```

![संदेश शीर्षक](/assets/docs/core/transactions/message_header.png)

### कॉम्पैक्ट-एरे प्रारूप

लेनदेन संदेश में एक कॉम्पैक्ट एरे उस एरे को संदर्भित करता है जिसे निम्नलिखित प्रारूप में अनुक्रमित किया गया है:

1. एरे की लंबाई (कोडित के रूप में
   [compact-u16](https://github.com/anza-xyz/agave/blob/v2.1.13/short-vec/src/lib.rs))
2. एरे आइटम एक के बाद एक सूचीबद्ध होते हैं

![कॉम्पैक्ट एरे प्रारूप](/assets/docs/core/transactions/compact_array_format.png)

यह प्रारूप लेनदेन संदेशों में
[खाते के पते](/docs/core/transactions#array-of-account-addresses) और
[निर्देशों](/docs/core/transactions#array-of-instructions) एरे की लंबाई को कोडित करने के लिए उपयोग किया जाता है।

### खाते के पते की सूची

एक लेनदेन संदेश में एक
[खाते के पते](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
की सूची होती है जो इसके निर्देशों द्वारा आवश्यक होती है। एरे एक
[compact-u16](/docs/core/transactions#compact-array-format) संख्या के साथ शुरू होती है जो यह दर्शाती है कि इसमें कितने पते हैं।
फिर पते उनके विशेषाधिकार के आधार पर क्रमबद्ध होते हैं, जो संदेश शीर्षक द्वारा निर्धारित होता है।

- खाते जो लिखने योग्य और हस्ताक्षरकर्ता हैं
- खाते जो पढ़ने के लिए केवल और हस्ताक्षरकर्ता हैं
- खाते जो लिखने योग्य हैं और हस्ताक्षरकर्ता नहीं हैं
- खाते जो पढ़ने के लिए केवल और हस्ताक्षरकर्ता नहीं हैं

![खाते के पते की कॉम्पैक्ट सूची](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### हाल का ब्लॉकहैश

प्रत्येक लेनदेन की आवश्यकता होती है
[हाल का ब्लॉकहैश](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L141)
जो दो उद्देश्यों की पूर्ति करता है:

1. एक टाइमस्टैम्प के रूप में कार्य करता है
2. डुप्लिकेट लेनदेन को रोकता है

एक ब्लॉकहैश
[150](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)
ब्लॉकों के बाद समाप्त हो जाता है (लगभग 1 मिनट मानते हुए 400ms ब्लॉक समय), जिसके बाद लेनदेन को संसाधित नहीं किया जा सकता।

आप [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) RPC
विधि का उपयोग करके वर्तमान ब्लॉकहैश और अंतिम ब्लॉक ऊंचाई प्राप्त कर सकते हैं जिस पर ब्लॉकहैश मान्य होगा। यहाँ एक उदाहरण है
[सोलाना प्लेग्राउंड](https://beta.solpg.io/661a06e1cffcf4b13384d046) पर।

### निर्देशों की सूची

एक लेनदेन संदेश में
[निर्देशों](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)\nकी एक सूची होती है जो
[CompiledInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
प्रकार में होती है। निर्देशों को लेनदेन में जोड़े जाने पर इस प्रकार में परिवर्तित किया जाता है।

जैसे संदेश में खाते के पते की सूची, यह एक
[compact-u16](/docs/core/transactions#compact-array-format) लंबाई के साथ शुरू होती है जिसके बाद निर्देश डेटा होता है। प्रत्येक निर्देश में शामिल होते हैं:

1. प्रोग्राम आईडी इंडेक्स: एक u8 इंडेक्स जो खाते के पते की सूची में प्रोग्राम के पते की ओर इशारा करता है। यह निर्दिष्ट करता है कि कौन सा प्रोग्राम निर्देश को संसाधित करेगा।
2. खाता इंडेक्स: u8 इंडेक्स की एक सूची जो इस निर्देश के लिए आवश्यक खाते के पते की ओर इशारा करती है।
3. निर्देश डेटा: एक बाइट एरे जो यह निर्दिष्ट करता है कि प्रोग्राम पर कौन सा निर्देश सक्रिय करना है और निर्देश द्वारा आवश्यक कोई अतिरिक्त डेटा (जैसे, फ़ंक्शन तर्क)।

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// लेनदेन कुंजी सूची में इंडेक्स जो इस निर्देश को निष्पादित करने वाले प्रोग्राम खाते को इंगित करता है।
    pub program_id_index: u8,
    /// लेनदेन कुंजी सूची में क्रमबद्ध इंडेक्स जो प्रोग्राम को पास किए जाने वाले खातों को इंगित करते हैं।
    #[serde(with = "short_vec")]
    pub accounts: Vec<u8>,
    /// प्रोग्राम इनपुट डेटा।
    #[serde(with = "short_vec")]
    pub data: Vec<u8>,
}
```

![निर्देशों की कॉम्पैक्ट सूची](/assets/docs/core/transactions/compact_array_of_ixs.png)

### उदाहरण लेनदेन संरचना

नीचे एक उदाहरण लेनदेन है जिसमें एकल
[SOL स्थानांतरण](/docs/core/transactions#basic-example) निर्देश शामिल है। लेनदेन के घटक शामिल हैं:

- `header`: `accountKeys` सूची में पते के लिए पढ़ने/लिखने और हस्ताक्षरकर्ता विशेषाधिकार निर्दिष्ट करता है

- `accountKeys`: लेनदेन के निर्देशों में उपयोग किए गए सभी खाता पते की सूची

- `recentBlockhash`: लेनदेन को टाइमस्टैम्प करने के लिए उपयोग किया जाने वाला ब्लॉकहैश

- `instructions`: निष्पादित करने के लिए निर्देशों की सूची। प्रत्येक `account` और
  `programIdIndex` एक निर्देश में `accountKeys` सूची को इंडेक्स द्वारा संदर्भित करता है। 

- `signatures`: सभी खातों के लिए हस्ताक्षरों की सूची जो लेनदेन पर निर्देशों द्वारा हस्ताक्षरकर्ता के रूप में आवश्यक हैं। एक हस्ताक्षर को एक खाते के लिए संबंधित निजी कुंजी का उपयोग करके लेनदेन संदेश पर हस्ताक्षर करके बनाया जाता है।

```json
"transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
        "5snoUseZG8s8CDFHrXY2ZHaCrJYsW457piktDmhyb5Jd",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "DzfXchZJoLMG3cNftcf2sw7qatkkuwQf4xH15N5wkKAb",
      "instructions": [
        {
          "accounts": [
            0,
            1
          ],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "5LrcE2f6uvydKRquEJ8xp19heGxSvqsVbcqUeFoiWbXe8JNip7ftPQNTAVPyTK7ijVdpkzmKKaAQR7MWMmujAhXD"
    ]
  }
```

## निर्देश

एक
[निर्देश](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)
एक तैनात [प्रोग्राम](/docs/core/accounts#program-account) पर एक सार्वजनिक फ़ंक्शन के रूप में सोचा जा सकता है जिसे कोई भी सोलाना नेटवर्क का उपयोग करके कॉल कर सकता है।

एक प्रोग्राम के निर्देश को सक्रिय करने के लिए तीन प्रमुख जानकारी के टुकड़े प्रदान करने की आवश्यकता होती है:

- प्रोग्राम आईडी: प्रोग्राम जिसे निर्देश निष्पादित करने के लिए सक्रिय किया जा रहा है
- खाते: उन खातों की सूची जिनकी निर्देश को आवश्यकता है
- निर्देश डेटा: बाइट एरे जो प्रोग्राम पर सक्रिय करने के लिए निर्देश को निर्दिष्ट करता है और निर्देश द्वारा आवश्यक कोई फ़ंक्शन तर्क

```rust title="निर्देश"
pub struct Instruction {
    /// प्रोग्राम का सार्वजनिक कुंजी जो इस निर्देश को निष्पादित करता है।
    pub program_id: Pubkey,
    /// खातों का मेटाडेटा जो प्रोग्राम को पास किया जाना चाहिए।
    pub accounts: Vec<AccountMeta>,
    /// प्रोग्राम के लिए अपने स्वयं के व्याख्या के लिए पास किया गया ओपेक डेटा।
    pub data: Vec<u8>,
}
```

![लेनदेन निर्देश](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

एक निर्देश द्वारा आवश्यक प्रत्येक खाते को एक
[AccountMeta](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25)
के रूप में प्रदान किया जाना चाहिए जिसमें शामिल होते हैं:

- `pubkey`: खाते का पता
- `is_signer`: क्या खाते को लेनदेन पर हस्ताक्षर करना चाहिए
- `is_writable`: क्या निर्देश खाते के डेटा को संशोधित करेगा

```rust title="AccountMeta"
pub struct AccountMeta {
    /// एक खाते की सार्वजनिक कुंजी।
    pub pubkey: Pubkey,
    /// यदि एक `निर्देश` को `pubkey` से मेल खाने वाले `लेनदेन` हस्ताक्षर की आवश्यकता है तो सत्य।
    pub is_signer: bool,
    /// यदि खाते का डेटा या मेटाडेटा प्रोग्राम निष्पादन के दौरान परिवर्तित किया जा सकता है तो सत्य।
    pub is_writable: bool,
}
```

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

यह निर्दिष्ट करके कि एक निर्देश किस खातों से पढ़ेगा या लिखेगा,
ऐसे लेनदेन जो समान खातों को संशोधित नहीं करते हैं, उन्हें समानांतर में संसाधित किया जा सकता है।

### उदाहरण निर्देश संरचना

नीचे एक सरल उदाहरण है जो SOL स्थानांतरण निर्देश की संरचना को दर्शाता है:

- `keys`: प्रत्येक खाते के लिए `AccountMeta` को शामिल करता है जो एक
  निर्देश द्वारा आवश्यक है। 
- `programId`: प्रोग्राम का पता जिसमें सक्रिय किए गए निर्देश के लिए निष्पादन तर्क होते हैं।
- `data`: निर्देश के लिए निर्देश डेटा बाइट्स के बफर के रूप में

```json
{
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  "programId": "11111111111111111111111111111111",
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

## विस्तारित उदाहरण

प्रोग्राम निर्देश बनाने के विवरण अक्सर क्लाइंट लाइब्रेरी द्वारा अमूर्त होते हैं। हालाँकि, यदि कोई उपलब्ध नहीं है, तो आप हमेशा निर्देश को मैन्युअल रूप से बनाने के लिए वापस जा सकते हैं।

### SOL स्थानांतरित करें

यहाँ एक [सोलाना प्लेग्राउंड](https://beta.solpg.io/656a102efb53fa325bfd0c3f)
उदाहरण है कि कैसे मैन्युअल रूप से SOL स्थानांतरण निर्देश बनाया जाए।

अंदर, [सरल उदाहरण](/docs/core/transactions#simple-sol-transfer) का उपयोग करते हुए
`SystemProgram.transfer` विधि कार्यात्मक रूप से नीचे दिए गए अधिक विस्तृत उदाहरण के समान है। `SystemProgram.transfer` विधि बस निर्देश डेटा बफर और प्रत्येक खाते के लिए `AccountMeta` बनाने के विवरण को अमूर्त करती है जो निर्देश द्वारा आवश्यक है।

नीचे दो टैब में स्निपेट कार्यात्मक रूप से समान हैं।

<Tabs items={['निर्देश मैन्युअल रूप से बनाएं', 'लाइब्रेरी का उपयोग करें']}>
<Tab value="निर्देश मैन्युअल रूप से बनाएं">

```typescript
// स्थानांतरित करने के लिए राशि को परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// सिस्टम प्रोग्राम स्थानांतरण निर्देश के लिए निर्देशांक
const transferInstructionIndex = 2;

// स्थानांतरण निर्देश के लिए डेटा पास करने के लिए बफर बनाएं
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// बफर में निर्देशांक लिखें
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// बफर में स्थानांतरण राशि लिखें
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// प्रेषक से प्राप्तकर्ता को SOL स्थानांतरित करने के लिए मैन्युअल रूप से स्थानांतरण निर्देश बनाएं
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true },
  ],
  programId: SystemProgram.programId,
  data: instructionData,
});

// एक नए लेनदेन में स्थानांतरण निर्देश जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
<Tab value="लाइब्रेरी का उपयोग करें">

```typescript
// स्थानांतरित करने के लिए राशि को परिभाषित करें
const transferAmount = 0.01; // 0.01 SOL

// वॉलेट_1 से वॉलेट_2 में SOL स्थानांतरित करने के लिए स्थानांतरण निर्देश बनाएं
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL, // transferAmount को लमपोर्ट में परिवर्तित करें
});

// एक नए लेनदेन में स्थानांतरण निर्देश जोड़ें
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
</Tabs>
