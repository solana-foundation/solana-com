---
title: लेनदेन और निर्देश
description:
  सोलाना लेनदेन और निर्देशों के बारे में जानें - सोलाना ब्लॉकचेन के साथ इंटरैक्ट
  करने के लिए मूलभूत बिल्डिंग ब्लॉक्स। व्यावहारिक उदाहरणों के साथ लेनदेन संरचना
  और निर्देश संरचना को समझें।
---

सोलाना पर, उपयोगकर्ता नेटवर्क के साथ इंटरैक्ट करने के लिए
[लेनदेन](/docs/core/transactions#transaction) भेजते हैं। लेनदेन में एक या अधिक
[निर्देश](/docs/core/transactions#instruction) होते हैं जो प्रोसेस करने के लिए
ऑपरेशन निर्दिष्ट करते हैं। निर्देशों के लिए एक्जीक्यूशन लॉजिक सोलाना नेटवर्क पर
डिप्लॉय किए गए [प्रोग्राम्स](/docs/core/programs) पर स्टोर किए जाते हैं, जहां
प्रत्येक प्रोग्राम अपने स्वयं के निर्देशों का सेट परिभाषित करता है।

नीचे सोलाना लेनदेन प्रोसेसिंग के बारे में प्रमुख विवरण दिए गए हैं:

- यदि कोई लेनदेन में कई निर्देश शामिल हैं, तो निर्देश लेनदेन में जोड़े गए क्रम
  में निष्पादित होते हैं।
- लेनदेन "एटॉमिक" हैं - सभी निर्देशों को सफलतापूर्वक प्रोसेस करना होगा, अन्यथा
  पूरा लेनदेन विफल हो जाता है और कोई परिवर्तन नहीं होता है।

एक लेनदेन अनिवार्य रूप से एक या अधिक निर्देशों को प्रोसेस करने का अनुरोध है।

![सरलीकृत लेनदेन](/assets/docs/core/transactions/transaction-simple.svg)

एक लेनदेन एक ऐसे लिफाफे की तरह है जिसमें फॉर्म होते हैं। प्रत्येक फॉर्म एक
निर्देश है जो नेटवर्क को बताता है कि क्या करना है। लेनदेन भेजना लिफाफे को मेल
करने जैसा है ताकि फॉर्म प्रोसेस किए जा सकें।

## प्रमुख बिंदु

- सोलाना लेनदेन में निर्देश शामिल होते हैं जो नेटवर्क पर प्रोग्राम को इनवोक करते
  हैं।
- लेनदेन **एटॉमिक** हैं - यदि कोई भी निर्देश विफल होता है, तो पूरा लेनदेन विफल
  हो जाता है और कोई परिवर्तन नहीं होता है।
- लेनदेन पर निर्देश क्रमिक क्रम में निष्पादित होते हैं।
- लेनदेन आकार की सीमा
  [1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
  बाइट्स है।
- प्रत्येक निर्देश के लिए तीन प्रकार की जानकारी की आवश्यकता होती है:
  1. इनवोक करने के लिए प्रोग्राम का पता
  2. वे अकाउंट्स जिन्हें निर्देश पढ़ता है या लिखता है
  3. निर्देश द्वारा आवश्यक कोई अतिरिक्त डेटा (जैसे, फंक्शन आर्गुमेंट्स)

## SOL ट्रांसफर उदाहरण

नीचे दिया गया आरेख एक प्रेषक से प्राप्तकर्ता को SOL स्थानांतरित करने के लिए एक
एकल निर्देश वाले लेनदेन का प्रतिनिधित्व करता है।

सोलाना पर, "वॉलेट" [सिस्टम प्रोग्राम](/docs/core/accounts#system-program) के
स्वामित्व वाले खाते हैं। केवल प्रोग्राम मालिक ही खाते के डेटा को बदल सकता है,
इसलिए SOL स्थानांतरित करने के लिए सिस्टम प्रोग्राम को आमंत्रित करने के लिए एक
लेनदेन भेजना आवश्यक है।

![SOL स्थानांतरण](/assets/docs/core/transactions/sol-transfer.svg)

प्रेषक खाते को लेनदेन पर हस्ताक्षर (`is_signer`) करना होगा ताकि सिस्टम प्रोग्राम
उसके लैम्पोर्ट बैलेंस को कम कर सके। प्रेषक और प्राप्तकर्ता खातों को लिखने योग्य
(`is_writable`) होना चाहिए क्योंकि उनके लैम्पोर्ट बैलेंस में परिवर्तन होता है।

लेनदेन भेजने के बाद, सिस्टम प्रोग्राम स्थानांतरण निर्देश को संसाधित करता है। फिर
सिस्टम प्रोग्राम प्रेषक और प्राप्तकर्ता दोनों खातों के लैम्पोर्ट बैलेंस को अपडेट
करता है।

![SOL स्थानांतरण प्रक्रिया](/assets/docs/core/transactions/sol-transfer-process.svg)

नीचे दिए गए उदाहरण दिखाते हैं कि एक खाते से दूसरे खाते में SOL स्थानांतरित करने
वाला लेनदेन कैसे भेजें।

<CodeTabs flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

// Create a connection to cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Fund sender with airdrop
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: sender.address,
  lamports: lamports(LAMPORTS_PER_SOL), // 1 SOL
  commitment: "confirmed"
});

// Check balance before transfer
const { value: preBalance1 } = await rpc.getBalance(sender.address).send();
const { value: preBalance2 } = await rpc.getBalance(recipient.address).send();

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount // 0.01 SOL in lamports
});

// Add the transfer instruction to a new transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

// Send the transaction to the network
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);
const transactionSignature = getSignatureFromTransaction(signedTransaction);

// Check balance after transfer
const { value: postBalance1 } = await rpc.getBalance(sender.address).send();
const { value: postBalance2 } = await rpc.getBalance(recipient.address).send();

console.log(
  "Sender prebalance:",
  Number(preBalance1) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Recipient prebalance:",
  Number(preBalance2) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Sender postbalance:",
  Number(postBalance1) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Recipient postbalance:",
  Number(postBalance2) / Number(LAMPORTS_PER_SOL)
);
console.log("Transaction Signature:", transactionSignature);
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

// Create a connection to cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Fund sender with airdrop
const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Check balance before transfer
const preBalance1 = await connection.getBalance(sender.publicKey);
const preBalance2 = await connection.getBalance(recipient.publicKey);

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

// Add the transfer instruction to a new transaction
const transaction = new Transaction().add(transferInstruction);

// Send the transaction to the network
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [sender] // signer
);

// Check balance after transfer
const postBalance1 = await connection.getBalance(sender.publicKey);
const postBalance2 = await connection.getBalance(recipient.publicKey);

console.log("Sender prebalance:", preBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient prebalance:", preBalance2 / LAMPORTS_PER_SOL);
console.log("Sender postbalance:", postBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient postbalance:", postBalance2 / LAMPORTS_PER_SOL);
console.log("Transaction Signature:", transactionSignature);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, signature::Signer,
    signer::keypair::Keypair, system_instruction, transaction::Transaction,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create a connection to cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Fund sender with airdrop
    let airdrop_signature = connection
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;
    loop {
        let confirmed = connection.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Check balance before transfer
    let pre_balance1 = connection.get_balance(&sender.pubkey()).await?;
    let pre_balance2 = connection.get_balance(&recipient.pubkey()).await?;

    // Define the amount to transfer
    let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction =
        system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    // Add the transfer instruction to a new transaction
    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    let blockhash = connection.get_latest_blockhash().await?;
    transaction.sign(&[&sender], blockhash);

    // Send the transaction to the network
    let transaction_signature = connection
        .send_and_confirm_transaction(&transaction)
        .await?;

    // Check balance after transfer
    let post_balance1 = connection.get_balance(&sender.pubkey()).await?;
    let post_balance2 = connection.get_balance(&recipient.pubkey()).await?;

    println!(
        "Sender prebalance: {}",
        pre_balance1 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Recipient prebalance: {}",
        pre_balance2 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Sender postbalance: {}",
        post_balance1 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Recipient postbalance: {}",
        post_balance2 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

</CodeTabs>

क्लाइंट लाइब्रेरीज अक्सर प्रोग्राम निर्देश बनाने के विवरणों को सरल बनाती हैं।
यदि कोई लाइब्रेरी उपलब्ध नहीं है, तो आप मैन्युअल रूप से निर्देश बना सकते हैं।
इसके लिए आपको निर्देश के कार्यान्वयन विवरण को जानना आवश्यक है।

नीचे दिए गए उदाहरण दिखाते हैं कि स्थानांतरण निर्देश को मैन्युअल रूप से कैसे
बनाया जाए। `Expanded Instruction` टैब कार्यात्मक रूप से `Instruction` टैब के
समान है।

- किट

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const TRANSFER_INSTRUCTION_INDEX = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(TRANSFER_INSTRUCTION_INDEX, 0);
instructionData.writeBigUInt64LE(transferAmount * LAMPORTS_PER_SOL, 4);

const SYSTEM_PROGRAM_ADDRESS = "11111111111111111111111111111111" as Address;

// Manually create the transfer instruction
const transferInstruction: IInstruction = {
  programAddress: SYSTEM_PROGRAM_ADDRESS,
  accounts: [
    {
      address: sender.address,
      role: AccountRole.WRITABLE_SIGNER
    },
    {
      address: recipient.address,
      role: AccountRole.WRITABLE
    }
  ],
  data: new Uint8Array(instructionData)
};
```

</CodeTabs>

- लेगेसी

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const transferInstructionIndex = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(transferInstructionIndex, 0);
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// Manually create a transfer instruction
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true }, // from account, is signer and is writable
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true } // to account, is not signer but is writable
  ],
  programId: SystemProgram.programId,
  data: instructionData
});
```

</CodeTabs>

- रस्ट

<CodeTabs>

```rs !! title="Instruction"
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

let transfer_instruction =
    system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);
```

```rs !! title="Expanded Instruction"
// Instruction index for the System Program's transfer instruction
let transfer_instruction_index: u32 = 2;

// Define the amount to transfer
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

// Create instruction data manually (12 bytes: 4 for u32 index + 8 for u64 lamports)
let mut instruction_data = Vec::with_capacity(12);
instruction_data.extend_from_slice(&transfer_instruction_index.to_le_bytes());
instruction_data.extend_from_slice(&transfer_amount.to_le_bytes());

// Manually create the transfer instruction
let transfer_instruction = Instruction {
    program_id: system_program::id(),
    accounts: vec![
        AccountMeta::new(sender.pubkey(), true), // from account, is signer and is writable
        AccountMeta::new(recipient.pubkey(), false), // to account, is not signer but is writable
    ],
    data: instruction_data,
};
```

</CodeTabs>

नीचे दिए गए अनुभागों में, हम लेनदेन और निर्देशों के विवरण के बारे में बात
करेंगे।

## निर्देश

Solana [प्रोग्राम](/docs/core/accounts#program-account) पर एक
[निर्देश](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)
को एक सार्वजनिक फ़ंक्शन के रूप में समझा जा सकता है जिसे Solana नेटवर्क का उपयोग
करके कोई भी कॉल कर सकता है।

किसी प्रोग्राम के निर्देश को लागू करने के लिए तीन महत्वपूर्ण जानकारियों की
आवश्यकता होती है:

- प्रोग्राम आईडी: वह प्रोग्राम जिसमें निर्देश के लिए एक्जीक्यूशन लॉजिक है
- अकाउंट्स: निर्देश के लिए आवश्यक अकाउंट्स की सूची
- instruction data: बाइट एरे जो प्रोग्राम पर लागू किए जाने वाले निर्देश और
  निर्देश द्वारा आवश्यक किसी भी आर्गुमेंट को निर्दिष्ट करता है

```rust title="Instruction"
pub struct Instruction {
    /// Pubkey of the program that executes this instruction.
    pub program_id: Pubkey,
    /// Metadata describing accounts that should be passed to the program.
    pub accounts: Vec<AccountMeta>,
    /// Opaque data passed to the program for its own interpretation.
    pub data: Vec<u8>,
}
```

![Transaction Instruction](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

निर्देश द्वारा आवश्यक प्रत्येक अकाउंट को
[AccountMeta](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25)
के रूप में प्रदान किया जाना चाहिए जिसमें शामिल है:

- `pubkey`: अकाउंट का एड्रेस
- `is_signer`: क्या अकाउंट को लेनदेन पर हस्ताक्षर करना होगा
- `is_writable`: क्या निर्देश अकाउंट के डेटा को संशोधित करता है

```rust title="AccountMeta"
pub struct AccountMeta {
    /// An account's public key.
    pub pubkey: Pubkey,
    /// True if an `Instruction` requires a `Transaction` signature matching `pubkey`.
    pub is_signer: bool,
    /// True if the account data or metadata may be mutated during program execution.
    pub is_writable: bool,
}
```

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

पहले से यह निर्दिष्ट करके कि कौन से अकाउंट्स को निर्देश पढ़ता या लिखता है, वे
लेनदेन जो समान अकाउंट्स को संशोधित नहीं करते हैं, समानांतर में निष्पादित हो सकते
हैं।

### उदाहरण निर्देश संरचना

SOL ट्रांसफर निर्देश की संरचना देखने के लिए नीचे दिए गए उदाहरणों को चलाएं।

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner, lamports } from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair
} from "@solana/web3.js";

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair, system_instruction,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Define the amount to transfer
    let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = system_instruction::transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        transfer_amount,
    );

    println!("{:#?}", transfer_instruction);

    Ok(())
}
```

</CodeTabs>

निम्नलिखित उदाहरण पिछले कोड स्निपेट से आउटपुट दिखाते हैं। सटीक प्रारूप SDK के
आधार पर भिन्न होता है, लेकिन हर Solana निर्देश के लिए निम्नलिखित जानकारी आवश्यक
है:

- **प्रोग्राम ID**: उस प्रोग्राम का पता जो निर्देश को निष्पादित करेगा।
- **अकाउंट्स**: निर्देश द्वारा आवश्यक अकाउंट्स की सूची। प्रत्येक अकाउंट के लिए,
  निर्देश को उसका पता, क्या उसे लेनदेन पर हस्ताक्षर करना होगा, और क्या उस पर
  लिखा जाएगा, निर्दिष्ट करना होगा।
- **डेटा**: एक बाइट बफर जो प्रोग्राम को बताता है कि कौन सा निर्देश निष्पादित
  करना है और निर्देश द्वारा आवश्यक किसी भी तर्क को शामिल करता है।

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "accounts": [
    {
      "address": "Hu28vRMGWpQXN56eaE7jRiDDRRz3vCXEs7EKHRfL6bC",
      "role": 3,
      "signer": {
        "address": "Hu28vRMGWpQXN56eaE7jRiDDRRz3vCXEs7EKHRfL6bC",
        "keyPair": {
          "privateKey": {},
          "publicKey": {}
        }
      }
    },
    {
      "address": "2mBY6CTgeyJNJDzo6d2Umipw2aGUquUA7hLdFttNEj7p",
      "role": 1
    }
  ],
  "programAddress": "11111111111111111111111111111111",
  "data": {
    "0": 2,
    "1": 0,
    "2": 0,
    "3": 0,
    "4": 128,
    "5": 150,
    "6": 152,
    "7": 0,
    "8": 0,
    "9": 0,
    "10": 0,
    "11": 0
  }
}
```

```json !! title="Legacy"
{
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  "programId": "11111111111111111111111111111111",
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

```json !! title="Rust"
{
  "program_id": "11111111111111111111111111111111",
  "accounts": [
    {
      "pubkey": "Hhh6vrA6xUNwaNftJVAXSTzfHiRiAKFKLGmHdcRH6Pmo",
      "is_signer": true,
      "is_writable": true
    },
    {
      "pubkey": "6RYMY3mFLixELbfNCMA7zNtzgNfRyEZs5YYkZQb8aK4t",
      "is_signer": false,
      "is_writable": true
    }
  ],
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

</CodeTabs>

## ट्रांजैक्शन्स

एक Solana
[ट्रांजैक्शन](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
में शामिल होता है:

1. [हस्ताक्षर](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30):
   ट्रांजैक्शन पर शामिल हस्ताक्षरों की एक सरणी।
2. [संदेश](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131):
   परमाणु रूप से संसाधित किए जाने वाले निर्देशों की सूची।

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    pub message: Message,
}
```

![ट्रांजैक्शन फॉर्मेट](/assets/docs/core/transactions/tx_format.png)

एक ट्रांजैक्शन संदेश की संरचना में शामिल है:

- [संदेश हेडर](/docs/core/transactions#message-header): हस्ताक्षरकर्ता और
  केवल-पठनीय अकाउंट की संख्या निर्दिष्ट करता है।
- [अकाउंट पते](/docs/core/transactions#array-of-account-addresses): ट्रांजैक्शन
  पर निर्देशों द्वारा आवश्यक अकाउंट पतों की एक सरणी।
- [हालिया ब्लॉकहैश](/docs/core/transactions#recent-blockhash): ट्रांजैक्शन के
  लिए एक टाइमस्टैम्प के रूप में कार्य करता है।
- [निर्देश](/docs/core/transactions#array-of-instructions): निष्पादित किए जाने
  वाले निर्देशों की एक सरणी।

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    pub instructions: Vec<CompiledInstruction>,
}
```

![ट्रांजैक्शन संदेश](/assets/docs/core/transactions/legacy_message.png)

### ट्रांजैक्शन आकार

Solana ट्रांजैक्शन का आकार सीमा
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
बाइट्स है। यह सीमा IPv6 अधिकतम ट्रांसमिशन यूनिट (MTU) आकार से आती है 1280
बाइट्स, जिसमें से नेटवर्क हेडर्स के लिए 48 बाइट्स (40 बाइट्स IPv6 + 8 बाइट्स
फ्रैगमेंट हेडर) कम किए गए हैं।

एक ट्रांजैक्शन का कुल आकार (हस्ताक्षर और संदेश) इस सीमा से कम रहना चाहिए और
इसमें शामिल है:

- हस्ताक्षर: प्रत्येक 64 बाइट्स
- संदेश: हेडर (3 बाइट्स), अकाउंट कीज़ (प्रत्येक 32 बाइट्स), हालिया ब्लॉकहैश (32
  बाइट्स), और निर्देश

![ट्रांजैक्शन फॉर्मेट](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### संदेश हेडर

[संदेश हेडर](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
अकाउंट विशेषाधिकारों को परिभाषित करने के लिए तीन बाइट्स का उपयोग करता है।

1. आवश्यक हस्ताक्षर
2. केवल-पठनीय हस्ताक्षरित अकाउंट्स की संख्या
3. केवल-पठनीय गैर-हस्ताक्षरित अकाउंट्स की संख्या

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    pub num_readonly_unsigned_accounts: u8,
}
```

![संदेश हेडर](/assets/docs/core/transactions/message_header.png)

### कॉम्पैक्ट-एरे फॉर्मेट

ट्रांजैक्शन संदेश में एक कॉम्पैक्ट एरे निम्न प्रारूप में सीरियलाइज़ किया गया एक
एरे है:

1. एरे की लंबाई
   ([compact-u16](https://github.com/anza-xyz/agave/blob/v2.1.13/short-vec/src/lib.rs)
   के रूप में एनकोडेड)
2. एरे आइटम एक के बाद एक सूचीबद्ध

![कॉम्पैक्ट एरे फॉर्मेट](/assets/docs/core/transactions/compact_array_format.png)

इस प्रारूप का उपयोग ट्रांजैक्शन संदेशों में
[अकाउंट एड्रेस](/docs/core/transactions#array-of-account-addresses) और
[instructions](/docs/core/transactions#array-of-instructions) एरे की लंबाई को
एनकोड करने के लिए किया जाता है।

### अकाउंट एड्रेस का एरे

एक ट्रांजैक्शन संदेश में
[अकाउंट एड्रेस](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
का एक एरे होता है जो उसके instructions के लिए आवश्यक होता है। एरे एक
[compact-u16](/docs/core/transactions#compact-array-format) संख्या से शुरू होता
है जो बताता है कि इसमें कितने एड्रेस हैं। फिर एड्रेस को उनके विशेषाधिकारों के
अनुसार क्रमबद्ध किया जाता है, जैसा कि संदेश हेडर द्वारा निर्धारित किया गया है।

- अकाउंट जो राइटेबल और साइनर हैं
- अकाउंट जो रीड-ओनली और साइनर हैं
- अकाउंट जो राइटेबल हैं और साइनर नहीं हैं
- अकाउंट जो रीड-ओनली हैं और साइनर नहीं हैं

![अकाउंट एड्रेस का कॉम्पैक्ट एरे](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### हालिया ब्लॉकहैश

प्रत्येक ट्रांजैक्शन के लिए एक
[हालिया ब्लॉकहैश](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L141)
की आवश्यकता होती है जो दो उद्देश्यों की पूर्ति करता है:

1. टाइमस्टैम्प के रूप में कार्य करता है
2. डुप्लिकेट ट्रांजैक्शन को रोकता है

एक ब्लॉकहैश
[150](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)
ब्लॉक्स (400ms ब्लॉक टाइम मानते हुए लगभग 1 मिनट) के बाद समाप्त हो जाता है, जिसके
बाद ट्रांजैक्शन को प्रोसेस नहीं किया जा सकता।

आप वर्तमान ब्लॉकहैश और अंतिम ब्लॉक ऊंचाई प्राप्त करने के लिए
[`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) RPC मेथड का उपयोग कर
सकते हैं, जिस पर ब्लॉकहैश वैध होगा। यहां
[Solana Playground](https://beta.solpg.io/661a06e1cffcf4b13384d046) पर एक उदाहरण
है।

### instructions का एरे

एक ट्रांजैक्शन संदेश में
[CompiledInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
प्रकार में
[instructions](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
का एक एरे होता है। जब instructions को ट्रांजैक्शन में जोड़ा जाता है, तो उन्हें
इस प्रकार में परिवर्तित किया जाता है।

संदेश में अकाउंट एड्रेस एरे की तरह, यह एक
[compact-u16](/docs/core/transactions#compact-array-format) लंबाई से शुरू होता
है, उसके बाद instruction डेटा आता है। प्रत्येक instruction में शामिल होता है:

1. प्रोग्राम ID इंडेक्स: एक u8 इंडेक्स जो खाता पतों की सरणी में प्रोग्राम के पते
   की ओर इशारा करता है। यह उस प्रोग्राम को निर्दिष्ट करता है जो निर्देश को
   संसाधित करेगा।
2. खाता इंडेक्स: u8 इंडेक्स की एक सरणी जो इस निर्देश के लिए आवश्यक खाता पतों की
   ओर इशारा करती है।
3. instruction data: एक बाइट सरणी जो निर्दिष्ट करती है कि प्रोग्राम पर कौन सा
   निर्देश लागू करना है और निर्देश द्वारा आवश्यक कोई अतिरिक्त डेटा (जैसे फ़ंक्शन
   आर्गुमेंट्स)।

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    pub data: Vec<u8>,
}
```

![निर्देशों की कॉम्पैक्ट सरणी](/assets/docs/core/transactions/compact_array_of_ixs.png)

### उदाहरण लेनदेन संरचना

एकल SOL ट्रांसफर निर्देश वाले लेनदेन की संरचना देखने के लिए नीचे दिए गए उदाहरणों
को चलाएँ।

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, signature::Signer,
    signer::keypair::Keypair, system_instruction, transaction::Transaction,
};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = system_instruction::transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

निम्नलिखित उदाहरण पिछले कोड स्निपेट से लेनदेन संदेश आउटपुट दिखाते हैं। सटीक
प्रारूप SDK के आधार पर भिन्न होता है, लेकिन इसमें समान जानकारी शामिल होती है।

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>

जब आप इसे नेटवर्क पर भेजने के बाद इसके हस्ताक्षर का उपयोग करके लेनदेन प्राप्त
करते हैं, तो आपको निम्न संरचना के साथ एक प्रतिक्रिया प्राप्त होगी।

`message` फ़ील्ड में निम्नलिखित फ़ील्ड शामिल हैं:

- `header`: `accountKeys` सरणी में पतों के लिए पढ़ने/लिखने और हस्ताक्षरकर्ता
  विशेषाधिकार निर्दिष्ट करता है

- `accountKeys`: लेनदेन के निर्देशों में उपयोग किए गए सभी खाता पतों की सरणी

- `recentBlockhash`: लेनदेन को टाइमस्टैम्प करने के लिए उपयोग किया गया ब्लॉकहैश

- `instructions`: निष्पादित करने के लिए निर्देशों की सरणी। प्रत्येक निर्देश में
  `account` और `programIdIndex` इंडेक्स द्वारा `accountKeys` सरणी को संदर्भित
  करते हैं।

- `signatures`: उन सभी खातों के लिए हस्ताक्षर शामिल करने वाली सरणी जिन्हें
  लेनदेन पर निर्देशों द्वारा हस्ताक्षरकर्ता के रूप में आवश्यक है। हस्ताक्षर किसी
  खाते के लिए संबंधित निजी कुंजी का उपयोग करके लेनदेन संदेश पर हस्ताक्षर करके
  बनाया जाता है।

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
