---
title: क्रॉस प्रोग्राम इन्वोकेशन
description:
  सोलाना पर क्रॉस प्रोग्राम इन्वोकेशन (CPI) के बारे में जानें - कैसे प्रोग्राम
  दूसरे प्रोग्रामों पर निर्देशों को कॉल कर सकते हैं, PDA हस्ताक्षरकर्ताओं को
  संभाल सकते हैं, और सोलाना नेटवर्क पर कार्यक्षमता को संयोजित कर सकते हैं।
h1: क्रॉस प्रोग्राम इन्वोकेशन (CPI)
---

क्रॉस प्रोग्राम इन्वोकेशन (CPI) तब होता है जब एक प्रोग्राम दूसरे प्रोग्राम के
निर्देशों को आमंत्रित करता है। यह सोलाना प्रोग्रामों की संयोजनीयता की अनुमति
देता है।

आप निर्देशों को API एंडपॉइंट्स के रूप में सोच सकते हैं जिन्हें एक प्रोग्राम
नेटवर्क के लिए प्रदर्शित करता है और CPI को एक API के रूप में जो आंतरिक रूप से
दूसरे API को आमंत्रित करता है।

![क्रॉस प्रोग्राम इन्वोकेशन](/assets/docs/core/cpi/cpi.svg)

## मुख्य बिंदु

- **क्रॉस प्रोग्राम इन्वोकेशन** सोलाना प्रोग्राम निर्देशों को सीधे दूसरे
  प्रोग्राम पर निर्देश आमंत्रित करने की अनुमति देता है।
- कॉलर प्रोग्राम से **हस्ताक्षरकर्ता विशेषाधिकार** कॉली प्रोग्राम तक विस्तारित
  होते हैं।
- क्रॉस प्रोग्राम इन्वोकेशन करते समय, **प्रोग्राम अपने स्वयं के प्रोग्राम आईडी
  से व्युत्पन्न PDAs की ओर से हस्ताक्षर कर सकते हैं**।
- कॉली प्रोग्राम अन्य प्रोग्रामों के लिए आगे CPIs बना सकता है, 4 की गहराई तक।

## CPI क्या है?

क्रॉस प्रोग्राम इन्वोकेशन (CPI) तब होता है जब एक प्रोग्राम दूसरे प्रोग्राम के
निर्देशों को आमंत्रित करता है।

CPI के साथ एक प्रोग्राम निर्देश लिखना उसी पैटर्न का अनुसरण करता है जैसे
[निर्देश](/docs/core/transactions#instruction) को लेनदेन में जोड़ने के लिए
बनाना। अंदर से, प्रत्येक CPI निर्देश को निर्दिष्ट करना चाहिए:

- **प्रोग्राम पता**: आमंत्रित करने के लिए प्रोग्राम निर्दिष्ट करता है
- **खाते**: हर खाते को सूचीबद्ध करता है जिससे निर्देश पढ़ता है या लिखता है, अन्य
  प्रोग्रामों सहित
- **निर्देश डेटा**: निर्दिष्ट करता है कि प्रोग्राम पर कौन सा निर्देश आमंत्रित
  करना है, साथ ही कोई भी डेटा जो निर्देश को आवश्यक है (फ़ंक्शन आर्गुमेंट्स)

जब कोई प्रोग्राम दूसरे प्रोग्राम को क्रॉस प्रोग्राम इन्वोकेशन (CPI) करता है:

- प्रारंभिक लेनदेन से हस्ताक्षरकर्ता विशेषाधिकार कॉली प्रोग्राम तक विस्तारित
  होते हैं (उदाहरण A->B)
- कॉली प्रोग्राम अन्य प्रोग्रामों के लिए आगे CPIs बना सकता है, 4 की गहराई तक
  (उदाहरण B->C, C->D)
- प्रोग्राम अपने प्रोग्राम आईडी से व्युत्पन्न [PDAs](/docs/core/pda) की ओर से
  "हस्ताक्षर" कर सकते हैं

<Callout>
  सोलाना प्रोग्राम रनटाइम एक
  [`max_instruction_stack_depth`](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L38)
  स्थिरांक
  [MAX_INSTRUCTION_STACK_DEPTH](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L13)
  5 का सेट करता है। यह प्रोग्राम निर्देश आमंत्रण स्टैक की अधिकतम ऊंचाई का प्रतिनिधित्व करता है।
  स्टैक की ऊंचाई प्रारंभिक लेनदेन के लिए 1 से शुरू होती है और हर बार जब कोई प्रोग्राम दूसरे
  निर्देश को आमंत्रित करता है तो 1 बढ़ जाती है। यह सेटिंग CPIs के लिए आमंत्रण की गहराई को 4 तक
  सीमित करती है।
</Callout>

जब कोई लेनदेन प्रोसेस किया जाता है, तो खाता विशेषाधिकार एक प्रोग्राम से दूसरे
प्रोग्राम तक विस्तारित होते हैं। इसका मतलब यह है:

मान लीजिए प्रोग्राम A को एक निर्देश प्राप्त होता है जिसमें:

- एक खाता जिसने लेनदेन पर हस्ताक्षर किए
- एक खाता जिसमें लिखा जा सकता है (परिवर्तनीय)

जब प्रोग्राम A प्रोग्राम B को CPI करता है:

- प्रोग्राम B को इन्हीं खातों को उनकी मूल अनुमतियों के साथ उपयोग करने की अनुमति
  मिलती है
- प्रोग्राम B हस्ताक्षरकर्ता खाते के साथ हस्ताक्षर कर सकता है
- प्रोग्राम B लिखने योग्य खाते में लिख सकता है
- प्रोग्राम B इन्हीं अनुमतियों को आगे भी पास कर सकता है अगर यह अपना स्वयं का CPI
  बनाता है

## क्रॉस प्रोग्राम इनवोकेशन्स

[`invoke`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/program.rs#L26-L28)

फंक्शन उन CPIs को संभालता है जिन्हें PDA हस्ताक्षरकर्ताओं की आवश्यकता नहीं होती।
यह फंक्शन `invoke_signed` फंक्शन को खाली `signers_seeds` ऐरे के साथ कॉल करता है,
जो इंगित करता है कि हस्ताक्षर के लिए कोई PDAs आवश्यक नहीं हैं।

```rust title="Invoke Function"
pub fn invoke(instruction: &Instruction, account_infos: &[AccountInfo]) -> ProgramResult {
    invoke_signed(instruction, account_infos, &[])
}
```

निम्नलिखित उदाहरण दिखाते हैं कि
[Anchor Framework](https://www.anchor-lang.com/docs) और नेटिव रस्ट का उपयोग करके
CPI कैसे बनाया जाए। उदाहरण प्रोग्राम में एक सिंगल इंस्ट्रक्शन शामिल है जो CPI का
उपयोग करके एक खाते से दूसरे खाते में SOL ट्रांसफर करता है।

### एंकर फ्रेमवर्क

निम्नलिखित उदाहरण एंकर प्रोग्राम में क्रॉस प्रोग्राम इनवोकेशन्स (CPIs) बनाने के
तीन तरीके प्रस्तुत करते हैं, प्रत्येक अलग-अलग स्तर के अमूर्तीकरण पर। सभी उदाहरण
एक ही तरह से काम करते हैं। मुख्य उद्देश्य CPI के कार्यान्वयन विवरण दिखाना है।

- उदाहरण 1: CPI इंस्ट्रक्शन बनाने के लिए एंकर के _rs`CpiContext`_ और हेल्पर
  फंक्शन का उपयोग करता है।
- उदाहरण 2: CPI इंस्ट्रक्शन बनाने के लिए `solana_program` क्रेट से
  _rs`system_instruction::transfer`_ फंक्शन का उपयोग करता है। उदाहरण 1 इस
  कार्यान्वयन को अमूर्त करता है।
- उदाहरण 3: CPI इंस्ट्रक्शन को मैन्युअली बनाता है। यह दृष्टिकोण तब उपयोगी होता
  है जब इंस्ट्रक्शन बनाने में मदद के लिए कोई क्रेट मौजूद नहीं होता।

<CodeTabs>

```rs !! title="Example 1"
use anchor_lang::prelude::*;
use anchor_lang::system_program::{transfer, Transfer};

declare_id!("9AvUNHjxscdkiKQ8tUn12QCMXtcnbR9BVGq3ULNzFMRi");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let cpi_context = CpiContext::new(
            program_id,
            Transfer {
                from: from_pubkey,
                to: to_pubkey,
            },
        );

        transfer(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Example 2"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke, system_instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let instruction =
            &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

        invoke(instruction, &[from_pubkey, to_pubkey, program_id])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Example 3"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke, instruction::Instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        // Prepare instruction AccountMetas
        let account_metas = vec![
            AccountMeta::new(from_pubkey.key(), true),
            AccountMeta::new(to_pubkey.key(), false),
        ];

        // SOL transfer instruction discriminator
        let instruction_discriminator: u32 = 2;

        // Prepare instruction data
        let mut instruction_data = Vec::with_capacity(4 + 8);
        instruction_data.extend_from_slice(&instruction_discriminator.to_le_bytes());
        instruction_data.extend_from_slice(&amount.to_le_bytes());

        // Create instruction
        let instruction = Instruction {
            program_id: program_id.key(),
            accounts: account_metas,
            data: instruction_data,
        };

        // Invoke instruction
        invoke(&instruction, &[from_pubkey, to_pubkey, program_id])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```ts !! title="Test"
import * as anchor from "@coral-xyz/anchor";
import { BN, Program } from "@coral-xyz/anchor";
import { Cpi } from "../target/types/cpi";
import { Keypair, LAMPORTS_PER_SOL } from "@solana/web3.js";

describe("cpi", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Cpi as Program<Cpi>;
  const sender = provider.wallet as anchor.Wallet;
  const recipient = new Keypair();

  const transferAmount = 0.01 * LAMPORTS_PER_SOL;

  it("SOL Transfer Anchor", async () => {
    const transactionSignature = await program.methods
      .solTransfer(new BN(transferAmount))
      .accounts({
        sender: sender.publicKey,
        recipient: recipient.publicKey
      })
      .rpc();

    console.log(`\nTransaction Signature: ${transactionSignature}`);
  });
});
```

</CodeTabs>

### नेटिव रस्ट

निम्नलिखित उदाहरण दिखाता है कि नेटिव रस्ट में लिखे गए प्रोग्राम से CPI कैसे
बनाया जाए। प्रोग्राम में एक सिंगल इंस्ट्रक्शन शामिल है जो CPI का उपयोग करके एक
अकाउंट से दूसरे अकाउंट में SOL ट्रांसफर करता है। टेस्ट फाइल प्रोग्राम का परीक्षण
करने के लिए [LiteSVM](https://github.com/LiteSVM/litesvm) का उपयोग करती है।

<CodeTabs>

```rs !! title="Example"
use borsh::BorshDeserialize;
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
};

// Declare program entrypoint
entrypoint!(process_instruction);

// Define program instructions
#[derive(BorshDeserialize)]
enum ProgramInstruction {
    SolTransfer { amount: u64 },
}

impl ProgramInstruction {
    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        Self::try_from_slice(input).map_err(|_| ProgramError::InvalidInstructionData)
    }
}

pub fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Deserialize instruction data
    let instruction = ProgramInstruction::unpack(instruction_data)?;

    // Process instruction
    match instruction {
        ProgramInstruction::SolTransfer { amount } => {
            // Parse accounts
            let [sender_info, recipient_info, system_program_info] = accounts else {
                return Err(ProgramError::NotEnoughAccountKeys);
            };

            // Verify the sender is a signer
            if !sender_info.is_signer {
                return Err(ProgramError::MissingRequiredSignature);
            }

            // Create and invoke the transfer instruction
            let transfer_ix = system_instruction::transfer(
                sender_info.key,
                recipient_info.key,
                amount,
            );

            invoke(
                &transfer_ix,
                &[
                    sender_info.clone(),
                    recipient_info.clone(),
                    system_program_info.clone(),
                ],
            )?;

            Ok(())
        }
    }
}
```

```ts !! title="Test"
import * as path from "path";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from "@solana/web3.js";
import { LiteSVM } from "litesvm";

test("sol transfer cpi", () => {
  const svm = new LiteSVM();

  const programId = PublicKey.unique();
  const programPath = path.join(__dirname, "program.so");
  svm.addProgramFromFile(programId, programPath);

  // Create sender and recipient
  const sender = new Keypair();
  const recipient = new Keypair();

  // Fund sender
  const amount = BigInt(LAMPORTS_PER_SOL);
  svm.airdrop(sender.publicKey, amount); // 1 SOL

  // Create instruction data buffer
  const transferAmount = amount / BigInt(2); // 0.5 SOL
  const instructionIndex = 0; // instruction index 0 for SolTransfer enum

  const data = Buffer.alloc(9); // 1 byte for instruction enum + 8 bytes for u64
  data.writeUInt8(instructionIndex, 0); // first byte identifies the instruction
  data.writeBigUInt64LE(transferAmount, 1); // remaining bytes are instruction arguments

  // Create instruction
  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: sender.publicKey, isSigner: true, isWritable: true },
      { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ],
    data
  });

  // Create and send transaction
  const transaction = new Transaction().add(instruction);
  transaction.recentBlockhash = svm.latestBlockhash();
  transaction.sign(sender);

  svm.sendTransaction(transaction);

  // Check balances
  const recipientBalance = svm.getBalance(recipient.publicKey);
  const senderBalance = svm.getBalance(sender.publicKey);

  const transactionFee = BigInt(5000);
  expect(recipientBalance).toBe(transferAmount);
  expect(senderBalance).toBe(amount - transferAmount - transactionFee);
});
```

</CodeTabs>

## PDA हस्ताक्षरकर्ताओं के साथ क्रॉस प्रोग्राम इनवोकेशन

[`invoke_signed`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/program.rs#L51-L73)

फंक्शन उन CPIs को संभालता है जिन्हें PDA हस्ताक्षरकर्ताओं की आवश्यकता होती है।
यह फंक्शन हस्ताक्षरकर्ता PDAs को प्राप्त करने के लिए बीजों को `signer_seeds` के
रूप में लेता है।

आप PDAs को प्राप्त करने के तरीके के विवरण के लिए
[प्रोग्राम डेराइव्ड एड्रेस](/docs/core/pda) पेज का संदर्भ ले सकते हैं।

```rust title="Invoke Signed"
pub fn invoke_signed(
    instruction: &Instruction,
    account_infos: &[AccountInfo],
    signers_seeds: &[&[&[u8]]],
) -> ProgramResult {
    // --snip--
    invoke_signed_unchecked(instruction, account_infos, signers_seeds)
}
```

जब एक ऐसे निर्देश को संसाधित किया जाता है जिसमें CPI शामिल होता है, तो सोलाना
रनटाइम आंतरिक रूप से

[`create_program_address`](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/syscalls/cpi.rs#L552)

को `signers_seeds` और कॉलिंग प्रोग्राम के `program_id` का उपयोग करके कॉल करता
है। जब एक वैध PDA सत्यापित होता है, तो पता
[एक वैध हस्ताक्षरकर्ता के रूप में जोड़ा जाता है](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/syscalls/cpi.rs#L554)।

निम्नलिखित उदाहरण दिखाते हैं कि
[Anchor Framework](https://www.anchor-lang.com/docs) और नेटिव रस्ट का उपयोग करके
PDA हस्ताक्षरकर्ताओं के साथ CPI कैसे बनाया जाए। उदाहरण प्रोग्रामों में एक एकल
निर्देश शामिल है जो PDA द्वारा हस्ताक्षरित CPI का उपयोग करके PDA से प्राप्तकर्ता
खाते में SOL स्थानांतरित करता है।

### Anchor Framework

निम्नलिखित उदाहरणों में एंकर प्रोग्राम में क्रॉस प्रोग्राम इनवोकेशन (CPIs) को
लागू करने के तीन दृष्टिकोण शामिल हैं, प्रत्येक अलग-अलग स्तर के अमूर्तीकरण पर।
सभी उदाहरण कार्यात्मक रूप से समान हैं। मुख्य उद्देश्य CPI के कार्यान्वयन विवरणों
को चित्रित करना है।

- उदाहरण 1: एंकर के _rs`CpiContext`_ और हेल्पर फंक्शन का उपयोग CPI निर्देश बनाने
  के लिए करता है।
- उदाहरण 2: CPI निर्देश बनाने के लिए `solana_program` क्रेट से
  _rs`system_instruction::transfer`_ फंक्शन का उपयोग करता है। उदाहरण 1 इस
  कार्यान्वयन का एक अमूर्तीकरण है।
- उदाहरण 3: CPI निर्देश को मैन्युअल रूप से बनाता है। यह दृष्टिकोण तब उपयोगी होता
  है जब आप जिस निर्देश को इनवोक करना चाहते हैं, उसे बनाने में मदद करने के लिए
  कोई क्रेट उपलब्ध नहीं है।

<CodeTabs>

```rs !! title="Example 1"
use anchor_lang::prelude::*;
use anchor_lang::system_program::{transfer, Transfer};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;
        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        let cpi_context = CpiContext::new(
            program_id,
            Transfer {
                from: from_pubkey,
                to: to_pubkey,
            },
        )
        .with_signer(signer_seeds);

        transfer(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Example 2"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke_signed, system_instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;

        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        let instruction =
            &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

        invoke_signed(instruction, &[from_pubkey, to_pubkey, program_id], signer_seeds)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Example 3"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke_signed, instruction::{Instruction, AccountMeta}};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        // Get PDA signer seeds
        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;
        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        // Prepare instruction AccountMetas
        let account_metas = vec![
            AccountMeta::new(from_pubkey.key(), true),
            AccountMeta::new(to_pubkey.key(), false),
        ];

        // SOL transfer instruction discriminator
        let instruction_discriminator: u32 = 2;

        // Prepare instruction data
        let mut instruction_data = Vec::with_capacity(4 + 8);
        instruction_data.extend_from_slice(&instruction_discriminator.to_le_bytes());
        instruction_data.extend_from_slice(&amount.to_le_bytes());

        // Create instruction
        let instruction = Instruction {
            program_id: program_id.key(),
            accounts: account_metas,
            data: instruction_data,
        };

        // Invoke instruction with PDA signer
        invoke_signed(&instruction, &[from_pubkey, to_pubkey, program_id], signer_seeds)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```ts !! title="Test"
import * as anchor from "@coral-xyz/anchor";

import { BN, Program } from "@coral-xyz/anchor";
import { LAMPORTS_PER_SOL, PublicKey } from "@solana/web3.js";

import { Cpi } from "../target/types/cpi";

describe("cpi", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Cpi as Program<Cpi>;
  const connection = program.provider.connection;
  const wallet = provider.wallet as anchor.Wallet;

  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("pda"), wallet.publicKey.toBuffer()],
    program.programId
  );

  const transferAmount = 0.1 * LAMPORTS_PER_SOL;

  before(async () => {
    // Request airdrop to fund PDA
    const signature = await connection.requestAirdrop(PDA, transferAmount);

    const { blockhash, lastValidBlockHeight } =
      await connection.getLatestBlockhash();

    await connection.confirmTransaction({
      signature,
      blockhash,
      lastValidBlockHeight
    });
  });

  it("SOL Transfer with PDA signer", async () => {
    const transactionSignature = await program.methods
      .solTransfer(new BN(transferAmount))
      .accounts({
        recipient: wallet.publicKey
      })
      .rpc();

    console.log(`\nTransaction Signature: ${transactionSignature}`);
  });
});
```

</CodeTabs>

### नेटिव रस्ट

निम्नलिखित उदाहरण दिखाता है कि नेटिव रस्ट में लिखे गए प्रोग्राम से PDA
हस्ताक्षरकर्ताओं के साथ CPI कैसे बनाया जाए। प्रोग्राम में एक ही निर्देश शामिल है
जो PDA द्वारा हस्ताक्षरित CPI का उपयोग करके PDA से प्राप्तकर्ता खाते में SOL
स्थानांतरित करता है। टेस्ट फ़ाइल प्रोग्राम का परीक्षण करने के लिए
[LiteSVM](https://github.com/LiteSVM/litesvm) का उपयोग करती है।

<CodeTabs>

```rs !! title="Example"
use borsh::BorshDeserialize;
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke_signed,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
};

// Declare program entrypoint
entrypoint!(process_instruction);

// Define program instructions
#[derive(BorshDeserialize)]
enum ProgramInstruction {
    SolTransfer { amount: u64 },
}

impl ProgramInstruction {
    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        Self::try_from_slice(input).map_err(|_| ProgramError::InvalidInstructionData)
    }
}

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Deserialize instruction data
    let instruction = ProgramInstruction::unpack(instruction_data)?;

    // Process instruction
    match instruction {
        ProgramInstruction::SolTransfer { amount } => {
            // Parse accounts
            let [pda_account_info, recipient_info, system_program_info] = accounts else {
                return Err(ProgramError::NotEnoughAccountKeys);
            };

            // Derive PDA and verify it matches the account provided by client
            let recipient_pubkey = recipient_info.key;
            let seeds = &[b"pda", recipient_pubkey.as_ref()];
            let (expected_pda, bump_seed) = Pubkey::find_program_address(seeds, program_id);

            if expected_pda != *pda_account_info.key {
                return Err(ProgramError::InvalidArgument);
            }

            // Create the transfer instruction
            let transfer_ix = system_instruction::transfer(
                pda_account_info.key,
                recipient_info.key,
                amount,
            );

            // Create signer seeds for PDA
            let signer_seeds: &[&[&[u8]]] = &[&[b"pda", recipient_pubkey.as_ref(), &[bump_seed]]];

            // Invoke the transfer instruction with PDA as signer
            invoke_signed(
                &transfer_ix,
                &[
                    pda_account_info.clone(),
                    recipient_info.clone(),
                    system_program_info.clone(),
                ],
                signer_seeds,
            )?;

            Ok(())
        }
    }
}
```

```ts !! title="Test"
import * as path from "path";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from "@solana/web3.js";
import { LiteSVM } from "litesvm";

test("sol transfer cpi with pda signer", () => {
  const svm = new LiteSVM();

  const programId = PublicKey.unique();
  const programPath = path.join(__dirname, "program.so");
  svm.addProgramFromFile(programId, programPath);

  // Create recipient
  const recipient = new Keypair();

  // Derive PDA that will hold and send funds
  const [pdaAddress] = PublicKey.findProgramAddressSync(
    [Buffer.from("pda"), recipient.publicKey.toBuffer()],
    programId
  );

  // Fund accounts
  const amount = BigInt(LAMPORTS_PER_SOL);
  svm.airdrop(recipient.publicKey, amount); // 1 SOL
  svm.airdrop(pdaAddress, amount); // 1 SOL

  // Create instruction data buffer
  const transferAmount = amount / BigInt(2); // 0.5 SOL
  const instructionIndex = 0; // instruction index 0 for SolTransfer enum

  const data = Buffer.alloc(9); // 1 byte for instruction enum + 8 bytes for u64
  data.writeUInt8(instructionIndex, 0); // first byte identifies the instruction
  data.writeBigUInt64LE(transferAmount, 1); // remaining bytes are instruction arguments

  // Create instruction
  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: pdaAddress, isSigner: false, isWritable: true },
      { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ],
    data
  });

  // Create and send transaction
  const transaction = new Transaction().add(instruction);
  transaction.recentBlockhash = svm.latestBlockhash();
  transaction.sign(recipient);

  svm.sendTransaction(transaction);

  // Check balances
  const recipientBalance = svm.getBalance(recipient.publicKey);
  const pdaBalance = svm.getBalance(pdaAddress);

  const transactionFee = BigInt(5000);
  // Recipient starts with 1 SOL, receives 0.5 SOL, pays tx fee
  expect(recipientBalance).toBe(amount + transferAmount - transactionFee);
  // PDA starts with 1 SOL, sends 0.5 SOL
  expect(pdaBalance).toBe(amount - transferAmount);
});
```

</CodeTabs>

### नेटिव रस्ट

निम्नलिखित उदाहरण दिखाता है कि नेटिव रस्ट में लिखे गए प्रोग्राम से PDA साइनर्स
के साथ CPI कैसे बनाया जाए। प्रोग्राम में एक सिंगल इंस्ट्रक्शन शामिल है जो PDA
द्वारा हस्ताक्षरित CPI का उपयोग करके PDA से प्राप्तकर्ता अकाउंट में SOL ट्रांसफर
करता है। टेस्ट फाइल प्रोग्राम का परीक्षण करने के लिए
[LiteSVM](https://github.com/LiteSVM/litesvm) का उपयोग करती है।

<CodeTabs>

```rs !! title="Example"
use borsh::BorshDeserialize;
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke_signed,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
};

// Declare program entrypoint
entrypoint!(process_instruction);

// Define program instructions
#[derive(BorshDeserialize)]
enum ProgramInstruction {
    SolTransfer { amount: u64 },
}

impl ProgramInstruction {
    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        Self::try_from_slice(input).map_err(|_| ProgramError::InvalidInstructionData)
    }
}

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Deserialize instruction data
    let instruction = ProgramInstruction::unpack(instruction_data)?;

    // Process instruction
    match instruction {
        ProgramInstruction::SolTransfer { amount } => {
            // Parse accounts
            let [pda_account_info, recipient_info, system_program_info] = accounts else {
                return Err(ProgramError::NotEnoughAccountKeys);
            };

            // Derive PDA and verify it matches the account provided by client
            let recipient_pubkey = recipient_info.key;
            let seeds = &[b"pda", recipient_pubkey.as_ref()];
            let (expected_pda, bump_seed) = Pubkey::find_program_address(seeds, program_id);

            if expected_pda != *pda_account_info.key {
                return Err(ProgramError::InvalidArgument);
            }

            // Create the transfer instruction
            let transfer_ix = system_instruction::transfer(
                pda_account_info.key,
                recipient_info.key,
                amount,
            );

            // Create signer seeds for PDA
            let signer_seeds: &[&[&[u8]]] = &[&[b"pda", recipient_pubkey.as_ref(), &[bump_seed]]];

            // Invoke the transfer instruction with PDA as signer
            invoke_signed(
                &transfer_ix,
                &[
                    pda_account_info.clone(),
                    recipient_info.clone(),
                    system_program_info.clone(),
                ],
                signer_seeds,
            )?;

            Ok(())
        }
    }
}
```

```ts !! title="Test"
import * as path from "path";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from "@solana/web3.js";
import { LiteSVM } from "litesvm";

test("sol transfer cpi with pda signer", () => {
  const svm = new LiteSVM();

  const programId = PublicKey.unique();
  const programPath = path.join(__dirname, "program.so");
  svm.addProgramFromFile(programId, programPath);

  // Create recipient
  const recipient = new Keypair();

  // Derive PDA that will hold and send funds
  const [pdaAddress] = PublicKey.findProgramAddressSync(
    [Buffer.from("pda"), recipient.publicKey.toBuffer()],
    programId
  );

  // Fund accounts
  const amount = BigInt(LAMPORTS_PER_SOL);
  svm.airdrop(recipient.publicKey, amount); // 1 SOL
  svm.airdrop(pdaAddress, amount); // 1 SOL

  // Create instruction data buffer
  const transferAmount = amount / BigInt(2); // 0.5 SOL
  const instructionIndex = 0; // instruction index 0 for SolTransfer enum

  const data = Buffer.alloc(9); // 1 byte for instruction enum + 8 bytes for u64
  data.writeUInt8(instructionIndex, 0); // first byte identifies the instruction
  data.writeBigUInt64LE(transferAmount, 1); // remaining bytes are instruction arguments

  // Create instruction
  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: pdaAddress, isSigner: false, isWritable: true },
      { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ],
    data
  });

  // Create and send transaction
  const transaction = new Transaction().add(instruction);
  transaction.recentBlockhash = svm.latestBlockhash();
  transaction.sign(recipient);

  svm.sendTransaction(transaction);

  // Check balances
  const recipientBalance = svm.getBalance(recipient.publicKey);
  const pdaBalance = svm.getBalance(pdaAddress);

  const transactionFee = BigInt(5000);
  // Recipient starts with 1 SOL, receives 0.5 SOL, pays tx fee
  expect(recipientBalance).toBe(amount + transferAmount - transactionFee);
  // PDA starts with 1 SOL, sends 0.5 SOL
  expect(pdaBalance).toBe(amount - transferAmount);
});
```

</CodeTabs>
