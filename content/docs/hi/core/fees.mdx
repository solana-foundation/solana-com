---
title: लेनदेन शुल्क
description:
  Solana के लेनदेन शुल्क के बारे में जानें, जिसमें आधार और प्राथमिकता शुल्क,
  प्रत्येक को कैसे लागू किया जाता है, और अपने लेनदेन में कंप्यूट यूनिट्स के
  प्रबंधन के लिए सर्वोत्तम प्रथाएं शामिल हैं।
---

हर Solana लेनदेन के लिए लेनदेन को संसाधित करने के लिए validators को मुआवजा देने
के लिए एक आधार शुल्क (SOL) की आवश्यकता होती है। आप अपने लेनदेन को वर्तमान लीडर
(validator) द्वारा संसाधित करने की संभावना बढ़ाने के लिए एक वैकल्पिक प्राथमिकता
शुल्क भी दे सकते हैं।

## प्रमुख बिंदु

- लेनदेन के लिए **आधार शुल्क** लेनदेन पर प्रति हस्ताक्षर 5000 lamport है।
- **प्राथमिकता शुल्क** (वैकल्पिक) एक अतिरिक्त शुल्क है जो आप validator को अपने
  लेनदेन को वर्तमान लीडर द्वारा संसाधित करने की संभावना बढ़ाने के लिए देते हैं।
- प्राथमिकता शुल्क बराबर होता है: **(कंप्यूट यूनिट सीमा \* कंप्यूट यूनिट
  मूल्य)**।
- **कंप्यूट यूनिट सीमा** अधिकतम कंप्यूट यूनिट्स है जो आपका लेनदेन उपयोग कर सकता
  है।
- **कंप्यूट यूनिट मूल्य** माइक्रो-lamport में प्रति कंप्यूट यूनिट का मूल्य है।
- 1,000,000 माइक्रो lamport = 1 lamport
- लेनदेन शुल्क भुगतानकर्ता को System Program के स्वामित्व वाला खाता होना चाहिए।

## आधार लेनदेन शुल्क

आधार शुल्क लेनदेन भेजने की लागत है। लागत लेनदेन में शामिल प्रति हस्ताक्षर 5000
lamport है।

आधार शुल्क लेनदेन शुल्क भुगतानकर्ता के खाते से निकलता है, जो लेनदेन पर पहला
हस्ताक्षरकर्ता है। शुल्क भुगतानकर्ता को System Program के स्वामित्व वाला खाता
होना चाहिए।

- [50% जलाया गया](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70):
  आधार शुल्क का आधा हिस्सा जला दिया जाता है।
- [50% वितरण](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62):
  आधा उस validator को भुगतान किया जाता है जिसने लेनदेन को संसाधित किया।

## प्राथमिकता शुल्क

प्राथमिकता शुल्क एक वैकल्पिक शुल्क है जो वर्तमान लीडर द्वारा आपके लेनदेन को
संसाधित करने की संभावना बढ़ाने के लिए भुगतान किया जाता है।

- [SIMD-0096](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md):
  लेनदेन को प्रोसेस करने वाला validator प्राथमिकता शुल्क का 100% प्राप्त करता
  है।

### कम्प्यूट यूनिट्स और सीमाएँ

जब एक लेनदेन प्रोसेस किया जाता है, तो यह कम्प्यूट यूनिट्स (CU) में मापे जाने
वाले कम्प्यूटेशनल संसाधनों का उपयोग करता है। प्रत्येक निर्देश लेनदेन के कम्प्यूट
यूनिट बजट से कटौती करता है।

- अधिकतम सीमा: एक लेनदेन अधिकतम
  [1.4 मिलियन कम्प्यूट यूनिट्स](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14)
  का उपयोग कर सकता है।
- डिफ़ॉल्ट सीमा: डिफ़ॉल्ट रूप से, प्रत्येक निर्देश अधिकतम
  [200,000 कम्प्यूट यूनिट्स](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
  का उपयोग कर सकता है।
- कस्टम सीमा: आप अपने लेनदेन में `SetComputeUnitLimit` निर्देश शामिल करके एक
  विशिष्ट कम्प्यूट यूनिट सीमा का अनुरोध कर सकते हैं।

कम्प्यूट यूनिट उपयोग के बारे में अधिक जानकारी के लिए:

- [ComputeBudget](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L22-L130)
- [कम्प्यूट यूनिट उपभोग डिफ़ॉल्ट्स](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197)

कम्प्यूट यूनिट उपयोग के बारे में अधिक जानकारी के लिए
[इष्टतम कम्प्यूट का अनुरोध कैसे करें](/developers/guides/advanced/how-to-request-optimal-compute)
गाइड देखें।

### कम्प्यूट यूनिट मूल्य

कम्प्यूट यूनिट मूल्य एक वैकल्पिक राशि है, जो माइक्रो-lamport में निर्दिष्ट की
जाती है, जिसे आप प्रत्येक अनुरोधित कम्प्यूट यूनिट के लिए भुगतान करते हैं। इस
मूल्य का उपयोग आपके लेनदेन के लिए प्राथमिकता शुल्क की गणना करने के लिए किया जाता
है।

<Callout>1,000,000 माइक्रो lamport = 1 lamport</Callout>

वर्तमान कम्प्यूट यूनिट मूल्य पर रीयल-टाइम अनुशंसाएँ प्राप्त करने के लिए इन
संसाधनों का उपयोग करें:

- Helius द्वारा
  [प्राथमिकता शुल्क API](https://docs.helius.dev/solana-apis/priority-fee-api)
- Triton द्वारा
  [ग्लोबल प्राथमिकता शुल्क ट्रैकर](https://triton.one/solana-prioritization-fees/)

प्राथमिकता शुल्क के बारे में अधिक जानकारी के लिए
[प्राथमिकता शुल्क का उपयोग कैसे करें](/developers/guides/advanced/how-to-use-priority-fees)
गाइड देखें।

### प्राथमिकता शुल्क की गणना

प्राथमिकता शुल्क की गणना इस प्रकार की जाती है:

**प्राथमिकता शुल्क = कम्प्यूट यूनिट सीमा × कम्प्यूट यूनिट मूल्य**

लेनदेन पर कम्प्यूट यूनिट सीमा और मूल्य सेट करने के लिए इन निर्देशों का उपयोग
करें:

- विशिष्ट यूनिट सीमा सेट करने के लिए
  [`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)।
- प्रति कम्प्यूट यूनिट मूल्य परिभाषित करने के लिए
  [`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)।

<Callout>

यदि आप इन निर्देशों को प्रदान नहीं करते हैं, तो लेनदेन डिफ़ॉल्ट कम्प्यूट यूनिट
सीमा का उपयोग करता है, जिसमें कम्प्यूट यूनिट मूल्य 0 होता है (कोई प्राथमिकता
शुल्क नहीं)।

प्राथमिकता शुल्क आपके द्वारा लेनदेन के लिए अनुरोधित कंप्यूट यूनिट सीमा पर निर्भर
करता है, न कि वास्तविक उपयोग किए गए कंप्यूट यूनिट्स पर। यदि आप बहुत अधिक कंप्यूट
यूनिट सीमा सेट करते हैं या डिफ़ॉल्ट राशि का उपयोग करते हैं, तो आप अप्रयुक्त
कंप्यूट यूनिट्स के लिए भुगतान कर सकते हैं।

</Callout>

### उदाहरण

निम्नलिखित उदाहरण दिखाते हैं कि लेनदेन के लिए कंप्यूट यूनिट सीमा और मूल्य कैसे
सेट करें।

| SDK                            | सोर्स कोड संदर्भ                                                                                                               |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    compute_budget::ComputeBudgetInstruction,
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    system_instruction,
    transaction::Transaction,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction =
        system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
