---
title: एकाधिक प्रोग्राम्स का संयोजन
description:
  Anchor फ्रेमवर्क का उपयोग करके Solana प्रोग्राम्स में क्रॉस प्रोग्राम
  इन्वोकेशन (CPIs) को कैसे लागू करें, यह जानें। यह ट्यूटोरियल खातों के बीच SOL
  ट्रांसफर करने, सिस्टम प्रोग्राम के साथ इंटरैक्ट करने, और CPIs में प्रोग्राम
  डिराइव्ड एड्रेसेस (PDAs) को हैंडल करने का प्रदर्शन करता है। कंपोज़ेबल Solana
  प्रोग्राम्स बनाने के इच्छुक डेवलपर्स के लिए उपयुक्त है।
h1: क्रॉस प्रोग्राम इन्वोकेशन
---

इस खंड में, पिछले PDA खंड से CRUD प्रोग्राम को क्रॉस प्रोग्राम इन्वोकेशन (CPIs)
जोड़कर अपडेट किया जाता है, जो एक ऐसी सुविधा है जो Solana प्रोग्राम्स को एक-दूसरे
को इन्वोक करने में सक्षम बनाती है।

यह ट्यूटोरियल यह भी दिखाता है कि प्रोग्राम क्रॉस प्रोग्राम इन्वोकेशन करते समय
प्रोग्राम डिराइव्ड एड्रेसेस (PDAs) के लिए कैसे "साइन" कर सकते हैं।

`update` और `delete` निर्देशों को सिस्टम प्रोग्राम को इन्वोक करके खातों के बीच
SOL ट्रांसफर को संभालने के लिए संशोधित करने की आवश्यकता है।

इस खंड का उद्देश्य Anchor फ्रेमवर्क का उपयोग करके Solana प्रोग्राम में CPIs को
लागू करने की प्रक्रिया के माध्यम से चलना है, जो पिछले खंड में खोजे गए PDA
अवधारणाओं पर आधारित है। अधिक जानकारी के लिए,
[क्रॉस प्रोग्राम इन्वोकेशन](/docs/core/cpi) पेज देखें।

संदर्भ के लिए, इस लिंक में PDA और CPI दोनों खंडों को पूरा करने के बाद
[अंतिम कोड](https://beta.solpg.io/668304cfcffcf4b13384d20a) शामिल है।

इस खंड के लिए [स्टार्टर कोड](https://beta.solpg.io/679d75eecffcf4b13384d604) में
केवल PDA खंड पूरा किया गया है।

<Steps>
<Step>

### अपडेट निर्देश को अपडेट करें

सबसे पहले, प्रोग्राम को _rs`Update`_ स्ट्रक्ट और `update` फंक्शन को बदलकर एक सरल
"पे-टू-अपडेट" तंत्र की आवश्यकता है।

`system_program` मॉड्यूल से आइटम्स को स्कोप में लाने के लिए `lib.rs` फाइल को
अपडेट करके शुरू करें।

```rs title="lib.rs"
use anchor_lang::system_program::{transfer, Transfer};
```

<Accordions>
<Accordion title="Diff">

```diff
  use anchor_lang::prelude::*;
+ use anchor_lang::system_program::{transfer, Transfer};
```

</Accordion>
</Accordions>

अगला, _rs`Update`_ स्ट्रक्ट को अपडेट करें ताकि एक नया अकाउंट शामिल हो जिसे
`vault_account` कहा जाता है। यह अकाउंट, जो प्रोग्राम द्वारा नियंत्रित है,
उपयोगकर्ता से SOL प्राप्त करता है जब वे अपने मैसेज अकाउंट को अपडेट करते हैं।

```rs title="lib.rs"
#[account(
    mut,
    seeds = [b"vault", user.key().as_ref()],
    bump,
)]
pub vault_account: SystemAccount<'info>,
```

<Accordions>
<Accordion title="डिफ़">

```diff
#[derive(Accounts)]
#[instruction(message: String)]
pub struct Update<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

+   #[account(
+       mut,
+       seeds = [b"vault", user.key().as_ref()],
+       bump,
+   )]
+   pub vault_account: SystemAccount<'info>,
    #[account(
        mut,
        seeds = [b"message", user.key().as_ref()],
        bump = message_account.bump,
        realloc = 8 + 32 + 4 + message.len() + 1,
        realloc::payer = user,
        realloc::zero = true,
    )]
    pub message_account: Account<'info, MessageAccount>,
    pub system_program: Program<'info, System>,
}
```

</Accordion>
<Accordion title="व्याख्या">

यह खंड _rs`Update`_ स्ट्रक्चर में `vault_account` नामक एक नया अकाउंट जोड़ता है।
यह अकाउंट एक प्रोग्राम-नियंत्रित "वॉल्ट" के रूप में कार्य करता है जो
उपयोगकर्ताओं से SOL प्राप्त करता है जब वे अपने संदेशों को अपडेट करते हैं।

वॉल्ट के लिए PDA का उपयोग करके, प्रोग्राम प्रत्येक उपयोगकर्ता के लिए एक अद्वितीय
प्रोग्राम-नियंत्रित अकाउंट बनाता है, जिससे प्रोग्राम के लॉजिक के भीतर फंड
प्रबंधन सक्षम होता है।

---

`vault_account` के प्रमुख पहलू:

- अकाउंट का पता एक PDA से आता है जो _rs`[b"vault", user.key().as_ref()]`_ सीड्स
  का उपयोग करके प्राप्त किया जाता है
- PDA होने के कारण, इसकी कोई प्राइवेट की नहीं है, इसलिए CPIs करते समय केवल
  प्रोग्राम ही पते के लिए "साइन" कर सकता है
- _rs`SystemAccount`_ प्रकार होने के कारण, सिस्टम प्रोग्राम इसे नियमित वॉलेट
  अकाउंट की तरह ही स्वामित्व में रखता है

यह सेटअप प्रोग्राम को निम्न कार्य करने की अनुमति देता है:

- प्रत्येक उपयोगकर्ता के "वॉल्ट" के लिए अद्वितीय, निर्धारित पते उत्पन्न करना
- लेनदेन के लिए साइन करने हेतु प्राइवेट की की आवश्यकता के बिना फंड को नियंत्रित
  करना।

`delete` निर्देश में, आप देखेंगे कि प्रोग्राम CPI में इस PDA के लिए कैसे "साइन"
कर सकता है।

</Accordion>
</Accordions>

अब, `update` निर्देश में CPI लॉजिक जोड़ें ताकि उपयोगकर्ता के अकाउंट से वॉल्ट
अकाउंट में 0.001 SOL ट्रांसफर किया जा सके।

<WithNotes>

```rs title="lib.rs"
// !tooltip[/transfer_accounts/] transfer_accounts
let transfer_accounts = Transfer {
    from: ctx.accounts.user.to_account_info(),
    to: ctx.accounts.vault_account.to_account_info(),
};

// !tooltip[/cpi_context/] cpi_context
let cpi_context = CpiContext::new(
    ctx.accounts.system_program.to_account_info(),
    transfer_accounts,
);

// !tooltip[/transfer/] transfer
transfer(cpi_context, 1_000_000)?;
```

### !transfer_accounts

_rs`Transfer`_ स्ट्रक्ट सिस्टम प्रोग्राम के ट्रांसफर निर्देश के लिए आवश्यक
अकाउंट्स को निर्दिष्ट करता है।

### !cpi_context

_rs`CpiContext`_ स्ट्रक्ट क्रॉस प्रोग्राम इन्वोकेशन (CPI) के लिए प्रोग्राम और
अकाउंट्स को निर्दिष्ट करता है।

### !transfer

_rs`transfer()`_ फंक्शन सिस्टम प्रोग्राम के ट्रांसफर निर्देश को इन्वोक करता है।

</WithNotes>

<Accordions>
<Accordion title="डिफ़">

```diff
    pub fn update(ctx: Context<Update>, message: String) -> Result<()> {
        msg!("Update Message: {}", message);
        let account_data = &mut ctx.accounts.message_account;
        account_data.message = message;

+       let transfer_accounts = Transfer {
+           from: ctx.accounts.user.to_account_info(),
+           to: ctx.accounts.vault_account.to_account_info(),
+       };
+       let cpi_context = CpiContext::new(
+           ctx.accounts.system_program.to_account_info(),
+           transfer_accounts,
+       );
+       transfer(cpi_context, 1_000_000)?;
        Ok(())
    }
```

</Accordion>
<Accordion title="स्पष्टीकरण">

`update` निर्देश में, कार्यान्वयन में Cross Program Invocation (CPI) शामिल है जो
System Program के `transfer` निर्देश को आमंत्रित करता है। यह दिखाता है कि
प्रोग्राम के भीतर से CPI कैसे किया जाए, जो Solana प्रोग्रामों की संयोजनीयता को
सक्षम बनाता है।

_rs`Transfer`_ संरचना System Program के ट्रांसफर निर्देश के लिए आवश्यक खातों को
निर्दिष्ट करती है:

- `from` - उपयोगकर्ता का खाता (फंड का स्रोत)
- `to` - वॉल्ट खाता (फंड का गंतव्य)

  ```rs title="lib.rs"
  let transfer_accounts = Transfer {
      from: ctx.accounts.user.to_account_info(),
      to: ctx.accounts.vault_account.to_account_info(),
  };
  ```

_rs`CpiContext`_ निर्दिष्ट करता है:

- आमंत्रित करने के लिए प्रोग्राम (System Program)
- CPI में आवश्यक खाते (_rs`Transfer`_ संरचना में परिभाषित)

  ```rs title="lib.rs"
  let cpi_context = CpiContext::new(
      ctx.accounts.system_program.to_account_info(),
      transfer_accounts,
  );
  ```

`transfer` फ़ंक्शन तब System Program पर ट्रांसफर निर्देश को आमंत्रित करता है,
जिसमें निम्न पास होते हैं:

- `cpi_context` (प्रोग्राम और खाते)
- ट्रांसफर करने के लिए `amount` (1,000,000 lamports, या 0.001 SOL)

  ```rs title="lib.rs"
  transfer(cpi_context, 1_000_000)?;
  ```

<Callout>

CPI के लिए सेटअप क्लाइंट-साइड निर्देशों के निर्माण से मेल खाता है, जहां आप किसी
विशेष निर्देश को आमंत्रित करने के लिए प्रोग्राम, खाते और निर्देश डेटा निर्दिष्ट
करते हैं। जब प्रोग्राम का `update` निर्देश एक आमंत्रण प्राप्त करता है, तो यह
आंतरिक रूप से System Program के ट्रांसफर निर्देश को आमंत्रित करता है।

</Callout>

</Accordion>
</Accordions>

प्रोग्राम को पुनर्निर्मित करें।

```terminal
$ build
```

</Step>
<Step>

### डिलीट निर्देश अपडेट करें

अब _rs`Delete`_ संरचना और `delete` फ़ंक्शन को बदलकर "डिलीट पर रिफंड" तंत्र
जोड़ें।

सबसे पहले, _rs`Delete`_ संरचना को अपडेट करके `vault_account` शामिल करें। यह
उपयोगकर्ता के संदेश खाते को बंद करते समय वॉल्ट में मौजूद किसी भी SOL को
उपयोगकर्ता को वापस ट्रांसफर करने की अनुमति देता है।

```rs title="lib.rs"
#[account(
    mut,
    seeds = [b"vault", user.key().as_ref()],
    bump,
)]
pub vault_account: SystemAccount<'info>,
```

साथ ही `system_program` को भी जोड़ें क्योंकि ट्रांसफर के लिए CPI को System
Program को आमंत्रित करने की आवश्यकता होती है।

```rs title="lib.rs"
pub system_program: Program<'info, System>,
```

<Accordions>
<Accordion title="Diff">

```diff
#[derive(Accounts)]
pub struct Delete<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

+   #[account(
+       mut,
+       seeds = [b"vault", user.key().as_ref()],
+       bump,
+   )]
+   pub vault_account: SystemAccount<'info>,
    #[account(
        mut,
        seeds = [b"message", user.key().as_ref()],
        bump = message_account.bump,
        close= user,
    )]
    pub message_account: Account<'info, MessageAccount>,
+   pub system_program: Program<'info, System>,
}
```

</Accordion>
<Accordion title="व्याख्या">

`vault_account` अपडेट स्ट्रक्ट में उपयोग किए गए समान PDA डेरिवेशन का उपयोग करता
है।

डिलीट स्ट्रक्ट में `vault_account` जोड़ने से प्रोग्राम को डिलीट इंस्ट्रक्शन के
दौरान उपयोगकर्ता के वॉल्ट अकाउंट तक पहुंचने की अनुमति मिलती है ताकि किसी भी जमा
SOL को उपयोगकर्ता को वापस ट्रांसफर किया जा सके।

</Accordion>
</Accordions>

<WithNotes>

अब, `delete` इंस्ट्रक्शन में CPI लॉजिक जोड़ें ताकि वॉल्ट अकाउंट से SOL को
उपयोगकर्ता के अकाउंट में वापस ट्रांसफर किया जा सके।

```rs title="lib.rs"
let user_key = ctx.accounts.user.key();
// !tooltip[/signer_seeds/] signer_seeds
let signer_seeds: &[&[&[u8]]] =
    &[&[b"vault", user_key.as_ref(), &[ctx.bumps.vault_account]]];

let transfer_accounts = Transfer {
    from: ctx.accounts.vault_account.to_account_info(),
    to: ctx.accounts.user.to_account_info(),
};
let cpi_context = CpiContext::new(
    ctx.accounts.system_program.to_account_info(),
    transfer_accounts,
// !tooltip[/with_signer/] with_signer
).with_signer(signer_seeds);
transfer(cpi_context, ctx.accounts.vault_account.lamports())?;
```

### !signer_seeds

_rs`signer_seeds`_ वैकल्पिक सीड्स और बंप सीड्स को निर्दिष्ट करते हैं जिनका उपयोग
PDA को डेरिव करने के लिए किया जाता है।

### !with_signer

_rs`with_signer()`_ मेथड CPI के साथ साइनर सीड्स को पास करता है।

यह एक प्रोग्राम को अपने प्रोग्राम आईडी से डेरिव किए गए PDA के लिए "साइन" करने की
अनुमति देता है।

इंस्ट्रक्शन प्रोसेसिंग के दौरान, रनटाइम यह सत्यापित करता है कि प्रदान किए गए
साइनर सीड्स सही ढंग से PDA के एड्रेस को डेरिव करते हैं। यदि सत्यापित होता है, तो
रनटाइम उस PDA अकाउंट को CPI की अवधि के लिए साइनर के रूप में मानता है।

</WithNotes>

ध्यान दें कि _rs`_ctx: Context<Delete>`_ को _rs`ctx: Context<Delete>`_ में बदला
गया है ताकि फंक्शन के बॉडी में कॉन्टेक्स्ट का उपयोग किया जा सके।

<Accordions>
<Accordion title="डिफ">

```diff
-    pub fn delete(_ctx: Context<Delete>) -> Result<()> {
+    pub fn delete(ctx: Context<Delete>) -> Result<()> {
         msg!("Delete Message");

+        let user_key = ctx.accounts.user.key();
+        let signer_seeds: &[&[&[u8]]] =
+            &[&[b"vault", user_key.as_ref(), &[ctx.bumps.vault_account]]];
+
+        let transfer_accounts = Transfer {
+            from: ctx.accounts.vault_account.to_account_info(),
+            to: ctx.accounts.user.to_account_info(),
+        };
+        let cpi_context = CpiContext::new(
+            ctx.accounts.system_program.to_account_info(),
+            transfer_accounts,
+        ).with_signer(signer_seeds);
+        transfer(cpi_context, ctx.accounts.vault_account.lamports())?;
         Ok(())
     }

```

</Accordion>
<Accordion title="व्याख्या">

डिलीट इंस्ट्रक्शन में, एक अन्य क्रॉस प्रोग्राम इन्वोकेशन (CPI) सिस्टम प्रोग्राम
के ट्रांसफर इंस्ट्रक्शन को लागू करता है। यह CPI दिखाता है कि कैसे एक ऐसा
ट्रांसफर किया जाए जिसके लिए Program Derived Address (PDA) साइनर की आवश्यकता होती
है।

सबसे पहले, वॉल्ट PDA के लिए साइनर सीड्स को परिभाषित करें:

```rs title="lib.rs"
let user_key = ctx.accounts.user.key();
let signer_seeds: &[&[&[u8]]] =
    &[&[b"vault", user_key.as_ref(), &[ctx.bumps.vault_account]]];
```

_rs`Transfer`_ स्ट्रक्ट सिस्टम प्रोग्राम के ट्रांसफर इंस्ट्रक्शन के लिए आवश्यक
अकाउंट्स को निर्दिष्ट करता है:

- from: वॉल्ट अकाउंट (फंड का स्रोत)
- to: उपयोगकर्ता का अकाउंट (फंड का गंतव्य)

  ```rs title="lib.rs"
  let transfer_accounts = Transfer {
      from: ctx.accounts.vault_account.to_account_info(),
      to: ctx.accounts.user.to_account_info(),
  };
  ```

_rs`CpiContext`_ निर्दिष्ट करता है:

- वह प्रोग्राम जिसे इनवोक करना है (सिस्टम प्रोग्राम)
- ट्रांसफर में शामिल अकाउंट्स (ट्रांसफर स्ट्रक्ट में परिभाषित)
- PDA के लिए साइनर सीड्स

  ```rs title="lib.rs"
  let cpi_context = CpiContext::new(
      ctx.accounts.system_program.to_account_info(),
      transfer_accounts,
  ).with_signer(signer_seeds);
  ```

_rs`transfer()`_ फंक्शन फिर सिस्टम प्रोग्राम पर ट्रांसफर इंस्ट्रक्शन को इनवोक
करता है, जिसमें निम्न पास किया जाता है:

- `cpi_context` (प्रोग्राम, अकाउंट्स, और PDA साइनर)
- ट्रांसफर की जाने वाली राशि (वॉल्ट अकाउंट का पूरा बैलेंस)

  ```rs title="lib.rs"
  transfer(cpi_context, ctx.accounts.vault_account.lamports())?;
  ```

यह CPI इम्प्लीमेंटेशन दिखाता है कि प्रोग्राम फंड्स को मैनेज करने के लिए PDA का
उपयोग कैसे कर सकते हैं। जब प्रोग्राम के डिलीट इंस्ट्रक्शन को इनवोक किया जाता है,
तो यह आंतरिक रूप से सिस्टम प्रोग्राम के ट्रांसफर इंस्ट्रक्शन को कॉल करता है, PDA
के लिए साइन करके वॉल्ट से यूजर को सभी फंड्स ट्रांसफर करने की अनुमति देता है।

</Accordion>
</Accordions>

प्रोग्राम को फिर से बिल्ड करें।

```terminal
$ build
```

</Step>
<Step>

### प्रोग्राम को रीडिप्लॉय करें

इन परिवर्तनों को करने के बाद, अपडेटेड प्रोग्राम को रीडिप्लॉय करें। यह सुनिश्चित
करता है कि संशोधित प्रोग्राम टेस्टिंग के लिए उपलब्ध हो जाए। सोलाना पर, प्रोग्राम
को अपडेट करने के लिए बस उसी प्रोग्राम आईडी पर प्रोग्राम को डिप्लॉय करना होता है।

<Callout>

सुनिश्चित करें कि आपके प्लेग्राउंड वॉलेट में डेवनेट SOL है।
[सोलाना फॉसेट](https://faucet.solana.com/) से डेवनेट SOL प्राप्त करें।

</Callout>

```terminal
$ deploy
Deploying... This could take a while depending on the program size and network conditions.
Deployment successful. Completed in 17s.
```

<Accordions>
<Accordion title="व्याख्या">

केवल प्रोग्राम का अपग्रेड अथॉरिटी ही इसे अपडेट कर सकता है। डेवलपर प्रोग्राम
डिप्लॉयमेंट के दौरान अपग्रेड अथॉरिटी सेट करता है, और यह एकमात्र अकाउंट रहता है
जिसे प्रोग्राम को बदलने या बंद करने की अनुमति होती है। अगर कोई अपग्रेड अथॉरिटी
को रिवोक कर देता है, तो प्रोग्राम अपरिवर्तनीय हो जाता है।

सोलाना प्लेग्राउंड पर प्रोग्राम डिप्लॉय करते समय, आपका प्लेग्राउंड वॉलेट आपके
सभी प्रोग्रामों के लिए अपग्रेड अथॉरिटी के रूप में कार्य करता है।

</Accordion>
</Accordions>

</Step>
<Step>

### टेस्ट फाइल अपडेट करें

अगला, `anchor.test.ts` फाइल को अपडेट करें ताकि इंस्ट्रक्शन में नए वॉल्ट अकाउंट
को शामिल किया जा सके। इसके लिए वॉल्ट PDA को डेराइव करना और इसे अपडेट और डिलीट
इंस्ट्रक्शन कॉल में शामिल करना आवश्यक है।

#### वॉल्ट PDA प्राप्त करें

सबसे पहले, वॉल्ट PDA डेरिवेशन जोड़ें:

```ts title="anchor.test.ts"
const [vaultPda, vaultBump] = PublicKey.findProgramAddressSync(
  [Buffer.from("vault"), wallet.publicKey.toBuffer()],
  program.programId
);
```

<Accordions>
<Accordion title="अंतर">

```diff
describe("pda", () => {
  const program = pg.program;
  const wallet = pg.wallet;

  const [messagePda, messageBump] = PublicKey.findProgramAddressSync(
    [Buffer.from("message"), wallet.publicKey.toBuffer()],
    program.programId
  );

+  const [vaultPda, vaultBump] = PublicKey.findProgramAddressSync(
+    [Buffer.from("vault"), wallet.publicKey.toBuffer()],
+    program.programId
+  );

  // ...tests
  });
```

</Accordion>
</Accordions>

#### अपडेट टेस्ट में परिवर्तन करें

<WithMentions>

फिर, अपडेट निर्देश को अपडेट करें ताकि [`vaultAccount`](mention:one) शामिल हो

```ts title="anchor.test.ts"  {5}
const transactionSignature = await program.methods
  .update(message)
  .accounts({
    messageAccount: messagePda,
    // !mention one
    vaultAccount: vaultPda
  })
  .rpc({ commitment: "confirmed" });
```

</WithMentions>

<Accordions>
<Accordion title="अंतर">

```diff
    const transactionSignature = await program.methods
      .update(message)
      .accounts({
        messageAccount: messagePda,
+       vaultAccount: vaultPda,
      })
      .rpc({ commitment: "confirmed" });
```

</Accordion>
</Accordions>

#### डिलीट टेस्ट में परिवर्तन करें

<WithMentions>

फिर, डिलीट निर्देश को अपडेट करें ताकि [`vaultAccount`](mention:one) शामिल हो

```ts title="anchor.test.ts"  {5}
const transactionSignature = await program.methods
  .delete()
  .accounts({
    messageAccount: messagePda,
    // !mention one
    vaultAccount: vaultPda
  })
  .rpc({ commitment: "confirmed" });
```

</WithMentions>

<Accordions>
<Accordion title="अंतर">

```diff
    const transactionSignature = await program.methods
      .delete()
      .accounts({
        messageAccount: messagePda,
+       vaultAccount: vaultPda,
      })
      .rpc({ commitment: "confirmed" });
```

</Accordion>
</Accordions>

</Step>
<Step>

### टेस्ट दोबारा चलाएँ

इन परिवर्तनों को करने के बाद, टेस्ट चलाएँ ताकि यह सुनिश्चित हो सके कि सब कुछ
अपेक्षित तरीके से काम कर रहा है:

```terminal
$ test
Running tests...
  anchor.test.ts:
  pda
    {
  "user": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
  "message": "Hello, World!",
  "bump": 254
}
    Transaction Signature: https://solana.fm/tx/qGsYb87mUUjeyh7Ha7r9VXkACw32HxVBujo2NUxqHiUc8qxRMFB7kdH2D4JyYtPBx171ddS91VyVrFXypgYaKUr?cluster=devnet-solana
    ✔ Create Message Account (842ms)
    {
  "user": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
  "message": "Hello, Solana!",
  "bump": 254
}
    Transaction Signature: https://solana.fm/tx/3KCDnNSfDDfmSy8kpiSrJsGGkzgxx2mt18KejuV2vmJjeyenkSoEfs2ghUQ6cMoYYgd9Qax9CbnYRcvF2zzumNt8?cluster=devnet-solana
    ✔ Update Message Account (946ms)
    Expect Null: null
    Transaction Signature: https://solana.fm/tx/3M7Z7Mea3TtQc6m9z386B9QuEgvLKxD999mt2RyVtJ26FgaAzV1QA5mxox3eXie3bpBkNpDQ4mEANr3trVHCWMC2?cluster=devnet-solana
    ✔ Delete Message Account (859ms)
  3 passing (3s)
```

फिर आप लेनदेन विवरण देखने के लिए SolanaFM लिंक का निरीक्षण कर सकते हैं, जहां
आपको अपडेट और डिलीट निर्देशों के भीतर ट्रांसफर निर्देशों के लिए CPIs मिलेंगे।

![अपडेट CPI](/assets/docs/intro/quickstart/cpi-update.png)

![डिलीट CPI](/assets/docs/intro/quickstart/cpi-delete.png)

यदि आपको कोई त्रुटि मिलती है, तो आप
[अंतिम कोड](https://beta.solpg.io/668304cfcffcf4b13384d20a) का संदर्भ ले सकते
हैं।

</Step>
</Steps>

## अगले कदम

Solana क्विकस्टार्ट गाइड पूरा करने पर बधाई। आपने निम्न Solana अवधारणाओं के साथ
व्यावहारिक अनुभव प्राप्त किया है:

- अकाउंट्स से डेटा फेच करना और पढ़ना
- लेनदेन बनाना और भेजना
- Solana प्रोग्राम डिप्लॉय करना और अपडेट करना
- Program Derived Addresses (PDAs) के साथ काम करना
- Cross-Program Invocations (CPIs) बनाना

इन अवधारणाओं की अपनी समझ को गहरा करने के लिए,
[कोर कॉन्सेप्ट्स](/docs/core/accounts) दस्तावेज़ देखें जो इस गाइड में शामिल
विषयों के विस्तृत स्पष्टीकरण प्रदान करता है।

### अधिक उदाहरण देखें

यदि आप उदाहरण से सीखना पसंद करते हैं, तो विभिन्न प्रकार के उदाहरण प्रोग्राम के
लिए
[प्रोग्राम एग्जांपल्स रिपॉजिटरी](https://github.com/solana-developers/program-examples)
देखें।

Solana प्लेग्राउंड एक सुविधाजनक फीचर प्रदान करता है जो आपको GitHub लिंक का उपयोग
करके प्रोजेक्ट्स को इम्पोर्ट या देखने की अनुमति देता है। उदाहरण के लिए, इस
[GitHub रेपो](https://github.com/solana-developers/program-examples/tree/main/basics/hello-solana/anchor)
से Anchor प्रोजेक्ट देखने के लिए
[Solana प्लेग्राउंड लिंक](https://beta.solpg.io/https://github.com/solana-developers/program-examples/tree/main/basics/hello-solana/anchor)
खोलें।

`Import` बटन पर क्लिक करें और Solana प्लेग्राउंड में अपनी प्रोजेक्ट्स की सूची
में जोड़ने के लिए एक प्रोजेक्ट नाम दर्ज करें। एक बार प्रोजेक्ट इम्पोर्ट हो जाने
के बाद, सभी परिवर्तन स्वचालित रूप से सहेजे जाते हैं और बने रहते हैं।
