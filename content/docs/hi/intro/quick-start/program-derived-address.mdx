---
title: डिटरमिनिस्टिक अकाउंट्स बनाना
description:
  Program Derived Addresses (PDAs) और Anchor फ्रेमवर्क का उपयोग करके CRUD
  (Create, Read, Update, Delete) Solana प्रोग्राम बनाना सीखें। यह
  स्टेप-बाय-स्टेप गाइड दिखाती है कि कैसे PDAs का उपयोग करके ऑन-चेन मैसेज
  अकाउंट्स को बनाना, अपडेट करना और हटाना, अकाउंट वैलिडेशन लागू करना और टेस्ट
  लिखना है। Solana प्रोग्राम में PDAs का उपयोग समझने के इच्छुक डेवलपर्स के लिए
  बिल्कुल उपयुक्त है।
h1: Program Derived Address
---

इस सेक्शन में, आप एक बेसिक क्रिएट, रीड, अपडेट, डिलीट (CRUD) प्रोग्राम बनाना
सीखेंगे।

यह गाइड एक सिंपल प्रोग्राम दिखाती है जहां यूजर्स मैसेज बना सकते हैं, अपडेट कर
सकते हैं और डिलीट कर सकते हैं। हर मैसेज एक अकाउंट में मौजूद होता है जिसका
डिटरमिनिस्टिक एड्रेस प्रोग्राम से ही डिराइव्ड होता है (Program Derived Address
या PDA)।

यह गाइड आपको Anchor फ्रेमवर्क का उपयोग करके Solana प्रोग्राम बनाने और टेस्ट करने
के प्रोसेस से गुजराती है, साथ ही Program Derived Addresses (PDAs) को भी दिखाती
है। अधिक जानकारी के लिए, [Program Derived Addresses](/docs/core/pda) पेज देखें।

रेफरेंस के लिए, आप PDA और Cross-Program Invocation (CPI) दोनों सेक्शन पूरा करने
के बाद [फाइनल कोड](https://beta.solpg.io/668304cfcffcf4b13384d20a) देख सकते हैं।

<Steps>
<Step>

### स्टार्टर कोड

स्टार्टर कोड के साथ इस
[Solana Playground लिंक](https://beta.solpg.io/66734b7bcffcf4b13384d1ad) को
खोलकर शुरू करें। फिर "Import" बटन पर क्लिक करें ताकि प्रोग्राम को अपने Solana
Playground प्रोजेक्ट्स में जोड़ सकें।

![Import](/assets/docs/intro/quickstart/pg-import.png)

<WithMentions>

`lib.rs` फाइल में, आपको [`create`](mention:one), [`update`](mention:two), और
[`delete`](mention:three) इंस्ट्रक्शंस मिलेंगे जिन्हें आगामी स्टेप्स में जोड़ना
है।

```rs title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("8KPzbM2Cwn4Yjak7QYAEH9wyoQh86NcBicaLuzPaejdw");

#[program]
pub mod pda {
    use super::*;

    // !mention one
    pub fn create(_ctx: Context<Create>) -> Result<()> {
        Ok(())
    }

    // !mention two
    pub fn update(_ctx: Context<Update>) -> Result<()> {
        Ok(())
    }

    // !mention three
    pub fn delete(_ctx: Context<Delete>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create {}

#[derive(Accounts)]
pub struct Update {}

#[derive(Accounts)]
pub struct Delete {}

#[account]
pub struct MessageAccount {}
```

</WithMentions>

शुरू करने से पहले, Playground टर्मिनल में _shell`build`_ चलाएं ताकि स्टार्टर
प्रोग्राम सफलतापूर्वक बिल्ड होता है यह चेक किया जा सके।

```terminal
$ build
Building...
Build successful. Completed in 3.50s.
```

</Step>
<Step>

### मैसेज अकाउंट टाइप को परिभाषित करें

सबसे पहले, प्रोग्राम द्वारा बनाए गए मैसेज अकाउंट के लिए स्ट्रक्चर को परिभाषित
करें। यह स्ट्रक्चर उस डेटा को परिभाषित करता है जिसे प्रोग्राम द्वारा बनाए गए
अकाउंट में स्टोर किया जाएगा।

<WithNotes>

`lib.rs` में, _rs`MessageAccount`_ स्ट्रक्ट को निम्नलिखित के साथ अपडेट करें:

```rs title="lib.rs"
// !tooltip[/account/] account
#[account]
pub struct MessageAccount {
    // !tooltip[/user/] user
    pub user: Pubkey,
    // !tooltip[/message/] message
    pub message: String,
    // !tooltip[/bump/] bump
    pub bump: u8,
}
```

### !account

Anchor प्रोग्राम में _rs`#[account]`_ एट्रिब्यूट उन स्ट्रक्ट्स को एनोटेट करता है
जो अकाउंट डेटा (अकाउंट के डेटा फील्ड में स्टोर करने के लिए डेटा टाइप) का
प्रतिनिधित्व करते हैं।

### !user

_rs`user`_ फील्ड में एक _rs`Pubkey`_ होता है जो उस उपयोगकर्ता की पहचान करता है
जिसने मैसेज अकाउंट बनाया है।

### !message

_rs`message`_ फील्ड में एक _rs`String`_ होता है जिसमें उपयोगकर्ता का संदेश होता
है।

### !bump

_rs`bump`_ फील्ड एक _rs`u8`_ ["bump" सीड](/docs/core/pda#canonical-bump) स्टोर
करता है जिसका उपयोग Program Derived Address (PDA) को डिराइव करने के लिए किया
जाता है। इस मान को स्टोर करने से कंप्यूट बचता है क्योंकि बाद के निर्देशों में
इसे फिर से गणना करने की आवश्यकता नहीं होती है।

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- #[account]
- pub struct MessageAccount {}

+ #[account]
+ pub struct MessageAccount {
+    pub user: Pubkey,
+    pub message: String,
+    pub bump: u8,
+ }
```

</Accordion>
<Accordion title="Explanation">

Anchor प्रोग्राम में _rs`#[account]`_ एट्रिब्यूट उन स्ट्रक्ट्स को एनोटेट करता है
जो अकाउंट डेटा (अकाउंट के डेटा फील्ड में स्टोर करने के लिए डेटा टाइप) का
प्रतिनिधित्व करते हैं।

इस उदाहरण में, _rs`MessageAccount`_ स्ट्रक्ट उपयोगकर्ताओं द्वारा बनाए गए संदेश
को स्टोर करता है जिसमें तीन फील्ड होते हैं:

- `user` - _rs`Pubkey`_ जो उस उपयोगकर्ता की पहचान करता है जिसने मैसेज अकाउंट
  बनाया है।
- `message` - _rs`String`_ जिसमें उपयोगकर्ता का संदेश होता है।
- `bump` - _rs`u8`_ जो Program Derived Address (PDA) को डिराइव करने के लिए
  ["bump" सीड](/docs/core/pda#canonical-bump) स्टोर करता है। इस मान को स्टोर
  करने से कंप्यूट बचता है क्योंकि बाद के निर्देशों में इसे फिर से गणना करने की
  आवश्यकता नहीं होती है।

जब एक अकाउंट बनाया जाता है, तो प्रोग्राम _rs`MessageAccount`_ डेटा को सीरियलाइज़
करता है और इसे नए अकाउंट के डेटा फील्ड में स्टोर करता है।

बाद में, जब अकाउंट से पढ़ते हैं, तो प्रोग्राम इस डेटा को वापस
_rs`MessageAccount`_ डेटा टाइप में डीसीरियलाइज़ करता है। टेस्टिंग सेक्शन अकाउंट
डेटा बनाने और पढ़ने की प्रक्रिया को प्रदर्शित करता है।

</Accordion>
</Accordions>

टर्मिनल में _shell`build`_ चलाकर प्रोग्राम को फिर से बिल्ड करें।

```terminal
$ build
```

यह कोड परिभाषित करता है कि संदेश खाते पर कौन सा डेटा स्टोर करना है। अगले चरण
में, आप प्रोग्राम निर्देश जोड़ेंगे।

</Step>
<Step>

### क्रिएट निर्देश जोड़ें

अब, _rs`create`_ निर्देश जोड़ें जो _rs`MessageAccount`_ को बनाता और प्रारंभ करता
है।

निम्नलिखित के साथ _rs`Create`_ स्ट्रक्ट को अपडेट करके निर्देश के लिए आवश्यक
खातों को परिभाषित करके शुरू करें:

<WithNotes>

```rs title="lib.rs"
#[derive(Accounts)]
// !tooltip[/instruction/] instruction
#[instruction(message: String)]
pub struct Create<'info> {
    // !tooltip[/mut/] mut
    #[account(mut)]
    // !tooltip[/Signer<'info>/] signer
    pub user: Signer<'info>,

    #[account(
        // !tooltip[/init/] init
        init,
        // !tooltip[/seeds/] seeds
        seeds = [b"message", user.key().as_ref()],
        // !tooltip[/bump/] bump
        bump,
        // !tooltip[/payer/] payer
        payer = user,
        // !tooltip[/space/] space
        space = 8 + 32 + 4 + message.len() + 1
    )]
    // !tooltip[/Account<'info, MessageAccount>/] account
    pub message_account: Account<'info, MessageAccount>,
    // !tooltip[/Program<'info, System>/] program
    pub system_program: Program<'info, System>,
}
```

### !mut

_rs`mut`_ कंस्ट्रेंट खाते को परिवर्तनीय (मुटेबल) घोषित करता है।

### !init

_rs`init`_ कंस्ट्रेंट एक नया खाता बनाता है।

### !seeds

_rs`seeds`_ कंस्ट्रेंट PDA प्राप्त करने के लिए उपयोग किए जाने वाले वैकल्पिक
इनपुट को परिभाषित करता है।

### !bump

_rs`bump`_ कंस्ट्रेंट PDA के लिए bump seed घोषित करता है।

यदि आप कोई मान निर्दिष्ट नहीं करते हैं, तो Anchor स्वचालित रूप से इसकी गणना करता
है।

### !payer

_rs`payer`_ कंस्ट्रेंट निर्दिष्ट करता है कि कौन सा खाता नए खाते के निर्माण के
लिए भुगतान करता है।

### !space

_rs`space`_ कंस्ट्रेंट नए खाते के डेटा फ़ील्ड के लिए असाइन करने के लिए बाइट्स की
संख्या निर्दिष्ट करता है।

### !signer

_rs`Signer<'info>`_ टाइप यह आवश्यक करता है कि खाता लेनदेन पर हस्ताक्षर करे।

### !account

_rs`Account<'info, T>`_ टाइप यह आवश्यक करता है कि खाता निर्दिष्ट प्रकार से मेल
खाए।

इस मामले में, अकाउंट को कस्टम _rs`MessageAccount`_ टाइप से मेल खाना चाहिए।

### !program

_rs`Program<'info, T>`_ टाइप के लिए अकाउंट का प्रोग्राम से मेल खाना आवश्यक है।

इस मामले में, अकाउंट को _rs`System`_ टाइप से मेल खाना चाहिए, जो सिस्टम प्रोग्राम
को संदर्भित करता है।

### !instruction

_rs`#[instruction(message: String)]`_ एनोटेशन _rs`Create`_ स्ट्रक्ट को `create`
निर्देश से _rs`message`_ पैरामीटर तक पहुंच प्रदान करता है।

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- #[derive(Accounts)]
- pub struct Create {}

+ #[derive(Accounts)]
+ #[instruction(message: String)]
+ pub struct Create<'info> {
+     #[account(mut)]
+     pub user: Signer<'info>,
+
+     #[account(
+         init,
+         seeds = [b"message", user.key().as_ref()],
+         bump,
+         payer = user,
+         space = 8 + 32 + 4 + message.len() + 1
+     )]
+     pub message_account: Account<'info, MessageAccount>,
+     pub system_program: Program<'info, System>,
+ }
```

</Accordion>
<Accordion title="Explanation">

Anchor प्रोग्राम में _rs`#[derive(Accounts)]`_ एट्रिब्यूट उन स्ट्रक्ट्स को
एनोटेट करता है जो किसी निर्देश के लिए आवश्यक अकाउंट्स को परिभाषित करते हैं।

स्ट्रक्ट में प्रत्येक फील्ड एक अकाउंट का प्रतिनिधित्व करती है जिसे दो तरीकों से
वैलिडेट किया जाता है:

1. अकाउंट टाइप (जैसे _rs`Signer<'info>`_ या _rs`Account<'info, T>`_) जो
   निर्दिष्ट करता है कि प्रोग्राम किस प्रकार के अकाउंट की अपेक्षा करता है
2. वैकल्पिक कंस्ट्रेंट्स (जैसे _rs`#[account(mut)]`_ या _rs`#[account(init)]`_)
   जो अतिरिक्त आवश्यकताओं को परिभाषित करते हैं

ये दोनों मिलकर Anchor को निर्देश में पास किए गए अकाउंट्स को स्वचालित रूप से
सत्यापित करने और प्रोग्राम को सुरक्षित करने में सक्षम बनाते हैं।

स्ट्रक्ट में फील्ड नाम आपके प्रोग्राम कोड में अकाउंट्स तक पहुंच प्रदान करते हैं,
लेकिन वैलिडेशन को प्रभावित नहीं करते। स्पष्टता के लिए आपको वर्णनात्मक नाम का
उपयोग करना चाहिए।

इस उदाहरण में, _rs`Create`_ स्ट्रक्ट _rs`create`_ निर्देश के लिए आवश्यक अकाउंट्स
को परिभाषित करता है।

1. _rs`user: Signer<'info>`_

   - मैसेज अकाउंट बनाने वाले उपयोगकर्ता का प्रतिनिधित्व करता है
   - परिवर्तनीय स्थिति (_rs`#[account(mut)]`_) की आवश्यकता होती है क्योंकि यह नए
     अकाउंट के लिए भुगतान करता है
   - इस अकाउंट से लैम्पोर्ट कटौती को अनुमोदित करने के लिए लेनदेन पर हस्ताक्षर
     करना चाहिए

2. _rs`message_account: Account<'info, MessageAccount>`_

   - नया अकाउंट जो उपयोगकर्ता के संदेश को स्टोर करता है
   - `init` कंस्ट्रेंट निर्देश निष्पादन के दौरान अकाउंट बनाता है
   - `seeds` और `bump` कंस्ट्रेंट्स अकाउंट एड्रेस को Program Derived Address
     (PDA) के रूप में व्युत्पन्न करते हैं
   - `payer = user` पहचानता है कि नए अकाउंट के निर्माण के लिए कौन भुगतान करता है
   - `space` अकाउंट के डेटा फील्ड के लिए आवश्यक बाइट्स आवंटित करता है

3. _rs`system_program: Program<'info, System>`_

   - खाता बनाने के लिए आवश्यक
   - पर्दे के पीछे, `init` कंस्ट्रेंट सिस्टम प्रोग्राम को कॉल करता है निर्दिष्ट
     `space` के साथ एक नया खाता बनाने के लिए और मालिक को वर्तमान प्रोग्राम में
     बदल देता है।

---

_rs`#[instruction(message: String)]`_ एनोटेशन _rs`Create`_ स्ट्रक्ट को `create`
निर्देश से _rs`message`_ पैरामीटर तक पहुंचने की अनुमति देता है।

---

`seeds` और `bump` कंस्ट्रेंट्स मिलकर एक खाते के पते को Program Derived Address
(PDA) के रूप में परिभाषित करते हैं।

```rs title="lib.rs"
seeds = [b"message", user.key().as_ref()],
bump,
```

`seeds` कंस्ट्रेंट PDA प्राप्त करने के लिए उपयोग किए जाने वाले वैकल्पिक इनपुट को
परिभाषित करता है।

- _rs`b"message"`_ - पहले seed के रूप में एक निश्चित स्ट्रिंग।
- _rs`user.key().as_ref()`_ - दूसरे seed के रूप में _rs`user`_ खाते की पब्लिक
  की।

`bump` कंस्ट्रेंट Anchor को स्वचालित रूप से सही bump seed खोजने और उपयोग करने के
लिए बताता है। Anchor PDA प्राप्त करने के लिए `seeds` और `bump` का उपयोग करता है।

---

`space` गणना _rs`(8 + 32 + 4 + message.len() + 1)`_ `MessageAccount` डेटा प्रकार
के लिए स्थान आवंटित करती है:

- Anchor खाता डिस्क्रिमिनेटर (पहचानकर्ता): 8 बाइट्स
- उपयोगकर्ता पता (_rs`Pubkey`_): 32 बाइट्स
- उपयोगकर्ता संदेश (_rs`String`_): लंबाई के लिए 4 बाइट्स + परिवर्तनीय संदेश
  लंबाई
- PDA Bump seed (_rs`u8`_): 1 बाइट

```rs title="lib.rs"
#[account]
pub struct MessageAccount {
    pub user: Pubkey,
    pub message: String,
    pub bump: u8,
}
```

Anchor प्रोग्राम के माध्यम से बनाए गए सभी खातों को खाता प्रकार के पहचानकर्ता के
रूप में काम करने वाले खाता डिस्क्रिमिनेटर के लिए 8 बाइट्स की आवश्यकता होती है,
जिसे Anchor खाता बनाते समय स्वचालित रूप से उत्पन्न करता है।

_rs`String`_ प्रकार को स्ट्रिंग की लंबाई संग्रहित करने के लिए 4 बाइट्स की
आवश्यकता होती है, और शेष लंबाई में वास्तविक डेटा होता है।

</Accordion>
</Accordions>

अब, _rs`create`_ निर्देश के लिए बिजनेस लॉजिक जोड़ें, `create` फ़ंक्शन को
निम्नलिखित के साथ अपडेट करके:

```rs title="lib.rs"
pub fn create(ctx: Context<Create>, message: String) -> Result<()> {
    msg!("Create Message: {}", message);
    let account_data = &mut ctx.accounts.message_account;
    account_data.user = ctx.accounts.user.key();
    account_data.message = message;
    account_data.bump = ctx.bumps.message_account;
    Ok(())
}
```

<Accordions>
<Accordion title="Diff">

```diff
- pub fn create(_ctx: Context<Create>) -> Result<()> {
-     Ok(())
- }

+ pub fn create(ctx: Context<Create>, message: String) -> Result<()> {
+     msg!("Create Message: {}", message);
+     let account_data = &mut ctx.accounts.message_account;
+     account_data.user = ctx.accounts.user.key();
+     account_data.message = message;
+     account_data.bump = ctx.bumps.message_account;
+     Ok(())
+ }
```

</Accordion>
<Accordion title="व्याख्या">

`create` फ़ंक्शन एक नए मैसेज अकाउंट के डेटा को इनिशियलाइज़ करने के लिए लॉजिक को
लागू करता है। यह दो पैरामीटर लेता है:

1. _rs`ctx: Context<Create>`_ - _rs`Create`_ स्ट्रक्ट में निर्दिष्ट अकाउंट्स तक
   पहुंच प्रदान करता है।
2. _rs`message: String`_ - स्टोरेज के लिए उपयोगकर्ता का संदेश।

फ़ंक्शन का बॉडी फिर निम्नलिखित लॉजिक को निष्पादित करता है:

1. _rs`msg!()`_ मैक्रो का उपयोग करके प्रोग्राम लॉग में एक संदेश प्रिंट करता है।

   ```rs
   msg!("Create Message: {}", message);
   ```

2. अकाउंट डेटा को इनिशियलाइज़ करना:

   - कॉन्टेक्स्ट से `message_account` तक पहुंचता है।

   ```rs
   let account_data = &mut ctx.accounts.message_account;
   ```

   - `user` फ़ील्ड को `user` अकाउंट की पब्लिक की पर सेट करता है।

   ```rs
   account_data.user = ctx.accounts.user.key();
   ```

   - `message` फ़ील्ड को फ़ंक्शन आर्गुमेंट से `message` पर सेट करता है।

   ```rs
   account_data.message = message;
   ```

   - PDA को डेराइव करने के लिए उपयोग किए गए `bump` वैल्यू को सेट करता है, जो
     `ctx.bumps.message_account` से प्राप्त किया गया है।

   ```rs
   account_data.bump = ctx.bumps.message_account;
   ```

</Accordion>
</Accordions>

प्रोग्राम को फिर से बिल्ड करें।

```terminal
$ build
```

</Step>
<Step>

### अपडेट इंस्ट्रक्शन जोड़ें

अगला, नए संदेश के साथ `MessageAccount` को बदलने के लिए `update` इंस्ट्रक्शन
जोड़ें।

पिछले चरण की तरह, पहले `update` इंस्ट्रक्शन द्वारा आवश्यक अकाउंट्स को निर्दिष्ट
करें।

`Update` स्ट्रक्ट को निम्नलिखित के साथ अपडेट करें:

<WithNotes>

```rs title="lib.rs"
#[derive(Accounts)]
#[instruction(message: String)]
pub struct Update<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        mut,
        seeds = [b"message", user.key().as_ref()],
        bump = message_account.bump,
        // !tooltip[/realloc/] realloc
        realloc = 8 + 32 + 4 + message.len() + 1,
        // !tooltip[/realloc::payer/] realloc::payer
        realloc::payer = user,
        // !tooltip[/realloc::zero/] realloc::zero
        realloc::zero = true,
    )]
    pub message_account: Account<'info, MessageAccount>,
    pub system_program: Program<'info, System>,
}
```

### !realloc

_rs`realloc`_ कंस्ट्रेंट खाते के डेटा का पुनः आवंटन करता है।

### !realloc::payer

_rs`realloc::payer`_ कंस्ट्रेंट उस खाते को निर्दिष्ट करता है जो पुनः आवंटन के
लिए भुगतान करेगा।

### !realloc::zero

_rs`realloc::zero`_ कंस्ट्रेंट खाते के डेटा को शून्य कर देता है।

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- #[derive(Accounts)]
- pub struct Update {}

+ #[derive(Accounts)]
+ #[instruction(message: String)]
+ pub struct Update<'info> {
+     #[account(mut)]
+     pub user: Signer<'info>,
+
+     #[account(
+         mut,
+         seeds = [b"message", user.key().as_ref()],
+         bump = message_account.bump,
+         realloc = 8 + 32 + 4 + message.len() + 1,
+         realloc::payer = user,
+         realloc::zero = true,
+     )]
+     pub message_account: Account<'info, MessageAccount>,
+     pub system_program: Program<'info, System>,
+ }
```

</Accordion>
<Accordion title="Explanation">

_rs`Update`_ स्ट्रक्ट _rs`update`_ निर्देश के लिए आवश्यक खातों को परिभाषित करता
है।

1. _rs`user: Signer<'info>`_

   - उस उपयोगकर्ता का प्रतिनिधित्व करता है जो संदेश खाते को अपडेट कर रहा है
   - परिवर्तनीय (_rs`#[account(mut)]`_) के रूप में चिह्नित है क्योंकि यह
     आवश्यकता पड़ने पर `message_account` के लिए अधिक स्थान का भुगतान कर सकता है
   - लेनदेन पर हस्ताक्षर करना आवश्यक है

2. _rs`message_account: Account<'info, MessageAccount>`_

   - अपडेट करने के लिए उपयोगकर्ता के संदेश को संग्रहीत करने वाला मौजूदा खाता
   - `mut` कंस्ट्रेंट इस खाते के लिए डेटा संशोधन को इंगित करता है
   - `realloc` कंस्ट्रेंट खाते के डेटा का आकार बदलने की अनुमति देता है
   - `seeds` और `bump` कंस्ट्रेंट खाते को सही PDA के रूप में सत्यापित करते हैं

3. _rs`system_program: Program<'info, System>`_
   - खाते के स्थान के संभावित पुनः आवंटन के लिए आवश्यक है
   - `realloc` कंस्ट्रेंट खाते के डेटा आकार को समायोजित करने के लिए सिस्टम
     प्रोग्राम को आमंत्रित करता है

ध्यान दें कि _rs`bump = message_account.bump`_ कंस्ट्रेंट _rs`message_account`_
पर संग्रहीत bump seed का उपयोग करता है, न कि Anchor द्वारा इसकी पुनर्गणना करवाता
है।

_rs`#[instruction(message: String)]`_ विशेषता _rs`Update`_ स्ट्रक्ट को
_rs`update`_ निर्देश से _rs`message`_ पैरामीटर तक पहुंचने की अनुमति देती है।

</Accordion>
</Accordions>

अब, `update` निर्देश के लिए लॉजिक जोड़ें।

```rs title="lib.rs"
pub fn update(ctx: Context<Update>, message: String) -> Result<()> {
    msg!("Update Message: {}", message);
    let account_data = &mut ctx.accounts.message_account;
    account_data.message = message;
    Ok(())
}
```

<Accordions>
<Accordion title="Diff">

```diff
- pub fn update(_ctx: Context<Update>) -> Result<()> {
-     Ok(())
- }

+ pub fn update(ctx: Context<Update>, message: String) -> Result<()> {
+     msg!("Update Message: {}", message);
+     let account_data = &mut ctx.accounts.message_account;
+     account_data.message = message;
+     Ok(())
+ }
```

</Accordion>
<Accordion title="Explanation">

`update` फ़ंक्शन मौजूदा संदेश खाते को संशोधित करने के लिए लॉजिक को लागू करता है।
यह दो पैरामीटर लेता है:

1. _rs`ctx: Context<Update>`_ - _rs`Update`_ स्ट्रक्ट में निर्दिष्ट खातों तक
   पहुंच प्रदान करता है।
2. _rs`message: String`_ - मौजूदा संदेश को बदलने के लिए नया संदेश।

फंक्शन का बॉडी फिर:

1. _rs`msg!()`_ मैक्रो का उपयोग करके प्रोग्राम लॉग में एक संदेश प्रिंट करता है।

2. अकाउंट डेटा अपडेट करता है:
   - कॉन्टेक्स्ट से `message_account` तक पहुंचता है।
   - `message` फील्ड को फंक्शन आर्गुमेंट से नए `message` पर सेट करता है।

</Accordion>
</Accordions>

प्रोग्राम को पुनर्निर्मित करें

```terminal
$ build
```

</Step>
<Step>

### डिलीट इंस्ट्रक्शन जोड़ें

अगला, _rs`delete`_ इंस्ट्रक्शन जोड़ें ताकि _rs`MessageAccount`_ को बंद किया जा
सके।

_rs`Delete`_ स्ट्रक्ट को निम्नलिखित के साथ अपडेट करें:

<WithNotes>

```rs title="lib.rs"
#[derive(Accounts)]
pub struct Delete<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        mut,
        // !tooltip[/seeds/] seeds
        seeds = [b"message", user.key().as_ref()],
        // !tooltip[/bump/] bump
        bump = message_account.bump,
        // !tooltip[/close/] close
        close = user,
    )]
    pub message_account: Account<'info, MessageAccount>,
}
```

### !seeds

_rs`seeds`_ कंस्ट्रेंट PDA को डिराइव करने के लिए उपयोग किए गए seeds को निर्दिष्ट
करता है।

### !bump

_rs`bump`_ कंस्ट्रेंट PDA के लिए bump seed को निर्दिष्ट करता है।

इस मामले में, प्रोग्राम _rs`message_account`_ पर संग्रहित मौजूदा bump seed का
उपयोग करता है।

### !close

_rs`close`_ कंस्ट्रेंट अकाउंट को बंद करता है।

इस मामले में, _rs`user`_ अकाउंट बंद किए गए _rs`message_account`_ से lamport
प्राप्त करता है।

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- #[derive(Accounts)]
- pub struct Delete {}

+ #[derive(Accounts)]
+ pub struct Delete<'info> {
+     #[account(mut)]
+     pub user: Signer<'info>,
+
+     #[account(
+         mut,
+         seeds = [b"message", user.key().as_ref()],
+         bump = message_account.bump,
+         close = user,
+     )]
+     pub message_account: Account<'info, MessageAccount>,
+ }
```

</Accordion>
<Accordion title="Explanation">

_rs`Delete`_ स्ट्रक्ट _rs`delete`_ इंस्ट्रक्शन के लिए आवश्यक अकाउंट्स को
परिभाषित करता है:

1. _rs`user: Signer<'info>`_

   - उपयोगकर्ता द्वारा संदेश खाते को बंद करने का प्रतिनिधित्व करता है
   - बंद किए गए खाते से lamports प्राप्त करने के लिए परिवर्तनीय
     (_rs`#[account(mut)]`_) के रूप में चिह्नित
   - यह सुनिश्चित करने के लिए हस्ताक्षर करना आवश्यक है कि केवल सही उपयोगकर्ता ही
     अपने संदेश खाते को बंद कर सकते हैं

2. _rs`message_account: Account<'info, MessageAccount>`_

   - बंद करने के लिए खाता
   - `mut` बाधा डेटा संशोधन को इंगित करती है
   - `seeds` और `bump` बाधाएँ खाते को सही PDA के रूप में सत्यापित करती हैं
   - `close = user` बाधा इस खाते को बंद करने के लिए चिह्नित करती है और इसके
     lamports को `user` खाते में स्थानांतरित करती है

</Accordion>
</Accordions>

अब `delete` निर्देश के लिए लॉजिक जोड़ें।

```rs title="lib.rs"
pub fn delete(_ctx: Context<Delete>) -> Result<()> {
    msg!("Delete Message");
    Ok(())
}
```

<Accordions>
<Accordion title="Diff">

```diff
- pub fn delete(_ctx: Context<Delete>) -> Result<()> {
-     Ok(())
- }

+ pub fn delete(_ctx: Context<Delete>) -> Result<()> {
+     msg!("Delete Message");
+     Ok(())
+ }
```

</Accordion>
<Accordion title="Explanation">

`delete` फ़ंक्शन एक पैरामीटर लेता है:

1. _rs`_ctx: Context<Delete>`_ - _rs`Delete`_ स्ट्रक्ट में निर्दिष्ट खातों तक
   पहुंच प्रदान करता है। _rs`_ctx`_ सिंटैक्स दिखाता है कि फ़ंक्शन अपने बॉडी में
   Context का उपयोग नहीं करता है।

फ़ंक्शन बॉडी केवल _rs`msg!()`_ मैक्रो का उपयोग करके प्रोग्राम लॉग में एक संदेश
प्रिंट करती है। फ़ंक्शन को अतिरिक्त लॉजिक की आवश्यकता नहीं है क्योंकि
_rs`close`_ बाधा _rs`Delete`_ स्ट्रक्ट में खाता बंद करने को संभालती है।

</Accordion>
</Accordions>

प्रोग्राम को पुनः बिल्ड करें।

```terminal
$ build
```

</Step>
<Step>

### प्रोग्राम डिप्लॉय करें

अब आपने बेसिक CRUD प्रोग्राम पूरा कर लिया है। प्लेग्राउंड टर्मिनल में `deploy`
चलाकर प्रोग्राम डिप्लॉय करें।

<Callout type="info">
इस उदाहरण में, आप प्रोग्राम को devnet पर डिप्लॉय करेंगे, जो विकास परीक्षण के लिए
एक Solana क्लस्टर है।

प्लेग्राउंड वॉलेट डिफ़ॉल्ट रूप से devnet से कनेक्ट होता है। सुनिश्चित करें कि
आपके प्लेग्राउंड वॉलेट में प्रोग्राम डिप्लॉयमेंट के लिए भुगतान करने के लिए
devnet SOL है। devnet SOL [Solana Faucet](https://faucet.solana.com/) से प्राप्त
करें।

</Callout>

```terminal
$ deploy
Deploying... This could take a while depending on the program size and network conditions.
Deployment successful. Completed in 17s.
```

</Step>
<Step>

### टेस्ट फ़ाइल सेट अप करें

स्टार्टर कोड में `anchor.test.ts` में एक टेस्ट फाइल भी शामिल है।

```ts title="anchor.test.ts"
import { PublicKey } from "@solana/web3.js";

describe("pda", () => {
  it("Create Message Account", async () => {});

  it("Update Message Account", async () => {});

  it("Delete Message Account", async () => {});
});
```

नीचे दिए गए कोड को _ts`describe()`_ के अंदर, लेकिन _ts`it()`_ सेक्शन से पहले
जोड़ें।

```ts title="anchor.test.ts"
const program = pg.program;
const wallet = pg.wallet;

const [messagePda, messageBump] = PublicKey.findProgramAddressSync(
  [Buffer.from("message"), wallet.publicKey.toBuffer()],
  program.programId
);
```

<Accordions>
<Accordion title="Diff">

```diff
  import { PublicKey } from "@solana/web3.js";

  describe("pda", () => {
+    const program = pg.program;
+    const wallet = pg.wallet;
+
+    const [messagePda, messageBump] = PublicKey.findProgramAddressSync(
+      [Buffer.from("message"), wallet.publicKey.toBuffer()],
+      program.programId
+    );

    it("Create Message Account", async () => {});

    it("Update Message Account", async () => {});

    it("Delete Message Account", async () => {});
  });
```

</Accordion>
<Accordion title="व्याख्या">

इस सेक्शन में, यह कोड बस टेस्ट फाइल को सेटअप करता है।

<WithMentions>

Solana Playground कुछ बॉयलरप्लेट सेटअप को हटा देता है जहां
[`pg.program`](mention:one) प्रोग्राम के साथ इंटरैक्ट करने के लिए मेथड्स तक
पहुंच प्रदान करता है, जबकि [`pg.wallet`](mention:two) आपके प्लेग्राउंड वॉलेट तक
पहुंच देता है।

```ts title="anchor.test.ts"
// !mention one
const program = pg.program;
// !mention two
const wallet = pg.wallet;
```

</WithMentions>

सेटअप के हिस्से के रूप में, टेस्ट फाइल मैसेज अकाउंट PDA को डिराइव करती है। यह
दिखाता है कि प्रोग्राम में निर्दिष्ट समान सीड्स का उपयोग करके जावास्क्रिप्ट में
PDA को कैसे डिराइव किया जाए।

```ts title="anchor.test.ts"
const [messagePda, messageBump] = PublicKey.findProgramAddressSync(
  [Buffer.from("message"), wallet.publicKey.toBuffer()],
  program.programId
);
```

</Accordion>
</Accordions>

प्लेग्राउंड टर्मिनल में _shell`test`_ चलाकर टेस्ट फाइल को रन करें ताकि यह जांच
सकें कि यह अपेक्षित रूप से चलती है। अगले चरणों में वास्तविक टेस्ट जोड़े जाएंगे।

```terminal
$ test
Running tests...
  anchor.test.ts:
  pda
    ✔ Create Message Account
    ✔ Update Message Account
    ✔ Delete Message Account
  3 passing (4ms)
```

</Step>
<Step>

### क्रिएट इंस्ट्रक्शन को इनवोक करें

<WithNotes>

पहले टेस्ट को निम्नलिखित के साथ अपडेट करें:

```ts title="anchor.test.ts"
it("Create Message Account", async () => {
  const message = "Hello, World!";
  const transactionSignature = await program.methods
    // !tooltip[/create/] create
    .create(message)
    // !tooltip[/accounts/] accounts
    .accounts({
      messageAccount: messagePda
    })
    // !tooltip[/rpc/] rpc
    .rpc({ commitment: "confirmed" });

  // !tooltip[/fetch/] fetch
  const messageAccount = await program.account.messageAccount.fetch(
    messagePda,
    "confirmed"
  );

  console.log(JSON.stringify(messageAccount, null, 2));
  console.log(
    "Transaction Signature:",
    `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
  );
});
```

### !create

_ts`create()`_ मेथड `create` इंस्ट्रक्शन को इनवोक करता है।

### !accounts

_ts`accounts()`_ विधि उन खातों को निर्दिष्ट करती है जो _ts`create()`_ निर्देश के
लिए आवश्यक हैं।

### !rpc

_ts`rpc()`_ विधि लेनदेन को नेटवर्क पर भेजती है।

### !fetch

_ts`fetch()`_ विधि नेटवर्क से खाता डेटा प्राप्त करती है।

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- it("Create Message Account", async () => {});

+ it("Create Message Account", async () => {
+   const message = "Hello, World!";
+   const transactionSignature = await program.methods
+     .create(message)
+     .accounts({
+       messageAccount: messagePda,
+     })
+     .rpc({ commitment: "confirmed" });
+
+   const messageAccount = await program.account.messageAccount.fetch(
+     messagePda,
+     "confirmed"
+   );
+
+   console.log(JSON.stringify(messageAccount, null, 2));
+   console.log(
+     "Transaction Signature:",
+     `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
+   );
+ });
```

</Accordion>
<Accordion title="Explanation">

सबसे पहले, टेस्ट फ़ाइल `create` निर्देश को आमंत्रित करने वाला एक लेनदेन भेजती
है, जिसमें संदेश के रूप में "Hello, World!" पास किया जाता है।

```ts title="anchor.test.ts"
const message = "Hello, World!";
const transactionSignature = await program.methods
  .create(message)
  .accounts({
    messageAccount: messagePda
  })
  .rpc({ commitment: "confirmed" });
```

लेनदेन भेजने और खाता बनाने के बाद, टेस्ट फ़ाइल इसके पते (`messagePda`) का उपयोग
करके खाता प्राप्त करती है।

```ts title="anchor.test.ts"
const messageAccount = await program.account.messageAccount.fetch(
  messagePda,
  "confirmed"
);
```

अंत में, टेस्ट फ़ाइल खाता डेटा और लेनदेन विवरण के लिंक को लॉग करती है।

```ts title="anchor.test.ts"
console.log(JSON.stringify(messageAccount, null, 2));
console.log(
  "Transaction Signature:",
  `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
);
```

</Accordion>
</Accordions>

</Step>
<Step>

### अपडेट निर्देश का आह्वान करें

<WithNotes>
दूसरे टेस्ट को निम्नलिखित के साथ अपडेट करें:

```ts title="anchor.test.ts"
it("Update Message Account", async () => {
  const message = "Hello, Solana!";
  const transactionSignature = await program.methods
    // !tooltip[/update/] update
    .update(message)
    // !tooltip[/accounts/] accounts
    .accounts({
      messageAccount: messagePda
    })
    // !tooltip[/rpc/] rpc
    .rpc({ commitment: "confirmed" });

  // !tooltip[/fetch/] fetch
  const messageAccount = await program.account.messageAccount.fetch(
    messagePda,
    "confirmed"
  );

  console.log(JSON.stringify(messageAccount, null, 2));
  console.log(
    "Transaction Signature:",
    `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
  );
});
```

### !update

_ts`update()`_ विधि `update` निर्देश का आह्वान करती है।

### !accounts

_ts`accounts()`_ विधि उन खातों को निर्दिष्ट करती है जो _ts`update()`_ निर्देश के
लिए आवश्यक हैं।

### !rpc

_ts`rpc()`_ विधि लेनदेन को नेटवर्क पर भेजती है।

### !fetch

_ts`fetch()`_ विधि नेटवर्क से खाता डेटा प्राप्त करती है।

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- it("Update Message Account", async () => {});

+ it("Update Message Account", async () => {
+   const message = "Hello, Solana!";
+   const transactionSignature = await program.methods
+     .update(message)
+     .accounts({
+       messageAccount: messagePda,
+     })
+     .rpc({ commitment: "confirmed" });
+
+   const messageAccount = await program.account.messageAccount.fetch(
+     messagePda,
+     "confirmed"
+   );
+
+   console.log(JSON.stringify(messageAccount, null, 2));
+   console.log(
+     "Transaction Signature:",
+     `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
+   );
+ });
```

</Accordion>
<Accordion title="Explanation">

सबसे पहले, टेस्ट फ़ाइल `update` निर्देश को आमंत्रित करते हुए एक लेनदेन भेजती है,
जिसमें "Hello, Solana!" को नए संदेश के रूप में पास किया जाता है।

```ts title="anchor.test.ts"
const message = "Hello, Solana!";
const transactionSignature = await program.methods
  .update(message)
  .accounts({
    messageAccount: messagePda
  })
  .rpc({ commitment: "confirmed" });
```

लेनदेन भेजने और खाते को अपडेट करने के बाद, टेस्ट फ़ाइल इसके पते (`messagePda`)
का उपयोग करके खाता प्राप्त करती है।

```ts title="anchor.test.ts"
const messageAccount = await program.account.messageAccount.fetch(
  messagePda,
  "confirmed"
);
```

अंत में, टेस्ट फ़ाइल खाता डेटा और लेनदेन विवरण के लिए एक लिंक लॉग करती है।

```ts title="anchor.test.ts"
console.log(JSON.stringify(messageAccount, null, 2));
console.log(
  "Transaction Signature:",
  `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
);
```

</Accordion>
</Accordions>

</Step>
<Step>

### डिलीट निर्देश का आह्वान करें

<WithNotes>

तीसरे टेस्ट को निम्नलिखित के साथ अपडेट करें:

```ts title="anchor.test.ts"
it("Delete Message Account", async () => {
  const transactionSignature = await program.methods
    // !tooltip[/delete/] delete
    .delete()
    // !tooltip[/accounts/] accounts
    .accounts({
      messageAccount: messagePda
    })
    // !tooltip[/rpc/] rpc
    .rpc({ commitment: "confirmed" });

  // !tooltip[/fetchNullable/] fetchNullable
  const messageAccount = await program.account.messageAccount.fetchNullable(
    messagePda,
    "confirmed"
  );

  console.log("Expect Null:", JSON.stringify(messageAccount, null, 2));
  console.log(
    "Transaction Signature:",
    `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
  );
});
```

### !delete

_ts`delete()`_ विधि `delete` निर्देश का आह्वान करती है।

### !accounts

_ts`accounts()`_ विधि _ts`delete()`_ निर्देश के लिए आवश्यक खातों को निर्दिष्ट
करती है।

### !rpc

_ts`rpc()`_ विधि लेनदेन को नेटवर्क पर भेजती है।

### !fetchNullable

_ts`fetchNullable()`_ विधि नेटवर्क से खाता डेटा प्राप्त करती है जो मौजूद नहीं भी
हो सकता है।

टेस्ट फ़ाइल इसका उपयोग करती है क्योंकि खाता बंद हो जाता है और डेटा अनुपलब्ध हो
जाता है।

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- it("Delete Message Account", async () => {});

+ it("Delete Message Account", async () => {
+   const transactionSignature = await program.methods
+     .delete()
+     .accounts({
+       messageAccount: messagePda,
+     })
+     .rpc({ commitment: "confirmed" });
+
+   const messageAccount = await program.account.messageAccount.fetchNullable(
+     messagePda,
+     "confirmed"
+   );
+
+   console.log("Expect Null:", JSON.stringify(messageAccount, null, 2));
+   console.log(
+     "Transaction Signature:",
+     `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
+   );
+ });
```

</Accordion>
<Accordion title="Explanation">

सबसे पहले, यह कोड मैसेज खाते को बंद करने के लिए `delete` निर्देश का आह्वान करते
हुए एक लेनदेन भेजता है।

```ts title="anchor.test.ts"
const transactionSignature = await program.methods
  .delete()
  .accounts({
    messageAccount: messagePda
  })
  .rpc({ commitment: "confirmed" });
```

लेनदेन भेजने और खाता बंद करने के बाद, उदाहरण `fetchNullable` के साथ इसके पते
(`messagePda`) का उपयोग करके खाता प्राप्त करने का प्रयास करता है। यह विधि null
लौटाती है जब खाता बंद होने के बाद अब मौजूद नहीं रहता है।

```ts title="anchor.test.ts"
const messageAccount = await program.account.messageAccount.fetchNullable(
  messagePda,
  "confirmed"
);
```

अंत में, टेस्ट फ़ाइल खाता डेटा और लेनदेन विवरण के लिंक को लॉग करती है। खाता डेटा
null के रूप में दिखाई देता है क्योंकि खाता अब मौजूद नहीं है।

```ts title="anchor.test.ts"
console.log(JSON.stringify(messageAccount, null, 2));
console.log(
  "Transaction Signature:",
  `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
);
```

</Accordion>
</Accordions>

</Step>
<Step>

### टेस्ट चलाएँ

अपने टेस्ट तैयार करने के बाद, प्लेग्राउंड टर्मिनल में _shell`test`_ के साथ टेस्ट
फ़ाइल चलाएँ। यह कमांड devnet पर डिप्लॉय किए गए प्रोग्राम के खिलाफ टेस्ट चलाता है
और लेनदेन विवरण देखने के लिए SolanaFM के लिंक लॉग करता है।

```terminal
$ test
Running tests...
  anchor.test.ts:
  pda
    {
  "user": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
  "message": "Hello, World!",
  "bump": 254
}
    Transaction Signature: https://solana.fm/tx/5oBT4jEdUR6CRYsFNGoqvyMBTRDvFqRWTAAmCGM9rEvYRBWy3B2bkb6GVFpVPKBnkr714UCFUurBSDKSa7nLHo8e?cluster=devnet-solana
    ✔ Create Message Account (1025ms)
    {
  "user": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
  "message": "Hello, Solana!",
  "bump": 254
}
    Transaction Signature: https://solana.fm/tx/42veGAsQjHbJP1SxWBGcfYF7EdRN9X7bACNv23NSZNe4U7w2dmaYgSv8UUWXYzwgJPoNHejhtWdKZModHiMaTWYK?cluster=devnet-solana
    ✔ Update Message Account (713ms)
    Expect Null: null
    Transaction Signature: https://solana.fm/tx/Sseog2i2X7uDEn2DyDMMJKVHeZEzmuhnqUwicwGhnGhstZo8URNwUZgED8o6HANiojJkfQbhXVbGNLdhsFtWrd6?cluster=devnet-solana
    ✔ Delete Message Account (812ms)
  3 passing (3s)
```

लेनदेन विवरण देखने के लिए SolanaFM लिंक का निरीक्षण करें।

<Callout type="info">
  ध्यान दें कि इस उदाहरण में, यदि आप टेस्ट फिर से चलाते हैं, तो `create` निर्देश
  विफल हो जाता है क्योंकि `messageAccount` पहले से ही एक खाते के रूप में मौजूद
  है। एक दिए गए PDA के लिए केवल एक खाता मौजूद हो सकता है।
</Callout>

</Step>
</Steps>
