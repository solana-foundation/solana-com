---
title: सीमाएँ
---

Solana ब्लॉकचेन पर प्रोग्राम विकसित करने में कुछ अंतर्निहित सीमाएँ होती हैं।
नीचे सामान्य सीमाओं की एक सूची दी गई है जिनका आप सामना कर सकते हैं।

## Rust लाइब्रेरीज़

चूंकि Rust आधारित ऑनचेन प्रोग्राम को सीमित संसाधन वाले, एकल-थ्रेडेड वातावरण में
निर्धारित रूप से चलाना होता है, इसलिए विभिन्न लाइब्रेरीज़ के उपयोग में कुछ
सीमाएँ हैं।

ऑन-चेन Rust प्रोग्राम Rust के अधिकांश libstd, libcore, और liballoc का समर्थन
करते हैं, साथ ही कई तृतीय-पक्ष क्रेट्स का भी।

कुछ सीमाएँ हैं क्योंकि ये प्रोग्राम सीमित संसाधन वाले, एकल-थ्रेडेड वातावरण में
चलते हैं, और निर्धारित होते हैं:

- इनका एक्सेस नहीं है
  - `rand`
  - `std::fs`
  - `std::net`
  - `std::future`
  - `std::process`
  - `std::sync`
  - `std::task`
  - `std::thread`
  - `std::time`
- सीमित एक्सेस:
  - `std::hash`
  - `std::os`
- Bincode कम्प्यूटेशनल रूप से बहुत अधिक महंगा है, दोनों साइकिल्स और कॉल डेप्थ
  में और इससे बचना चाहिए
- स्ट्रिंग फॉर्मेटिंग से बचना चाहिए क्योंकि यह भी कम्प्यूटेशनल रूप से महंगा है।
- `println!`, `print!` का समर्थन नहीं है, इसके बजाय
  [`msg!`](https://github.com/solana-labs/solana/blob/d9b0fc0e3eec67dfe4a97d9298b15969b2804fab/sdk/program/src/log.rs#L33)
  मैक्रो का उपयोग करें।
- रनटाइम एक निर्देश के प्रसंस्करण के दौरान प्रोग्राम द्वारा निष्पादित किए जा
  सकने वाले निर्देशों की संख्या पर सीमा लागू करता है। अधिक जानकारी के लिए
  [कम्प्यूट बजट](/docs/core/fees#compute-budget) देखें।

## कम्प्यूट बजट

ब्लॉकचेन के कम्प्यूटेशनल संसाधनों के दुरुपयोग को रोकने के लिए, प्रत्येक लेनदेन
को एक [कम्प्यूट बजट](/docs/references/terminology#compute-budget) आवंटित किया
जाता है। इस कम्प्यूट बजट से अधिक होने पर लेनदेन विफल हो जाएगा।

अधिक विशिष्ट विवरण के लिए
[कम्प्यूटेशनल प्रतिबंध](/docs/core/fees#compute-budget) दस्तावेज़ीकरण देखें।

## कॉल स्टैक डेप्थ - `CallDepthExceeded` त्रुटि

Solana प्रोग्राम को तेज़ी से चलने के लिए प्रतिबंधित किया गया है, और इसकी सुविधा
के लिए, प्रोग्राम के कॉल स्टैक को अधिकतम **64 फ्रेम्स** की गहराई तक सीमित किया
गया है।

जब कोई प्रोग्राम अनुमत कॉल स्टैक डेप्थ लिमिट से अधिक हो जाता है, तो उसे
`CallDepthExceeded` त्रुटि प्राप्त होगी।

## CPI कॉल डेप्थ - `CallDepth` त्रुटि

क्रॉस-प्रोग्राम इनवोकेशन प्रोग्राम्स को सीधे अन्य प्रोग्राम्स को इनवोक करने की
अनुमति देता है, लेकिन वर्तमान में डेप्थ `4` तक सीमित है।

जब कोई प्रोग्राम अनुमत [क्रॉस-प्रोग्राम इनवोकेशन कॉल डेप्थ](/docs/core/cpi) से
अधिक हो जाता है, तो उसे `CallDepth` त्रुटि प्राप्त होगी

## फ्लोट रस्ट टाइप्स सपोर्ट

प्रोग्राम रस्ट के फ्लोट ऑपरेशन्स के सीमित सबसेट का समर्थन करते हैं। यदि कोई
प्रोग्राम ऐसे फ्लोट ऑपरेशन का उपयोग करने का प्रयास करता है जो समर्थित नहीं है,
तो रनटाइम एक अनरिज़ॉल्व्ड सिंबल त्रुटि रिपोर्ट करेगा।

फ्लोट ऑपरेशन्स सॉफ्टवेयर लाइब्रेरीज के माध्यम से किए जाते हैं, विशेष रूप से LLVM
के फ्लोट बिल्ट-इन्स। सॉफ्टवेयर एमुलेटेड होने के कारण, वे इंटीजर ऑपरेशन्स की
तुलना में अधिक कंप्यूट यूनिट्स का उपभोग करते हैं। सामान्य तौर पर, जहां संभव हो
फिक्स्ड पॉइंट ऑपरेशन्स की सिफारिश की जाती है।

[Solana Program Library math](https://github.com/solana-labs/solana-program-library/tree/master/libraries/math)
टेस्ट कुछ गणित ऑपरेशन्स के प्रदर्शन की रिपोर्ट करेंगे। टेस्ट चलाने के लिए, रेपो
को सिंक करें और चलाएं:

```shell
cargo test-sbf -- --nocapture --test-threads=1
```

हाल के परिणाम दिखाते हैं कि फ्लोट ऑपरेशन्स इंटीजर समकक्षों की तुलना में अधिक
निर्देशों का उपयोग करते हैं। फिक्स्ड पॉइंट कार्यान्वयन भिन्न हो सकते हैं लेकिन
फ्लोट समकक्षों से कम ही होंगे:

```text
          u64   f32
Multiply    8   176
Divide      9   219
```

## स्टैटिक राइटेबल डेटा

प्रोग्राम शेयर्ड ऑब्जेक्ट्स राइटेबल शेयर्ड डेटा का समर्थन नहीं करते हैं।
प्रोग्राम्स को समान शेयर्ड रीड-ओनली कोड और डेटा का उपयोग करके कई समानांतर
एक्जीक्यूशन के बीच साझा किया जाता है। इसका मतलब है कि डेवलपर्स को प्रोग्राम्स
में कोई भी स्टैटिक राइटेबल या ग्लोबल वेरिएबल्स शामिल नहीं करना चाहिए। भविष्य में
राइटेबल डेटा का समर्थन करने के लिए कॉपी-ऑन-राइट मैकेनिज्म जोड़ा जा सकता है।

## साइन्ड डिवीज़न

SBF इंस्ट्रक्शन सेट साइन्ड डिवीज़न का समर्थन नहीं करता है।
