---
title: अक्सर पूछे जाने वाले प्रश्न
---

[StackExchange](https://solana.stackexchange.com/questions/ask) पर अपने प्रश्न
पोस्ट करें।

## बर्कले पैकेट फिल्टर (BPF)

Solana ऑनचेन प्रोग्राम [LLVM कंपाइलर इंफ्रास्ट्रक्चर](https://llvm.org/) के
माध्यम से
[एक्जीक्यूटेबल एंड लिंकेबल फॉर्मेट (ELF)](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)
में कंपाइल किए जाते हैं, जिसमें
[बर्कले पैकेट फिल्टर (BPF)](https://en.wikipedia.org/wiki/Berkeley_Packet_Filter)
बाइटकोड का एक प्रकार होता है।

चूंकि Solana LLVM कंपाइलर इंफ्रास्ट्रक्चर का उपयोग करता है, इसलिए प्रोग्राम किसी
भी प्रोग्रामिंग भाषा में लिखा जा सकता है जो LLVM के BPF बैकएंड को लक्षित कर सकता
है।

BPF एक कुशल
[इंस्ट्रक्शन सेट](https://github.com/iovisor/bpf-docs/blob/master/eBPF.md)
प्रदान करता है जिसे इंटरप्रेटेड वर्चुअल मशीन में या कुशल जस्ट-इन-टाइम कंपाइल्ड
नेटिव इंस्ट्रक्शंस के रूप में निष्पादित किया जा सकता है।

## मेमोरी मैप

Solana SBF प्रोग्राम द्वारा उपयोग किया जाने वाला वर्चुअल एड्रेस मेमोरी मैप
निश्चित है और निम्नानुसार व्यवस्थित है

- प्रोग्राम कोड 0x100000000 से शुरू होता है
- स्टैक डेटा 0x200000000 से शुरू होता है
- हीप डेटा 0x300000000 से शुरू होता है
- प्रोग्राम इनपुट पैरामीटर्स 0x400000000 से शुरू होते हैं

उपरोक्त वर्चुअल एड्रेस स्टार्ट एड्रेस हैं, लेकिन प्रोग्राम को मेमोरी मैप के एक
सबसेट तक पहुंच दी जाती है। यदि प्रोग्राम किसी ऐसे वर्चुअल एड्रेस को पढ़ने या
लिखने का प्रयास करता है जिस तक उसे पहुंच नहीं दी गई है, तो प्रोग्राम पैनिक हो
जाएगा, और एक "AccessViolation" त्रुटि लौटाई जाएगी जिसमें उल्लंघन के प्रयास का
एड्रेस और आकार शामिल होगा।

## InvalidAccountData

यह प्रोग्राम त्रुटि कई कारणों से हो सकती है। आमतौर पर, यह प्रोग्राम को ऐसा
अकाउंट पास करने से होती है जिसकी प्रोग्राम अपेक्षा नहीं कर रहा है, या तो निर्देश
में गलत स्थिति में या ऐसा अकाउंट जो निष्पादित किए जा रहे निर्देश के साथ संगत
नहीं है।

प्रोग्राम का एक कार्यान्वयन क्रॉस-प्रोग्राम निर्देश करते समय और आप जिस प्रोग्राम
को कॉल कर रहे हैं उसके लिए अकाउंट प्रदान करना भूलने पर भी यह त्रुटि उत्पन्न कर
सकता है।

## InvalidInstructionData

यह प्रोग्राम त्रुटि निर्देश को डीसीरियलाइज़ करने के प्रयास के दौरान हो सकती है,
जांचें कि पास की गई संरचना बिल्कुल निर्देश से मेल खाती है। फ़ील्ड्स के बीच कुछ
पैडिंग हो सकती है। यदि प्रोग्राम Rust `Pack` ट्रेट को लागू करता है तो निर्देश
प्रकार `T` को पैक और अनपैक करके देखें कि प्रोग्राम किस प्रकार की एनकोडिंग की
अपेक्षा करता है।

## MissingRequiredSignature

कुछ निर्देशों के लिए अकाउंट का हस्ताक्षरकर्ता होना आवश्यक है; यह त्रुटि तब लौटाई
जाती है जब किसी अकाउंट से हस्ताक्षरित होने की अपेक्षा की जाती है लेकिन वह नहीं
है।

प्रोग्राम का कार्यान्वयन इस त्रुटि को तब भी उत्पन्न कर सकता है जब ऐसा
[क्रॉस-प्रोग्राम इनवोकेशन](/docs/core/cpi) किया जाता है जिसके लिए हस्ताक्षरित
प्रोग्राम एड्रेस की आवश्यकता होती है, लेकिन `invoke_signed` को पास किए गए
हस्ताक्षरकर्ता बीज प्रोग्राम एड्रेस बनाने के लिए उपयोग किए गए हस्ताक्षरकर्ता
बीजों से मेल नहीं खाते
[`create_program_address`](/docs/core/pda#createprogramaddress)।

## Stack

SBF चर स्टैक पॉइंटर के बजाय स्टैक फ्रेम्स का उपयोग करता है। प्रत्येक स्टैक फ्रेम
4KB आकार का होता है।

यदि कोई प्रोग्राम उस स्टैक फ्रेम के आकार का उल्लंघन करता है, तो कंपाइलर ओवररन को
चेतावनी के रूप में रिपोर्ट करेगा।

उदाहरण के लिए:

```text
Error: Function _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082E Stack offset of -30728 exceeded max offset of -4096 by 26632 bytes, please minimize large stack variables
```

संदेश यह पहचानता है कि कौन सा सिंबल अपने स्टैक फ्रेम से अधिक है, लेकिन नाम विकृत
हो सकता है।

> Rust सिंबल को डीमैंगल करने के लिए
> [rustfilt](https://github.com/luser/rustfilt) का उपयोग करें।

उपरोक्त चेतावनी एक Rust प्रोग्राम से आई थी, इसलिए डीमैंगल्ड सिंबल नाम है:

```shell
rustfilt _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082E
curve25519_dalek::edwards::EdwardsBasepointTable::create
```

चेतावनी को त्रुटि के बजाय रिपोर्ट करने का कारण यह है कि कुछ निर्भर क्रेट्स में
ऐसी कार्यक्षमता शामिल हो सकती है जो स्टैक फ्रेम प्रतिबंधों का उल्लंघन करती है,
भले ही प्रोग्राम उस कार्यक्षमता का उपयोग न करे। यदि प्रोग्राम रनटाइम पर स्टैक
आकार का उल्लंघन करता है, तो एक `AccessViolation` त्रुटि रिपोर्ट की जाएगी।

SBF स्टैक फ्रेम्स एक वर्चुअल एड्रेस रेंज पर कब्जा करते हैं जो `0x200000000` से
शुरू होती है।

## हीप साइज़

प्रोग्राम्स को Rust `alloc` APIs के माध्यम से रनटाइम हीप तक पहुंच प्राप्त होती
है। तेज़ आवंटन की सुविधा के लिए, एक सरल 32KB बंप हीप का उपयोग किया जाता है। हीप
`free` या `realloc` का समर्थन नहीं करता है।

आंतरिक रूप से, प्रोग्राम्स को वर्चुअल एड्रेस 0x300000000 से शुरू होने वाले 32KB
मेमोरी क्षेत्र तक पहुंच प्राप्त होती है और वे प्रोग्राम की विशिष्ट आवश्यकताओं के
आधार पर एक कस्टम हीप लागू कर सकते हैं।

Rust प्रोग्राम्स सीधे एक कस्टम
[`global_allocator`](https://github.com/solana-labs/solana/blob/d9b0fc0e3eec67dfe4a97d9298b15969b2804fab/sdk/program/src/entrypoint.rs#L72)
को परिभाषित करके हीप को लागू करते हैं

## लोडर्स

प्रोग्राम्स को रनटाइम लोडर्स के साथ डिप्लॉय और निष्पादित किया जाता है, वर्तमान
में दो समर्थित लोडर्स हैं
[BPF Loader](https://github.com/solana-labs/solana/blob/7ddf10e602d2ed87a9e3737aa8c32f1db9f909d8/sdk/program/src/bpf_loader.rs#L17)
और
[BPF loader deprecated](https://github.com/solana-labs/solana/blob/7ddf10e602d2ed87a9e3737aa8c32f1db9f909d8/sdk/program/src/bpf_loader_deprecated.rs#L14)

लोडर्स विभिन्न एप्लिकेशन बाइनरी इंटरफेस का समर्थन कर सकते हैं, इसलिए डेवलपर्स को
अपने प्रोग्राम्स को उसी लोडर के लिए लिखना और डिप्लॉय करना चाहिए। यदि एक लोडर के
लिए लिखा गया प्रोग्राम किसी अन्य लोडर पर डिप्लॉय किया जाता है, तो परिणाम आमतौर
पर प्रोग्राम के इनपुट पैरामीटर्स के बेमेल डीसीरियलाइजेशन के कारण एक
`AccessViolation` त्रुटि होती है।

सभी व्यावहारिक उद्देश्यों के लिए प्रोग्राम को हमेशा नवीनतम BPF लोडर को लक्षित
करने के लिए लिखा जाना चाहिए और नवीनतम लोडर कमांड-लाइन इंटरफेस और जावास्क्रिप्ट
APIs के लिए डिफ़ॉल्ट है।

- [Rust प्रोग्राम एंट्रीपॉइंट्स](/docs/programs/lang-rust#program-entrypoint)

### डिप्लॉयमेंट

SBF प्रोग्राम डिप्लॉयमेंट एक प्रोग्राम अकाउंट के डेटा में BPF शेयर्ड ऑब्जेक्ट को
अपलोड करने और अकाउंट को एक्जीक्यूटेबल के रूप में चिह्नित करने की प्रक्रिया है।
एक क्लाइंट SBF शेयर्ड ऑब्जेक्ट को छोटे टुकड़ों में विभाजित करता है और उन्हें
[`Write`](https://github.com/solana-labs/solana/blob/bc7133d7526a041d1aaee807b80922baa89b6f90/sdk/program/src/loader_instruction.rs#L13)
निर्देशों के निर्देश डेटा के रूप में लोडर को भेजता है, जहां लोडर उस डेटा को
प्रोग्राम के अकाउंट डेटा में लिखता है। एक बार सभी टुकड़े प्राप्त हो जाने के बाद,
क्लाइंट लोडर को एक
[`Finalize`](https://github.com/solana-labs/solana/blob/bc7133d7526a041d1aaee807b80922baa89b6f90/sdk/program/src/loader_instruction.rs#L30)
निर्देश भेजता है, फिर लोडर यह सत्यापित करता है कि SBF डेटा वैध है और प्रोग्राम
अकाउंट को _executable_ के रूप में चिह्नित करता है। एक बार प्रोग्राम अकाउंट को
एक्जीक्यूटेबल के रूप में चिह्नित कर दिया जाता है, तो बाद के ट्रांजैक्शन उस
प्रोग्राम के लिए प्रोसेस करने के लिए निर्देश जारी कर सकते हैं।

जब एक निर्देश एक निष्पादन योग्य SBF प्रोग्राम की ओर निर्देशित होता है, तो लोडर
प्रोग्राम के निष्पादन वातावरण को कॉन्फ़िगर करता है, प्रोग्राम के इनपुट
पैरामीटर्स को सीरियलाइज़ करता है, प्रोग्राम के एंट्रीपॉइंट को कॉल करता है, और
किसी भी त्रुटि की रिपोर्ट करता है।

अधिक जानकारी के लिए, [प्रोग्राम डिप्लॉय करना](/docs/programs/deploying) देखें।

### इनपुट पैरामीटर सीरियलाइज़ेशन

SBF लोडर प्रोग्राम इनपुट पैरामीटर्स को एक बाइट ऐरे में सीरियलाइज़ करते हैं जो
फिर प्रोग्राम के एंट्रीपॉइंट को पास किया जाता है, जहां प्रोग्राम ऑन-चेन इसे
डीसीरियलाइज़ करने के लिए जिम्मेदार होता है। पुराने लोडर और वर्तमान लोडर के बीच
एक परिवर्तन यह है कि इनपुट पैरामीटर्स को इस तरह से सीरियलाइज़ किया जाता है जिससे
विभिन्न पैरामीटर्स संरेखित बाइट ऐरे के भीतर संरेखित ऑफसेट पर पड़ते हैं। यह
डीसीरियलाइज़ेशन कार्यान्वयन को सीधे बाइट ऐरे का संदर्भ देने और प्रोग्राम को
संरेखित पॉइंटर प्रदान करने की अनुमति देता है।

- [Rust प्रोग्राम पैरामीटर डीसीरियलाइज़ेशन](/docs/programs/lang-rust#parameter-deserialization)

नवीनतम लोडर प्रोग्राम इनपुट पैरामीटर्स को निम्नानुसार सीरियलाइज़ करता है (सभी
एनकोडिंग लिटिल एंडियन है):

- 8 बाइट्स अनसाइन्ड नंबर ऑफ अकाउंट्स
- प्रत्येक अकाउंट के लिए
  - 1 बाइट जो इंगित करता है कि यह एक डुप्लिकेट अकाउंट है या नहीं, अगर डुप्लिकेट
    नहीं है तो मान 0xff है, अन्यथा मान उस अकाउंट का इंडेक्स है जिसका यह
    डुप्लिकेट है।
  - यदि डुप्लिकेट है: 7 बाइट्स पैडिंग
  - यदि डुप्लिकेट नहीं है:
    - 1 बाइट बूलियन, सत्य यदि अकाउंट एक साइनर है
    - 1 बाइट बूलियन, सत्य यदि अकाउंट राइटेबल है
    - 1 बाइट बूलियन, सत्य यदि अकाउंट एक्ज़ेक्यूटेबल है
    - 4 बाइट्स पैडिंग
    - 32 बाइट्स अकाउंट पब्लिक की
    - 32 बाइट्स अकाउंट के ओनर की पब्लिक की
    - 8 बाइट्स अनसाइन्ड नंबर ऑफ lamport अकाउंट द्वारा स्वामित्व
    - 8 बाइट्स अनसाइन्ड नंबर ऑफ बाइट्स ऑफ अकाउंट डेटा
    - x बाइट्स अकाउंट डेटा
    - 10k बाइट्स पैडिंग, रीएलोक के लिए उपयोग किया जाता है
    - ऑफसेट को 8 बाइट्स से संरेखित करने के लिए पर्याप्त पैडिंग।
    - 8 बाइट्स रेंट एपोक
- 8 बाइट्स अनसाइन्ड नंबर ऑफ instruction data
- x बाइट्स instruction data
- 32 बाइट्स प्रोग्राम आईडी
