---
title: Rust 程序
description:
  学习如何使用 Rust 开发 Solana 程序，包括创建、构建、测试和部署 Solana
  区块链上智能合约的分步 说明。
h1: 使用 Rust 开发程序
---

Solana 程序主要使用 Rust 编程语言开发。本页面专注于不使用 Anchor 框架编写 Solana 程序，这种方法通常被称为编写"原生 Rust"程序。

原生 Rust 开发为开发者提供了对 Solana 程序的直接控制。然而，与使用 Anchor 框架相比，这种方法需要更多的手动设置和样板代码。这种方法推荐给以下开发者：

* 寻求对程序逻辑和优化的精细控制
* 希望在转向更高级框架之前学习底层概念

对于初学者，我们建议从 Anchor 框架开始。有关更多信息，请参阅
[Anchor](https://www.anchor-lang.com/docs) 部分。

## 前提条件

有关详细的安装说明，请访问 [安装](/docs/intro/installation) 页面。

在开始之前，请确保您已安装以下内容：

* Rust：用于构建 Solana 程序的编程语言。
* Solana CLI：Solana 开发的命令行工具。

## 入门指南

以下示例涵盖了创建您的第一个用 Rust 编写的 Solana 程序的基本步骤。我们将创建一个最小的程序，向程序日志打印"Hello,
world!"。

<Steps>
  <Step>
    ### 创建新程序

    首先，使用标准的 `cargo init` 命令和
    `--lib` 标志创建一个新的 Rust 项目。

    ```shell title="Terminal"
    cargo init hello_world --lib
    ```

    导航到项目目录。您应该看到默认的`src/lib.rs`和
    `Cargo.toml`文件

    ```shell title="Terminal"
    cd hello_world
    ```

    接下来，添加`solana-program`依赖项。这是构建Solana程序所需的最小依赖项。

    ```shell title="Terminal"
    cargo add solana-program@1.18.26
    ```

    接下来，将以下代码片段添加到`Cargo.toml`中。如果不包含此配置，在构建程序时将不会生成`target/deploy`目录。

    ```toml title="Cargo.toml"
    [lib]
    crate-type = ["cdylib", "lib"]
    ```

    你的`Cargo.toml`文件应该如下所示：

    ```toml title="Cargo.toml"
    [package]
    name = "hello_world"
    version = "0.1.0"
    edition = "2021"

    [lib]
    crate-type = ["cdylib", "lib"]

    [dependencies]
    solana-program = "1.18.26"
    ```

    接下来，用以下代码替换`src/lib.rs`的内容。这是一个最小的Solana程序，当程序被调用时，它会在程序日志中打印"Hello, world!"。

    `msg!`宏在Solana程序中用于向程序日志打印消息。

    ```rs title="lib.rs"
    use solana_program::{
        account_info::AccountInfo, entrypoint, entrypoint::ProgramResult, msg, pubkey::Pubkey,
    };

    entrypoint!(process_instruction);

    pub fn process_instruction(
        _program_id: &Pubkey,
        _accounts: &[AccountInfo],
        _instruction_data: &[u8],
    ) -> ProgramResult {
        msg!("Hello, world!");
        Ok(())
    }
    ```
  </Step>

  <Step>
    ### 构建程序

    接下来，使用`cargo build-sbf`命令构建程序。

    ```shell title="Terminal"
    cargo build-sbf
    ```

    此命令会生成一个`target/deploy`目录，其中包含两个重要文件：

    1. 一个`.so`文件（例如，`hello_world.so`）：这是编译好的Solana程序，将作为"智能合约"部署到网络上。
    2. 一个密钥对文件（例如，`hello_world-keypair.json`）：部署程序时，此密钥对的公钥将用作程序ID。

    要查看程序ID，请在终端中运行以下命令。此命令会打印指定文件路径中密钥对的公钥：

    ```shell title="Terminal"
    solana address -k ./target/deploy/hello_world-keypair.json
    ```

    示例输出：

    ```
    4Ujf5fXfLx2PAwRqcECCLtgDxHKPznoJpa43jUBxFfMz
    ```
  </Step>

  <Step>
    ### 测试程序

    接下来，使用`solana-program-test`crate测试程序。添加以下依赖项到`Cargo.toml`。

    ```shell title="Terminal"
    cargo add solana-program-test@1.18.26 --dev
    cargo add solana-sdk@1.18.26 --dev
    cargo add tokio --dev
    ```

    在`src/lib.rs`中，在程序代码下方添加以下测试。这是一个调用hello world程序的测试模块。

    ```rs title="lib.rs"
    #[cfg(test)]
    mod test {
        use solana_program_test::*;
        use solana_sdk::{
            instruction::Instruction, pubkey::Pubkey, signature::Signer, transaction::Transaction,
        };

        #[tokio::test]
        async fn test_hello_world() {
            let program_id = Pubkey::new_unique();
            let mut program_test = ProgramTest::default();
            program_test.add_program("hello_world", program_id, None);
            let (mut banks_client, payer, recent_blockhash) = program_test.start().await;
            // Create instruction
            let instruction = Instruction {
                program_id,
                accounts: vec![],
                data: vec![],
            };
            // Create transaction with instruction
            let mut transaction = Transaction::new_with_payer(&[instruction], Some(&payer.pubkey()));

            // Sign transaction
            transaction.sign(&[&payer], recent_blockhash);

            let transaction_result = banks_client.process_transaction(transaction).await;
            assert!(transaction_result.is_ok());
        }
    }
    ```

    使用`cargo test-sbf`命令运行测试。程序日志将显示"Hello, world!"。

    ```shell title="Terminal"
    cargo test-sbf
    ```

    示例输出：

    ```shell title="Terminal" {4} /Program log: Hello, world!/
    running 1 test
    [2024-10-18T21:24:54.889570000Z INFO  solana_program_test] "hello_world" SBF program from /hello_world/target/deploy/hello_world.so, modified 35 seconds, 828 ms, 268 µs and 398 ns ago
    [2024-10-18T21:24:54.974294000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM invoke [1]
    [2024-10-18T21:24:54.974814000Z DEBUG solana_runtime::message_processor::stable_log] Program log: Hello, world!
    [2024-10-18T21:24:54.976848000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM consumed 140 of 200000 compute units
    [2024-10-18T21:24:54.976868000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM success
    test test::test_hello_world ... ok

    test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.13s
    ```
  </Step>

  <Step>
    ### 部署程序

    接下来，部署程序。在本地开发时，我们可以使用`solana-test-validator`。

    首先，配置Solana CLI使用本地Solana集群。

    ```shell title="Terminal"
    solana config set -ul
    ```

    示例输出：

    ```
    Config File: /.config/solana/cli/config.yml
    RPC URL: http://localhost:8899
    WebSocket URL: ws://localhost:8900/ (computed)
    Keypair Path: /.config/solana/id.json
    Commitment: confirmed
    ```

    打开一个新终端并运行`solana-test-validators`命令来启动
    本地验证器。

    ```shell title="Terminal"
    solana-test-validator
    ```

    在测试验证器运行时，在
    另一个终端中运行`solana program deploy`命令
    将程序部署到本地验证器。

    ```shell title="Terminal"
    solana program deploy ./target/deploy/hello_world.so
    ```

    输出示例：

    ```
    Program Id: 4Ujf5fXfLx2PAwRqcECCLtgDxHKPznoJpa43jUBxFfMz
    Signature:
    5osMiNMiDZGM7L1e2tPHxU8wdB8gwG8fDnXLg5G7SbhwFz4dHshYgAijk4wSQL5cXiu8z1MMou5kLadAQuHp7ybH
    ```

    你可以在[Solana Explorer](https://explorer.solana.com/?cluster=custom\&customUrl=http%3A%2F%2Flocalhost%3A8899)上查看程序ID和交易签名。
    请注意，Solana Explorer上的集群也必须设置为localhost。Solana Explorer上的"自定义RPC
    URL"选项默认为`http://localhost:8899`。
  </Step>

  <Step>
    ### 调用程序

    接下来，我们将演示如何使用Rust客户端调用程序。

    首先创建一个`examples`目录和一个`client.rs`文件。

    ```shell title="Terminal"
    mkdir -p examples
    touch examples/client.rs
    ```

    将以下内容添加到`Cargo.toml`中。

    ```toml title="Cargo.toml"
    [[example]]
    name = "client"
    path = "examples/client.rs"
    ```

    添加`solana-client`依赖。

    ```shell title="Terminal"
    cargo add solana-client@1.18.26 --dev
    ```

    将以下代码添加到`examples/client.rs`。这是一个Rust客户端脚本，它为一个新的密钥对提供资金以支付交易费用，然后调用hello world程序。

    ```rs title="example/client.rs"
    use solana_client::rpc_client::RpcClient;
    use solana_sdk::{
        commitment_config::CommitmentConfig,
        instruction::Instruction,
        pubkey::Pubkey,
        signature::{Keypair, Signer},
        transaction::Transaction,
    };
    use std::str::FromStr;

    #[tokio::main]
    async fn main() {
        // 程序ID（替换为你的实际程序ID）
        let program_id = Pubkey::from_str("4Ujf5fXfLx2PAwRqcECCLtgDxHKPznoJpa43jUBxFfMz").unwrap();

        // 连接到Solana开发网络
        let rpc_url = String::from("http://127.0.0.1:8899");
        let client = RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed());

        // 为付款人生成新的密钥对
        let payer = Keypair::new();

        // 请求空投
        let airdrop_amount = 1_000_000_000; // 1 SOL
        let signature = client
            .request_airdrop(&payer.pubkey(), airdrop_amount)
            .expect("Failed to request airdrop");

        // 等待空投确认
        loop {
            let confirmed = client.confirm_transaction(&signature).unwrap();
            if confirmed {
                break;
            }
        }

        // 创建指令
        let instruction = Instruction::new_with_borsh(
            program_id,
            &(),    // 空指令数据
            vec![], // 不需要账户
        );

        // 将指令添加到新交易中
        let mut transaction = Transaction::new_with_payer(&[instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer], client.get_latest_blockhash().unwrap());

        // 发送并确认交易
        match client.send_and_confirm_transaction(&transaction) {
            Ok(signature) => println!("交易签名: {}", signature),
            Err(err) => eprintln!("发送交易错误: {}", err),
        }
    }
    ```

    在运行脚本之前，请将上面代码片段中的程序ID替换为你的程序ID。

    你可以通过运行以下命令获取你的程序ID。

    ```shell title="Terminal"
    solana address -k ./target/deploy/hello_world-keypair.json
    ```

    ```diff
    #[tokio::main]
    async fn main() {
    -     let program_id = Pubkey::from_str("4Ujf5fXfLx2PAwRqcECCLtgDxHKPznoJpa43jUBxFfMz").unwrap();
    +     let program_id = Pubkey::from_str("YOUR_PROGRAM_ID).unwrap();
        }
    }
    ```

    使用以下命令运行客户端脚本。

    ```shell title="Terminal"
    cargo run --example client
    ```

    示例输出：

    ```
    交易签名：54TWxKi3Jsi3UTeZbhLGUFX6JQH7TspRJjRRFZ8NFnwG5BXM9udxiX77bAACjKAS9fGnVeEazrXL4SfKrW7xZFYV
    ```

    你可以在
    [Solana Explorer](https://explorer.solana.com/?cluster=custom\&customUrl=http%3A%2F%2Flocalhost%3A8899)
    （本地集群）上查看交易签名，以在程序日志中看到"Hello, world!"。
  </Step>

  <Step>
    ### 更新程序

    Solana程序可以通过重新部署到相同的程序ID来更新。更新
    `src/lib.rs`中的程序，将"Hello, world!"改为"Hello, Solana!"。

    ```diff title="lib.rs"
    pub fn process_instruction(
        _program_id: &Pubkey,
        _accounts: &[AccountInfo],
        _instruction_data: &[u8],
    ) -> ProgramResult {
    -   msg!("Hello, world!");
    +   msg!("Hello, Solana!");
        Ok(())
    }
    ```

    通过运行`cargo test-sbf`命令测试更新后的程序。

    ```shell title="Terminal"
    cargo test-sbf
    ```

    你应该在程序日志中看到"Hello, Solana!"。

    ```shell title="Terminal" {4}
    运行1个测试
    [2024-10-23T19:28:28.842639000Z INFO  solana_program_test] "hello_world" SBF程序来自/code/misc/delete/hello_world/target/deploy/hello_world.so，修改于4分钟，31秒，435毫秒，566微秒和766纳秒前
    [2024-10-23T19:28:28.934854000Z DEBUG solana_runtime::message_processor::stable_log] 程序1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM调用[1]
    [2024-10-23T19:28:28.936735000Z DEBUG solana_runtime::message_processor::stable_log] 程序日志：Hello, Solana!
    [2024-10-23T19:28:28.938774000Z DEBUG solana_runtime::message_processor::stable_log] 程序1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM消耗了200000计算单元中的140个
    [2024-10-23T19:28:28.938793000Z DEBUG solana_runtime::message_processor::stable_log] 程序1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM成功
    test test::test_hello_world ... ok

    测试结果：ok。1通过；0失败；0忽略；0测量；0过滤；在0.14秒内完成
    ```

    运行`cargo build-sbf`命令生成更新后的`.so`文件。

    ```shell title="Terminal"
    cargo build-sbf
    ```

    使用`solana program deploy` 命令。

    ```shell title="Terminal"
    solana program deploy ./target/deploy/hello_world.so
    ```

    再次运行客户端代码并在 Solana Explorer 上检查交易签名，以在程序日志中看到 "Hello, Solana!"。

    ```shell title="Terminal"
    cargo run --example client
    ```
  </Step>

  <Step>
    ### 关闭程序

    您可以关闭 Solana 程序以回收分配给该账户的 SOL。关闭程序是不可逆的，因此应谨慎操作。

    要关闭程序，请使用 `solana program close <PROGRAM_ID>` 命令。例如：

    ```shell title="Terminal"
    solana program close 4Ujf5fXfLx2PAwRqcECCLtgDxHKPznoJpa43jUBxFfMz
    --bypass-warning
    ```

    示例输出：

    ```
    Closed Program Id 4Ujf5fXfLx2PAwRqcECCLtgDxHKPznoJpa43jUBxFfMz, 0.1350588 SOL
    reclaimed
    ```

    请注意，一旦程序关闭，其程序 ID 将无法重复使用。尝试使用先前已关闭的程序 ID 部署程序将导致错误。

    ```
    Error: Program 4Ujf5fXfLx2PAwRqcECCLtgDxHKPznoJpa43jUBxFfMz has been closed, use
    a new Program Id
    ```

    如果您在关闭程序后需要使用相同的源代码重新部署程序，则必须生成一个新的程序 ID。要为程序生成新的密钥对，请运行以下命令：

    ```shell title="Terminal"
    solana-keygen new -o ./target/deploy/hello_world-keypair.json --force
    ```

    或者，您可以删除现有的密钥对文件（例如 `./target/deploy/hello_world-keypair.json`）并再次运行 `cargo build-sbf`，这将生成一个新的密钥对文件。
  </Step>
</Steps>
