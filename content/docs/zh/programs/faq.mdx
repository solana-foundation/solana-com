---
title: "常见问题"
---

在
[StackExchange](https://solana.stackexchange.com/questions/ask)上提出您的问题。

## 伯克利数据包过滤器（BPF）

Solana链上程序通过 [LLVM编译器基础架构](https://llvm.org/)编译为包含
[可执行与可链接格式（ELF）](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)
的文件，其中包含
[伯克利数据包过滤器（BPF）](https://en.wikipedia.org/wiki/Berkeley_Packet_Filter)
字节码的变体。

由于Solana使用LLVM编译器基础架构，程序可以用任何能够针对LLVM的BPF后端的编程语言编写。

BPF提供了一个高效的
[指令集](https://github.com/iovisor/bpf-docs/blob/master/eBPF.md)，可以在解释型虚拟机中执行，或作为高效的即时编译原生指令执行。

## 内存映射

Solana SBF程序使用的虚拟地址内存映射是固定的，布局如下

* 程序代码从0x100000000开始
* 栈数据从0x200000000开始
* 堆数据从0x300000000开始
* 程序输入参数从0x400000000开始

上述虚拟地址是起始地址，但程序只能访问内存映射的一个子集。如果程序尝试读取或写入未被授权访问的虚拟地址，程序将会崩溃，并返回一个
`AccessViolation`错误，其中包含尝试违规访问的地址和大小。

## InvalidAccountData

这种程序错误可能由多种原因引起。通常，它是由于向程序传递了程序未预期的账户所致，可能是指令中位置错误的账户或与正在执行的指令不兼容的账户。

程序的实现也可能在执行跨程序指令时忘记提供您正在调用的程序的账户，从而导致此错误。

## InvalidInstructionData

这种程序错误可能在尝试反序列化指令时发生，请检查传入的结构是否与指令完全匹配。字段之间可能存在一些填充。如果程序实现了Rust的`Pack`特性，那么尝试打包和解包指令类型`T`以确定程序期望的确切编码。

## MissingRequiredSignature

某些指令要求账户是签名者；如果预期账户已签名但实际未签名，则会返回此错误。

程序的实现也可能在执行需要签名程序地址的[跨程序调用](/docs/core/cpi)时导致此错误，但传递给`invoke_signed`的签名者种子与用于创建程序地址的签名者种子不匹配[`create_program_address`](/docs/core/pda#createprogramaddress)。

## 栈

SBF使用栈帧而不是可变栈指针。每个栈帧大小为4KB。

如果程序违反了该栈帧大小，编译器将以警告形式报告溢出。

例如：

```text
Error: Function _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082E Stack offset of -30728 exceeded max offset of -4096 by 26632 bytes, please minimize large stack variables
```

该消息标识出哪个符号超出了其堆栈帧，但名称可能被修饰过。

> 要还原Rust符号的原始名称，请使用[rustfilt](https://github.com/luser/rustfilt)。

上述警告来自Rust程序，因此还原后的符号名称是：

```shell
rustfilt _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082E
curve25519_dalek::edwards::EdwardsBasepointTable::create
```

之所以报告警告而不是错误，是因为某些依赖包可能包含违反堆栈帧限制的功能，即使程序没有使用该功能。如果程序在运行时违反堆栈大小限制，将会报告`AccessViolation`错误。

SBF堆栈帧占用的虚拟地址范围从`0x200000000`开始。

## 堆大小

程序可以通过Rust的`alloc`API访问运行时堆。为了实现快速分配，系统使用了一个简单的32KB的bump堆。该堆不支持
`free`或`realloc`。

在内部，程序可以访问从虚拟地址0x300000000开始的32KB内存区域，并可以根据程序的特定需求实现自定义堆。

Rust程序通过定义自定义的
[`global_allocator`](https://github.com/solana-labs/solana/blob/d9b0fc0e3eec67dfe4a97d9298b15969b2804fab/sdk/program/src/entrypoint.rs#L72)

## 加载器

程序由运行时加载器部署和执行，目前支持两种加载器
[BPF 加载器](https://github.com/solana-labs/solana/blob/7ddf10e602d2ed87a9e3737aa8c32f1db9f909d8/sdk/program/src/bpf_loader.rs#L17)
和
[已弃用的 BPF 加载器](https://github.com/solana-labs/solana/blob/7ddf10e602d2ed87a9e3737aa8c32f1db9f909d8/sdk/program/src/bpf_loader_deprecated.rs#L14)

加载器可能支持不同的应用程序二进制接口，因此开发者必须为特定加载器编写程序并将其部署到相同的加载器上。如果为一个加载器编写的程序被部署到另一个不同的加载器上，通常会导致
`AccessViolation` 错误，这是由于程序输入参数的反序列化不匹配造成的。

出于实际目的，程序应始终编写为针对最新的 BPF 加载器，而最新的加载器是命令行界面和 JavaScript
API 的默认选项。

* [Rust 程序入口点](/docs/programs/lang-rust#program-entrypoint)

### 部署

SBF 程序部署是将 BPF 共享对象上传到程序账户的数据中并将该账户标记为可执行的过程。客户端将 SBF 共享对象分解为更小的片段，并将它们作为指令数据发送给
[`Write`](https://github.com/solana-labs/solana/blob/bc7133d7526a041d1aaee807b80922baa89b6f90/sdk/program/src/loader_instruction.rs#L13)
指令到加载器，加载器将这些数据写入程序的账户数据中。一旦接收到所有片段，客户端会发送一个
[`Finalize`](https://github.com/solana-labs/solana/blob/bc7133d7526a041d1aaee807b80922baa89b6f90/sdk/program/src/loader_instruction.rs#L30)
指令到加载器，加载器随后验证 SBF 数据是否有效并将程序账户标记为*可执行*。一旦程序账户被标记为可执行，后续交易就可以发出该程序处理的指令。

当指令指向一个可执行的 SBF 程序时，加载器配置程序的执行环境，序列化程序的输入参数，调用程序的入口点，并报告遇到的任何错误。

更多信息，请参阅[部署程序](/docs/programs/deploying)。

### 输入参数序列化

SBF 加载器将程序输入参数序列化为字节数组，然后传递给程序的入口点，程序负责在链上对其进行反序列化。已弃用的加载器和当前加载器之间的一个变化是，输入参数的序列化方式使各种参数落在对齐字节数组内的对齐偏移量上。这允许反序列化实现直接引用字节数组并向程序提供对齐的指针。

* [Rust程序参数反序列化](/docs/programs/lang-rust#parameter-deserialization)

最新的加载器按以下方式序列化程序输入参数（所有编码均为小端序）：

* 8字节无符号账户数量
* 对于每个账户
  * 1字节表示这是否为重复账户，如果不是重复账户，则值为0xff，否则值为它所复制的账户索引。
  * 如果是重复账户：7字节填充
  * 如果不是重复账户：
    * 1字节布尔值，如果账户是签名者则为true
    * 1字节布尔值，如果账户可写则为true
    * 1字节布尔值，如果账户可执行则为true
    * 4字节填充
    * 32字节的账户公钥
    * 32字节的账户所有者公钥
    * 8字节无符号数，表示账户拥有的lamports数量
    * 8字节无符号数，表示账户数据的字节数
    * x字节的账户数据
    * 10k字节的填充，用于重新分配
    * 足够的填充以将偏移量对齐到8字节。
    * 8字节租金周期
* 8字节无符号数，表示指令数据的大小
* x字节的指令数据
* 32字节的程序ID
