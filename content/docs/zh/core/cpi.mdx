---
title: Cross Program Invocation
description:
  了解Solana上的Cross Program Invocation (CPI) -
  程序如何调用其他程序的指令、处理PDA签名者以及在Solana网络上组合功能。
h1: Cross Program Invocation (CPI)
---

跨程序调用（Cross Program
Invocation，CPI）是指一个程序调用另一个程序的指令。这使得Solana程序之间能够实现组合性。

你可以将指令视为程序向网络公开的API端点，而CPI则是一个API内部调用另一个API。

![Cross Program Invocation](/assets/docs/core/cpi/cpi.svg)

## 关键要点

* **跨程序调用**使Solana程序指令能够直接调用另一个程序的指令。
* **签名者权限**从调用者程序延伸到被调用程序。
* 在进行跨程序调用时，**程序可以代表**由其自身程序ID派生的
* 被调用程序可以进一步向其他程序发起CPI，最大深度为4。

## 什么是CPI？

跨程序调用（CPI）是指一个程序调用另一个程序的指令。

使用CPI编写程序指令遵循与构建[指令](/docs/core/transactions#instruction)添加到交易相同的模式。在底层，每个CPI指令必须指定：

* **程序地址**：指定要调用的程序
* **账户**：列出指令读取或写入的每个账户，包括其他程序
* **指令数据**：指定要在程序上调用的指令，以及指令需要的任何数据（函数参数）

当程序向另一个程序发起跨程序调用（CPI）时：

* 初始交易的签名者权限延伸到被调用程序（例如 A->B）
* 被调用程序可以向其他程序发起进一步的CPI，最大深度为4（例如 B->C, C->D）
* 程序可以代表从其程序ID派生的[PDA](/docs/core/pda)进行"签名"

<Callout>
  Solana程序运行时设置了
  [`max_instruction_stack_depth`](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L38)
  常量
  [MAX\_INSTRUCTION\_STACK\_DEPTH](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L13)
  为5。这代表程序指令调用栈的最大高度。栈高度从初始交易的1开始，每当程序调用另一个指令时增加1。此设置将CPI的调用深度限制为4。
</Callout>

当处理交易时，账户权限从一个程序延伸到另一个程序。这意味着：

假设程序A接收到一条指令，其中包含：

* 一个签署了交易的账户
* 一个可以被写入的账户（可变的）

当程序A向程序B发起CPI时：

* 程序B可以使用这些相同的账户及其原始权限
* 程序B可以使用签名者账户进行签名
* 程序B可以写入可写账户
* 如果程序B发起自己的CPI，它甚至可以将这些相同的权限传递下去

## Cross Program Invocations

函数
[`invoke`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/program.rs#L26-L28)
处理不需要PDA签名者的CPI。该函数调用
`invoke_signed`函数，并传入一个空的`signers_seeds`数组，表示不需要PDA进行签名。

```rust title="Invoke Function"
pub fn invoke(instruction: &Instruction, account_infos: &[AccountInfo]) -> ProgramResult {
    invoke_signed(instruction, account_infos, &[])
}
```

以下示例展示了如何使用
[Anchor Framework](https://www.anchor-lang.com/docs)和原生Rust进行CPI调用。这些示例程序包含一个单一指令，通过CPI将SOL从一个账户转移到另一个账户。

### 以下示例展示了如何使用

Anchor框架

* 示例1：使用Anchor的*rs`CpiContext`*&#x548C;辅助函数构建CPI指令。
* 示例2：使用*rs`system_instruction::transfer`*&#x51FD;数（来自
  `solana_program`crate）构建CPI指令。示例1抽象了这种实现。
* 示例3：手动构建CPI指令。当没有现成的crate帮助构建指令时，这种方法很有用。

<CodeTabs>
  ```rs !! title="Example 1"
  use anchor_lang::prelude::*;
  use anchor_lang::system_program::{transfer, Transfer};

  declare_id!("9AvUNHjxscdkiKQ8tUn12QCMXtcnbR9BVGq3ULNzFMRi");

  #[program] pub mod cpi { use super::\*;

      pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
          let from_pubkey = ctx.accounts.sender.to_account_info();
          let to_pubkey = ctx.accounts.recipient.to_account_info();
          let program_id = ctx.accounts.system_program.to_account_info();

          let cpi_context = CpiContext::new(
              program_id,
              Transfer {
                  from: from_pubkey,
                  to: to_pubkey,
              },
          );

          transfer(cpi_context, amount)?;
          Ok(())
      }

  }

  #[derive(Accounts)] pub struct SolTransfer<'info> { #[account(mut)] sender:
  Signer<'info>, #[account(mut)] recipient: SystemAccount<'info>, system_program:
  Program<'info, System>, }

  ```

  ```rs !! title="Example 2"
  use anchor_lang::prelude::*;
  use anchor_lang::solana_program::{program::invoke, system_instruction};

  declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

  #[program]
  pub mod cpi {
      use super::*;

      pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
          let from_pubkey = ctx.accounts.sender.to_account_info();
          let to_pubkey = ctx.accounts.recipient.to_account_info();
          let program_id = ctx.accounts.system_program.to_account_info();

          let instruction =
              &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

          invoke(instruction, &[from_pubkey, to_pubkey, program_id])?;
          Ok(())
      }
  }

  #[derive(Accounts)]
  pub struct SolTransfer<'info> {
      #[account(mut)]
      sender: Signer<'info>,
      #[account(mut)]
      recipient: SystemAccount<'info>,
      system_program: Program<'info, System>,
  }
  ```

  ```rs !! title="Example 3"
  use anchor_lang::prelude::*;
  use anchor_lang::solana_program::{program::invoke, instruction::Instruction};

  declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

  #[program]
  pub mod cpi {
      use super::*;

      pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
          let from_pubkey = ctx.accounts.sender.to_account_info();
          let to_pubkey = ctx.accounts.recipient.to_account_info();
          let program_id = ctx.accounts.system_program.to_account_info();

          // Prepare instruction AccountMetas
          let account_metas = vec![
              AccountMeta::new(from_pubkey.key(), true),
              AccountMeta::new(to_pubkey.key(), false),
          ];

          // SOL transfer instruction discriminator
          let instruction_discriminator: u32 = 2;

          // Prepare instruction data
          let mut instruction_data = Vec::with_capacity(4 + 8);
          instruction_data.extend_from_slice(&instruction_discriminator.to_le_bytes());
          instruction_data.extend_from_slice(&amount.to_le_bytes());

          // Create instruction
          let instruction = Instruction {
              program_id: program_id.key(),
              accounts: account_metas,
              data: instruction_data,
          };

          // Invoke instruction
          invoke(&instruction, &[from_pubkey, to_pubkey, program_id])?;
          Ok(())
      }
  }

  #[derive(Accounts)]
  pub struct SolTransfer<'info> {
      #[account(mut)]
      sender: Signer<'info>,
      #[account(mut)]
      recipient: SystemAccount<'info>,
      system_program: Program<'info, System>,
  }
  ```

  ```ts !! title="Test"
  import * as anchor from "@coral-xyz/anchor";
  import { BN, Program } from "@coral-xyz/anchor";
  import { Cpi } from "../target/types/cpi";
  import { Keypair, LAMPORTS_PER_SOL } from "@solana/web3.js";

  describe("cpi", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.Cpi as Program<Cpi>;
    const sender = provider.wallet as anchor.Wallet;
    const recipient = new Keypair();

    const transferAmount = 0.01 * LAMPORTS_PER_SOL;

    it("SOL Transfer Anchor", async () => {
      const transactionSignature = await program.methods
        .solTransfer(new BN(transferAmount))
        .accounts({
          sender: sender.publicKey,
          recipient: recipient.publicKey
        })
        .rpc();

      console.log(`\nTransaction Signature: ${transactionSignature}`);
    });
  });
  ```
</CodeTabs>

### use anchor\_lang::prelude::\*;&#xA;use anchor\_lang::system\_program::\{transfer, Transfer};&#xA;&#xA;declare\_id!("9AvUNHjxscdkiKQ8tUn12QCMXtcnbR9BVGq3ULNzFMRi");&#xA;&#xA;#\[program]&#xA;pub mod cpi \{&#xA; use super::\*;&#xA;&#xA; pub fn sol\_transfer(ctx: Context\<SolTransfer>, amount: u64) -> Result\<()> \{&#xA; let from\_pubkey = ctx.accounts.sender.to\_account\_info();&#xA; let to\_pubkey = ctx.accounts.recipient.to\_account\_info();&#xA; let program\_id = ctx.accounts.system\_program.to\_account\_info();&#xA;&#xA; let cpi\_context = CpiContext::new(&#xA; program\_id,&#xA; Transfer \{&#xA; from: from\_pubkey,&#xA; to: to\_pubkey,&#xA; },&#xA; );&#xA;&#xA; transfer(cpi\_context, amount)?;&#xA; Ok(())&#xA; }&#xA;}&#xA;&#xA;#\[derive(Accounts)]&#xA;pub struct SolTransfer\<'info> \{&#xA; \#\[account(mut)]&#xA; sender: Signer\<'info>,&#xA; \#\[account(mut)]&#xA; recipient: SystemAccount\<'info>,&#xA; system\_program: Program\<'info, System>,&#xA;}

原生 Rust[LiteSVM](https://github.com/LiteSVM/litesvm) 来测试程序。

<CodeTabs>
  ```rs !! title="Example"
  以下示例展示了如何从使用原生 Rust 编写的程序中进行 CPI（跨程序调用）。该程序包含一个单一指令，通过 CPI 将 SOL 从一个账户转移到另一个账户。测试文件使用

  ```

  ```ts !! title="Test"
  import * as path from "path";
  import {
    Keypair,
    LAMPORTS_PER_SOL,
    PublicKey,
    SystemProgram,
    Transaction,
    TransactionInstruction
  } from "@solana/web3.js";
  import { LiteSVM } from "litesvm";

  test("sol transfer cpi", () => {
    const svm = new LiteSVM();

    const programId = PublicKey.unique();
    const programPath = path.join(__dirname, "program.so");
    svm.addProgramFromFile(programId, programPath);

    // Create sender and recipient
    const sender = new Keypair();
    const recipient = new Keypair();

    // Fund sender
    const amount = BigInt(LAMPORTS_PER_SOL);
    svm.airdrop(sender.publicKey, amount); // 1 SOL

    // Create instruction data buffer
    const transferAmount = amount / BigInt(2); // 0.5 SOL
    const instructionIndex = 0; // instruction index 0 for SolTransfer enum

    const data = Buffer.alloc(9); // 1 byte for instruction enum + 8 bytes for u64
    data.writeUInt8(instructionIndex, 0); // first byte identifies the instruction
    data.writeBigUInt64LE(transferAmount, 1); // remaining bytes are instruction arguments

    // Create instruction
    const instruction = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: sender.publicKey, isSigner: true, isWritable: true },
        { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
      ],
      data
    });

    // Create and send transaction
    const transaction = new Transaction().add(instruction);
    transaction.recentBlockhash = svm.latestBlockhash();
    transaction.sign(sender);

    svm.sendTransaction(transaction);

    // Check balances
    const recipientBalance = svm.getBalance(recipient.publicKey);
    const senderBalance = svm.getBalance(sender.publicKey);

    const transactionFee = BigInt(5000);
    expect(recipientBalance).toBe(transferAmount);
    expect(senderBalance).toBe(amount - transferAmount - transactionFee);
  });
  ```
</CodeTabs>

use borsh::BorshDeserialize; use solana\_program::\{ &#x20;
account\_info::AccountInfo,   entrypoint,   entrypoint::ProgramResult,
&#x20; program::invoke,   program\_error::ProgramError, &#x20;
pubkey::Pubkey,   system\_instruction, };

// 声明程序入口点 entrypoint!(process\_instruction);

// 定义程序指令 #\[derive(BorshDeserialize)] enum ProgramInstruction \{ &#x20;
SolTransfer \{ amount: u64 }, }

impl ProgramInstruction \{   fn unpack(input: &\[u8]) -> Result\<Self,
ProgramError> \{   Self::try\_from\_slice(input).map\_err(|\_|
ProgramError::InvalidInstructionData)   } }

pub fn process\_instruction(   \_program\_id: \&Pubkey,   accounts:
&\[AccountInfo],   instruction\_data: &\[u8], ) -> ProgramResult \{ &#x20;
// 反序列化指令数据   let instruction =
ProgramInstruction::unpack(instruction\_data)?;

&#x20; // 处理指令   match instruction \{ &#x20;
ProgramInstruction::SolTransfer \{ amount } => \{   // 解析账户   let
\[sender\_info, recipient\_info, system\_program\_info] = accounts else \{ &#x20;
return Err(ProgramError::NotEnoughAccountKeys);   };

&#x20; // 验证发送方是签名者   if !sender\_info.is\_signer \{   return
Err(ProgramError::MissingRequiredSignature);   }

&#x20; // 创建并调用转账指令   let transfer\_ix =
system\_instruction::transfer(   sender\_info.key,   recipient\_info.key,
&#x20; amount,   );

&#x20; invoke(   \&transfer\_ix,   &\[   sender\_info.clone(),
&#x20; recipient\_info.clone(),   system\_program\_info.clone(),   ],
&#x20; )?;

&#x20; Ok(())   }   } }

*

使用 PDA 签名者的跨程序调用[`invoke_signed`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/program.rs#L51-L73)
函数处理需要PDA签名者的CPI调用。该函数将用于派生签名者PDA的种子作为`signer_seeds`参数。

您可以参考[Program Derived Address](/docs/core/pda)页面了解如何派生PDA的详细信息。

```rust title="Invoke Signed"
pub fn invoke_signed(
    instruction: &Instruction,
    account_infos: &[AccountInfo],
    signers_seeds: &[&[&[u8]]],
) -> ProgramResult {
    // --snip--
    invoke_signed_unchecked(instruction, account_infos, signers_seeds)
}
```

您可以参考
[`Program Derived Address`](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/syscalls/cpi.rs#L552)
页面了解如何派生 PDA 的详细信息。`signers_seeds` 和调用程序的
`program_id`。当验证有效的 PDA 时，该地址将被[添加为有效签名者](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/syscalls/cpi.rs#L554)。

以下示例演示了如何使用 [Anchor Framework](https://www.anchor-lang.com/docs)
和原生 Rust 进行带有 PDA 签名者的跨程序调用（CPI）。这些示例程序包含一个指令，该指令通过由 PDA 签名的 CPI 将 SOL 从 PDA 账户转移到接收者账户。

### 当处理包含 CPI 的指令时，Solana 运行时内部会调用

以下示例包括在 Anchor 程序中实现跨程序调用（CPIs）的三种方法，每种方法都有不同的抽象级别。所有示例在功能上是等效的。主要目的是说明 CPI 的实现细节。

* 示例 1：使用 Anchor 的 *rs`CpiContext`* 和辅助函数构建 CPI 指令。
* 示例 2：使用 *rs`system_instruction::transfer`* 函数（来自 `solana_program`
  crate）构建 CPI 指令。示例 1 是此实现的抽象。
* 示例 3：手动构建 CPI 指令。当没有可用的 crate 来帮助构建你想要调用的指令时，这种方法很有用。

<CodeTabs>
  ```rs !! title="Example 1"
  以下示例演示了如何使用 
  ```

  ```rs !! title="Example 2"
  use anchor_lang::prelude::*;
  use anchor_lang::solana_program::{program::invoke_signed, system_instruction};

  declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

  #[program]
  pub mod cpi {
      use super::*;

      pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
          let from_pubkey = ctx.accounts.pda_account.to_account_info();
          let to_pubkey = ctx.accounts.recipient.to_account_info();
          let program_id = ctx.accounts.system_program.to_account_info();

          let seed = to_pubkey.key();
          let bump_seed = ctx.bumps.pda_account;

          let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

          let instruction =
              &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

          invoke_signed(instruction, &[from_pubkey, to_pubkey, program_id], signer_seeds)?;
          Ok(())
      }
  }

  #[derive(Accounts)]
  pub struct SolTransfer<'info> {
      #[account(
          mut,
          seeds = [b"pda", recipient.key().as_ref()],
          bump,
      )]
      pda_account: SystemAccount<'info>,
      #[account(mut)]
      recipient: SystemAccount<'info>,
      system_program: Program<'info, System>,
  }
  ```

  ```rs !! title="Example 3"

  和原生 Rust 进行带有 PDA 签名者的 CPI。示例程序包含一个指令，该指令通过由 PDA 签名的 CPI 将 SOL 从 PDA 转移到接收账户。
  ```

  ```ts !! title="Test"
  import * as anchor from "@coral-xyz/anchor";

  import { BN, Program } from "@coral-xyz/anchor";
  import { LAMPORTS_PER_SOL, PublicKey } from "@solana/web3.js";

  import { Cpi } from "../target/types/cpi";

  describe("cpi", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.Cpi as Program<Cpi>;
    const connection = program.provider.connection;
    const wallet = provider.wallet as anchor.Wallet;

    const [PDA] = PublicKey.findProgramAddressSync(
      [Buffer.from("pda"), wallet.publicKey.toBuffer()],
      program.programId
    );

    const transferAmount = 0.1 * LAMPORTS_PER_SOL;

    before(async () => {
      // 请求空投以为PDA提供资金
      const signature = await connection.requestAirdrop(PDA, transferAmount);

      const { blockhash, lastValidBlockHeight } =
        await connection.getLatestBlockhash();

      await connection.confirmTransaction({
        signature,
        blockhash,
        lastValidBlockHeight
      });
    });

    it("使用PDA签名者进行SOL转账", async () => {
      const transactionSignature = await program.methods
        .solTransfer(new BN(transferAmount))
        .accounts({
          recipient: wallet.publicKey
        })
        .rpc();

      console.log(`\n交易签名: ${transactionSignature}`);
    });
  });
  ```
</CodeTabs>

### Anchor 框架

以下示例包括在 Anchor 程序中实现跨程序调用 (CPI) 的三种方法，每种方法都有不同的抽象级别。所有示例在功能上是等效的。主要目的是说明 CPI 的实现细节。[LiteSVM](https://github.com/LiteSVM/litesvm)来测试程序。

<CodeTabs>
  ```rs !! title="Example"
  use borsh::BorshDeserialize;
  use solana_program::{
      account_info::AccountInfo,
      entrypoint,
      entrypoint::ProgramResult,
      program::invoke_signed,
      program_error::ProgramError,
      pubkey::Pubkey,
      system_instruction,
  };

  // 声明程序入口点 entrypoint!(process_instruction);

  // 定义程序指令 #[derive(BorshDeserialize)] enum ProgramInstruction {
  SolTransfer { amount: u64 }, }

  impl ProgramInstruction { fn unpack(input: &[u8]) -> Result<Self, ProgramError>
  { Self::try*from_slice(input).map_err(|*| ProgramError::InvalidInstructionData)
  } }

  pub fn process_instruction( program_id: &Pubkey, accounts: &[AccountInfo],
  instruction_data: &[u8], ) -> ProgramResult { // 反序列化指令数据 let
  instruction = ProgramInstruction::unpack(instruction_data)?;

      // 处理指令
      match instruction {
          ProgramInstruction::SolTransfer { amount } => {
              // 解析账户
              let [pda_account_info, recipient_info, system_program_info] = accounts else {
                  return Err(ProgramError::NotEnoughAccountKeys);
              };

              // 派生PDA并验证它与客户端提供的账户匹配
              let recipient_pubkey = recipient_info.key;
              let seeds = &[b"pda", recipient_pubkey.as_ref()];
              let (expected_pda, bump_seed) = Pubkey::find_program_address(seeds, program_id);

              if expected_pda != *pda_account_info.key {
                  return Err(ProgramError::InvalidArgument);
              }

              // 创建转账指令
              let transfer_ix = system_instruction::transfer(
                  pda_account_info.key,
                  recipient_info.key,
                  amount,
              );

              // 为PDA创建签名者种子
              let signer_seeds: &[&[&[u8]]] = &[&[b"pda", recipient_pubkey.as_ref(), &[bump_seed]]];

              // 调用转账指令，PDA作为签名者
              invoke_signed(
                  &transfer_ix,
                  &[
                      pda_account_info.clone(),
                      recipient_info.clone(),
                      system_program_info.clone(),
                  ],
                  signer_seeds,
              )?;

              Ok(())
          }
      }

  }

  ```

  ```ts !! title="Test"
  import * as path from "path";
  import {
    Keypair,
    LAMPORTS_PER_SOL,
    PublicKey,
    SystemProgram,
    Transaction,
    TransactionInstruction
  } from "@solana/web3.js";
  import { LiteSVM } from "litesvm";

  test("带有pda签名者的sol转账cpi", () => {
    const svm = new LiteSVM();

    const programId = PublicKey.unique();
    const programPath = path.join(__dirname, "program.so");
    svm.addProgramFromFile(programId, programPath);

    // 创建接收方
    const recipient = new Keypair();

    // 派生将持有并发送资金的PDA
    const [pdaAddress] = PublicKey.findProgramAddressSync(
      [Buffer.from("pda"), recipient.publicKey.toBuffer()],
      programId
    );

    // 为账户注资
    const amount = BigInt(LAMPORTS_PER_SOL);
    svm.airdrop(recipient.publicKey, amount); // 1 SOL
    svm.airdrop(pdaAddress, amount); // 1 SOL

    // 创建指令数据缓冲区
    const transferAmount = amount / BigInt(2); // 0.5 SOL
    const instructionIndex = 0; // SolTransfer枚举的指令索引0

    const data = Buffer.alloc(9); // 1字节用于指令枚举 + 8字节用于u64
    data.writeUInt8(instructionIndex, 0); // 第一个字节标识指令
    data.writeBigUInt64LE(transferAmount, 1); // 剩余字节是指令参数

    // 创建指令
    const instruction = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: pdaAddress, isSigner: false, isWritable: true },
        { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
      ],
      data
    });

    // 创建并发送交易
    const transaction = new Transaction().add(instruction);
    transaction.recentBlockhash = svm.latestBlockhash();
    transaction.sign(recipient);

    svm.sendTransaction(transaction);

    // 检查余额
    const recipientBalance = svm.getBalance(recipient.publicKey);
    const pdaBalance = svm.getBalance(pdaAddress);

    const transactionFee = BigInt(5000);
    // 接收方开始有1 SOL，收到0.5 SOL，支付交易费
    expect(recipientBalance).toBe(amount + transferAmount - transactionFee);
    // PDA开始有1 SOL，发送0.5 SOL
    expect(pdaBalance).toBe(amount - transferAmount);
  });
  ```
</CodeTabs>
