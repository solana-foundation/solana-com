---
title: 跨程序调用
description:
  了解 Solana 上的跨程序调用（CPI）- 程序如何调用其他程序的指令，处理 PDA
  签名者，以及在 Solana 网络上组合功能。
h1: 跨程序调用（CPI）
---

跨程序调用（Cross Program
Invocation，CPI）是指一个程序调用另一个程序的指令。这使得Solana程序之间可以实现组合性。

你可以将指令视为程序向网络公开的API端点，而CPI则是一个API内部调用另一个API。

![跨程序调用](/assets/docs/core/cpi/cpi.svg)

## 关键点

- **跨程序调用**使Solana程序指令能够直接调用另一个程序上的指令。
- 调用方程序的**签名者权限**会延伸到被调用程序。
- 在进行跨程序调用时，**程序可以代表**从其自身程序ID派生的**PDA进行签名**。
- 被调用程序可以进一步向其他程序发起CPI，最大深度为4。

## 什么是CPI？

跨程序调用（CPI）是指一个程序调用另一个程序的指令。

使用CPI编写程序指令遵循与构建[指令](/docs/core/transactions#instruction)添加到交易相同的模式。在底层，每个CPI指令必须指定：

- **程序地址**：指定要调用的程序
- **账户**：列出指令读取或写入的每个账户，包括其他程序
- **指令数据**：指定要在程序上调用的指令，以及指令需要的任何数据（函数参数）

当一个程序向另一个程序发起跨程序调用（CPI）时：

- 初始交易的签名者权限延伸到被调用程序（例如 A->B）
- 被调用程序可以进一步向其他程序发起CPI，最大深度为4（例如 B->C, C->D）
- 程序可以代表从其程序ID派生的[PDA](/docs/core/pda)进行"签名"

<Callout>
  Solana程序运行时设置了一个
  [`max_instruction_stack_depth`](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L38)
  常量
  [MAX_INSTRUCTION_STACK_DEPTH](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L13)
  为5。这代表程序指令调用栈的最大高度。栈高度从初始交易的1开始，每当程序调用另一个指令时增加1。此设置将CPI的调用深度限制为4。
</Callout>

当处理交易时，账户权限从一个程序延伸到另一个程序。这意味着：

假设程序A接收到一个指令，其中包含：

- 一个签署了交易的账户
- 一个可以被写入的账户（可变的）

当程序A向程序B发起CPI时：

- 程序B可以使用这些相同的账户及其原始权限
- 程序B可以使用签名者账户进行签名
- 程序B可以写入可写账户
- 如果程序B发起自己的CPI，它甚至可以将这些相同的权限传递下去

## 跨程序调用

[`invoke`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/program.rs#L26-L28)

函数处理不需要PDA签名者的CPI。该函数调用`invoke_signed`函数时使用空的`signers_seeds`数组，表示不需要PDA进行签名。

```rust title="Invoke函数"
pub fn invoke(instruction: &Instruction, account_infos: &[AccountInfo]) -> ProgramResult {
    invoke_signed(instruction, account_infos, &[])
}
```

以下示例展示了如何使用[Anchor框架](https://www.anchor-lang.com/docs)和原生Rust进行CPI调用。这些示例程序包含一个单一指令，通过CPI将SOL从一个账户转移到另一个账户。

### Anchor框架

以下示例展示了在Anchor程序中创建跨程序调用(CPI)的三种方式，每种方式都有不同的抽象级别。所有示例的工作方式相同。主要目的是展示CPI的实现细节。

- 示例1：使用Anchor的*rs`CpiContext`*和辅助函数构建CPI指令。
- 示例2：使用`solana_program`包中的*rs`system_instruction::transfer`*函数构建CPI指令。示例1抽象了这种实现。
- 示例3：手动构建CPI指令。当没有现成的包来帮助构建指令时，这种方法很有用。

<CodeTabs>

```rs !! title="示例1"
use anchor_lang::prelude::*;
use anchor_lang::system_program::{transfer, Transfer};

declare_id!("9AvUNHjxscdkiKQ8tUn12QCMXtcnbR9BVGq3ULNzFMRi");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let cpi_context = CpiContext::new(
            program_id,
            Transfer {
                from: from_pubkey,
                to: to_pubkey,
            },
        );

        transfer(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="示例2"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke, system_instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let instruction =
            &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

        invoke(instruction, &[from_pubkey, to_pubkey, program_id])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="示例3"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke, instruction::Instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        // 准备指令AccountMetas
        let account_metas = vec![
            AccountMeta::new(from_pubkey.key(), true),
            AccountMeta::new(to_pubkey.key(), false),
        ];

        // SOL转账指令识别码
        let instruction_discriminator: u32 = 2;

        // 准备指令数据
        let mut instruction_data = Vec::with_capacity(4 + 8);
        instruction_data.extend_from_slice(&instruction_discriminator.to_le_bytes());
        instruction_data.extend_from_slice(&amount.to_le_bytes());

        // 创建指令
        let instruction = Instruction {
            program_id: program_id.key(),
            accounts: account_metas,
            data: instruction_data,
        };

        // 调用指令
        invoke(&instruction, &[from_pubkey, to_pubkey, program_id])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```ts !! title="测试"
import * as anchor from "@coral-xyz/anchor";
import { BN, Program } from "@coral-xyz/anchor";
import { Cpi } from "../target/types/cpi";
import { Keypair, LAMPORTS_PER_SOL } from "@solana/web3.js";

describe("cpi", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Cpi as Program<Cpi>;
  const sender = provider.wallet as anchor.Wallet;
  const recipient = new Keypair();

  const transferAmount = 0.01 * LAMPORTS_PER_SOL;

  it("SOL Transfer Anchor", async () => {
    const transactionSignature = await program.methods
      .solTransfer(new BN(transferAmount))
      .accounts({
        sender: sender.publicKey,
        recipient: recipient.publicKey
      })
      .rpc();

    console.log(`\nTransaction Signature: ${transactionSignature}`);
  });
});
```

</CodeTabs>

### 原生 Rust

以下示例展示了如何从用原生 Rust 编写的程序中进行 CPI（跨程序调用）。该程序包含一个指令，通过 CPI 将 SOL 从一个账户转移到另一个账户。测试文件使用
[LiteSVM](https://github.com/LiteSVM/litesvm) 来测试程序。

<CodeTabs>

```rs !! title="示例"
use borsh::BorshDeserialize;
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
};

// 声明程序入口点
entrypoint!(process_instruction);

// 定义程序指令
#[derive(BorshDeserialize)]
enum ProgramInstruction {
    SolTransfer { amount: u64 },
}

impl ProgramInstruction {
    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        Self::try_from_slice(input).map_err(|_| ProgramError::InvalidInstructionData)
    }
}

pub fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // 反序列化指令数据
    let instruction = ProgramInstruction::unpack(instruction_data)?;

    // 处理指令
    match instruction {
        ProgramInstruction::SolTransfer { amount } => {
            // 解析账户
            let [sender_info, recipient_info, system_program_info] = accounts else {
                return Err(ProgramError::NotEnoughAccountKeys);
            };

            // 验证发送方是签名者
            if !sender_info.is_signer {
                return Err(ProgramError::MissingRequiredSignature);
            }

            // 创建并调用转账指令
            let transfer_ix = system_instruction::transfer(
                sender_info.key,
                recipient_info.key,
                amount,
            );

            invoke(
                &transfer_ix,
                &[
                    sender_info.clone(),
                    recipient_info.clone(),
                    system_program_info.clone(),
                ],
            )?;

            Ok(())
        }
    }
}
```

```ts !! title="测试"
import * as path from "path";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from "@solana/web3.js";
import { LiteSVM } from "litesvm";

test("sol transfer cpi", () => {
  const svm = new LiteSVM();

  const programId = PublicKey.unique();
  const programPath = path.join(__dirname, "program.so");
  svm.addProgramFromFile(programId, programPath);

  // 创建发送方和接收方
  const sender = new Keypair();
  const recipient = new Keypair();

  // 为发送方提供资金
  const amount = BigInt(LAMPORTS_PER_SOL);
  svm.airdrop(sender.publicKey, amount); // 1 SOL

  // 创建指令数据缓冲区
  const transferAmount = amount / BigInt(2); // 0.5 SOL
  const instructionIndex = 0; // SolTransfer 枚举的指令索引为 0

  const data = Buffer.alloc(9); // 1 字节用于指令枚举 + 8 字节用于 u64
  data.writeUInt8(instructionIndex, 0); // 第一个字节标识指令
  data.writeBigUInt64LE(transferAmount, 1); // 剩余字节是指令参数

  // 创建指令
  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: sender.publicKey, isSigner: true, isWritable: true },
      { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ],
    data
  });

  // 创建并发送交易
  const transaction = new Transaction().add(instruction);
  transaction.recentBlockhash = svm.latestBlockhash();
  transaction.sign(sender);

  svm.sendTransaction(transaction);

  // 检查余额
  const recipientBalance = svm.getBalance(recipient.publicKey);
  const senderBalance = svm.getBalance(sender.publicKey);

  const transactionFee = BigInt(5000);
  expect(recipientBalance).toBe(transferAmount);
  expect(senderBalance).toBe(amount - transferAmount - transactionFee);
});
```

</CodeTabs>

## 使用 PDA 签名者的跨程序调用

[`invoke_signed`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/program.rs#L51-L73)

函数处理需要 PDA 签名者的跨程序调用(CPI)。该函数将用于派生签名者 PDA 的种子作为
`signer_seeds` 参数。

您可以参考 [程序派生地址](/docs/core/pda) 页面了解如何派生 PDA 的详细信息。

```rust title="Invoke Signed"
pub fn invoke_signed(
    instruction: &Instruction,
    account_infos: &[AccountInfo],
    signers_seeds: &[&[&[u8]]],
) -> ProgramResult {
    // --snip--
    invoke_signed_unchecked(instruction, account_infos, signers_seeds)
}
```

当处理包含 CPI 的指令时，Solana 运行时内部会调用

[`create_program_address`](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/syscalls/cpi.rs#L552)

使用 `signers_seeds` 和调用程序的
`program_id`。当验证有效的 PDA 后，该地址会被[添加为有效签名者](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/syscalls/cpi.rs#L554)。

以下示例演示了如何使用 [Anchor 框架](https://www.anchor-lang.com/docs)
和原生 Rust 进行带有 PDA 签名者的 CPI。这些示例程序包含一个指令，该指令通过由 PDA 签名的 CPI 将 SOL 从 PDA 转移到接收账户。

### Anchor 框架

以下示例包括在 Anchor 程序中实现跨程序调用(CPI)的三种方法，每种方法都有不同的抽象级别。所有示例在功能上是等效的。主要目的是说明 CPI 的实现细节。

- 示例 1：使用 Anchor 的 _rs`CpiContext`_ 和辅助函数构建 CPI 指令。
- 示例 2：使用 `solana_program` 包中的 _rs`system_instruction::transfer`_
  函数构建 CPI 指令。示例 1 是此实现的抽象。
- 示例 3：手动构建 CPI 指令。当没有可用的包来帮助构建您想要调用的指令时，这种方法很有用。

<CodeTabs>

```rs !! title="示例 1"
use anchor_lang::prelude::*;
use anchor_lang::system_program::{transfer, Transfer};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;
        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        let cpi_context = CpiContext::new(
            program_id,
            Transfer {
                from: from_pubkey,
                to: to_pubkey,
            },
        )
        .with_signer(signer_seeds);

        transfer(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="示例 2"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke_signed, system_instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;

        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        let instruction =
            &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

        invoke_signed(instruction, &[from_pubkey, to_pubkey, program_id], signer_seeds)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="示例 3"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke_signed, instruction::{Instruction, AccountMeta}};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        // 获取 PDA 签名者种子
        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;
        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        // 准备指令 AccountMetas
        let account_metas = vec![
            AccountMeta::new(from_pubkey.key(), true),
            AccountMeta::new(to_pubkey.key(), false),
        ];

        // SOL 转账指令识别码
        let instruction_discriminator: u32 = 2;

        // 准备指令数据
        let mut instruction_data = Vec::with_capacity(4 + 8);
        instruction_data.extend_from_slice(&instruction_discriminator.to_le_bytes());
        instruction_data.extend_from_slice(&amount.to_le_bytes());

        // 创建指令
        let instruction = Instruction {
            program_id: program_id.key(),
            accounts: account_metas,
            data: instruction_data,
        };

        // 使用 PDA 签名者调用指令
        invoke_signed(&instruction, &[from_pubkey, to_pubkey, program_id], signer_seeds)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```ts !! title="测试"
import * as anchor from "@coral-xyz/anchor";

import { BN, Program } from "@coral-xyz/anchor";
import { LAMPORTS_PER_SOL, PublicKey } from "@solana/web3.js";

import { Cpi } from "../target/types/cpi";

describe("cpi", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Cpi as Program<Cpi>;
  const connection = program.provider.connection;
  const wallet = provider.wallet as anchor.Wallet;

  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("pda"), wallet.publicKey.toBuffer()],
    program.programId
  );

  const transferAmount = 0.1 * LAMPORTS_PER_SOL;

  before(async () => {
    // 请求空投以资助 PDA
    const signature = await connection.requestAirdrop(PDA, transferAmount);

    const { blockhash, lastValidBlockHeight } =
      await connection.getLatestBlockhash();

    await connection.confirmTransaction({
      signature,
      blockhash,
      lastValidBlockHeight
    });
  });

  it("带 PDA 签名者的 SOL 转账", async () => {
    const transactionSignature = await program.methods
      .solTransfer(new BN(transferAmount))
      .accounts({
        recipient: wallet.publicKey
      })
      .rpc();

    console.log(`\n交易签名: ${transactionSignature}`);
  });
});
```

</CodeTabs>

### 原生 Rust

以下示例展示了如何从用原生 Rust 编写的程序中使用 PDA 签名者进行 CPI 调用。该程序包含一个指令，通过 PDA 签名的 CPI 将 SOL 从 PDA 账户转移到接收者账户。测试文件使用
[LiteSVM](https://github.com/LiteSVM/litesvm) 来测试程序。

<CodeTabs>

```rs !! title="示例"
use borsh::BorshDeserialize;
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke_signed,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
};

// 声明程序入口点
entrypoint!(process_instruction);

// 定义程序指令
#[derive(BorshDeserialize)]
enum ProgramInstruction {
    SolTransfer { amount: u64 },
}

impl ProgramInstruction {
    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        Self::try_from_slice(input).map_err(|_| ProgramError::InvalidInstructionData)
    }
}

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // 反序列化指令数据
    let instruction = ProgramInstruction::unpack(instruction_data)?;

    // 处理指令
    match instruction {
        ProgramInstruction::SolTransfer { amount } => {
            // 解析账户
            let [pda_account_info, recipient_info, system_program_info] = accounts else {
                return Err(ProgramError::NotEnoughAccountKeys);
            };

            // 派生 PDA 并验证它与客户端提供的账户匹配
            let recipient_pubkey = recipient_info.key;
            let seeds = &[b"pda", recipient_pubkey.as_ref()];
            let (expected_pda, bump_seed) = Pubkey::find_program_address(seeds, program_id);

            if expected_pda != *pda_account_info.key {
                return Err(ProgramError::InvalidArgument);
            }

            // 创建转账指令
            let transfer_ix = system_instruction::transfer(
                pda_account_info.key,
                recipient_info.key,
                amount,
            );

            // 为 PDA 创建签名种子
            let signer_seeds: &[&[&[u8]]] = &[&[b"pda", recipient_pubkey.as_ref(), &[bump_seed]]];

            // 调用带有 PDA 作为签名者的转账指令
            invoke_signed(
                &transfer_ix,
                &[
                    pda_account_info.clone(),
                    recipient_info.clone(),
                    system_program_info.clone(),
                ],
                signer_seeds,
            )?;

            Ok(())
        }
    }
}
```

```ts !! title="测试"
import * as path from "path";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from "@solana/web3.js";
import { LiteSVM } from "litesvm";

test("sol transfer cpi with pda signer", () => {
  const svm = new LiteSVM();

  const programId = PublicKey.unique();
  const programPath = path.join(__dirname, "program.so");
  svm.addProgramFromFile(programId, programPath);

  // 创建接收者
  const recipient = new Keypair();

  // 派生将持有并发送资金的 PDA
  const [pdaAddress] = PublicKey.findProgramAddressSync(
    [Buffer.from("pda"), recipient.publicKey.toBuffer()],
    programId
  );

  // 为账户注资
  const amount = BigInt(LAMPORTS_PER_SOL);
  svm.airdrop(recipient.publicKey, amount); // 1 SOL
  svm.airdrop(pdaAddress, amount); // 1 SOL

  // 创建指令数据缓冲区
  const transferAmount = amount / BigInt(2); // 0.5 SOL
  const instructionIndex = 0; // SolTransfer 枚举的指令索引为 0

  const data = Buffer.alloc(9); // 1 字节用于指令枚举 + 8 字节用于 u64
  data.writeUInt8(instructionIndex, 0); // 第一个字节标识指令
  data.writeBigUInt64LE(transferAmount, 1); // 剩余字节是指令参数

  // 创建指令
  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: pdaAddress, isSigner: false, isWritable: true },
      { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ],
    data
  });

  // 创建并发送交易
  const transaction = new Transaction().add(instruction);
  transaction.recentBlockhash = svm.latestBlockhash();
  transaction.sign(recipient);

  svm.sendTransaction(transaction);

  // 检查余额
  const recipientBalance = svm.getBalance(recipient.publicKey);
  const pdaBalance = svm.getBalance(pdaAddress);

  const transactionFee = BigInt(5000);
  // 接收者开始有 1 SOL，收到 0.5 SOL，支付交易费
  expect(recipientBalance).toBe(amount + transferAmount - transactionFee);
  // PDA 开始有 1 SOL，发送 0.5 SOL
  expect(pdaBalance).toBe(amount - transferAmount);
});
```

</CodeTabs>

### 原生 Rust

以下示例展示了如何从用原生 Rust 编写的程序中使用 PDA 签名者进行 CPI（跨程序调用）。该程序包含一个指令，通过 PDA 签名的 CPI 将 SOL 从 PDA 账户转移到接收者账户。测试文件使用
[LiteSVM](https://github.com/LiteSVM/litesvm) 来测试程序。

<CodeTabs>

```rs !! title="示例"
use borsh::BorshDeserialize;
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke_signed,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
};

// 声明程序入口点
entrypoint!(process_instruction);

// 定义程序指令
#[derive(BorshDeserialize)]
enum ProgramInstruction {
    SolTransfer { amount: u64 },
}

impl ProgramInstruction {
    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        Self::try_from_slice(input).map_err(|_| ProgramError::InvalidInstructionData)
    }
}

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // 反序列化指令数据
    let instruction = ProgramInstruction::unpack(instruction_data)?;

    // 处理指令
    match instruction {
        ProgramInstruction::SolTransfer { amount } => {
            // 解析账户
            let [pda_account_info, recipient_info, system_program_info] = accounts else {
                return Err(ProgramError::NotEnoughAccountKeys);
            };

            // 派生 PDA 并验证它与客户端提供的账户匹配
            let recipient_pubkey = recipient_info.key;
            let seeds = &[b"pda", recipient_pubkey.as_ref()];
            let (expected_pda, bump_seed) = Pubkey::find_program_address(seeds, program_id);

            if expected_pda != *pda_account_info.key {
                return Err(ProgramError::InvalidArgument);
            }

            // 创建转账指令
            let transfer_ix = system_instruction::transfer(
                pda_account_info.key,
                recipient_info.key,
                amount,
            );

            // 为 PDA 创建签名种子
            let signer_seeds: &[&[&[u8]]] = &[&[b"pda", recipient_pubkey.as_ref(), &[bump_seed]]];

            // 调用带有 PDA 作为签名者的转账指令
            invoke_signed(
                &transfer_ix,
                &[
                    pda_account_info.clone(),
                    recipient_info.clone(),
                    system_program_info.clone(),
                ],
                signer_seeds,
            )?;

            Ok(())
        }
    }
}
```

```ts !! title="测试"
import * as path from "path";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from "@solana/web3.js";
import { LiteSVM } from "litesvm";

test("sol transfer cpi with pda signer", () => {
  const svm = new LiteSVM();

  const programId = PublicKey.unique();
  const programPath = path.join(__dirname, "program.so");
  svm.addProgramFromFile(programId, programPath);

  // 创建接收者
  const recipient = new Keypair();

  // 派生将持有并发送资金的 PDA
  const [pdaAddress] = PublicKey.findProgramAddressSync(
    [Buffer.from("pda"), recipient.publicKey.toBuffer()],
    programId
  );

  // 为账户提供资金
  const amount = BigInt(LAMPORTS_PER_SOL);
  svm.airdrop(recipient.publicKey, amount); // 1 SOL
  svm.airdrop(pdaAddress, amount); // 1 SOL

  // 创建指令数据缓冲区
  const transferAmount = amount / BigInt(2); // 0.5 SOL
  const instructionIndex = 0; // SolTransfer 枚举的指令索引为 0

  const data = Buffer.alloc(9); // 1 字节用于指令枚举 + 8 字节用于 u64
  data.writeUInt8(instructionIndex, 0); // 第一个字节标识指令
  data.writeBigUInt64LE(transferAmount, 1); // 剩余字节是指令参数

  // 创建指令
  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: pdaAddress, isSigner: false, isWritable: true },
      { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ],
    data
  });

  // 创建并发送交易
  const transaction = new Transaction().add(instruction);
  transaction.recentBlockhash = svm.latestBlockhash();
  transaction.sign(recipient);

  svm.sendTransaction(transaction);

  // 检查余额
  const recipientBalance = svm.getBalance(recipient.publicKey);
  const pdaBalance = svm.getBalance(pdaAddress);

  const transactionFee = BigInt(5000);
  // 接收者开始有 1 SOL，收到 0.5 SOL，支付交易费
  expect(recipientBalance).toBe(amount + transferAmount - transactionFee);
  // PDA 开始有 1 SOL，发送 0.5 SOL
  expect(pdaBalance).toBe(amount - transferAmount);
});
```

</CodeTabs>
