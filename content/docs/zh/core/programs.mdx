---
title: Solana上的程序
description: 了解Solana程序（智能合约）以及如何使用Rust或Anchor框架开发它们。理解Solana网络上的程序部署、升级和验证。
h1: 项目
---

在Solana上，"智能合约"被称为程序。
[程序](/docs/core/accounts#program-account)被部署到链上的账户中，这些账户包含程序的已编译可执行二进制文件。用户通过发送包含
[指令](/docs/core/transactions#instruction)的交易与程序交互，告诉程序要做什么。

## 关键点

* 程序是包含**可执行代码**的账户，代码组织成称为**指令**的函数。
* 虽然程序是**无状态的**，但它们可以包含创建和更新其他账户以存储数据的指令。
* 一个**升级权限**可以更新程序。一旦这个权限被移除，程序就变成不可变的。
* 用户可以通过可验证构建来验证链上程序账户的数据是否与其公开源代码匹配。

## 编写Solana程序

Solana程序主要使用[Rust](https://rust-book.cs.brown.edu/title-page.html)编程语言编写，开发有两种常见方法：

* [Anchor](https://www.anchor-lang.com/docs)：为Solana程序开发设计的框架。它提供了更快速、更简单的程序编写方式，使用Rust宏显著减少样板代码。对于初学者，建议从Anchor框架开始。

* [原生Rust](/docs/programs/rust)：这种方法涉及不使用任何框架直接用Rust编写Solana程序。它提供更多灵活性，但复杂性也更高。

## 更新Solana程序

要了解更多关于部署和升级程序的信息，请参阅
[部署程序](/docs/programs/deploying)页面。

链上程序可以被[直接修改](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L704)
由被指定为"升级权限"的账户进行，这通常是最初部署该程序的账户。如果
[升级权限](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L894)
被撤销并设置为`None`，程序就变成不可变的，不能再更新。

## 可验证程序

，修改者是被指定为"升级权限"的账户，通常是最初部署该程序的账户。如果

Solana开发者社区已经引入了支持可验证构建的工具，使开发者和用户都能够验证链上程序是否准确反映了他们公开共享的源代码。

* **搜索已验证的程序**：要快速检查已验证的程序，用户可以在[SolanaFM](https://solana.fm/)
  浏览器上搜索程序地址并导航到"验证"标签。查看已验证程序的示例
  [这里](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)。

* **验证工具**：
  [Solana可验证构建CLI](https://github.com/Ellipsis-Labs/solana-verifiable-build)
  由Ellipsis Labs开发，使用户能够独立验证链上程序是否与发布的源代码一致。

* **Anchor中对可验证构建的支持**：Anchor提供了对可验证构建的内置支持。详情可在
  [Anchor文档](https://www.anchor-lang.com/docs/verifiable-builds)中找到。

## 可验证程序

可验证构建允许任何人检查程序的链上代码是否与其公开源代码匹配，使得可以检测源代码和已部署版本之间的差异。[LLVM](https://llvm.org/)来编译程序为
[ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)文件。这些文件包含Solana自定义版本的
[eBPF](https://en.wikipedia.org/wiki/EBPF)字节码，称为"Solana字节码格式"(sBPF)。ELF文件包含程序的二进制代码，并在程序部署时存储在链上的可执行账户中。

## Solana开发者社区已引入工具来支持可验证构建，使开发者和用户都能验证链上程序是否准确反映了其公开共享的源代码。

### 加载器程序

Berkeley数据包过滤器（BPF）

1. 原生加载器：

* 程序ID：`NativeLoader1111111111111111111111111111111`
* 拥有其他四个加载器

2. 加载器-v1：

* 程序ID：`BPFLoader1111111111111111111111111111111111`
* 管理指令已禁用，但程序仍可执行

3. 原生加载器：

* 程序ID：`NativeLoader1111111111111111111111111111111`
* [指令](https://docs.rs/solana-loader-v2-interface/latest/solana_loader_v2_interface/enum.LoaderInstruction.html)
* 管理指令已禁用，但程序仍可执行

4. 加载器v1：

* 程序ID：`BPFLoader1111111111111111111111111111111111`
* [指令](https://docs.rs/solana-loader-v3-interface/latest/solana_loader_v3_interface/instruction/enum.UpgradeableLoaderInstruction.html)
* 正在被淘汰

5. 加载器v2：

* 程序ID：`BPFLoader2111111111111111111111111111111111`
* [指令](https://docs.rs/solana-loader-v4-interface/latest/solana_loader_v4_interface/instruction/enum.LoaderV4Instruction.html)
* 管理指令已禁用，但程序仍然可以执行

这些加载器对于创建和管理自定义程序是必要的：

* 程序ID：
* 关闭程序或缓冲区
* 正在逐步淘汰
* 转移程序的权限
* 完成程序

加载器-v3和加载器-v4支持在初始部署后修改程序。执行此操作的权限由程序的权限管理，因为每个程序的账户所有权归属于加载器。

### 预编译程序

#### 这些加载器对于创建和管理自定义程序是必要的：

用于验证ed25519签名的程序。它接收一个ed25519签名、一个公钥和一条消息。可以验证多个签名。如果任何签名验证失败，将返回错误。

* 程序ID：`Ed25519SigVerify111111111111111111111111111`
* [指令](https://docs.rs/solana-ed25519-program/latest/solana_ed25519_program/index.html)

预编译程序`u8`是要检查的签名数量，后跟一个字节的填充。之后，以下结构被序列化，每个要检查的签名对应一个。

```
struct Ed25519SignatureOffsets {
    signature_offset: u16,             // 64字节ed25519签名的偏移量
    signature_instruction_index: u16,  // 查找签名的指令索引
    public_key_offset: u16,            // 32字节公钥的偏移量
    public_key_instruction_index: u16, // 查找公钥的指令索引
    message_data_offset: u16,          // 消息数据开始的偏移量
    message_data_size: u16,            // 消息数据的大小
    message_instruction_index: u16,    // 获取消息数据的指令数据索引
}
```

用于验证ed25519签名的程序。它接收一个ed25519签名、一个公钥和一条消息。可以验证多个签名。如果任何签名验证失败，将返回错误。

```
process_instruction() {
    for i in 0..count {
        // 引用的第i个索引值：
        instructions = &transaction.message().instructions
        instruction_index = ed25519_signature_instruction_index != u16::MAX ? ed25519_signature_instruction_index : current_instruction;
        signature = instructions[instruction_index].data[ed25519_signature_offset..ed25519_signature_offset + 64]
        instruction_index = ed25519_pubkey_instruction_index != u16::MAX ? ed25519_pubkey_instruction_index : current_instruction;
        pubkey = instructions[instruction_index].data[ed25519_pubkey_offset..ed25519_pubkey_offset + 32]
        instruction_index = ed25519_message_instruction_index != u16::MAX ? ed25519_message_instruction_index : current_instruction;
        message = instructions[instruction_index].data[ed25519_message_data_offset..ed25519_message_data_offset + ed25519_message_data_size]
        if pubkey.verify(signature, message) != Success {
            return Error
        }
    }
    return Success
}
```

#### ed25519程序处理一条指令。第一个

验证secp256k1公钥恢复操作（ecrecover）。

* 程序ID：`KeccakSecp256k11111111111111111111111111111`
* [指令](https://docs.rs/solana-secp256k1-program/latest/solana_secp256k1_program/index.html)

secp256k1程序处理一条指令，该指令将第一个字节作为指令数据中序列化的以下结构的计数：

```
struct Secp256k1SignatureOffsets {
    secp_signature_offset: u16,            // 64+1字节的[签名,恢复ID]的偏移量
    secp_signature_instruction_index: u8,  // 查找签名的指令索引
    secp_pubkey_offset: u16,               // 20字节的以太坊地址公钥的偏移量
    secp_pubkey_instruction_index: u8,     // 查找公钥的指令索引
    secp_message_data_offset: u16,         // 消息数据开始的偏移量
    secp_message_data_size: u16,           // 消息数据的大小
    secp_message_instruction_index: u8,    // 查找消息数据的指令索引
}
```

验证 secp256k1 公钥恢复操作（ecrecover）。

```
process_instruction() {
  for i in 0..count {
      // 引用的第i个索引值：
      instructions = &transaction.message().instructions
      signature = instructions[secp_signature_instruction_index].data[secp_signature_offset..secp_signature_offset + 64]
      recovery_id = instructions[secp_signature_instruction_index].data[secp_signature_offset + 64]
      ref_eth_pubkey = instructions[secp_pubkey_instruction_index].data[secp_pubkey_offset..secp_pubkey_offset + 20]
      message_hash = keccak256(instructions[secp_message_instruction_index].data[secp_message_data_offset..secp_message_data_offset + secp_message_data_size])
      pubkey = ecrecover(signature, recovery_id, message_hash)
      eth_pubkey = keccak256(pubkey[1..])[12..]
      if eth_pubkey != ref_eth_pubkey {
          return Error
      }
  }
  return Success
}
```

secp256k1 程序处理的指令在第一个字节中包含以下结构体的计数，这些结构体在指令数据中序列化：

交易成本将计算需要验证的签名数量乘以签名成本验证乘数。

#### 恢复验证的伪代码：

用于验证secp256r1签名的程序。它接收一个secp256r1签名、一个公钥和一条消息。最多可以验证8个签名。如果任何签名验证失败，将返回错误。

* 程序ID：`Secp256r1SigVerify1111111111111111111111111`
* [指令](https://docs.rs/solana-secp256k1-recover/latest/solana_secp256k1_recover/index.html)

交易的成本将计算要验证的签名数量乘以签名成本验证乘数。`u8`
是要检查的签名数量，后跟一个字节的填充。之后，以下结构被序列化，每个要检查的签名对应一个：

```rust
struct Secp256r1SignatureOffsets {
    signature_offset: u16,             // 64字节紧凑型secp256r1签名的偏移量
    signature_instruction_index: u16,  // 查找签名的指令索引
    public_key_offset: u16,            // 33字节压缩公钥的偏移量
    public_key_instruction_index: u16, // 查找公钥的指令索引
    message_data_offset: u16,          // 消息数据起始的偏移量
    message_data_size: u16,            // 消息数据的大小
    message_instruction_index: u16,    // 获取消息数据的指令数据索引
}

```

用于验证 secp256r1 签名的程序。它接收一个 secp256r1 签名、一个公钥和一条消息。最多可以验证 8 个签名。如果任何签名验证失败，将返回错误。

```
process_instruction() {
    if data.len() < SIGNATURE_OFFSETS_START {
        return Error
    }

    num_signatures = data[0] as usize
    if num_signatures == 0 || num_signatures > 8 {
        return Error
    }

    expected_data_size = num_signatures * SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START
    if data.len() < expected_data_size {
        return Error
    }

    for i in 0..num_signatures {
        offsets = parse_signature_offsets(data, i)

        signature = get_data_slice(data, instruction_datas, offsets.signature_instruction_index, offsets.signature_offset, SIGNATURE_SERIALIZED_SIZE)

        if s > half_curve_order {
            return Error
        }

        pubkey = get_data_slice(data, instruction_datas, offsets.public_key_instruction_index, offsets.public_key_offset, COMPRESSED_PUBKEY_SERIALIZED_SIZE)

        message = get_data_slice(data, instruction_datas, offsets.message_instruction_index, offsets.message_data_offset, offsets.message_data_size)

        if !verify_signature(signature, pubkey, message) {
            return Error
        }
    }

    return Success
}
```

secp256r1 程序处理一条指令。第一个&#x20;

### 核心程序

签名验证的伪代码：

1. 系统程序

* 程序ID：`11111111111111111111111111111111`
* [指令](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html)
* 创建新账户，分配账户数据，将账户分配给所有者程序，从系统程序拥有的账户转移lamport并支付交易费用。

2. 投票程序

* 程序ID：`Vote111111111111111111111111111111111111111`
* [指令](https://docs.rs/solana-vote-program/latest/solana_vote_program/vote_instruction/enum.VoteInstruction.html)
* 创建和管理用于跟踪验证者投票状态和奖励的账户。

3. 系统程序

* 程序ID：`Stake11111111111111111111111111111111111111`
* [指令](https://docs.rs/solana-sdk/latest/solana_sdk/stake/instruction/enum.StakeInstruction.html)
* 创建新账户，分配账户数据，将账户分配给所有者程序，从系统程序拥有的账户转移lamport并支付交易费用。

4. 投票程序

* 程序ID：`Vote111111111111111111111111111111111111111`
* [指令](https://docs.rs/solana-config-program/latest/solana_config_program/config_instruction/index.html)
* 创建和管理跟踪validator投票状态和奖励的账户。

5. 质押程序

* 程序ID：`Stake11111111111111111111111111111111111111`
* [指令](https://docs.rs/solana-compute-budget-interface/latest/solana_compute_budget_interface/enum.ComputeBudgetInstruction.html)

6. 配置程序

* 程序ID：`Config1111111111111111111111111111111111111`
* [指令](https://docs.rs/solana-sdk/latest/solana_sdk/address_lookup_table/instruction/enum.ProgramInstruction.html)

7. 计算预算程序

* 程序ID：`ComputeBudget111111111111111111111111111111`

8. 地址查找表程序

* 程序ID：`AddressLookupTab1e1111111111111111111111111`
