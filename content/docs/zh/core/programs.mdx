---
title: Solana上的程序
description:
  了解Solana程序（智能合约）以及如何使用
  Rust或Anchor框架进行开发。理解程序的部署、升级和
  在Solana网络上的验证。
h1: 程序
---

在Solana中，“智能合约”被称为程序。
[程序](/docs/core/accounts#program-account)被部署在链上，
存储程序的编译可执行二进制文件的账户中。用户通过发送包含
[指令](/docs/core/transactions#instruction)的交易与程序进行交互，
指令告诉程序该做什么。

## 关键点

- 程序是包含**可执行代码**的账户，组织成称为**指令**的函数。
- 虽然程序是**无状态的**，但它们可以包含创建和更新其他账户以存储数据的指令。
- **升级权限**可以更新程序。一旦移除此权限，程序将变为不可变。
- 用户可以通过可验证的构建验证链上程序账户的数据是否与其公共源代码匹配。

## 编写Solana程序

Solana程序主要使用
[Rust](https://rust-book.cs.brown.edu/title-page.html)编程语言编写，
有两种常见的开发方法：

- [Anchor](https://www.anchor-lang.com/docs): 一个为Solana程序开发设计的框架。
  它提供了一种更快、更简单的编写程序的方法，
  使用Rust宏显著减少样板代码。对于初学者，
  建议从Anchor框架开始。

- [原生Rust](/docs/programs/rust): 这种方法涉及在Rust中编写Solana程序，
  不利用任何框架。它提供了更多的灵活性，
  但复杂性也随之增加。

## 更新Solana程序

要了解有关部署和升级程序的更多信息，请参见
[部署程序](/docs/programs/deploying)页面。

链上程序可以被指定为“升级权限”的账户
[直接修改](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L704)，
通常是最初部署程序的账户。如果
[升级权限](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L894)
被撤销并设置为`None`，程序将变为不可变，无法再进行更新。

## 可验证的程序

可验证的构建允许任何人检查程序的链上代码是否与其
公共源代码匹配，从而能够检测源代码与已部署版本之间的差异。

Solana开发者社区推出了支持可验证构建的工具，
使开发者和用户都能验证链上程序是否准确反映其公开共享的源代码。

- **搜索已验证的程序**: 为了快速检查已验证的程序，
  用户可以在[SolanaFM](https://solana.fm/)探索器中搜索程序地址，
  并导航到“验证”选项卡。查看已验证程序的示例
  [这里](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)。

- **验证工具**: 由Ellipsis Labs提供的
  [Solana可验证构建CLI](https://github.com/Ellipsis-Labs/solana-verifiable-build)
  使用户能够独立验证链上程序与发布的源代码。

- **Anchor中的可验证构建支持**: Anchor提供了对可验证构建的内置支持。
  详细信息可以在
  [Anchor文档](https://www.anchor-lang.com/docs/verifiable-builds)中找到。

## 伯克利数据包过滤器（BPF）

Solana使用[LLVM](https://llvm.org/)将程序编译为
[ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)文件。这些
文件包含Solana自定义版本的
[eBPF](https://en.wikipedia.org/wiki/EBPF)字节码，称为“Solana字节码
格式”（sBPF）。ELF文件包含程序的二进制文件，并在程序部署时
存储在链上的可执行账户中。

## 内置程序

### 加载程序

每个程序本身由另一个程序拥有，即其加载程序。目前有五个加载程序：

1. 原生加载程序：

  - 程序ID: `NativeLoader1111111111111111111111111111111`
  - 拥有其他四个加载程序

2. loader-v1：

  - 程序ID: `BPFLoader1111111111111111111111111111111111`
  - 管理指令被禁用，但程序仍然执行

3. loader-v2：

  - 程序ID: `BPFLoader2111111111111111111111111111111111`
  - [指令](https://docs.rs/solana-loader-v2-interface/latest/solana_loader_v2_interface/enum.LoaderInstruction.html)
  - 管理指令被禁用，但程序仍然执行

4. loader-v3：

  - 程序ID: `BPFLoaderUpgradeab1e11111111111111111111111`
  - [指令](https://docs.rs/solana-loader-v3-interface/latest/solana_loader_v3_interface/instruction/enum.UpgradeableLoaderInstruction.html)
  - 正在逐步淘汰

5. loader-v4：

  - 程序ID: `LoaderV411111111111111111111111111111111111`
  - [指令](https://docs.rs/solana-loader-v4-interface/latest/solana_loader_v4_interface/instruction/enum.LoaderV4Instruction.html)
  - 将成为标准加载程序

这些加载程序对于创建和管理自定义程序是必要的：

- 部署新程序或缓冲区
- 关闭程序或缓冲区
- 重新部署/升级现有程序
- 转移程序的权限
- 完成程序

Loader-v3和loader-v4支持在程序初始部署后对其进行修改。进行此操作的权限由程序的权限控制，
因为每个程序的账户所有权归加载程序所有。

### 预编译程序

#### Ed25519程序

用于验证ed25519签名的程序。它接受一个ed25519签名、一个公钥和一条消息。
可以验证多个签名。如果任何签名验证失败，将返回错误。

- 程序ID: `Ed25519SigVerify111111111111111111111111111`
- [指令](https://docs.rs/solana-ed25519-program/latest/solana_ed25519_program/index.html)

ed25519程序处理一条指令。第一个`u8`是要检查的签名数量，后面跟着一个单字节填充。之后，
以下结构被序列化，每个要检查的签名一个。

```
struct Ed25519SignatureOffsets {
    signature_offset: u16,             // ed25519签名的64字节偏移
    signature_instruction_index: u16,  // 查找签名的指令索引
    public_key_offset: u16,            // 公钥的32字节偏移
    public_key_instruction_index: u16, // 查找公钥的指令索引
    message_data_offset: u16,          // 消息数据开始的偏移
    message_data_size: u16,            // 消息数据的大小
    message_instruction_index: u16,    // 获取消息数据的指令数据索引
}
```

签名验证的伪代码：

```
process_instruction() {
    for i in 0..count {
        // i'th索引值引用：
        instructions = &transaction.message().instructions
        instruction_index = ed25519_signature_instruction_index != u16::MAX ? ed25519_signature_instruction_index : current_instruction;
        signature = instructions[instruction_index].data[ed25519_signature_offset..ed25519_signature_offset + 64]
        instruction_index = ed25519_pubkey_instruction_index != u16::MAX ? ed25519_pubkey_instruction_index : current_instruction;
        pubkey = instructions[instruction_index].data[ed25519_pubkey_offset..ed25519_pubkey_offset + 32]
        instruction_index = ed25519_message_instruction_index != u16::MAX ? ed25519_message_instruction_index : current_instruction;
        message = instructions[instruction_index].data[ed25519_message_data_offset..ed25519_message_data_offset + ed25519_message_data_size]
        if pubkey.verify(signature, message) != Success {
            return Error
        }
    }
    return Success
}
```

#### Secp256k1程序

验证secp256k1公钥恢复操作（ecrecover）。

- 程序ID: `KeccakSecp256k11111111111111111111111111111`
- [指令](https://docs.rs/solana-secp256k1-program/latest/solana_secp256k1_program/index.html)

secp256k1程序处理一条指令，第一字节是以下结构在指令数据中序列化的计数：

```
struct Secp256k1SignatureOffsets {
    secp_signature_offset: u16,            // [signature,recovery_id]的偏移，64+1字节
    secp_signature_instruction_index: u8,  // 查找签名的指令索引
    secp_pubkey_offset: u16,               // ethereum_address公钥的20字节偏移
    secp_pubkey_instruction_index: u8,     // 查找公钥的指令索引
    secp_message_data_offset: u16,         // 消息数据开始的偏移
    secp_message_data_size: u16,           // 消息数据的大小
    secp_message_instruction_index: u8,    // 查找消息数据的指令索引
}
```

恢复验证的伪代码：

```
process_instruction() {
  for i in 0..count {
      // i'th索引值引用：
      instructions = &transaction.message().instructions
      signature = instructions[secp_signature_instruction_index].data[secp_signature_offset..secp_signature_offset + 64]
      recovery_id = instructions[secp_signature_instruction_index].data[secp_signature_offset + 64]
      ref_eth_pubkey = instructions[secp_pubkey_instruction_index].data[secp_pubkey_offset..secp_pubkey_offset + 20]
      message_hash = keccak256(instructions[secp_message_instruction_index].data[secp_message_data_offset..secp_message_data_offset + secp_message_data_size])
      pubkey = ecrecover(signature, recovery_id, message_hash)
      eth_pubkey = keccak256(pubkey[1..])[12..]
      if eth_pubkey != ref_eth_pubkey {
          return Error
      }
  }
  return Success
}
```

这允许用户在交易中指定任何指令数据以进行签名和消息数据。通过指定特殊的指令sysvar，还可以从交易本身接收数据。

交易的成本将计算要验证的签名数量乘以签名成本验证乘数。

#### Secp256r1程序

用于验证secp256r1签名的程序。它接受一个secp256r1签名、一个公钥和一条消息。最多可以验证8个签名。如果任何签名验证失败，将返回错误。

- 程序ID: `Secp256r1SigVerify1111111111111111111111111`
- [指令](https://docs.rs/solana-secp256k1-recover/latest/solana_secp256k1_recover/index.html)

secp256r1程序处理一条指令。第一个`u8`是要检查的签名数量，后面跟着一个单字节填充。之后，以下结构被序列化，每个要检查的签名一个：

```rust
struct Secp256r1SignatureOffsets {
    signature_offset: u16,             // 压缩secp256r1签名的64字节偏移
    signature_instruction_index: u16,  // 查找签名的指令索引
    public_key_offset: u16,            // 压缩公钥的33字节偏移
    public_key_instruction_index: u16, // 查找公钥的指令索引
    message_data_offset: u16,          // 消息数据开始的偏移
    message_data_size: u16,            // 消息数据的大小
    message_instruction_index: u16,    // 获取消息数据的指令数据索引
}

```

签名验证的伪代码：
```
process_instruction() {
    if data.len() < SIGNATURE_OFFSETS_START {
        return Error
    }

    num_signatures = data[0] as usize
    if num_signatures == 0 || num_signatures > 8 {
        return Error
    }

    expected_data_size = num_signatures * SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START
    if data.len() < expected_data_size {
        return Error
    }

    for i in 0..num_signatures {
        offsets = parse_signature_offsets(data, i)

        signature = get_data_slice(data, instruction_datas, offsets.signature_instruction_index, offsets.signature_offset, SIGNATURE_SERIALIZED_SIZE)

        if s > half_curve_order {
            return Error
        }

        pubkey = get_data_slice(data, instruction_datas, offsets.public_key_instruction_index, offsets.public_key_offset, COMPRESSED_PUBKEY_SERIALIZED_SIZE)

        message = get_data_slice(data, instruction_datas, offsets.message_instruction_index, offsets.message_data_offset, offsets.message_data_size)

        if !verify_signature(signature, pubkey, message) {
            return Error
        }
    }

    return Success
}
```
注意：为避免意外的签名可变性，所有签名都强制执行低S值。

### 核心程序

Solana集群创世包括一系列特殊程序，提供网络的各种核心功能。历史上，这些程序被称为“原生”程序，曾与验证者代码一起分发。

1. 系统程序

- 程序ID: `11111111111111111111111111111111`
- [指令](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html)
- 创建新账户，分配账户数据，将账户分配给拥有程序，
  从系统程序拥有的账户转移lamports并支付交易费用。

2. 投票程序

- 程序ID: `Vote111111111111111111111111111111111111111`
- [指令](https://docs.rs/solana-vote-program/latest/solana_vote_program/vote_instruction/enum.VoteInstruction.html)
- 创建和管理跟踪验证者投票状态和奖励的账户。

3. 质押程序

- 程序ID: `Stake11111111111111111111111111111111111111`
- [指令](https://docs.rs/solana-sdk/latest/solana_sdk/stake/instruction/enum.StakeInstruction.html)
- 创建和管理代表质押和对验证者的委托奖励的账户。

4. 配置程序

- 程序ID: `Config1111111111111111111111111111111111111`
- [指令](https://docs.rs/solana-config-program/latest/solana_config_program/config_instruction/index.html)
- 将配置数据添加到链上，后面是允许修改它的公钥列表。与其他程序不同，配置程序不定义任何单独的指令。它只有一个隐式指令：“存储”。其指令数据是一组控制访问账户的密钥和要存储在其中的数据。

5. 计算预算程序

- 程序ID: `ComputeBudget111111111111111111111111111111`
- [指令](https://docs.rs/solana-compute-budget-interface/latest/solana_compute_budget_interface/enum.ComputeBudgetInstruction.html)

6. 地址查找表程序

- 程序ID: `AddressLookupTab1e1111111111111111111111111`
- [指令](https://docs.rs/solana-sdk/latest/solana_sdk/address_lookup_table/instruction/enum.ProgramInstruction.html)

7. Zk代币证明程序

- 程序ID: `ZkTokenProof1111111111111111111111111111111`

8. Zk Elgamal证明程序

- 程序ID: `ZkE1Gama1Proof11111111111111111111111111111`
