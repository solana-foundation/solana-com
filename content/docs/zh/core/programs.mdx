---
title: Solana上的程序
description: 了解Solana程序（智能合约）以及如何使用Rust或Anchor框架开发它们。理解Solana网络上的程序部署、升级和验证。
h1: 项目
---

在Solana上，"智能合约"被称为程序。
[程序](/docs/core/accounts#program-account)被部署到链上的账户中，这些账户包含程序的已编译可执行二进制文件。用户通过发送包含
[指令](/docs/core/transactions#instruction)的交易与程序交互，告诉程序要做什么。

## 关键点

* 程序是包含**可执行代码**的账户，代码组织成称为**指令**的函数。
* 虽然程序是**无状态的**，但它们可以包含创建和更新其他账户以存储数据的指令。
* 一个**升级权限**可以更新程序。一旦这个权限被移除，程序就变成不可变的。
* 用户可以通过可验证构建来验证链上程序账户的数据是否与其公开源代码匹配。

## 编写Solana程序

Solana程序主要使用[Rust](https://rust-book.cs.brown.edu/title-page.html)编程语言编写，开发有两种常见方法：

* [Anchor](https://www.anchor-lang.com/docs): 一个为Solana程序开发设计的框架。它通过使用Rust宏减少样板代码，提供了更快速、更简单的程序编写方式。对于初学者，建议从Anchor框架开始。

* [原生Rust](/docs/programs/rust)：这种方法涉及不使用任何框架直接用Rust编写Solana程序。它提供更多灵活性，但复杂性也更高。

## 更新Solana程序

要了解更多关于部署和升级程序的信息，请参阅
[部署程序](/docs/programs/deploying)页面。

程序可以
[直接修改](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L704)
由被指定为"升级权限"的账户进行，这通常是最初部署该程序的账户。如果
[升级权限](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L894)
被撤销并设置为`None`，程序就变成不可变的，不能再更新。

## 可验证程序

，修改者是被指定为"升级权限"的账户，通常是最初部署该程序的账户。如果

Solana开发者社区已经引入了支持可验证构建的工具，使开发者和用户都能够验证链上程序是否准确反映了其公开共享的源代码。

* **搜索已验证的程序**: 要快速检查已验证的程序，用户可以在
  [Solana Explorer](https://explorer.solana.com/)上搜索程序地址。查看已验证程序的示例
  [这里](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)。

* **验证工具**：
  [Solana可验证构建CLI](https://github.com/Ellipsis-Labs/solana-verifiable-build)
  由Ellipsis Labs开发，使用户能够独立验证链上程序是否与发布的源代码一致。

* **Anchor中对可验证构建的支持**：Anchor提供了对可验证构建的内置支持。详情可在
  [Anchor文档](https://www.anchor-lang.com/docs/verifiable-builds)中找到。

## 可验证程序

可验证构建允许任何人检查程序的链上代码是否与其公开源代码匹配，使得可以检测源代码和已部署版本之间的差异。[LLVM](https://llvm.org/)
(低级虚拟机)来将程序编译成
[ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)
(可执行和可链接格式)文件。这些文件包含Solana自定义版本的
[eBPF](https://en.wikipedia.org/wiki/EBPF)字节码，称为"Solana字节码格式"(sBPF)。ELF文件包含程序的二进制代码，并在程序部署时存储在链上的可执行账户中。

## Solana开发者社区已引入工具来支持可验证构建，使开发者和用户都能验证链上程序是否准确反映了其公开共享的源代码。

### 加载器程序

每个程序本身都由另一个程序拥有，这就是它的加载器。目前，存在五个加载器程序：

| 加载器    | 程序ID                                          | 备注                                                               | 指令链接                                                                                                                                            |
| ------ | --------------------------------------------- | ---------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| native | `NativeLoader1111111111111111111111111111111` | Owns the other four loaders                                      | —                                                                                                                                               |
| v1     | `BPFLoader1111111111111111111111111111111111` | Management instructions are disabled, but programs still execute | —                                                                                                                                               |
| v2     | `BPFLoader2111111111111111111111111111111111` | Management instructions are disabled, but programs still execute | [Instructions](https://docs.rs/solana-loader-v2-interface/latest/solana_loader_v2_interface/enum.LoaderInstruction.html)                        |
| v3     | `BPFLoaderUpgradeab1e11111111111111111111111` | Is being phased out                                              | [Instructions](https://docs.rs/solana-loader-v3-interface/latest/solana_loader_v3_interface/instruction/enum.UpgradeableLoaderInstruction.html) |
| v4     | `LoaderV411111111111111111111111111111111111` | v4预计将成为标准加载器                                                     | [Instructions](https://docs.rs/solana-loader-v4-interface/latest/solana_loader_v4_interface/instruction/enum.LoaderV4Instruction.html)          |

These loaders are necessary to create and manage custom programs:

* 部署新程序或缓冲区
* Close a program or buffer
* Redeploy / upgrade an existing program
* Transfer the authority over a program
* Finalize a program

Loader-v3 and loader-v4 support modifications to programs after their initial
deployment. Permission to do so is regulated by the authority of a program
because the account ownership of each program resides with the loader.

### 预编译程序

#### Ed25519 Program

| 程序              | 程序 ID                                         | 描述                            | Instructions                                                                                    |
| --------------- | --------------------------------------------- | ----------------------------- | ----------------------------------------------------------------------------------------------- |
| Ed25519 Program | `Ed25519SigVerify111111111111111111111111111` | 验证 ed25519 签名。如果任何签名失败，将返回错误。 | [Instructions](https://docs.rs/solana-ed25519-program/latest/solana_ed25519_program/index.html) |

ed25519 程序处理指令。第一个`u8`是要检查的签名数量，后跟单字节填充。之后，为每个要检查的签名序列化以下结构体。

```rs title="Ed25519SignatureOffsets"
struct Ed25519SignatureOffsets {
    signature_offset: u16,             // offset to ed25519 signature of 64 bytes
    signature_instruction_index: u16,  // instruction index to find signature
    public_key_offset: u16,            // offset to public key of 32 bytes
    public_key_instruction_index: u16, // instruction index to find public key
    message_data_offset: u16,          // offset to start of message data
    message_data_size: u16,            // size of message data
    message_instruction_index: u16,    // index of instruction data to get message data
}
```

The pseudo code of the signature verification:

```
process_instruction() {
    for i in 0..count {
        // i'th index values referenced:
        instructions = &transaction.message().instructions
        instruction_index = ed25519_signature_instruction_index != u16::MAX ? ed25519_signature_instruction_index : current_instruction;
        signature = instructions[instruction_index].data[ed25519_signature_offset..ed25519_signature_offset + 64]
        instruction_index = ed25519_pubkey_instruction_index != u16::MAX ? ed25519_pubkey_instruction_index : current_instruction;
        pubkey = instructions[instruction_index].data[ed25519_pubkey_offset..ed25519_pubkey_offset + 32]
        instruction_index = ed25519_message_instruction_index != u16::MAX ? ed25519_message_instruction_index : current_instruction;
        message = instructions[instruction_index].data[ed25519_message_data_offset..ed25519_message_data_offset + ed25519_message_data_size]
        if pubkey.verify(signature, message) != Success {
            return Error
        }
    }
    return Success
}
```

#### Secp256k1 程序

| 程序           | 程序 ID                                         | 描述                              | Instructions                                                                                        |
| ------------ | --------------------------------------------- | ------------------------------- | --------------------------------------------------------------------------------------------------- |
| Secp256k1 程序 | `KeccakSecp256k11111111111111111111111111111` | 验证 secp256k1 公钥恢复操作（ecrecover）。 | [Instructions](https://docs.rs/solana-secp256k1-program/latest/solana_secp256k1_program/index.html) |

secp256k1 程序处理一条指令，该指令将第一个字节作为指令数据中序列化的以下结构体的计数：

```rs title="Secp256k1SignatureOffsets"
struct Secp256k1SignatureOffsets {
    secp_signature_offset: u16,            // offset to [signature,recovery_id] of 64+1 bytes
    secp_signature_instruction_index: u8,  // instruction index to find signature
    secp_pubkey_offset: u16,               // offset to ethereum_address pubkey of 20 bytes
    secp_pubkey_instruction_index: u8,     // instruction index to find pubkey
    secp_message_data_offset: u16,         // offset to start of message data
    secp_message_data_size: u16,           // size of message data
    secp_message_instruction_index: u8,    // instruction index to find message data
}
```

恢复验证的伪代码：

```
process_instruction() {
  for i in 0..count {
      // i'th index values referenced:
      instructions = &transaction.message().instructions
      signature = instructions[secp_signature_instruction_index].data[secp_signature_offset..secp_signature_offset + 64]
      recovery_id = instructions[secp_signature_instruction_index].data[secp_signature_offset + 64]
      ref_eth_pubkey = instructions[secp_pubkey_instruction_index].data[secp_pubkey_offset..secp_pubkey_offset + 20]
      message_hash = keccak256(instructions[secp_message_instruction_index].data[secp_message_data_offset..secp_message_data_offset + secp_message_data_size])
      pubkey = ecrecover(signature, recovery_id, message_hash)
      eth_pubkey = keccak256(pubkey[1..])[12..]
      if eth_pubkey != ref_eth_pubkey {
          return Error
      }
  }
  return Success
}
```

这允许用户在交易中为签名和消息数据指定任何指令数据。通过指定特殊的指令 sysvar，还可以从交易本身接收数据。

Cost of the transaction will count the number of signatures to verify multiplied
by the signature cost verify multiplier.

#### Secp256r1 程序

| 程序                | 程序 ID                                         | 描述                                              | Instructions                                                                                        |
| ----------------- | --------------------------------------------- | ----------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| Secp256r1 Program | `Secp256r1SigVerify1111111111111111111111111` | 验证最多 8 个 secp256r1 签名。接收签名、公钥和消息。如果任何一个失败则返回错误。 | [Instructions](https://docs.rs/solana-secp256k1-recover/latest/solana_secp256k1_recover/index.html) |

secp256r1 程序处理一条指令。第一个`u8`是要检查的签名数量，后跟单字节填充。之后，为每个要检查的签名序列化以下结构体：

```rs title="Secp256r1SignatureOffsets"
struct Secp256r1SignatureOffsets {
    signature_offset: u16,             // offset to compact secp256r1 signature of 64 bytes
    signature_instruction_index: u16,  // instruction index to find signature
    public_key_offset: u16,            // offset to compressed public key of 33 bytes
    public_key_instruction_index: u16, // instruction index to find public key
    message_data_offset: u16,          // offset to start of message data
    message_data_size: u16,            // size of message data
    message_instruction_index: u16,    // index of instruction data to get message data
}

```

The pseudo code of the signature verification:

```
process_instruction() {
    if data.len() < SIGNATURE_OFFSETS_START {
        return Error
    }

    num_signatures = data[0] as usize
    if num_signatures == 0 || num_signatures > 8 {
        return Error
    }

    expected_data_size = num_signatures * SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START
    if data.len() < expected_data_size {
        return Error
    }

    for i in 0..num_signatures {
        offsets = parse_signature_offsets(data, i)

        signature = get_data_slice(data, instruction_datas, offsets.signature_instruction_index, offsets.signature_offset, SIGNATURE_SERIALIZED_SIZE)

        if s > half_curve_order {
            return Error
        }

        pubkey = get_data_slice(data, instruction_datas, offsets.public_key_instruction_index, offsets.public_key_offset, COMPRESSED_PUBKEY_SERIALIZED_SIZE)

        message = get_data_slice(data, instruction_datas, offsets.message_instruction_index, offsets.message_data_offset, offsets.message_data_size)

        if !verify_signature(signature, pubkey, message) {
            return Error
        }
    }

    return Success
}
```

Note: Low S values are enforced for all signatures to avoid accidental signature
malleability.

### 核心程序

Solana 集群创世包含一系列提供网络核心功能的特殊程序。历史上，这些被称为"原生"程序，它们曾与验证节点代码一起分发。

| 程序                               | 程序 ID                                         | 描述                                                                                           | Instructions                                                                                                                                          |
| -------------------------------- | --------------------------------------------- | -------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **System Program**               | `11111111111111111111111111111111`            | 创建新账户，分配账户数据，将账户分配给所有者程序，从系统程序拥有的账户转移lamport，并支付交易费用。                                        | [SystemInstruction](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html)                              |
| **Vote Program**                 | `Vote111111111111111111111111111111111111111` | Create and manage accounts that track validator voting state and rewards.                    | [VoteInstruction](https://docs.rs/solana-vote-program/latest/solana_vote_program/vote_instruction/enum.VoteInstruction.html)                          |
| **Stake Program**                | `Stake11111111111111111111111111111111111111` | 创建和管理代表委托给验证者的质押和奖励的账户。                                                                      | [StakeInstruction](https://docs.rs/solana-sdk/latest/solana_sdk/stake/instruction/enum.StakeInstruction.html)                                         |
| **Config Program**               | `Config1111111111111111111111111111111111111` | 将配置数据添加到链上，后跟允许修改它的公钥列表。与其他程序不同，配置程序不定义任何单独的指令。它只有一个隐式指令："存储"。其指令数据是一组控制对账户访问的密钥以及要存储在其中的数据。 | [ConfigInstruction](https://docs.rs/solana-config-program/latest/solana_config_program/config_instruction/index.html)                                 |
| **Compute Budget Program**       | `ComputeBudget111111111111111111111111111111` | 设置交易的计算单元限制和价格，允许用户控制计算资源和优先级费用。                                                             | [ComputeBudgetInstruction](https://docs.rs/solana-compute-budget-interface/latest/solana_compute_budget_interface/enum.ComputeBudgetInstruction.html) |
| **Address Lookup Table Program** | `AddressLookupTab1e1111111111111111111111111` | 管理地址查找表，允许交易引用比交易账户列表中能容纳的更多账户。                                                              | [ProgramInstruction](https://docs.rs/solana-sdk/latest/solana_sdk/address_lookup_table/instruction/enum.ProgramInstruction.html)                      |
| **ZK ElGamal 证明程序**              | `ZkE1Gama1Proof11111111111111111111111111111` | 为ElGamal加密数据提供零知识证明验证。                                                                       | —                                                                                                                                                     |
