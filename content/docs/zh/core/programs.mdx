---
title: Solana上的程序
description: 了解Solana程序（智能合约）以及如何使用Rust或Anchor框架开发它们。理解Solana网络上的程序部署、升级和验证。
h1: 项目
---

在Solana上，"智能合约"被称为程序。
[程序](/docs/core/accounts#program-account)被部署到链上的账户中，这些账户包含程序的已编译可执行二进制文件。用户通过发送包含
[指令](/docs/core/transactions#instruction)的交易与程序交互，告诉程序要做什么。

## 关键点

- 程序是包含**可执行代码**的账户，代码组织成称为**指令**的函数。
- 虽然程序是**无状态的**，但它们可以包含创建和更新其他账户以存储数据的指令。
- **升级权限**可以更新程序。一旦此权限被移除，程序就变成不可变的。
- 用户可以通过可验证构建来验证链上程序账户的数据是否与其公开源代码匹配。

## 编写Solana程序

Solana程序主要使用[Rust](https://rust-book.cs.brown.edu/title-page.html)编程语言编写，开发有两种常见方法：

- [Anchor](https://www.anchor-lang.com/docs)：为Solana程序开发设计的框架。它提供了更快速、更简单的程序编写方式，使用Rust宏显著减少样板代码。对于初学者，建议从Anchor框架开始。

- [原生Rust](/docs/programs/rust)：这种方法涉及不使用任何框架直接用Rust编写Solana程序。它提供更多灵活性，但复杂性也更高。

## 更新Solana程序

要了解更多关于部署和升级程序的信息，请参阅
[部署程序](/docs/programs/deploying)页面。

链上程序可以被

[直接修改](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L704)

，修改者是被指定为"升级权限"的账户，通常是最初部署该程序的账户。如果

[升级权限](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L894)

被撤销并设置为`None`，程序就变成不可变的，不能再更新。

## 可验证程序

可验证构建允许任何人检查程序的链上代码是否与其公开源代码匹配，使得可以检测源代码和已部署版本之间的差异。

Solana开发者社区已引入工具来支持可验证构建，使开发者和用户都能验证链上程序是否准确反映了其公开共享的源代码。

- **搜索已验证程序**：要快速检查已验证程序，用户可以在[SolanaFM](https://solana.fm/)浏览器上搜索程序地址并导航到"验证"选项卡。查看已验证程序的示例
  [点击这里](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)。

- **验证工具**：Ellipsis Labs开发的
  [Solana可验证构建CLI](https://github.com/Ellipsis-Labs/solana-verifiable-build)
  使用户能够独立验证链上程序与已发布源代码的一致性。

- **Anchor中的可验证构建支持**：Anchor提供内置的可验证构建支持。详情可在[Anchor文档](https://www.anchor-lang.com/docs/verifiable-builds)中找到。

## Berkeley数据包过滤器（BPF）

Solana使用[LLVM](https://llvm.org/)将程序编译成[ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)文件。这些文件包含Solana定制版的[eBPF](https://en.wikipedia.org/wiki/EBPF)字节码，称为"Solana字节码格式"（sBPF）。ELF文件包含程序的二进制代码，并在程序部署时存储在链上的可执行账户中。

## 内置程序

### 加载器程序

每个程序本身都由另一个程序拥有，这个程序就是它的加载器。目前有五种加载器：

1. 原生加载器：

- 程序ID：`NativeLoader1111111111111111111111111111111`
- 拥有其他四个加载器

2. 加载器v1：

- 程序ID：`BPFLoader1111111111111111111111111111111111`
- 管理指令已禁用，但程序仍然可以执行

3. 加载器v2：

- 程序ID：`BPFLoader2111111111111111111111111111111111`
- [指令](https://docs.rs/solana-loader-v2-interface/latest/solana_loader_v2_interface/enum.LoaderInstruction.html)
- 管理指令已禁用，但程序仍然可以执行

4. 加载器v3：

- 程序ID：`BPFLoaderUpgradeab1e11111111111111111111111`
- [指令](https://docs.rs/solana-loader-v3-interface/latest/solana_loader_v3_interface/instruction/enum.UpgradeableLoaderInstruction.html)
- 正在逐步淘汰

5. 加载器v4：

- 程序ID：`LoaderV411111111111111111111111111111111111`
- [指令](https://docs.rs/solana-loader-v4-interface/latest/solana_loader_v4_interface/instruction/enum.LoaderV4Instruction.html)
- 将成为标准加载器

这些加载器对于创建和管理自定义程序是必要的：

- 部署新程序或缓冲区
- 关闭程序或缓冲区
- 重新部署/升级现有程序
- 转移程序的权限
- 完成程序

加载器v3和加载器v4支持在初始部署后修改程序。由于每个程序的账户所有权归属于加载器，因此对程序进行修改的权限由程序的权限持有者控制。

### 预编译程序

#### Ed25519程序

用于验证ed25519签名的程序。它接收一个ed25519签名、一个公钥和一条消息。可以验证多个签名。如果任何签名验证失败，将返回错误。

- 程序ID：`Ed25519SigVerify111111111111111111111111111`
- [指令](https://docs.rs/solana-ed25519-program/latest/solana_ed25519_program/index.html)

ed25519程序处理一条指令。第一个`u8`是要检查的签名数量，后跟一个字节的填充。之后，为每个要检查的签名序列化以下结构。

```
struct Ed25519SignatureOffsets {
    signature_offset: u16,             // 64字节ed25519签名的偏移量
    signature_instruction_index: u16,  // 查找签名的指令索引
    public_key_offset: u16,            // 32字节公钥的偏移量
    public_key_instruction_index: u16, // 查找公钥的指令索引
    message_data_offset: u16,          // 消息数据开始的偏移量
    message_data_size: u16,            // 消息数据的大小
    message_instruction_index: u16,    // 获取消息数据的指令数据索引
}
```

签名验证的伪代码：

```
process_instruction() {
    for i in 0..count {
        // 引用第i个索引值：
        instructions = &transaction.message().instructions
        instruction_index = ed25519_signature_instruction_index != u16::MAX ? ed25519_signature_instruction_index : current_instruction;
        signature = instructions[instruction_index].data[ed25519_signature_offset..ed25519_signature_offset + 64]
        instruction_index = ed25519_pubkey_instruction_index != u16::MAX ? ed25519_pubkey_instruction_index : current_instruction;
        pubkey = instructions[instruction_index].data[ed25519_pubkey_offset..ed25519_pubkey_offset + 32]
        instruction_index = ed25519_message_instruction_index != u16::MAX ? ed25519_message_instruction_index : current_instruction;
        message = instructions[instruction_index].data[ed25519_message_data_offset..ed25519_message_data_offset + ed25519_message_data_size]
        if pubkey.verify(signature, message) != Success {
            return Error
        }
    }
    return Success
}
```

#### Secp256k1 程序

验证 secp256k1 公钥恢复操作（ecrecover）。

- 程序 ID：`KeccakSecp256k11111111111111111111111111111`
- [指令](https://docs.rs/solana-secp256k1-program/latest/solana_secp256k1_program/index.html)

secp256k1 程序处理的指令在第一个字节中包含以下结构体的计数，这些结构体在指令数据中序列化：

```
struct Secp256k1SignatureOffsets {
    secp_signature_offset: u16,            // 64+1 字节的 [signature,recovery_id] 的偏移量
    secp_signature_instruction_index: u8,  // 查找签名的指令索引
    secp_pubkey_offset: u16,               // 20 字节的以太坊地址公钥的偏移量
    secp_pubkey_instruction_index: u8,     // 查找公钥的指令索引
    secp_message_data_offset: u16,         // 消息数据开始的偏移量
    secp_message_data_size: u16,           // 消息数据的大小
    secp_message_instruction_index: u8,    // 查找消息数据的指令索引
}
```

恢复验证的伪代码：

```
process_instruction() {
  for i in 0..count {
      // 引用的第 i 个索引值：
      instructions = &transaction.message().instructions
      signature = instructions[secp_signature_instruction_index].data[secp_signature_offset..secp_signature_offset + 64]
      recovery_id = instructions[secp_signature_instruction_index].data[secp_signature_offset + 64]
      ref_eth_pubkey = instructions[secp_pubkey_instruction_index].data[secp_pubkey_offset..secp_pubkey_offset + 20]
      message_hash = keccak256(instructions[secp_message_instruction_index].data[secp_message_data_offset..secp_message_data_offset + secp_message_data_size])
      pubkey = ecrecover(signature, recovery_id, message_hash)
      eth_pubkey = keccak256(pubkey[1..])[12..]
      if eth_pubkey != ref_eth_pubkey {
          return Error
      }
  }
  return Success
}
```

这允许用户在交易中为签名和消息数据指定任何指令数据。通过指定特殊的指令 sysvar，还可以从交易本身接收数据。

交易的成本将计算要验证的签名数量乘以签名成本验证乘数。

#### Secp256r1 程序

用于验证 secp256r1 签名的程序。它接收一个 secp256r1 签名、一个公钥和一条消息。最多可以验证 8 个签名。如果任何签名验证失败，将返回错误。

- 程序 ID：`Secp256r1SigVerify1111111111111111111111111`
- [指令](https://docs.rs/solana-secp256k1-recover/latest/solana_secp256k1_recover/index.html)

secp256r1 程序处理一条指令。第一个 `u8`
是要检查的签名数量，后跟一个字节的填充。之后，为每个要检查的签名序列化以下结构体：

```rust
struct Secp256r1SignatureOffsets {
    signature_offset: u16,             // 64 字节的紧凑型 secp256r1 签名的偏移量
    signature_instruction_index: u16,  // 查找签名的指令索引
    public_key_offset: u16,            // 33 字节的压缩公钥的偏移量
    public_key_instruction_index: u16, // 查找公钥的指令索引
    message_data_offset: u16,          // 消息数据开始的偏移量
    message_data_size: u16,            // 消息数据的大小
    message_instruction_index: u16,    // 获取消息数据的指令数据索引
}

```

签名验证的伪代码：

```
process_instruction() {
    if data.len() < SIGNATURE_OFFSETS_START {
        return Error
    }

    num_signatures = data[0] as usize
    if num_signatures == 0 || num_signatures > 8 {
        return Error
    }

    expected_data_size = num_signatures * SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START
    if data.len() < expected_data_size {
        return Error
    }

    for i in 0..num_signatures {
        offsets = parse_signature_offsets(data, i)

        signature = get_data_slice(data, instruction_datas, offsets.signature_instruction_index, offsets.signature_offset, SIGNATURE_SERIALIZED_SIZE)

        if s > half_curve_order {
            return Error
        }

        pubkey = get_data_slice(data, instruction_datas, offsets.public_key_instruction_index, offsets.public_key_offset, COMPRESSED_PUBKEY_SERIALIZED_SIZE)

        message = get_data_slice(data, instruction_datas, offsets.message_instruction_index, offsets.message_data_offset, offsets.message_data_size)

        if !verify_signature(signature, pubkey, message) {
            return Error
        }
    }

    return Success
}
```

注意：对所有签名强制执行低 S 值，以避免意外的签名可塑性。

### 核心程序

Solana集群创世包含一系列特殊程序，为网络提供各种核心功能。历史上，这些被称为"原生"程序，它们曾与验证节点代码一起分发。

1. 系统程序

- 程序ID：`11111111111111111111111111111111`
- [指令](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html)
- 创建新账户，分配账户数据，将账户分配给所有者程序，从系统程序拥有的账户转移lamport并支付交易费用。

2. 投票程序

- 程序ID：`Vote111111111111111111111111111111111111111`
- [指令](https://docs.rs/solana-vote-program/latest/solana_vote_program/vote_instruction/enum.VoteInstruction.html)
- 创建和管理跟踪validator投票状态和奖励的账户。

3. 质押程序

- 程序ID：`Stake11111111111111111111111111111111111111`
- [指令](https://docs.rs/solana-sdk/latest/solana_sdk/stake/instruction/enum.StakeInstruction.html)
- 创建和管理代表委托给validator的质押和奖励的账户。

4. 配置程序

- 程序ID：`Config1111111111111111111111111111111111111`
- [指令](https://docs.rs/solana-config-program/latest/solana_config_program/config_instruction/index.html)
- 向链上添加配置数据，后跟允许修改它的公钥列表。与其他程序不同，配置程序没有定义任何单独的指令。它只有一个隐式指令："存储"。其指令数据是一组控制账户访问的密钥和要存储在其中的数据。

5. 计算预算程序

- 程序ID：`ComputeBudget111111111111111111111111111111`
- [指令](https://docs.rs/solana-compute-budget-interface/latest/solana_compute_budget_interface/enum.ComputeBudgetInstruction.html)

6. 地址查找表程序

- 程序ID：`AddressLookupTab1e1111111111111111111111111`
- [指令](https://docs.rs/solana-sdk/latest/solana_sdk/address_lookup_table/instruction/enum.ProgramInstruction.html)

7. Zk令牌证明程序

- 程序ID：`ZkTokenProof1111111111111111111111111111111`

8. Zk Elgamal证明程序

- 程序ID：`ZkE1Gama1Proof11111111111111111111111111111`
