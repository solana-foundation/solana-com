---
title: 程序派生地址
description:
  了解Solana上的程序派生地址（PDAs） - 确定性账户
  地址，能够实现安全的程序签名。理解PDA派生、
  规范性增量，以及如何创建PDA账户。
h1: 程序派生地址（PDA）
---

程序派生地址（PDAs）为Solana上的开发者提供了两个主要使用
案例：

- **确定性账户地址**：PDAs提供了一种机制，
  使用可选的“种子”（预定义输入）和特定的程序ID
  确定性地派生地址。
- **启用程序签名**：Solana运行时允许程序为
  从其程序ID派生的PDAs进行“签名”。

你可以将PDAs视为一种在链上从预定义输入集（例如字符串、数字和其他账户地址）创建类似哈希映射的结构。

这种方法的好处在于，它消除了跟踪确切地址的需要。相反，你只需记住用于其派生的特定输入。

![程序派生地址](/assets/docs/core/pda/pda.svg)

重要的是要理解，简单地派生一个程序派生地址（PDA）并不会自动在该地址上创建一个链上账户。
具有PDA作为链上地址的账户必须通过用于派生地址的程序显式创建。你可以将派生PDA视为在地图上找到一个地址。仅仅拥有一个地址并不意味着在该位置上有任何东西构建。

> 本节将涵盖派生PDAs的详细信息。程序如何使用PDAs进行签名的细节将在
> [跨程序调用（CPI）](/docs/core/cpi)部分中讨论，因为这需要对
> 两个概念的上下文。

## 关键点

- PDAs是**通过用户定义的种子、增量种子和程序ID的组合确定性派生**的地址。
- PDAs是从Ed25519曲线派生的地址，**没有对应的私钥**。
- Solana程序可以**代表使用其程序ID派生的PDAs进行签名**。
- 派生PDA并不会自动创建链上账户。
- 使用PDA作为其地址的账户必须通过Solana程序中的专用指令显式创建。

## 什么是PDA

PDAs是确定性派生的地址，看起来像标准的公钥，但没有关联的私钥。这意味着没有外部用户可以为该地址生成有效的签名。然而，Solana运行时允许程序在不需要私钥的情况下以编程方式“签名”PDAs。

作为背景，Solana
[密钥对](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/src/signer/keypair.rs#L25)
是Ed25519曲线上的点（椭圆曲线密码学），具有公钥和相应的私钥。我们通常使用公钥作为新链上账户的唯一ID，使用私钥进行签名。

![在曲线上的地址](/assets/docs/core/pda/address-on-curve.svg)

PDA是一个故意派生的点，旨在从Ed25519曲线外派生，使用一组预定义的输入。一个不在Ed25519曲线上的点没有有效的对应私钥，不能用于加密操作（签名）。

然后，PDA可以用作链上账户的地址（唯一标识符），提供一种轻松存储、映射和获取程序状态的方法。

![在曲线外的地址](/assets/docs/core/pda/address-off-curve.svg)

## 如何派生PDA

派生PDA需要3个输入。

- **可选种子**：用于派生PDA的预定义输入（例如字符串、数字、其他账户地址）。这些输入被转换为字节缓冲区。
- **增量种子**：一个附加输入（值在255-0之间），用于确保生成有效的PDA（在曲线外）。这个增量种子（从255开始）在生成PDA时附加到可选种子上，以“推动”点离开Ed25519曲线。增量种子有时被称为“随机数”。
- **程序ID**：PDA派生自的程序的地址。这也是可以“代表PDA进行签名”的程序。

![PDA派生](/assets/docs/core/pda/pda-derivation.svg)

下面的示例包括指向Solana Playground的链接，你可以在浏览器编辑器中运行这些示例。

### FindProgramAddress

要派生PDA，我们可以使用
[`findProgramAddressSync`](https://github.com/solana-labs/solana-web3.js/blob/ca9da583a39cdf8fd874a2e03fccdc849e29de34/packages/library-legacy/src/publickey.ts#L212)
方法来自[`@solana/web3.js`](https://www.npmjs.com/package/@solana/web3.js)。在其他编程语言中也有此函数的等效实现（例如
[Rust](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/pubkey.rs#L484)），但在本节中，我们将通过使用Javascript的示例进行讲解。

使用`findProgramAddressSync`方法时，我们传入：

- 转换为字节缓冲区的预定义可选种子，以及
- 用于派生PDA的程序ID（地址）

一旦找到有效的PDA，`findProgramAddressSync`将返回派生PDA所用的地址（PDA）和增量种子。

下面的示例在未提供任何可选种子的情况下派生PDA。

```ts /[]/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");

const [PDA, bump] = PublicKey.findProgramAddressSync([], programId);

console.log(`PDA: ${PDA}`);
console.log(`Bump: ${bump}`);
```

你可以在
[Solana Playground](https://beta.solpg.io/66031e5acffcf4b13384cfef)上运行这个示例。PDA和
增量种子的输出将始终相同：

```
PDA: Cu7NwqCXSmsR5vgGA3Vw9uYVViPi3kQvkbKByVQ8nPY9
Bump: 255
```

下面的下一个示例添加了一个可选种子“helloWorld”。

```ts /string/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";

const [PDA, bump] = PublicKey.findProgramAddressSync(
  [Buffer.from(string)],
  programId,
);

console.log(`PDA: ${PDA}`);
console.log(`Bump: ${bump}`);
```

你也可以在
[Solana Playground](https://beta.solpg.io/66031ee5cffcf4b13384cff0)上运行这个示例。PDA和
增量种子的输出将始终相同：

```
PDA: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
Bump: 254
```

注意，增量种子为254。这意味着255派生了一个在Ed25519曲线上的点，并不是一个有效的PDA。

`findProgramAddressSync`返回的增量种子是给定可选种子和程序ID组合中派生有效PDA的第一个值（在255-0之间）。

> 这个第一个有效的增量种子被称为“规范性增量”。为了程序安全，建议在处理PDAs时仅使用规范性增量。

### CreateProgramAddress

在底层，`findProgramAddressSync`将迭代地将附加的增量种子（随机数）附加到种子缓冲区，并调用
[`createProgramAddressSync`](https://github.com/solana-labs/solana-web3.js/blob/ca9da583a39cdf8fd874a2e03fccdc849e29de34/packages/library-legacy/src/publickey.ts#L168)
方法。增量种子从255开始，逐渐减少，直到找到有效的PDA（在曲线外）。

你可以通过使用`createProgramAddressSync`并显式传入254的增量种子来复制之前的示例。

```ts /bump/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";
const bump = 254;

const PDA = PublicKey.createProgramAddressSync(
  [Buffer.from(string), Buffer.from([bump])],
  programId,
);

console.log(`PDA: ${PDA}`);
```

在
[Solana Playground](https://beta.solpg.io/66031f8ecffcf4b13384cff1)上运行上面的示例。给定相同的种子和程序ID，PDA的输出将与之前的相匹配：

```
PDA: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
```

### 规范性增量

“规范性增量”指的是第一个增量种子（从255开始并递减1），它派生出有效的PDA。为了程序安全，建议仅使用从规范性增量派生的PDAs。

以之前的示例为参考，下面的示例尝试使用每个增量种子从255-0派生PDA。

```ts
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";

// 循环遍历所有增量种子以进行演示
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(string), Buffer.from([bump])],
      programId,
    );
    console.log("增量 " + bump + ": " + PDA);
  } catch (error) {
    console.log("增量 " + bump + ": " + error);
  }
}
```

在
[Solana Playground](https://beta.solpg.io/66032009cffcf4b13384cff2)上运行示例，你应该看到以下输出：

```
增量 255: 错误: 无效的种子，地址必须在曲线外
增量 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
增量 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
增量 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
增量 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
增量 250: 错误: 无效的种子，地址必须在曲线外
...
// 其余增量输出
```

如预期，增量种子255抛出错误，派生有效PDA的第一个增量种子是254。

然而，请注意，增量种子253-251都派生出有效的PDA，地址不同。这意味着在给定相同的可选种子和`programId`的情况下，具有不同值的增量种子仍然可以派生出有效的PDA。

<Callout type="warn">
  在构建Solana程序时，建议包含安全检查，
  验证传递给程序的PDA是使用规范性增量派生的。
  如果不这样做，可能会引入漏洞，允许意外的
  账户被提供给程序。
</Callout>

## 创建PDA账户

这个示例程序在
[Solana Playground](https://beta.solpg.io/github.com/ZYJLiu/doc-examples/tree/main/pda-account)
演示了如何使用PDA作为新账户的地址创建一个账户。示例程序使用Anchor框架编写。

在`lib.rs`文件中，你会找到以下程序，其中包括一个指令，用于使用PDA作为账户的地址创建新账户。新账户存储`user`的地址和用于派生PDA的`bump`种子。

```rust title="lib.rs" {11-14,26-29}
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // 存储`user`的地址
        account_data.user = *ctx.accounts.user.key;
        // 存储规范性增量
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        init,
        // 设置种子以派生PDA
        seeds = [b"data", user.key().as_ref()],
        // 使用规范性增量
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]

#[derive(InitSpace)]
pub struct DataAccount {
    pub user: Pubkey,
    pub bump: u8,
}
```

用于派生PDA的种子包括硬编码字符串`data`和在指令中提供的`user`账户的地址。Anchor框架自动派生规范性的`bump`种子。

```rust /data/ /user.key()/ /bump/
#[account(
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

`init`约束指示Anchor调用系统程序以使用PDA作为地址创建新账户。在底层，这是通过[CPI](/docs/core/cpi)完成的。

```rust /init/
#[account(
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

在Solana Playground提供的链接中的测试文件（`pda-account.test.ts`）中，你会找到派生PDA的Javascript等效实现。

```ts /data/ /user.publicKey/
const [PDA] = PublicKey.findProgramAddressSync(
  [Buffer.from("data"), user.publicKey.toBuffer()],
  program.programId,
);
```

然后发送一个事务以调用`initialize`指令，使用PDA作为地址创建一个新的链上账户。一旦事务被发送，PDA将用于获取在该地址上创建的链上账户。

```ts /initialize()/ /PDA/  {14}
it("已初始化！", async () => {
  const transactionSignature = await program.methods
    .initialize()
    .accounts({
      user: user.publicKey,
      pdaAccount: PDA,
    })
    .rpc();

  console.log("事务签名：", transactionSignature);
});

it("获取账户", async () => {
  const pdaAccount = await program.account.dataAccount.fetch(PDA);
  console.log(JSON.stringify(pdaAccount, null, 2));
});
```

注意，如果你使用相同的`user`地址作为种子多次调用`initialize`指令，则事务将失败。这是因为在派生的地址上已经存在一个账户。
