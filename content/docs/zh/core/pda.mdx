---
title: Program Derived Address
description:
  了解 Solana 上的程序派生地址（PDAs）-
  确定性账户地址，可实现安全的程序签名。理解 PDA 派生、规范化凸点以及如何创建
  PDA 账户。
h1: 程序派生地址 (PDA)
---

Solana上的Program Derived
Addresses（PDAs，程序派生地址）为开发者提供了两个主要用例：

- **确定性账户地址**：PDAs提供了一种机制，通过组合可选的"seeds"（预定义输入）和特定程序ID来确定性地派生地址。
- **启用程序签名**：Solana运行时使程序能够为从其程序ID派生的PDAs进行"签名"。

你可以将PDAs视为一种方式，通过预定义的输入集（例如字符串、数字和其他账户地址）在链上创建类似哈希映射的结构。

这种方法的好处是无需跟踪确切的地址。相反，你只需要记住用于派生它的特定输入。

![Program Derived Address](/assets/docs/core/pda/pda.svg)

重要的是要理解，仅仅派生Program Derived
Address（PDA）并不会自动在该地址创建链上账户。使用PDA作为链上地址的账户必须通过用于派生该地址的程序显式创建。你可以将派生PDA视为在地图上找到一个地址。仅仅拥有地址并不意味着该位置已经建造了任何东西。

> 本节将介绍派生PDAs的详细信息。关于程序如何使用PDAs进行签名的详细信息将在[Cross Program Invocations (CPIs)](/docs/core/cpi)部分中讨论，因为它需要这两个概念的上下文。

## 要点

- PDAs是使用用户定义的seeds、bump seed和程序ID的组合**确定性派生**的地址。
- PDAs是落在Ed25519曲线之外的地址，**没有对应的私钥**。
- Solana程序可以**代表使用其程序ID派生的PDAs进行签名**。
- 派生PDA不会自动创建链上账户。
- 使用PDA作为地址的账户必须通过Solana程序中的专用指令显式创建。

## 什么是PDA

PDA是确定性派生的地址，看起来像标准的公钥，但没有关联的私钥。这意味着没有外部用户可以为该地址生成有效签名。然而，Solana运行时使程序能够以编程方式为PDA"签名"，而无需私钥。

为了提供上下文，Solana[密钥对](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/src/signer/keypair.rs#L25)
是Ed25519曲线（椭圆曲线密码学）上的点，它们具有公钥和相应的私钥。我们通常使用公钥作为新的链上账户的唯一标识符，而私钥用于签名。

![On Curve Address](/assets/docs/core/pda/address-on-curve.svg)

是Ed25519曲线（椭圆曲线密码学）上的点，它们有公钥和相应的私钥。我们经常使用公钥作为链上新账户的唯一标识符，使用私钥进行签名。

PDA可以用作链上账户的地址（唯一标识符），提供一种简单存储、映射和获取程序状态的方法。

![Off Curve Address](/assets/docs/core/pda/address-off-curve.svg)

## PDA随后可以用作链上账户的地址（唯一标识符），提供一种简单存储、映射和获取程序状态的方法。

PDA的派生需要3个输入。

- **可选种子**: 用于派生PDA的预定义输入（例如字符串、数字、其他账户地址）。这些输入被转换为字节缓冲区。
- **bump
  seed**: 一个额外的输入（值在255-0之间），用于确保生成有效的PDA（非曲线上的点）。在生成PDA时，这个bump
  seed（从255开始）会附加到可选种子上，以将点"推离"Ed25519曲线。bump
  seed有时也被称为"nonce"。
- **程序ID**: PDA派生自的程序地址。这也是可以代表PDA"签名"的程序。

![PDA Derivation](/assets/docs/core/pda/pda-derivation.svg)

以下示例包含Solana Playground的链接，您可以在浏览器内编辑器中运行这些示例。

### FindProgramAddress

以下示例包含 Solana
Playground 的链接，您可以在浏览器内编辑器中运行这些示例。[`findProgramAddressSync`](https://github.com/solana-labs/solana-web3.js/blob/ca9da583a39cdf8fd874a2e03fccdc849e29de34/packages/library-legacy/src/publickey.ts#L212)
方法来自[`@solana/web3.js`](https://www.npmjs.com/package/@solana/web3.js)。其他编程语言中也有这个函数的等效实现（例如
[Rust](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/pubkey.rs#L484)），但在本节中，我们将使用Javascript演示示例。

FindProgramAddress`findProgramAddressSync`方法中，我们传入：

- 转换为字节缓冲区的预定义可选种子，以及
- 用于派生PDA的程序ID（地址）

一旦找到有效的 PDA，`findProgramAddressSync`
会返回地址（PDA）和用于派生 PDA 的 bump seed。

方法，该方法来自

```ts /[]/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");

const [PDA, bump] = PublicKey.findProgramAddressSync([], programId);

console.log(`PDA: ${PDA}`);
console.log(`Bump: ${bump}`);
```

您可以在 [Solana Playground](https://beta.solpg.io/66031e5acffcf4b13384cfef)
上运行此示例。PDA 和 bump seed 输出将始终相同：

```
PDA: Cu7NwqCXSmsR5vgGA3Vw9uYVViPi3kQvkbKByVQ8nPY9
Bump: 255
```

下面的示例在不提供任何可选 seed 的情况下推导 PDA。

```ts /string/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");

const [PDA, bump] = PublicKey.findProgramAddressSync([], programId);

console.log(`PDA: ${PDA}`);
console.log(`Bump: ${bump}`);
```

您可以在 [Solana Playground](https://beta.solpg.io/66031ee5cffcf4b13384cff0)
上运行此示例。PDA 和 bump seed 输出将始终相同：

```
PDA: Cu7NwqCXSmsR5vgGA3Vw9uYVViPi3kQvkbKByVQ8nPY9
Bump: 255
```

下面的示例添加了一个可选 seed "helloWorld"。

`findProgramAddressSync` 返回的 bump
seed 是给定可选 seed 和程序 ID 组合中能推导出有效 PDA 的第一个值（在 255-0 之间）。

> 这个第一个有效的 bump
> seed 被称为"规范 bump"。为了程序安全，建议在使用 PDA 时只使用规范 bump。

### CreateProgramAddress

请注意，bump
seed 是 254。这意味着 255 推导出了 Ed25519 曲线上的一个点，因此不是有效的 PDA。`findProgramAddressSync`
将迭代地将额外的 bump seed（随机数）附加到 seeds 缓冲区并调用
[`createProgramAddressSync`](https://github.com/solana-labs/solana-web3.js/blob/ca9da583a39cdf8fd874a2e03fccdc849e29de34/packages/library-legacy/src/publickey.ts#L168)
方法。bump seed 从值 255 开始，每次减 1，直到找到有效的 PDA（非曲线点）。

findProgramAddressSync` 返回的 bump seed 是给定可选 seed 和程序 ID 组合中能推导出有效 PDA 的第一个值（在 255-0 之间）。`
并明确传入 bump seed 值 254。

```ts /bump/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";
const bump = 254;

const PDA = PublicKey.createProgramAddressSync(
  [Buffer.from(string), Buffer.from([bump])],
  programId
);

console.log(`PDA: ${PDA}`);
```

CreateProgramAddress[Solana Playground](https://beta.solpg.io/66031f8ecffcf4b13384cff1)。给定相同的 seed 和程序 ID，PDA 输出将与前一个匹配：

```
PDA: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
```

### 规范 Bump

方法。bump
seed 的初始值为 255，然后每次减 1，直到找到一个有效的 PDA（曲线外点）。

你可以通过使用&#x20;

```ts
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";
const bump = 254;

const PDA = PublicKey.createProgramAddressSync(
  [Buffer.from(string), Buffer.from([bump])],
  programId
);

console.log(`PDA: ${PDA}`);
```

在 [Solana Playground](https://beta.solpg.io/66032009cffcf4b13384cff2)
上运行上面的示例。给定相同的种子和程序 ID，PDA 输出将与之前的匹配：

```
PDA: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
```

规范 Bump

"规范 bump"指的是第一个能够派生出有效 PDA 的 bump
seed（从 255 开始递减 1）。为了程序安全，建议只使用由规范 bump 派生的 PDA。`programId`，使用不同值的 bump
seed 仍然可以派生出有效的 PDA。

<Callout type="warn">
  在构建Solana程序时，建议包含安全检查，验证传递给程序的PDA是使用规范的bump值派生的。如果不这样做，可能会引入漏洞，允许意外的账户被提供给程序。
</Callout>

## 创建PDA账户

在
[Solana Playground](https://beta.solpg.io/github.com/ZYJLiu/doc-examples/tree/main/pda-account)
上运行示例，你应该会看到以下输出：

在`lib.rs`文件中，你会找到以下程序，其中包含一个单一指令，用于使用PDA作为账户地址创建新账户。新账户存储了`user`的地址和用于派生PDA的`bump`种子。

```rust title="lib.rs" {11-14,26-29}
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        init,
        // set the seeds to derive the PDA
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]

#[derive(InitSpace)]
pub struct DataAccount {
    pub user: Pubkey,
    pub bump: u8,
}
```

然而，请注意 bump seed
253-251 都派生出了具有不同地址的有效 PDA。这意味着给定相同的可选种子和
`programId`，不同值的 bump
seed 仍然可以派生出有效的 PDA。`user`账户的地址。Anchor框架自动派生规范的`bump`种子。

```rust /data/ /user.key()/ /bump/
#[account(
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

创建PDA账户`init`约束指示Anchor调用System
Program，使用PDA作为地址创建新账户。在底层，这是通过[CPI](/docs/core/cpi)。

```rust /init/
#[account(
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

在测试文件（`pda-account.test.ts`）中，该文件位于上面提供的Solana
Playground链接中，你将找到派生PDA的JavaScript等效代码。

```ts /data/ /user.publicKey/
const [PDA] = PublicKey.findProgramAddressSync(
  [Buffer.from("data"), user.publicKey.toBuffer()],
  program.programId
);
```

在`lib.rs`文件中，你会找到以下程序，其中包含一个单独的指令，用于使用PDA作为账户地址创建新账户。新账户存储了

```ts /initialize()/ /PDA/  {14}
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        init,
        // set the seeds to derive the PDA
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]

#[derive(InitSpace)]
pub struct DataAccount {
    pub user: Pubkey,
    pub bump: u8,
}
```

用于派生PDA的seeds包括硬编码字符串`data`和指令中提供的`user`账户地址。Anchor框架会自动派生规范的
