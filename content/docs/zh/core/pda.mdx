---
title: Program Derived Address
description:
  了解 Solana 上的程序派生地址（PDAs）-
  确定性账户地址，可实现安全的程序签名。理解 PDA 派生、规范化凸点以及如何创建
  PDA 账户。
h1: 程序派生地址 (PDA)
---

Solana上的Program Derived
Addresses（PDAs，程序派生地址）为开发者提供了两个主要用例：

* **确定性账户地址**:
  PDA提供了一种机制，通过组合可选的"seeds"（预定义输入）和特定程序ID来确定性地创建地址。
* **启用程序签名**: Solana运行时使程序能够为从程序地址派生的PDA进行"签名"。

你可以将PDAs视为一种方式，通过预定义的输入集（例如字符串、数字和其他账户地址）在链上创建类似哈希映射的结构。

这种方法的好处是无需跟踪确切的地址。相反，你只需要记住用于派生它的特定输入。

![Program Derived Address](/assets/docs/core/pda/pda.svg)

重要的是要理解，仅仅派生程序派生地址 (PDA)并不会自动在该地址创建链上账户。使用PDA作为链上地址的账户必须通过用于派生该地址的程序显式创建。你可以将派生PDA想象为在地图上找到一个地址。仅仅拥有地址并不意味着该位置已经建造了任何东西。

<Callout type="info">
  本节涵盖了派生PDA的详细信息。关于[跨
  程序调用(CPI)](/docs/core/cpi)的部分解释了程序如何使用PDA进行 签名。
</Callout>

## 要点

* PDAs是使用用户定义的seeds、bump
  seed和程序ID的组合**确定性派生**使用预定义种子、bump seed和程序ID的组合。
* PDAs是落在Ed25519曲线之外的地址，**没有对应的私钥**。
* Solana程序可以**代表从其程序ID派生的PDA进行签名**。
* 派生PDA不会自动创建链上账户。
* 使用PDA作为地址的账户必须通过Solana程序中的指令创建。

## 什么是PDA

PDA是确定性派生的地址，看起来像公钥，但没有私钥。这意味着无法为该地址生成有效签名。然而，Solana运行时使程序能够为PDA"签名"，而无需私钥。

为了提供上下文，Solana[密钥对](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/keypair/src/lib.rs#L26)
是Ed25519曲线（椭圆曲线密码学）上的点，具有公钥和相应的私钥。公钥用作链上账户的地址（唯一标识符）。

![On Curve Address](/assets/docs/core/pda/address-on-curve.svg)

PDA 是一个有意派生的点，它通过使用预定义的输入集合而落在 Ed25519 曲线之外。不在 Ed25519 曲线上的点没有有效的对应私钥，因此无法执行加密操作（签名）。

PDA 可以作为链上账户的地址（唯一标识符），提供一种简便的方法来存储、映射和获取程序状态。

![Off Curve Address](/assets/docs/core/pda/address-off-curve.svg)

## PDA随后可以用作链上账户的地址（唯一标识符），提供一种简单存储、映射和获取程序状态的方法。

PDA 的派生需要三个输入：

* **可选种子**seed：用于 PDA 派生的预定义输入（例如字符串、数字、其他账户地址）。
* **bump seed**bump
  seed：附加到可选 seed 的额外字节，以确保生成有效的 PDA（曲线外点）。bump
  seed 从 255 开始，每次递减 1，直到找到有效的 PDA。
* **程序ID**program ID：从中派生 PDA 的程序地址。该程序可以代表 PDA 进行签名。

![PDA Derivation](/assets/docs/core/pda/pda-derivation.svg)

使用以下各 SDK 中的函数来派生 PDA。

| SDK                            | 函数                                                                                                                               |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `@solana/kit` (Typescript)     | [`getProgramDerivedAddress`](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L157) |
| `@solana/web3.js` (Typescript) | [`findProgramAddressSync`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/publickey.ts#L212)               |
| `solana_sdk` (Rust)            | [`find_program_address`](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/pubkey/src/lib.rs#L617)                        |

要派生 PDA，请向 SDK 函数提供以下输入：

* 转换为字节的预定义可选 seed
* 用于派生的程序 ID（地址）

一旦找到有效的 PDA，该函数将返回地址（PDA）和用于派生的 bump seed。

### 示例

以下示例展示了如何使用相应的 SDK 派生 PDA。

点击"运行"按钮执行代码。

#### 使用可选字符串 seed 派生 PDA

<CodeTabs storage="pda-examples" flags="r">
  ```ts !! title="Kit"
  import { Address, getProgramDerivedAddress } from "@solana/kit";

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;

    let seeds: &[&[u8]] = &[b"helloWorld"];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Derive a PDA with optional address seed

\<CodeTabs storage="pda-examples"flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;

    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### console.log(

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const optionalSeedString = "helloWorld";
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedString, optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const optionalSeedString = "helloWorld";
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [Buffer.from(optionalSeedString), optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;

    let optional_seed_bytes = b"helloWorld";
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

<CodeTabs storage="pda-examples" flags="r">
  ```ts !! title="Kit"
  import {
    Address,
    getAddressEncoder,
    getProgramDerivedAddress
  } from "@solana/kit";

### const programAddress = "11111111111111111111111111111111" as Address;

const optionalSeedString = "helloWorld"; const addressEncoder =
getAddressEncoder(); const optionalSeedAddress = addressEncoder.encode(
"B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address ); const seeds =
\[optionalSeedString, optionalSeedAddress]; const \[pda, bump] = await
getProgramDerivedAddress({ programAddress, seeds });

console.log(

<Callout type="info">
  Kit example not included because the
  [createProgramDerivedAddress](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L101)
  function isn't exported.
</Callout>

<CodeTabs flags="r">

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const optionalSeed = "helloWorld";

// Loop through all bump seeds (255 down to 0)
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(optionalSeed), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed = b"helloWorld";

    // Loop through all bump seeds (255 down to 0)
    for bump in (0..=255).rev() {
        match Pubkey::create_program_address(&[optional_seed.as_ref(), &[bump]], &program_id) {
            Ok(pda) => println!("bump {}: {}", bump, pda),
            Err(err) => println!("bump {}: {}", bump, err),
        }
    }

    Ok(())
}
```

</CodeTabs>

<CodeTabs>

```sh !! title="Expected TS Output"
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// remaining bump outputs
```

```sh !! title="Expected Rust Output"
bump 255: Provided seeds do not result in a valid address
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Provided seeds do not result in a valid address
...
// remaining bump outputs
```

</CodeTabs>

// Loop through all bump seeds (255 down to 0) for (let bump = 255; bump >= 0;
bump--) { try { const PDA = PublicKey.createProgramAddressSync(
\[Buffer.from(optionalSeed), Buffer.from(\[bump])], programId );
console.log("bump " + bump + ": " + PDA); } catch (error) { console.log("bump
" + bump + ": " + error); } }

Note that bump seeds 253-251 all derive valid PDAs with different addresses.
This means that given the same optional seeds and `programId`, a bump seed with
a different value can still derive a valid PDA.

</CodeTabs>

## Create PDA Accounts

The example program below shows how to create an account using a PDA as the
address of the new account. The example program uses the
[Anchor framework](https://www.anchor-lang.com/docs).

The program includes a single `initialize` instruction to create a new account
using a PDA as the address of the account. The new account stores the address of
the `user` and the `bump` seed used to derive the PDA.

<CodeTabs>

```rs !! title="Program"
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        // !mark
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bump
        // !mark
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        init,
        // define the seeds to derive the PDA
        // !mark
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        // !mark
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]

#[derive(InitSpace)]
pub struct DataAccount {
    pub user: Pubkey,
    pub bump: u8,
}
```

```ts !! title="Test"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PdaAccount } from "../target/types/pda_account";
import { PublicKey } from "@solana/web3.js";

describe("pda-account", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.PdaAccount as Program<PdaAccount>;
  const user = provider.wallet as anchor.Wallet;

  // Derive the PDA address using the seeds specified on the program
  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("data"), user.publicKey.toBuffer()],
    program.programId
  );

  it("Is initialized!", async () => {
    const transactionSignature = await program.methods
      .initialize()
      .accounts({
        user: user.publicKey
      })
      .rpc();

    console.log("Transaction Signature:", transactionSignature);
  });

  it("Fetch Account", async () => {
    const pdaAccount = await program.account.dataAccount.fetch(PDA);
    console.log(JSON.stringify(pdaAccount, null, 2));
  });
});
```

</CodeTabs>

下面的示例程序展示了如何使用PDA作为新账户的地址来创建账户。该示例程序使用`data`.`user`
account provided in the instruction. The Anchor framework automatically finds
the canonical `bump` seed.

```rust title="pda_account"
#[account(
    init,
    // !mark[/seeds/]
    seeds = [b"data", user.key().as_ref()],
    // !mark[/bump/]
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

The `init` constraint instructs Anchor to invoke the System Program to create a
new account using the PDA as the address. Anchor does this through a
[CPI](/docs/core/cpi)的配置文件。

```rust title="pda_account"
#[account(
    // !mark[/init/]
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

\#\[program] pub mod pda\_account { use super::\*;

```ts title="Derive PDA"
const [PDA] = PublicKey.findProgramAddressSync(
  // !mark
  [Buffer.from("data"), user.publicKey.toBuffer()],
  program.programId
);
```

}`initialize` instruction to create a new on-chain account using the PDA as the
address. In this example, Anchor can infer the PDA address in the instruction
accounts, so it doesn't need to be explicitly provided.

```ts title="Invoke Initialize Instruction"
it("Is initialized!", async () => {
  const transactionSignature = await program.methods
    // !mark
    .initialize()
    .accounts({
      user: user.publicKey
    })
    .rpc();

  console.log("Transaction Signature:", transactionSignature);
});
```

The test file also shows how fetch the on-chain account created at that address
once the transaction is sent.

```ts title="Fetch Account"
it("Fetch Account", async () => {
  // !mark
  const pdaAccount = await program.account.dataAccount.fetch(PDA);
  console.log(JSON.stringify(pdaAccount, null, 2));
});
```

\#\[account]`initialize` instruction more than once using the same `user`
address as a seed, then the transaction fails. This happens because an account
already exists at the derived address.
