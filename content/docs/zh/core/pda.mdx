---
title: Program Derived Address
description:
  了解 Solana 上的程序派生地址（PDAs）-
  确定性账户地址，可实现安全的程序签名。理解 PDA 派生、规范化凸点以及如何创建
  PDA 账户。
h1: 程序派生地址 (PDA)
---

Solana上的Program Derived
Addresses（PDAs，程序派生地址）为开发者提供了两个主要用例：

* **确定性账户地址**:
  PDA提供了一种机制，通过组合可选的"seeds"（预定义输入）和特定程序ID来确定性地创建地址。
* **启用程序签名**: Solana运行时使程序能够为从程序地址派生的PDA进行"签名"。

你可以将PDAs视为一种方式，通过预定义的输入集（例如字符串、数字和其他账户地址）在链上创建类似哈希映射的结构。

这种方法的好处是无需跟踪确切的地址。相反，你只需要记住用于派生它的特定输入。

![Program Derived Address](/assets/docs/core/pda/pda.svg)

重要的是要理解，仅仅派生程序派生地址 (PDA)并不会自动在该地址创建链上账户。使用PDA作为链上地址的账户必须通过用于派生该地址的程序显式创建。你可以将派生PDA想象为在地图上找到一个地址。仅仅拥有地址并不意味着该位置已经建造了任何东西。

<Callout type="info">
  本节涵盖了派生PDA的详细信息。关于[跨
  程序调用(CPI)](/docs/core/cpi)的部分解释了程序如何使用PDA进行 签名。
</Callout>

## 要点

* PDAs是使用用户定义的seeds、bump
  seed和程序ID的组合**确定性派生**使用预定义种子、bump seed和程序ID的组合。
* PDAs是落在Ed25519曲线之外的地址，**没有对应的私钥**。
* Solana程序可以**代表从其程序ID派生的PDA进行签名**。
* 派生PDA不会自动创建链上账户。
* 使用PDA作为地址的账户必须通过Solana程序中的指令创建。

## 什么是PDA

PDA是确定性派生的地址，看起来像公钥，但没有私钥。这意味着无法为该地址生成有效签名。然而，Solana运行时使程序能够为PDA"签名"，而无需私钥。

为了提供上下文，Solana[密钥对](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/keypair/src/lib.rs#L26)
是Ed25519曲线（椭圆曲线密码学）上的点，具有公钥和相应的私钥。公钥用作链上账户的地址（唯一标识符）。

![On Curve Address](/assets/docs/core/pda/address-on-curve.svg)

PDA 是一个有意派生的点，它通过使用预定义的输入集合而落在 Ed25519 曲线之外。不在 Ed25519 曲线上的点没有有效的对应私钥，因此无法执行加密操作（签名）。

PDA 可以作为链上账户的地址（唯一标识符），提供一种简便的方法来存储、映射和获取程序状态。

![Off Curve Address](/assets/docs/core/pda/address-off-curve.svg)

## PDA随后可以用作链上账户的地址（唯一标识符），提供一种简单存储、映射和获取程序状态的方法。

PDA 的派生需要三个输入：

* **可选种子**seed：用于 PDA 派生的预定义输入（例如字符串、数字、其他账户地址）。
* **bump seed**bump
  seed：附加到可选 seed 的额外字节，以确保生成有效的 PDA（曲线外点）。bump
  seed 从 255 开始，每次递减 1，直到找到有效的 PDA。
* **程序ID**program ID：从中派生 PDA 的程序地址。该程序可以代表 PDA 进行签名。

![PDA Derivation](/assets/docs/core/pda/pda-derivation.svg)

使用以下各 SDK 中的函数来派生 PDA。

| SDK                            | 函数                                                                                                                               |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `@solana/kit` (Typescript)     | [`getProgramDerivedAddress`](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L157) |
| `@solana/web3.js` (Typescript) | [`findProgramAddressSync`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/publickey.ts#L212)               |
| `solana_sdk` (Rust)            | [`find_program_address`](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/pubkey/src/lib.rs#L617)                        |

要派生 PDA，请向 SDK 函数提供以下输入：

* 转换为字节的预定义可选 seed
* 用于派生的程序 ID（地址）

一旦找到有效的 PDA，该函数将返回地址（PDA）和用于派生的 bump seed。

### 示例

以下示例展示了如何使用相应的 SDK 派生 PDA。

点击"运行"按钮执行代码。

#### 使用可选字符串 seed 派生 PDA

<CodeTabs storage="pda-examples" flags="r">
  ```ts !! title="Kit"
  import { Address, getProgramDerivedAddress } from "@solana/kit";

  const programAddress = "11111111111111111111111111111111" as Address;

  const seeds = ["helloWorld"]; const [pda, bump] = await
  getProgramDerivedAddress({ programAddress, seeds });

  console.log(`PDA: ${pda}`); console.log(`Bump: ${bump}`);

  ```

  ```ts !! title="Legacy"
  import { PublicKey } from "@solana/web3.js";

  const programAddress = new PublicKey("11111111111111111111111111111111");

  const seeds = ["helloWorld"];
  const [pda, bump] = await PublicKey.findProgramAddressSync(
    seeds,
    programAddress
  );

  console.log(`PDA: ${pda}`);
  console.log(`Bump: ${bump}`);
  ```

  ```rs !! title="Rust"
  use solana_sdk::pubkey::Pubkey;
  use std::str::FromStr;

  #[tokio::main]
  async fn main() -> anyhow::Result<()> {
      let program_address = Pubkey::from_str("11111111111111111111111111111111")?;

      let seeds: &[&[u8]] = &[b"helloWorld"];
      let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

      println!("PDA: {}", pda);
      println!("Bump: {}", bump);
      Ok(())
  }
  ```
</CodeTabs>

#### 使用可选地址种子派生 PDA

<CodeTabs storage="pda-examples" flags="r">
  ```ts !! title="Kit"
  import {
    Address,
    getAddressEncoder,
    getProgramDerivedAddress
  } from "@solana/kit";

  const programAddress = "11111111111111111111111111111111" as Address;

  const addressEncoder = getAddressEncoder(); const optionalSeedAddress =
  addressEncoder.encode( "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
  ); const seeds = [optionalSeedAddress]; const [pda, bump] = await
  getProgramDerivedAddress({ programAddress, seeds });

  console.log(`PDA: ${pda}`); console.log(`Bump: ${bump}`);

  ```

  ```ts !! title="Legacy"
  import { PublicKey } from "@solana/web3.js";

  const programAddress = new PublicKey("11111111111111111111111111111111");

  const optionalSeedAddress = new PublicKey(
    "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
  );
  const seeds = [optionalSeedAddress.toBuffer()];
  const [pda, bump] = await PublicKey.findProgramAddressSync(
    seeds,
    programAddress
  );

  console.log(`PDA: ${pda}`);
  console.log(`Bump: ${bump}`);
  ```

  ```rs !! title="Rust"
  use solana_sdk::pubkey::Pubkey;
  use std::str::FromStr;

  #[tokio::main]
  async fn main() -> anyhow::Result<()> {
      let program_address = Pubkey::from_str("11111111111111111111111111111111")?;

      let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
      let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
      let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

      println!("PDA: {}", pda);
      println!("Bump: {}", bump);
      Ok(())
  }
  ```
</CodeTabs>

#### 使用多个可选种子派生 PDA

<CodeTabs storage="pda-examples" flags="r">
  ```ts !! title="Kit"
  import {
    Address,
    getAddressEncoder,
    getProgramDerivedAddress
  } from "@solana/kit";

  const programAddress = "11111111111111111111111111111111" as Address;

  const optionalSeedString = "helloWorld"; const addressEncoder =
  getAddressEncoder(); const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address ); const seeds =
  [optionalSeedString, optionalSeedAddress]; const [pda, bump] = await
  getProgramDerivedAddress({ programAddress, seeds });

  console.log(`PDA: ${pda}`); console.log(`Bump: ${bump}`);

  ```

  ```ts !! title="Legacy"
  import { PublicKey } from "@solana/web3.js";

  const programAddress = new PublicKey("11111111111111111111111111111111");

  const optionalSeedString = "helloWorld";
  const optionalSeedAddress = new PublicKey(
    "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
  );
  const seeds = [Buffer.from(optionalSeedString), optionalSeedAddress.toBuffer()];
  const [pda, bump] = await PublicKey.findProgramAddressSync(
    seeds,
    programAddress
  );

  console.log(`PDA: ${pda}`);
  console.log(`Bump: ${bump}`);
  ```

  ```rs !! title="Rust"
  use solana_sdk::pubkey::Pubkey;
  use std::str::FromStr;

  #[tokio::main]
  async fn main() -> anyhow::Result<()> {
      let program_address = Pubkey::from_str("11111111111111111111111111111111")?;

      let optional_seed_bytes = b"helloWorld";
      let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
      let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
      let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

      println!("PDA: {}", pda);
      println!("Bump: {}", bump);
      Ok(())
  }
  ```
</CodeTabs>

### 规范化的 Bump

PDA 派生需要一个"bump
seed"，这是附加到可选 seed 的额外字节。派生函数会迭代 bump 值，从 255 开始递减 1，直到产生有效的非曲线地址。产生有效非曲线地址的第一个 bump 值就是"规范化的 bump"。

以下示例展示了使用所有可能的 bump seed（255 到 0）进行 PDA 派生：

<Callout type="info">
  未包含 Kit 示例，因为
  [createProgramDerivedAddress](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L101)
  函数未被导出。
</Callout>

<CodeTabs flags="r">
  ```ts !! title="Legacy"
  import { PublicKey } from "@solana/web3.js";

  const programId = new PublicKey("11111111111111111111111111111111"); const
  optionalSeed = "helloWorld";

  // Loop through all bump seeds (255 down to 0) for (let bump = 255; bump >= 0;
  bump--) { try { const PDA = PublicKey.createProgramAddressSync(
  [Buffer.from(optionalSeed), Buffer.from([bump])], programId ); console.log("bump
  " + bump + ": " + PDA); } catch (error) { console.log("bump " + bump + ": " +
  error); } }

  ```

  ```rs !! title="Rust"
  use solana_sdk::pubkey::Pubkey;
  use std::str::FromStr;

  #[tokio::main]
  async fn main() -> anyhow::Result<()> {
      let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
      let optional_seed = b"helloWorld";

      // Loop through all bump seeds (255 down to 0)
      for bump in (0..=255).rev() {
          match Pubkey::create_program_address(&[optional_seed.as_ref(), &[bump]], &program_id) {
              Ok(pda) => println!("bump {}: {}", bump, pda),
              Err(err) => println!("bump {}: {}", bump, err),
          }
      }

      Ok(())
  }
  ```
</CodeTabs>

<CodeTabs>
  ```sh !! title="Expected TS Output"
  bump 255：错误：无效的种子，地址必须偏离曲线
  bump 254：46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
  bump 253：GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
  bump 252：THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
  bump 251：EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
  bump 250：错误：无效的种子，地址必须偏离曲线
  ...
  // 剩余的bump输出
  ```

  ```sh !! title="Expected Rust Output"
  bump 255：提供的种子不会产生有效地址
  bump 254：46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
  bump 253：GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
  bump 252：THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
  bump 251：EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
  bump 250：提供的种子不会产生有效地址
  ...
  // 剩余的bump输出
  ```
</CodeTabs>

bump seed 255 抛出错误，而能够派生有效PDA的第一个bump seed是254。

请注意，bump seed
253-251都能派生出有效的PDA，但地址不同。这意味着给定相同的可选种子和`programId`，具有不同值的bump
seed仍然可以派生出有效的PDA。

<Callout type="warn">
  在构建Solana程序时，始终包含安全检查以确保传递给程序的PDA是由规范bump派生的。如果不包含这些检查，可能会引入漏洞，允许在程序指令中使用意外的账户。最佳实践是在派生PDA时只使用规范bump。
</Callout>

## 创建PDA账户

下面的示例程序展示了如何使用PDA作为新账户的地址来创建账户。该示例程序使用[Anchor框架](https://www.anchor-lang.com/docs).

该程序包含一个`initialize`指令，用于使用PDA作为账户地址创建新账户。新账户存储用于派生PDA的`user`
and the `bump`种子的地址。

<CodeTabs>
  ```rs !! title="Program"
  use anchor_lang::prelude::*;

  declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

  #[program] pub mod pda_account { use super::\*;

      pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
          let account_data = &mut ctx.accounts.pda_account;
          // 存储`user`的地址
          // !mark
          account_data.user = *ctx.accounts.user.key;
          // 存储规范bump
          // !mark
          account_data.bump = ctx.bumps.pda_account;
          Ok(())
      }

  }

  #[derive(Accounts)] pub struct Initialize<'info> { #[account(mut)] pub user:
  Signer<'info>,

      #[account(
          init,
          // 定义用于派生PDA的种子
          // !mark
          seeds = [b"data", user.key().as_ref()],
          // 使用规范bump
          // !mark
          bump,
          payer = user,
          space = 8 + DataAccount::INIT_SPACE
      )]
      pub pda_account: Account<'info, DataAccount>,
      pub system_program: Program<'info, System>,

  }

  #[account]

  #[derive(InitSpace)] pub struct DataAccount { pub user: Pubkey, pub bump: u8, }

  ```

  ```ts !! title="Test"
  import * as anchor from "@coral-xyz/anchor";
  import { Program } from "@coral-xyz/anchor";
  import { PdaAccount } from "../target/types/pda_account";
  import { PublicKey } from "@solana/web3.js";

  describe("pda-account", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.PdaAccount as Program<PdaAccount>;
    const user = provider.wallet as anchor.Wallet;

    // 使用程序中指定的种子派生PDA地址
    const [PDA] = PublicKey.findProgramAddressSync(
      [Buffer.from("data"), user.publicKey.toBuffer()],
      program.programId
    );

    it("Is initialized!", async () => {
      const transactionSignature = await program.methods
        .initialize()
        .accounts({
          user: user.publicKey
        })
        .rpc();

      console.log("Transaction Signature:", transactionSignature);
    });

    it("Fetch Account", async () => {
      const pdaAccount = await program.account.dataAccount.fetch(PDA);
      console.log(JSON.stringify(pdaAccount, null, 2));
    });
  });
  ```
</CodeTabs>

在这个例子中，PDA派生的seed包括固定字符串`data`和指令中提供的`user`账户地址。Anchor框架会自动找到规范的`bump`
seed.

```rust title="pda_account"
#[account(
    init,
    // !mark[/seeds/]
    seeds = [b"data", user.key().as_ref()],
    // !mark[/bump/]
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

`init`约束指示Anchor调用System
Program，使用PDA作为地址创建一个新账户。Anchor通过[CPI](/docs/core/cpi).

```rust title="pda_account"
#[account(
    // !mark[/init/]
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

测试文件包含派生PDA的TypeScript代码。

```ts title="Derive PDA"
const [PDA] = PublicKey.findProgramAddressSync(
  // !mark
  [Buffer.from("data"), user.publicKey.toBuffer()],
  program.programId
);
```

测试文件中的交易调用`initialize`指令，使用PDA作为地址创建一个新的链上账户。在这个例子中，Anchor可以在指令账户中推断PDA地址，所以不需要明确提供。

```ts title="Invoke Initialize Instruction"
it("已初始化！", async () => {
  const transactionSignature = await program.methods
    // !mark
    .initialize()
    .accounts({
      user: user.publicKey
    })
    .rpc();

  console.log("交易签名：", transactionSignature);
});
```

测试文件还展示了如何在交易发送后获取在该地址上创建的链上账户。

```ts title="Fetch Account"
it("获取账户", async () => {
  // !mark
  const pdaAccount = await program.account.dataAccount.fetch(PDA);
  console.log(JSON.stringify(pdaAccount, null, 2));
});
```

请注意，在这个例子中，如果你使用相同的`initialize`指令多次调用，并使用相同的`user`地址作为seed，那么交易将会失败。这是因为在派生地址上已经存在一个账户。
