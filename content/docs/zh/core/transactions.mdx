---
title: 交易和指令
description:
  了解Solana交易和指令 -
  与Solana区块链交互的基本构建块。通过实用示例理解交易结构和指令组成。
---

在Solana上，用户发送[交易](/docs/core/transactions#transaction)来与网络交互。交易包含一个或多个[指令](/docs/core/transactions#instruction)，用于指定要处理的操作。指令的执行逻辑存储在[程序](/docs/core/programs)中，每个程序定义了自己的指令集。

以下是Solana交易处理的关键细节：

* 如果一个交易包含多个指令，这些指令会按照添加到交易中的顺序执行。
* 交易是"原子性"的 - 所有指令必须成功处理，否则整个交易失败且不会发生任何变化。

交易本质上是处理一个或多个指令的请求。

![Transaction Simplified](/assets/docs/core/transactions/transaction-simple.svg)

交易就像一个装有表格的信封。每个表格是一条指令，告诉网络做什么。发送交易就像邮寄信封以处理这些表格。

## 关键要点

* Solana交易包含调用网络上程序的指令。
* 交易是**原子性**的 - 如果任何指令失败，整个交易都会失败，不会发生任何更改。
* 交易中的指令按顺序执行。
* 交易大小限制是[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)字节。
* 每条指令需要三部分信息：
  1. 要调用的程序的地址
  2. 指令读取或写入的账户
  3. 指令所需的任何额外数据（例如，函数参数）

## SOL转账示例

下图表示一个包含单个指令的交易，用于将SOL从发送方转移到接收方。

在Solana上，"钱包"是由[系统程序](/docs/core/accounts#system-program)拥有的账户。只有程序所有者可以更改账户的数据，因此转移SOL需要发送交易来调用系统程序。

![SOL Transfer](/assets/docs/core/transactions/sol-transfer.svg)

发送账户必须签署（`is_signer`）交易，以允许系统程序扣除其lamport余额。发送方和接收方账户必须是可写的（`is_writable`），因为它们的lamport余额会发生变化。

发送交易后，系统程序处理转账指令。然后系统程序更新发送方和接收方账户的lamport余额。

![SOL Transfer Process](/assets/docs/core/transactions/sol-transfer-process.svg)

以下示例展示了如何发送一个包含从一个账户向另一个账户转账 SOL 指令的交易。

客户端库通常会抽象构建程序指令的细节。如果没有可用的库，你可以手动构建指令。

下面的两个示例在功能上是等效的。示例 1 使用`SystemProgram.transfer`方法，它抽象了创建指令数据缓冲区和为指令所需的每个账户设置`AccountMeta`的细节。

<CodeTabs storage="sol-transfer">
  ```typescript !! title="Example 1"
  // 定义转账金额
  const transferAmount = 0.01; // 0.01 SOL

```typescript !! title="Example 1"
// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from wallet_1 to wallet_2
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

// Add the transfer instruction to a new transaction
const transaction = new Transaction().add(transferInstruction);
```

```typescript !! title="Example 2"
// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the SystemProgram transfer instruction
const transferInstructionIndex = 2;

// Create a buffer for the data to be passed to the transfer instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// Write the instruction index to the buffer
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// Write the transfer amount to the buffer
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// Manually create a transfer instruction for transferring SOL from sender to receiver
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true }
  ],
  programId: SystemProgram.programId,
  data: instructionData
});

// Add the transfer instruction to a new transaction
const transaction = new Transaction().add(transferInstruction);
```

</CodeTabs>

</CodeTabs>

```ts !! title="Example 1"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

// Use devnet cluster connection
const connection = new Connection("http://localhost:8899", "confirmed");

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Fund sender with airdrop
const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Check balance before transfer
const preBalance1 = await connection.getBalance(sender.publicKey);
const preBalance2 = await connection.getBalance(recipient.publicKey);

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

// Add the transfer instruction to a new transaction
const transaction = new Transaction().add(transferInstruction);

// Send the transaction to the network
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [sender] // signer
);

// Check balance after transfer
const postBalance1 = await connection.getBalance(sender.publicKey);
const postBalance2 = await connection.getBalance(recipient.publicKey);

console.log("Sender prebalance:", preBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient prebalance:", preBalance2 / LAMPORTS_PER_SOL);
console.log("Sender postbalance:", postBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient postbalance:", postBalance2 / LAMPORTS_PER_SOL);
console.log("Transaction Signature:", transactionSignature);
```

```ts !! title="Example 2"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  TransactionInstruction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Fund sender with airdrop
const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Check balance before transfer
const preBalance1 = await connection.getBalance(sender.publicKey);
const preBalance2 = await connection.getBalance(recipient.publicKey);

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the SystemProgram transfer instruction
const transferInstructionIndex = 2;

// Create a buffer for the data to be passed to the transfer instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// Write the instruction index to the buffer
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// Write the transfer amount to the buffer
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// Manually create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: recipient.publicKey, isSigner: false, isWritable: true }
  ],
  programId: SystemProgram.programId,
  data: instructionData
});

// Add the transfer instruction to a new transaction
const transaction = new Transaction().add(transferInstruction);

// Send the transaction to the network
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [sender] // signer
);

// Check balance after transfer
const postBalance1 = await connection.getBalance(sender.publicKey);
const postBalance2 = await connection.getBalance(recipient.publicKey);

console.log("Sender prebalance:", preBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient prebalance:", preBalance2 / LAMPORTS_PER_SOL);
console.log("Sender postbalance:", postBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient postbalance:", postBalance2 / LAMPORTS_PER_SOL);
console.log("Transaction Signature:", transactionSignature);
```

</CodeTabs>

// 通过空投为发送方提供资金 const airdropSignature = await
connection.requestAirdrop( sender.publicKey, LAMPORTS\_PER\_SOL ); await
connection.confirmTransaction(airdropSignature, "confirmed");

// 转账前检查余额 const preBalance1 = await
connection.getBalance(sender.publicKey); const preBalance2 = await
connection.getBalance(recipient.publicKey);

***

Solana
[程序](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)上的[指令](/docs/core/accounts#program-account)可以被理解为一个公共函数，任何使用Solana网络的人都可以调用它。

// 定义转账金额 const transferAmount = 0.01; // 0.01 SOL

* 程序ID：具有指令执行逻辑的程序
* 账户：指令需要的账户列表
* instruction data：指定要在程序上调用的指令以及该指令所需的任何参数的字节数组

```rust title="Instruction"
pub struct Instruction {
    /// Pubkey of the program that executes this instruction.
    pub program_id: Pubkey,
    /// Metadata describing accounts that should be passed to the program.
    pub accounts: Vec<AccountMeta>,
    /// Opaque data passed to the program for its own interpretation.
    pub data: Vec<u8>,
}
```

![Transaction Instruction](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

console.log("发送方转账前余额:", preBalance1 / LAMPORTS\_PER\_SOL);
console.log("接收方转账前余额:", preBalance2 / LAMPORTS\_PER\_SOL);
console.log("发送方转账后余额:", postBalance1 / LAMPORTS\_PER\_SOL);
console.log("接收方转账后余额:", postBalance2 / LAMPORTS\_PER\_SOL);
console.log("交易签名:",
transactionSignature);[AccountMeta](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25)包含：

* `pubkey`：账户的地址
* `is_signer`：账户是否必须签署交易
* `is_writable`：指令是否修改账户的数据

```rust title="AccountMeta"
pub struct AccountMeta {
    /// An account's public key.
    pub pubkey: Pubkey,
    /// True if an `Instruction` requires a `Transaction` signature matching `pubkey`.
    pub is_signer: bool,
    /// True if the account data or metadata may be mutated during program execution.
    pub is_writable: bool,
}
```

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

通过预先指定指令读取或写入哪些账户，不修改相同账户的交易可以并行执行。

### Solana上的

调用程序的指令需要三个关键信息：

* `keys`：包括指令所需的每个账户的`AccountMeta`。
* `programId`：具有指令执行逻辑的程序的地址。
* `data`：作为字节缓冲区的指令数据

```json title="SOL Transfer Instruction"
{
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  "programId": "11111111111111111111111111111111",
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

<CodeTabs flags="r">

```ts !! title="Example"
<CodeTabs flags="r">
```

</CodeTabs>

## 交易

Transactions[交易](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)包括：

1. [签名](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)：交易中包含的签名数组。
2. [消息](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)：要原子性处理的指令列表。

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    pub message: Message,
}
```

![Transaction Format](/assets/docs/core/transactions/tx_format.png)

交易消息的结构包括：

* [消息头](/docs/core/transactions#message-header)：指定签名者和只读账户的数量。
* [账户地址](/docs/core/transactions#array-of-account-addresses)：交易指令所需的账户地址数组。
* [最近区块哈希](/docs/core/transactions#recent-blockhash)：作为交易的时间戳。
* [指令](/docs/core/transactions#array-of-instructions)：要执行的指令数组。

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    pub instructions: Vec<CompiledInstruction>,
}
```

![Transaction Message](/assets/docs/core/transactions/legacy_message.png)

### 交易大小

// 生成发送方和接收方密钥对 const sender = Keypair.generate(); const recipient =
new
Keypair();[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
字节。这个限制来自IPv6最大传输单元（MTU）大小1280字节，减去48字节的网络头（40字节IPv6 +
8字节分片头）。

// 定义转账金额 const transferAmount = 0.01; // 0.01 SOL

* 签名：每个64字节
* 消息：头部（3字节），账户密钥（每个32字节），最近区块哈希（32字节）和指令

![Transaction Format](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### 消息头

Message
Header[消息头](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
使用三个字节定义账户权限。

1. 所需签名
2. 只读已签名账户数量
3. 只读未签名账户数量

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    pub num_readonly_unsigned_accounts: u8,
}
```

![Message Header](/assets/docs/core/transactions/message_header.png)

### 紧凑数组格式

Transaction Size

1. 数组长度（编码为[compact-u16](https://github.com/anza-xyz/agave/blob/v2.1.13/short-vec/src/lib.rs))
2. 数组项一个接一个列出

![Compact array format](/assets/docs/core/transactions/compact_array_format.png)

这种格式用于编码交易消息中
[账户地址](/docs/core/transactions#array-of-account-addresses)和
[指令](/docs/core/transactions#array-of-instructions)数组的长度。

### This format is used to encode the lengths of the&#xA;

消息头部[账户地址](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
是由其指令所需的。该数组以一个
[compact-u16](/docs/core/transactions#compact-array-format)数字开始，表示它包含多少个地址。然后，这些地址按照消息头部确定的权限顺序排列。

* 可写且为签名者的账户
* 只读且为签名者的账户
* 可写但非签名者的账户
* 只读且非签名者的账户

![Compact array of account addresses](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### 最近区块哈希

Recent
Blockhash[最近区块哈希](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L141)
有两个用途：

1. 作为时间戳
2. 防止重复交易

区块哈希在
[150](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)
个区块后过期（假设区块时间为400毫秒，约1分钟），之后交易将无法处理。

A blockhash expires after
[`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) blocks (about 1 minute
assuming 400ms block times), after which the transaction cannot be
processed.[Solana Playground](https://beta.solpg.io/661a06e1cffcf4b13384d046)。

### You can use the&#x20;

这种格式用于编码
[instructions](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
在
[CompiledInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
类型中。指令在添加到交易时会转换为此类型。

Array of Account
Addresses[instructions](/docs/core/transactions#compact-array-format) in the

1. 程序 ID 索引：一个 u8 索引，指向账户地址数组中程序的地址。这指定了将处理该指令的程序。
2. 账户索引：一个 u8 索引数组，指向此指令所需的账户地址。
3. 指令数据：一个字节数组，指定要在程序上调用的指令以及指令所需的任何附加数据（例如函数参数）。

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    pub data: Vec<u8>,
}
```

![Compact array of Instructions](/assets/docs/core/transactions/compact_array_of_ixs.png)

### 交易结构示例

Every transaction requires a

```json title="Transaction Data"
{
  "recentBlockhash": "BVSg5fnMhWXHtAV5631CMCkvAsqkJWd5ESCqxuEd6M3a",
  "feePayer": "J3YyEVXxQNU24C3cSRm4tY1GuWAxYmpSbTCAuxSTQY1Y",
  "nonceInfo": null,
  "instructions": [
    {
      "keys": [
        {
          "pubkey": "J3YyEVXxQNU24C3cSRm4tY1GuWAxYmpSbTCAuxSTQY1Y",
          "isSigner": true,
          "isWritable": true
        },
        {
          "pubkey": "AxrbyGTXVLx265cdf2jHmLduVU5uf3V1bNdQfAKeP1BZ",
          "isSigner": false,
          "isWritable": true
        }
      ],
      "programId": "11111111111111111111111111111111",
      "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
    }
  ],
  "signers": ["J3YyEVXxQNU24C3cSRm4tY1GuWAxYmpSbTCAuxSTQY1Y"]
}
```

<CodeTabs flags="r">

```ts !! title="Example"
<CodeTabs flags="r">
```

</CodeTabs>

当您在将交易发送到网络后使用其签名获取交易时，您将收到具有以下结构的响应。

Like the account addresses array in the message, it starts with a`message`
字段包含以下字段：

* `header`: 为 `accountKeys` 数组中的地址指定读/写和签名者权限

* `accountKeys`: 交易指令中使用的所有账户地址的数组

* `recentBlockhash`: 用于为交易添加时间戳的区块哈希

* `instructions`: 要执行的指令数组。每个指令中的 `account` 和 `programIdIndex`
  通过索引引用 `accountKeys` 数组。

* `signatures`: 包含交易指令所需的所有签名者账户的签名的数组。签名是通过使用账户对应的私钥对交易消息进行签名而创建的。

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
