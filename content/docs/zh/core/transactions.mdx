---
title: 交易和指令
description:
  了解Solana交易和指令 -
  与Solana区块链交互的基本构建块。通过实用示例理解交易结构和指令组成。
---

在Solana上，用户发送[交易](/docs/core/transactions#transaction)来与网络交互。交易包含一个或多个[指令](/docs/core/transactions#instruction)，用于指定要处理的操作。指令的执行逻辑存储在[程序](/docs/core/programs)中，每个程序定义了自己的指令集。

以下是Solana交易处理的关键细节：

* 如果一个交易包含多个指令，这些指令会按照添加到交易中的顺序执行。
* 交易是"原子性"的 - 所有指令必须成功处理，否则整个交易失败且不会发生任何变化。

交易本质上是处理一个或多个指令的请求。

![Transaction Simplified](/assets/docs/core/transactions/transaction-simple.svg)

交易就像一个装有表格的信封。每个表格是一条指令，告诉网络做什么。发送交易就像邮寄信封以处理这些表格。

## 关键要点

* Solana交易包含调用网络上程序的指令。
* 交易是**原子性**的 - 如果任何指令失败，整个交易都会失败，不会发生任何更改。
* 交易中的指令按顺序执行。
* 交易大小限制是[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)字节。
* 每条指令需要三部分信息：
  1. 要调用的程序的地址
  2. 指令读取或写入的账户
  3. 指令所需的任何额外数据（例如，函数参数）

## SOL转账示例

下图表示一个包含单个指令的交易，用于将SOL从发送方转移到接收方。

在Solana上，"钱包"是由[系统程序](/docs/core/accounts#system-program)拥有的账户。只有程序所有者可以更改账户的数据，因此转移SOL需要发送交易来调用系统程序。

![SOL Transfer](/assets/docs/core/transactions/sol-transfer.svg)

发送账户必须签署（`is_signer`）交易，以允许系统程序扣除其lamport余额。发送方和接收方账户必须是可写的（`is_writable`），因为它们的lamport余额会发生变化。

发送交易后，系统程序处理转账指令。然后系统程序更新发送方和接收方账户的lamport余额。

![SOL Transfer Process](/assets/docs/core/transactions/sol-transfer-process.svg)

以下示例展示了如何发送一个包含从一个账户向另一个账户转账 SOL 指令的交易。

客户端库通常会抽象构建程序指令的细节。如果没有可用的库，你可以手动构建指令。

下面的两个示例在功能上是等效的。示例 1 使用`SystemProgram.transfer`方法，它抽象了创建指令数据缓冲区和为指令所需的每个账户设置`AccountMeta`的细节。

<CodeTabs storage="sol-transfer">
  ```typescript !! title="Example 1"
  // 定义转账金额
  const transferAmount = 0.01; // 0.01 SOL

  // 创建一个从 wallet_1 向 wallet_2 转账 SOL 的转账指令 const transferInstruction
  = SystemProgram.transfer({ fromPubkey: sender.publicKey, toPubkey:
  receiver.publicKey, lamports: transferAmount \* LAMPORTS_PER_SOL
  // 将转账金额转换为 lamports });

  // 将转账指令添加到新交易中 const transaction = new
  Transaction().add(transferInstruction);

  ```

  ```typescript !! title="Example 2"
  // 定义转账金额
  const transferAmount = 0.01; // 0.01 SOL

  // SystemProgram 转账指令的指令索引
  const transferInstructionIndex = 2;

  // 为传递给转账指令的数据创建一个缓冲区
  const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
  // 将指令索引写入缓冲区
  instructionData.writeUInt32LE(transferInstructionIndex, 0);
  // 将转账金额写入缓冲区
  instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

  // 手动创建一个从发送者向接收者转账 SOL 的转账指令
  const transferInstruction = new TransactionInstruction({
    keys: [
      { pubkey: sender.publicKey, isSigner: true, isWritable: true },
      { pubkey: receiver.publicKey, isSigner: false, isWritable: true }
    ],
    programId: SystemProgram.programId,
    data: instructionData
  });

  // 将转账指令添加到新交易中
  const transaction = new Transaction().add(transferInstruction);
  ```
</CodeTabs>

<CodeTabs storage="sol-transfer" flags="r">
  ```ts !! title="Example 1"
  import {
    LAMPORTS_PER_SOL,
    SystemProgram,
    Transaction,
    sendAndConfirmTransaction,
    Keypair,
    Connection
  } from "@solana/web3.js";

  // 使用devnet集群连接const connection = new Connection("http://localhost:8899",
  "confirmed");

  // 生成发送方和接收方密钥对 const sender = Keypair.generate(); const recipient =
  new Keypair();

  // 通过空投为发送方提供资金 const airdropSignature = await
  connection.requestAirdrop( sender.publicKey, LAMPORTS_PER_SOL ); await
  connection.confirmTransaction(airdropSignature, "confirmed");

  // 转账前检查余额 const preBalance1 = await
  connection.getBalance(sender.publicKey); const preBalance2 = await
  connection.getBalance(recipient.publicKey);

  // 定义转账金额 const transferAmount = 0.01; // 0.01 SOL

  // 创建从发送方到接收方转账SOL的指令const transferInstruction =
  SystemProgram.transfer({ fromPubkey: sender.publicKey, toPubkey:
  recipient.publicKey, lamports: transferAmount \* LAMPORTS_PER_SOL
  // 将转账金额转换为lamports });

  // 将转账指令添加到新交易中 const transaction = new
  Transaction().add(transferInstruction);

  // 将交易发送到网络 const transactionSignature = await
  sendAndConfirmTransaction( connection, transaction, [sender] // 签名者 );

  // 转账后检查余额 const postBalance1 = await
  connection.getBalance(sender.publicKey); const postBalance2 = await
  connection.getBalance(recipient.publicKey);

  console.log("发送方转账前余额:", preBalance1 / LAMPORTS_PER_SOL);
  console.log("接收方转账前余额:", preBalance2 / LAMPORTS_PER_SOL);
  console.log("发送方转账后余额:", postBalance1 / LAMPORTS_PER_SOL);
  console.log("接收方转账后余额:", postBalance2 / LAMPORTS_PER_SOL);
  console.log("交易签名:", transactionSignature);

  ```

  ```ts !! title="Example 2"
  import {
    LAMPORTS_PER_SOL,
    SystemProgram,
    Transaction,
    sendAndConfirmTransaction,
    TransactionInstruction,
    Keypair,
    Connection
  } from "@solana/web3.js";

  const connection = new Connection("http://localhost:8899", "confirmed");

  // 生成发送方和接收方密钥对
  const sender = Keypair.generate();
  const recipient = new Keypair();

  // 通过空投为发送方提供资金
  const airdropSignature = await connection.requestAirdrop(
    sender.publicKey,
    LAMPORTS_PER_SOL
  );
  await connection.confirmTransaction(airdropSignature, "confirmed");

  // 转账前检查余额
  const preBalance1 = await connection.getBalance(sender.publicKey);
  const preBalance2 = await connection.getBalance(recipient.publicKey);

  // 定义转账金额
  const transferAmount = 0.01; // 0.01 SOL

  // SystemProgram转账指令的索引
  const transferInstructionIndex = 2;

  // 创建一个缓冲区用于传递给转账指令的数据
  const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
  // 将指令索引写入缓冲区
  instructionData.writeUInt32LE(transferInstructionIndex, 0);
  // 将转账金额写入缓冲区
  instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

  // 手动创建从发送方到接收方转账SOL的指令
  const transferInstruction = new TransactionInstruction({
    keys: [
      { pubkey: sender.publicKey, isSigner: true, isWritable: true },
      { pubkey: recipient.publicKey, isSigner: false, isWritable: true }
    ],
    programId: SystemProgram.programId,
    data: instructionData
  });

  // 将转账指令添加到新交易中
  const transaction = new Transaction().add(transferInstruction);

  // 将交易发送到网络
  const transactionSignature = await sendAndConfirmTransaction(
    connection,
    transaction,
    [sender] // 签名者
  );

  // 转账后检查余额
  const postBalance1 = await connection.getBalance(sender.publicKey);
  const postBalance2 = await connection.getBalance(recipient.publicKey);

  console.log("发送方转账前余额:", preBalance1 / LAMPORTS_PER_SOL);
  console.log("接收方转账前余额:", preBalance2 / LAMPORTS_PER_SOL);
  console.log("发送方转账后余额:", postBalance1 / LAMPORTS_PER_SOL);
  console.log("接收方转账后余额:", postBalance2 / LAMPORTS_PER_SOL);
  console.log("交易签名:", transactionSignature);
  ```
</CodeTabs>

在下面的章节中，我们将详细介绍交易和指令的细节。

## 指令

Solana上的[instruction data](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)可以被理解为[program](/docs/core/accounts#program-account)任何人都可以通过Solana网络调用的公共函数。

调用程序的指令需要三个关键信息：

* 程序ID：具有指令执行逻辑的程序
* 账户：指令需要的账户列表
* 指令数据：指定要在程序上调用的指令及指令所需任何参数的字节数组

```rust title="Instruction"
pub struct Instruction {
    /// Pubkey of the program that executes this instruction.
    pub program_id: Pubkey,
    /// Metadata describing accounts that should be passed to the program.
    pub accounts: Vec<AccountMeta>,
    /// Opaque data passed to the program for its own interpretation.
    pub data: Vec<u8>,
}
```

![Transaction Instruction](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

指令所需的每个账户都必须作为[AccountMeta](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25)
that contains:

* `pubkey`: Account's address
* `is_signer`: Whether the account must sign the transaction
* `is_writable`：指令是否修改账户的数据

```rust title="AccountMeta"
pub struct AccountMeta {
    /// An account's public key.
    pub pubkey: Pubkey,
    /// True if an `Instruction` requires a `Transaction` signature matching `pubkey`.
    pub is_signer: bool,
    /// True if the account data or metadata may be mutated during program execution.
    pub is_writable: bool,
}
```

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

通过预先指定指令读取或写入哪些账户，不修改相同账户的交易可以并行执行。

### Example Instruction Structure

下面的示例显示了SOL转账指令的结构。

* `keys`: Includes the `AccountMeta` for each account required by an
  instruction.
* `programId`：具有指令执行逻辑的程序地址。
* `data`: The instruction data for the instruction as a buffer of bytes

```json title="SOL Transfer Instruction"
{
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  "programId": "11111111111111111111111111111111",
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

<CodeTabs flags="r">
  ```ts !! title="Example"
  import {
    LAMPORTS_PER_SOL,
    SystemProgram,
    Transaction,
    Keypair,
    Connection
  } from "@solana/web3.js";

  const connection = new Connection("http://localhost:8899", "confirmed");

  // 生成发送方和接收方密钥对 const sender = Keypair.generate(); const recipient =
  new Keypair();

  // 定义转账金额 const transferAmount = 0.01; // 0.01 SOL

  // 创建一个从发送方向接收方转账SOL的转账指令const transferInstruction =
  SystemProgram.transfer({ fromPubkey: sender.publicKey, toPubkey:
  recipient.publicKey, lamports: transferAmount \* LAMPORTS_PER_SOL
  // 将转账金额转换为lamports });

  console.log(JSON.stringify(transferInstruction, null, 2));

  ```
</CodeTabs>

## 交易

Solana
[交易](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
包含：

1. [Signatures](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30):
   An array of signatures included on the transaction.
2. [Message](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131):
   List of instructions to be processed atomically.

```rust title="Transaction"
pub struct Transaction {
#[wasm_bindgen(skip)]
#[serde(with = "short_vec")]
pub signatures: Vec<Signature>,

#[wasm_bindgen(skip)]
pub message: Message,
}
```

![Transaction Format](/assets/docs/core/transactions/tx_format.png)

The structure of a transaction message consists of:

* [Message Header](/docs/core/transactions#message-header): Specifies the number
  of signer and read-only account.
* [Account Addresses](/docs/core/transactions#array-of-account-addresses): An
  array of account addresses required by the instructions on the transaction.
* [Recent Blockhash](/docs/core/transactions#recent-blockhash): Acts as a
  timestamp for the transaction.
* [Instructions](/docs/core/transactions#array-of-instructions): An array of
  instructions to be executed.

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    pub instructions: Vec<CompiledInstruction>,
}
```

![Transaction Message](/assets/docs/core/transactions/legacy_message.png)

### Transaction Size

Solana交易的大小限制为
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
字节。这个限制来源于IPv6最大传输单元(MTU)大小1280字节，减去48字节的网络头部（40字节IPv6 +
8字节分片头部）。

交易的总大小（签名和消息）必须保持在这个限制之下并包括：

* Signatures: 64 bytes each
* Message: Header (3 bytes), account keys (32 bytes each), recent blockhash (32
  bytes), and instructions

![Transaction Format](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### 消息头部

这个
[消息头部](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
使用三个字节来定义账户权限。

1. 所需签名
2. Number of read-only signed accounts
3. Number of read-only unsigned accounts

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    pub num_readonly_unsigned_accounts: u8,
}
```

![Message Header](/assets/docs/core/transactions/message_header.png)

### Compact-Array Format

交易消息中的紧凑数组是按以下格式序列化的数组：

1. The array length (encoded as
   [compact-u16](https://github.com/anza-xyz/agave/blob/v2.1.13/short-vec/src/lib.rs))
2. The array items listed one after another

![Compact array format](/assets/docs/core/transactions/compact_array_format.png)

这种格式用于编码
[账户地址](/docs/core/transactions#array-of-account-addresses)和
[Instructions](/docs/core/transactions#array-of-instructions) arrays in
transaction messages.

### Array of Account Addresses

A transaction message contains an array of
[account addresses](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
所需的指令长度。数组以一个
[compact-u16](/docs/core/transactions#compact-array-format)数字开始，表示它包含多少个地址。然后这些地址按照它们的权限排序，这由消息头部决定。

* Accounts that are writable and signers
* Accounts that are read-only and signers
* Accounts that are writable and not signers
* Accounts that are read-only and not signers

![Compact array of account addresses](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### 最近的区块哈希

Every transaction requires a
[recent blockhash](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L141)
that serves two purposes:

1. Acts as a timestamp
2. Prevents duplicate transactions

区块哈希在
[150](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)
blocks (about 1 minute assuming 400ms block times), after which the transaction
cannot be processed.

你可以使用[`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash)RPC方法获取当前区块哈希和区块哈希有效的最后区块高度。这里是一个
[Solana Playground](https://beta.solpg.io/661a06e1cffcf4b13384d046).

### 指令数组

A transaction message contains an array of
[instructions](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
in the
[CompiledInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
type. Instructions are converted to this type when added to a transaction.

Like the account addresses array in the message, it starts with a
[compact-u16](/docs/core/transactions#compact-array-format) length followed by
the instruction data. Each instruction contains:

1. Program ID Index: An u8 index that points to the program's address in the
   account addresses array. This specifies the program that will process the
   instruction.
2. Account Indexes: An array of u8 indexes that point to the account addresses
   required for this instruction.
3. Instruction Data: A byte array specifying which instruction to invoke on the
   program and any additional data required by the instruction (eg. function
   arguments).

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    pub data: Vec<u8>,
}
```

![Compact array of Instructions](/assets/docs/core/transactions/compact_array_of_ixs.png)

### 交易结构示例

下面的示例显示了一个包含单个SOL转账指令的交易结构，在它被发送到网络之前。

```json title="Transaction Data"
{
  "recentBlockhash": "BVSg5fnMhWXHtAV5631CMCkvAsqkJWd5ESCqxuEd6M3a",
  "feePayer": "J3YyEVXxQNU24C3cSRm4tY1GuWAxYmpSbTCAuxSTQY1Y",
  "nonceInfo": null,
  "instructions": [
    {
      "keys": [
        {
          "pubkey": "J3YyEVXxQNU24C3cSRm4tY1GuWAxYmpSbTCAuxSTQY1Y",
          "isSigner": true,
          "isWritable": true
        },
        {
          "pubkey": "AxrbyGTXVLx265cdf2jHmLduVU5uf3V1bNdQfAKeP1BZ",
          "isSigner": false,
          "isWritable": true
        }
      ],
      "programId": "11111111111111111111111111111111",
      "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
    }
  ],
  "signers": ["J3YyEVXxQNU24C3cSRm4tY1GuWAxYmpSbTCAuxSTQY1Y"]
}
```

<CodeTabs flags="r">
  ```ts !! title="Example"
  import {
    LAMPORTS_PER_SOL,
    SystemProgram,
    Transaction,
    Keypair,
    Connection
  } from "@solana/web3.js";

  const connection = new Connection("http://localhost:8899", "confirmed"); const {
  blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();

  // 生成发送方和接收方密钥对 const sender = Keypair.generate(); const recipient =
  new Keypair();

  // 定义转账金额 const transferAmount = 0.01; // 0.01 SOL

  // 创建一个从发送方向接收方转账SOL的转账指令const transferInstruction =
  SystemProgram.transfer({ fromPubkey: sender.publicKey, toPubkey:
  recipient.publicKey, lamports: transferAmount \* LAMPORTS_PER_SOL
  // 将转账金额转换为lamports });

  const transaction = new Transaction({ blockhash, lastValidBlockHeight, feePayer:
  sender.publicKey }).add(transferInstruction); transaction.sign(sender);

  console.log(JSON.stringify(transaction, null, 2));

  ```
</CodeTabs>

当你使用交易签名从网络获取交易后，你将收到一个具有以下结构的响应。

message`字段包含以下内容：` 字段包含以下字段：

* `header`: Specifies read/write and signer privileges for addresses in the
  `accountKeys` array

* `accountKeys`: Array of all account addresses used in the transaction's
  instructions

* `recentBlockhash`: Blockhash used to timestamp the transaction

* `instructions`: Array of instructions to execute. Each `account` and
  `programIdIndex` in an instruction references the `accountKeys` array by
  index.

* `signatures`: Array including signatures for all accounts required as signers
  by the instructions on the transaction. A signature is created by signing the
  transaction message using the corresponding private key for an account.

```json title="Transaction Data"
{
"blockTime": 1745196488,
"meta": {
"computeUnitsConsumed": 150,
"err": null,
"fee": 5000,
"innerInstructions": [],
"loadedAddresses": {
  "readonly": [],
  "writable": []
},
"logMessages": [
  "Program 11111111111111111111111111111111 invoke [1]",
  "Program 11111111111111111111111111111111 success"
],
"postBalances": [989995000, 10000000, 1],
"postTokenBalances": [],
"preBalances": [1000000000, 0, 1],
"preTokenBalances": [],
"rewards": [],
"status": {
  "Ok": null
}
},
"slot": 13049,
"transaction": {
"message": {
  "header": {
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1,
    "numRequiredSignatures": 1
  },
  "accountKeys": [
    "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
    "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
  "instructions": [
    {
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb",
      "programIdIndex": 2,
      "stackHeight": null
    }
  ],
  "indexToProgramIds": {}
},
"signatures": [
  "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
]
},
"version": "legacy"
}
```
