---
title: 交易和指令
description:
  了解Solana交易和指令 -
  与Solana区块链交互的基本构建块。通过实际示例理解交易结构和指令组成。
---

在Solana上，我们发送[交易](/docs/core/transactions#transaction)来与网络交互。交易包含一个或多个[指令](/docs/core/transactions#instruction)，用于指定要处理的操作。指令的执行逻辑存储在部署到Solana网络的[程序](/docs/core/programs)中，每个程序定义了自己的指令集。

以下是关于交易处理的关键细节：

- 如果一个交易包含多个指令，这些指令会按照添加到交易中的顺序执行
- 交易是"原子性"的 - 要么所有指令都成功处理，要么整个交易失败且不会做出任何更改。

简单来说，交易可以被视为处理一个或多个指令的请求。

![交易简化图](/assets/docs/core/transactions/transaction-simple.svg)

可以将交易想象成一个装有表格的信封。每个表格都是一条指令，告诉网络我们请求做什么。当你发送交易时，就像是邮寄信封以处理这些表格。

## 关键点

- Solana交易包含指令，这些指令是请求调用网络上程序的请求。
- 交易是**原子性的** - 如果任何指令失败，整个交易都会失败，不会发生任何更改。
- 交易中的指令**按顺序处理**。
- 交易的最大大小是[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)字节。
- 每条指令需要3个信息：
  1. 要调用的程序的地址
  2. 指令将读取或写入的账户
  3. 指令所需的任何额外数据（例如函数参数）

## 基本示例

下面是一个图表，表示一个包含单个指令的交易，该指令用于将SOL从发送方转移到接收方。

在Solana上，我们称为"钱包"的账户由[系统程序](/docs/core/accounts#system-program)拥有。只有程序所有者才能修改账户的数据，因此转移SOL需要发送交易来调用系统程序。

![SOL 转账](/assets/docs/core/transactions/sol-transfer.svg)

发送方账户必须签署（`is_signer`）交易以授权扣除其 lamport 余额。发送方和接收方账户都需要被标记为可写入（`is_writable`），因为这些账户上的 lamport 余额将会发生变化。

一旦交易被发送，系统程序将被调用来处理转账指令。然后系统程序相应地更新发送方和接收方账户的 lamport 余额。

![SOL 转账流程](/assets/docs/core/transactions/sol-transfer-process.svg)

### 转账 SOL

这是一个使用 `SystemProgram.transfer` 方法构建 SOL 转账指令的
[Solana Playground](https://beta.solpg.io/656a0ea7fb53fa325bfd0c3e) 示例：

```typescript title="转账 SOL"
// 定义转账金额
const transferAmount = 0.01; // 0.01 SOL

// 创建一个从 wallet_1 向 wallet_2 转账 SOL 的转账指令
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // 将转账金额转换为 lamports
});

// 将转账指令添加到新交易中
const transaction = new Transaction().add(transferInstruction);
```

通过在 Playground 终端中使用 `run` 命令或点击"运行"按钮来运行示例。

<Callout type="info">

确保你的 Playground 钱包有开发网 SOL。从
[Solana 水龙头](https://faucet.solana.com/) 获取开发网 SOL。

</Callout>

在下面的章节中，我们将详细介绍交易和指令的细节。

## 交易

Solana

[交易](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)

由以下部分组成：

1. [签名](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)：交易中包含的签名数组。
2. [消息](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)：要原子性处理的指令列表。

```rust title="交易"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    pub message: Message,
}
```

![交易格式](/assets/docs/core/transactions/tx_format.png)

交易消息的结构包括：

- [消息头](/docs/core/transactions#message-header)：指定签名者和只读账户的数量。
- [账户地址](/docs/core/transactions#array-of-account-addresses)：交易指令所需的账户地址数组。
- [最近区块哈希](/docs/core/transactions#recent-blockhash)：作为交易的时间戳。
- [指令](/docs/core/transactions#array-of-instructions)：要执行的指令数组。

```rust title="消息"
pub struct Message {
    /// 消息头，标识已签名和只读的 `account_keys`。
    pub header: MessageHeader,

    /// 此交易使用的所有账户密钥。
    #[serde(with = "short_vec")]
    pub account_keys: Vec<Pubkey>,

    /// 最近账本条目的 ID。
    pub recent_blockhash: Hash,

    /// 将按顺序执行的程序，如果全部成功，将在一个原子交易中提交。
    #[serde(with = "short_vec")]
    pub instructions: Vec<CompiledInstruction>,
}
```

![交易消息](/assets/docs/core/transactions/legacy_message.png)

### 交易大小

Solana交易限制为

[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)

字节。这个限制来源于IPv6 MTU大小1280字节，减去48字节的网络头部（40字节IPv6 +
8字节分片头部）。

一个交易的总大小（签名和消息）必须保持在这个限制以下，包括：

- 签名：每个64字节
- 消息：头部（3字节），账户密钥（每个32字节），最近的区块哈希（32字节），以及指令

![交易格式](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### 消息头部

这个

[消息头部](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)

使用三个字节来定义账户权限：

1. 所需签名和
   [消息版本](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/versions/mod.rs#L220-L231)
   （例如传统版本与v0）
2. 只读已签名账户的数量
3. 只读未签名账户的数量

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    pub num_readonly_unsigned_accounts: u8,
}
```

![消息头部](/assets/docs/core/transactions/message_header.png)

### 紧凑数组格式

交易消息中的紧凑数组是指以下列格式序列化的数组：

1. 数组长度（编码为
   [compact-u16](https://github.com/anza-xyz/agave/blob/v2.1.13/short-vec/src/lib.rs)）
2. 数组项目一个接一个列出

![紧凑数组格式](/assets/docs/core/transactions/compact_array_format.png)

这种格式用于编码交易消息中的
[账户地址](/docs/core/transactions#array-of-account-addresses)和
[指令](/docs/core/transactions#array-of-instructions)数组的长度。

### 账户地址数组

交易消息包含一个

[账户地址](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)

数组，这些地址是其指令所需的。该数组以一个
[compact-u16](/docs/core/transactions#compact-array-format)数字开始，表示它包含多少个地址。然后根据它们的权限对地址进行排序，这由消息头部决定。

- 可写且为签名者的账户
- 只读且为签名者的账户
- 可写但不是签名者的账户
- 只读且不是签名者的账户

![账户地址的紧凑数组](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### 最近的区块哈希

每个交易都需要一个

[最近的区块哈希](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L141)

它有两个用途：

1. 作为时间戳
2. 防止重复交易

区块哈希在

[150](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)

个区块后过期（假设区块时间为400毫秒，大约1分钟），之后交易将无法处理。

你可以使用[`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash)
RPC方法获取当前区块哈希和该区块哈希有效的最后区块高度。这里有一个在[Solana Playground](https://beta.solpg.io/661a06e1cffcf4b13384d046)上的示例。

### 指令数组

交易消息包含一个

[指令](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)

数组，类型为

[CompiledInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)

当指令被添加到交易中时，它们会被转换为这种类型。

与消息中的账户地址数组类似，它以[compact-u16](/docs/core/transactions#compact-array-format)长度开始，后跟指令数据。每条指令包含：

1. 程序ID索引：一个u8索引，指向账户地址数组中程序的地址。这指定了将处理该指令的程序。
2. 账户索引：一个u8索引数组，指向此指令所需的账户地址。
3. 指令数据：一个字节数组，指定要在程序上调用的指令以及指令所需的任何附加数据（例如函数参数）。

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// 交易密钥数组中的索引，指示执行此指令的程序账户。
    pub program_id_index: u8,
    /// 交易密钥数组中的有序索引，指示要传递给程序的账户。
    #[serde(with = "short_vec")]
    pub accounts: Vec<u8>,
    /// 程序输入数据。
    #[serde(with = "short_vec")]
    pub data: Vec<u8>,
}
```

![指令的紧凑数组](/assets/docs/core/transactions/compact_array_of_ixs.png)

### 交易结构示例

以下是包含单个[SOL转账](/docs/core/transactions#basic-example)指令的示例交易。该交易的组成部分包括：

- `header`：为`accountKeys`数组中的地址指定读/写和签名者权限

- `accountKeys`：交易指令中使用的所有账户地址的数组

- `recentBlockhash`：用于为交易添加时间戳的区块哈希

- `instructions`：要执行的指令数组。指令中的每个`account`和`programIdIndex`通过索引引用`accountKeys`数组。

- `signatures`：包含交易指令要求的所有签名者账户的签名数组。签名是通过使用账户对应的私钥对交易消息进行签名创建的。

```json
"transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
        "5snoUseZG8s8CDFHrXY2ZHaCrJYsW457piktDmhyb5Jd",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "DzfXchZJoLMG3cNftcf2sw7qatkkuwQf4xH15N5wkKAb",
      "instructions": [
        {
          "accounts": [
            0,
            1
          ],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "5LrcE2f6uvydKRquEJ8xp19heGxSvqsVbcqUeFoiWbXe8JNip7ftPQNTAVPyTK7ijVdpkzmKKaAQR7MWMmujAhXD"
    ]
  }
```

## 指令

一个

[指令](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)

在已部署的[程序](/docs/core/accounts#program-account)上可以被视为一个公共函数，任何使用Solana网络的人都可以调用它。

调用程序的指令需要提供三个关键信息：

- 程序ID：被调用执行指令的程序
- 账户：指令所需的账户列表
- 指令数据：指定要调用的程序指令和指令所需的任何函数参数的字节数组

```rust title="指令"
pub struct Instruction {
    /// 执行此指令的程序的公钥。
    pub program_id: Pubkey,
    /// 描述应传递给程序的账户的元数据。
    pub accounts: Vec<AccountMeta>,
    /// 传递给程序供其自行解释的不透明数据。
    pub data: Vec<u8>,
}
```

![交易指令](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

指令所需的每个账户必须作为

[AccountMeta](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25)

提供，其中包含：

- `pubkey`：账户的地址
- `is_signer`：账户是否必须签署交易
- `is_writable`：指令是否会修改账户的数据

```rust title="AccountMeta"
pub struct AccountMeta {
    /// 账户的公钥。
    pub pubkey: Pubkey,
    /// 如果`Instruction`需要与`pubkey`匹配的`Transaction`签名，则为true。
    pub is_signer: bool,
    /// 如果在程序执行期间可能修改账户数据或元数据，则为true。
    pub is_writable: bool,
}
```

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

通过预先指定指令将读取或写入哪些账户，不修改相同账户的交易可以并行处理。

### 指令结构示例

以下是一个简单示例，展示了SOL转账指令的结构：

- `keys`：包括指令所需的每个账户的`AccountMeta`。
- `programId`：包含被调用指令的执行逻辑的程序地址。
- `data`：作为字节缓冲区的指令数据

```json
{
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  "programId": "11111111111111111111111111111111",
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

## 扩展示例

构建程序指令的细节通常由客户端库抽象化。但是，如果没有可用的客户端库，你始终可以回退到手动构建指令。

### 转账SOL

这是一个[Solana Playground](https://beta.solpg.io/656a102efb53fa325bfd0c3f)示例，展示了如何手动构建SOL转账指令。

在底层，使用`SystemProgram.transfer`方法的[简单示例](/docs/core/transactions#simple-sol-transfer)在功能上等同于下面更详细的示例。`SystemProgram.transfer`方法只是抽象了创建指令数据缓冲区和指令所需的每个账户的`AccountMeta`的细节。

下面两个选项卡中的代码片段在功能上是等效的。

<Tabs items={['手动构建指令', '使用库']}> <Tab value="手动构建指令">

```typescript
// 定义要转账的金额
const transferAmount = 0.01; // 0.01 SOL

// SystemProgram转账指令的指令索引
const transferInstructionIndex = 2;

// 为传递给转账指令的数据创建缓冲区
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// 将指令索引写入缓冲区
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// 将转账金额写入缓冲区
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// 手动创建一个从发送者到接收者转账SOL的指令
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true }
  ],
  programId: SystemProgram.programId,
  data: instructionData
});

// 将转账指令添加到新交易中
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
<Tab value="使用库">

```typescript
// 定义要转账的金额
const transferAmount = 0.01; // 0.01 SOL

// 创建一个从wallet_1到wallet_2转账SOL的指令
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // 将transferAmount转换为lamports
});

// 将转账指令添加到新交易中
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
</Tabs>
