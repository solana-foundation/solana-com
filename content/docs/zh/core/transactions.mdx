---
title: 交易和指令
description:
  了解Solana交易和指令 -
  与Solana区块链交互的基本构建块。通过实用示例理解交易结构和指令组成。
---

在Solana上，我们发送[交易](/docs/core/transactions#transaction)来与网络交互。交易包含一个或多个[指令](/docs/core/transactions#instruction)，用于指定要处理的操作。指令的执行逻辑存储在部署到Solana网络的[程序](/docs/core/programs)中，每个程序定义了自己的指令集。

以下是关于交易处理的关键细节：

* 如果一个交易包含多个指令，这些指令会按照添加到交易中的顺序执行
* 交易是"原子性"的 - 要么所有指令都成功处理，要么整个交易失败且不会做出任何更改。

简单来说，交易可以被视为处理一个或多个指令的请求。

![Transaction Simplified](/assets/docs/core/transactions/transaction-simple.svg)

可以将交易想象成一个装有表格的信封。每个表格都是一条指令，告诉网络我们请求做什么。当你发送交易时，就像是邮寄信封以处理这些表格。

## 关键要点

* Solana交易包含指令，这些指令是请求调用网络上程序的请求。
* 交易是**原子性**的 - 如果任何指令失败，整个交易都会失败，不会发生任何更改。
* 交易中的指令**按顺序处理**。
* 交易的最大大小为[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)字节。
* 每条指令需要3个信息：
  1. 要调用的程序的地址
  2. 指令将读取或写入的账户
  3. 指令所需的任何额外数据（例如函数参数）

## 基本示例

下面是一个图表，表示一个包含单个指令的交易，该指令用于将SOL从发送方转移到接收方。

在Solana上，我们称为"钱包"的账户由[系统程序](/docs/core/accounts#system-program)拥有。只有程序所有者才能修改账户的数据，因此转移SOL需要发送交易来调用系统程序。

![SOL Transfer](/assets/docs/core/transactions/sol-transfer.svg)

发送账户必须签署（`is_signer`）交易以授权减少其 lamport 余额。发送和接收账户都需要被标记为可写入（`is_writable`），因为这些账户上的 lamport 余额将会发生变化。

一旦交易被发送，系统程序将被调用来处理转账指令。系统程序随后相应地更新发送者和接收者账户的 lamport 余额。

![SOL Transfer Process](/assets/docs/core/transactions/sol-transfer-process.svg)

### 转账 SOL

这是一个 [Solana Playground](https://beta.solpg.io/656a0ea7fb53fa325bfd0c3e)
示例，展示如何使用 `SystemProgram.transfer` 方法构建 SOL 转账指令：

```typescript title="Transfer SOL"
// 定义转账金额
const transferAmount = 0.01; // 0.01 SOL

// 创建一个从 wallet_1 向 wallet_2 转账 SOL 的指令
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // 将转账金额转换为 lamports
});

// 将转账指令添加到新交易中
const transaction = new Transaction().add(transferInstruction);
```

通过在 Playground 终端中使用 `run` 命令或点击"运行"按钮来执行示例。

<Callout type="info">
  确保你的 Playground 钱包有开发网 SOL。从 [Solana
  水龙头](https://faucet.solana.com/) 获取开发网 SOL。
</Callout>

在下面的章节中，我们将详细介绍交易和指令的细节。

## 交易

Solana[交易](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
包含：

1. [签名](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)：交易中包含的签名数组。
2. [消息](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)：要原子性处理的指令列表。

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    pub message: Message,
}
```

![Transaction Format](/assets/docs/core/transactions/tx_format.png)

交易消息的结构包括：

* [消息头](/docs/core/transactions#message-header)：指定签名者和只读账户的数量。
* [账户地址](/docs/core/transactions#array-of-account-addresses)：交易指令所需的账户地址数组。
* [最近区块哈希](/docs/core/transactions#recent-blockhash)：作为交易的时间戳。
* [指令](/docs/core/transactions#array-of-instructions)：要执行的指令数组。

```rust title="Message"
pub struct Message {
    /// 消息头，标识已签名和只读的`account_keys`。
    pub header: MessageHeader,

    /// 此交易使用的所有账户密钥。
    #[serde(with = "short_vec")]
    pub account_keys: Vec<Pubkey>,

    /// 最近账本条目的ID。
    pub recent_blockhash: Hash,

    /// 将按顺序执行的程序，如果全部成功，将在一个原子交易中提交。
    #[serde(with = "short_vec")]
    pub instructions: Vec<CompiledInstruction>,
}
```

![Transaction Message](/assets/docs/core/transactions/legacy_message.png)

### 交易大小

Solana交易限制为[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
字节。这个限制来源于IPv6 MTU大小1280字节，减去48字节的网络头部（40字节IPv6 +
8字节分片头部）。

交易大小

* 签名：每个64字节
* 消息：头部（3字节），账户密钥（每个32字节），最近区块哈希（32字节）和指令

![Transaction Format](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### 字节。这个限制来源于IPv6 MTU大小1280字节，减去48字节的网络头部（40字节IPv6 +&#xA;8字节分片头部）。

交易的总大小（签名和消息）必须保持在这个限制以下，包括：[消息头](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
使用三个字节定义账户权限：

1. 签名：每个64字节[消息版本](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/versions/mod.rs#L220-L231)
   （例如 legacy 与 v0）
2. 消息：头部（3字节），账户密钥（每个32字节），最近的区块哈希（32字节）和指令
3. 只读未签名账户数量

```rust title="MessageHeader"
pub struct MessageHeader {
    /// 此消息被视为有效所需的签名数量。这些签名的签名者必须与
    /// [`Message::account_keys`] 的前 `num_required_signatures` 个匹配。
    pub num_required_signatures: u8,

    /// 已签名密钥中的最后 `num_readonly_signed_accounts` 个是只读账户。
    pub num_readonly_signed_accounts: u8,

    /// 未签名密钥中的最后 `num_readonly_unsigned_accounts` 个是只读账户。
    pub num_readonly_unsigned_accounts: u8,
}
```

![Message Header](/assets/docs/core/transactions/message_header.png)

### 这个

交易消息中的紧凑数组是指按以下格式序列化的数组：

1. 数组长度（编码为[compact-u16](https://github.com/anza-xyz/agave/blob/v2.1.13/short-vec/src/lib.rs)）
2. 数组项目一个接一个列出

![Compact array format](/assets/docs/core/transactions/compact_array_format.png)

这种格式用于编码交易消息中[账户地址](/docs/core/transactions#array-of-account-addresses)和[指令](/docs/core/transactions#array-of-instructions)数组的长度。

### 账户地址数组

紧凑数组格式[账户地址](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
这些地址是由其指令所需的。数组以一个[compact-u16](/docs/core/transactions#compact-array-format)数字开始，表示它包含多少个地址。然后根据它们的权限对地址进行排序，这由消息头部决定。

* 可写且为签名者的账户
* 只读且为签名者的账户
* 可写但非签名者的账户
* 只读且非签名者的账户

![Compact array of account addresses](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### 最近区块哈希

这种格式用于编码交易消息中的
[账户地址](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L141)和

1. 作为时间戳
2. 防止重复交易

交易消息包含一个[150](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)
个区块后过期（假设区块时间为400毫秒，约1分钟），之后交易将无法处理。

你可以使用 [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash)
RPC方法获取当前区块哈希和该区块哈希有效的最后区块高度。这里有一个在
[Solana Playground](https://beta.solpg.io/661a06e1cffcf4b13384d046)上的示例。

### 数组，这是其指令所需的。该数组以一个&#xA;

交易消息包含一个
[指令](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
数组，类型为
[CompiledInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
。指令在添加到交易时会转换为此类型。

与消息中的账户地址数组一样，它以
[compact-u16](/docs/core/transactions#compact-array-format)
长度开始，后跟指令数据。每条指令包含：

1. 程序ID索引：一个u8索引，指向账户地址数组中程序的地址。这指定了将处理该指令的程序。
2. 账户索引：一个u8索引数组，指向此指令所需的账户地址。
3. 指令数据：一个字节数组，指定要在程序上调用的指令以及指令所需的任何附加数据（例如函数参数）。

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// 交易密钥数组中的索引，指示执行此指令的程序账户。
    pub program_id_index: u8,
    /// 交易密钥数组中的有序索引，指示要传递给程序的账户。
    #[serde(with = "short_vec")]
    pub accounts: Vec<u8>,
    /// 程序输入数据。
    #[serde(with = "short_vec")]
    pub data: Vec<u8>,
}
```

![Compact array of Instructions](/assets/docs/core/transactions/compact_array_of_ixs.png)

### 它有两个用途：

下面是包含单个
[SOL 转账](/docs/core/transactions#basic-example)指令的示例交易。该交易的组成部分包括：

* `header`：指定 `accountKeys` 数组中地址的读/写和签名者权限

* `accountKeys`: 交易指令中使用的所有账户地址数组

* `recentBlockhash`: 用于为交易添加时间戳的区块哈希

* `instructions`: 要执行的指令数组。每个指令中的`account`和
  `programIdIndex`通过索引引用`accountKeys`数组。

* `signatures`: 包含交易指令要求的所有签名账户的签名数组。签名是通过使用账户对应的私钥对交易消息进行签名创建的。

```json
"transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
        "5snoUseZG8s8CDFHrXY2ZHaCrJYsW457piktDmhyb5Jd",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "DzfXchZJoLMG3cNftcf2sw7qatkkuwQf4xH15N5wkKAb",
      "instructions": [
        {
          "accounts": [
            0,
            1
          ],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "5LrcE2f6uvydKRquEJ8xp19heGxSvqsVbcqUeFoiWbXe8JNip7ftPQNTAVPyTK7ijVdpkzmKKaAQR7MWMmujAhXD"
    ]
  }
```

## 个区块后过期（假设区块时间为400毫秒，约1分钟），之后交易将无法处理。

您可以使用[getLatestBlockhash](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)
RPC方法获取当前区块哈希和该区块哈希有效的最后区块高度。这里有一个在[Solana Playground](/docs/core/accounts#program-account)上的示例。

指令数组

* Program ID: 被调用执行指令的程序
* Accounts: 指令所需的账户列表
* Instruction Data: 指定程序上要调用的指令和指令所需的任何函数参数的字节数组

```rust title="Instruction"
pub struct Instruction {
    /// 执行此指令的程序的公钥。
    pub program_id: Pubkey,
    /// 描述应传递给程序的账户的元数据。
    pub accounts: Vec<AccountMeta>,
    /// 传递给程序供其自行解释的不透明数据。
    pub data: Vec<u8>,
}
```

![Transaction Instruction](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

当指令添加到交易中时，会转换为这种类型。[AccountMeta](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25)，其中包含：

* `pubkey`: 账户的地址
* `is_signer`: 账户是否必须签署交易
* `is_writable`: 指令是否会修改账户的数据

```rust title="AccountMeta"
pub struct AccountMeta {
    /// 账户的公钥。
    pub pubkey: Pubkey,
    /// 如果`Instruction`要求`Transaction`签名与`pubkey`匹配则为真。
    pub is_signer: bool,
    /// 如果在程序执行期间可能修改账户数据或元数据则为真。
    pub is_writable: bool,
}
```

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

通过预先指定指令将读取或写入哪些账户，不修改相同账户的交易可以并行处理。

### 交易结构示例

以下是包含单个

* `header`：指定`accountKeys`数组中地址的读/写和签名者权限
* `accountKeys`：交易指令中使用的所有账户地址的数组
* `recentBlockhash`：用于为交易添加时间戳的区块哈希

```json
"transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
        "5snoUseZG8s8CDFHrXY2ZHaCrJYsW457piktDmhyb5Jd",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "DzfXchZJoLMG3cNftcf2sw7qatkkuwQf4xH15N5wkKAb",
      "instructions": [
        {
          "accounts": [
            0,
            1
          ],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "5LrcE2f6uvydKRquEJ8xp19heGxSvqsVbcqUeFoiWbXe8JNip7ftPQNTAVPyTK7ijVdpkzmKKaAQR7MWMmujAhXD"
    ]
  }
```

## 指令

一个

### 转账 SOL

在已部署的[程序](https://beta.solpg.io/656a102efb53fa325bfd0c3f)上可以被视为一个公共函数，任何使用Solana网络的人都可以调用它。

调用程序的指令需要提供三个关键信息：[简单示例](/docs/core/transactions#simple-sol-transfer)使用
`SystemProgram.transfer`方法在功能上等同于下面更详细的示例。`SystemProgram.transfer`方法只是抽象了创建指令数据缓冲区和为指令所需的每个账户创建`AccountMeta`的细节。

下面两个选项卡中的代码片段在功能上是等效的。

<Tabs items={['Build Instruction Manually', 'Use Library']}>
  <Tab value="手动构建指令">
    ```typescript
    // 定义要转账的金额
    const transferAmount = 0.01; // 0.01 SOL

    // SystemProgram转账指令的指令索引
    const transferInstructionIndex = 2;

    // 为传递给转账指令的数据创建缓冲区
    const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
    // 将指令索引写入缓冲区
    instructionData.writeUInt32LE(transferInstructionIndex, 0);
    // 将转账金额写入缓冲区
    instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

    // 手动创建一个从发送方到接收方转账SOL的指令
    const transferInstruction = new TransactionInstruction({
      keys: [
        { pubkey: sender.publicKey, isSigner: true, isWritable: true },
        { pubkey: receiver.publicKey, isSigner: false, isWritable: true },
      ],
      programId: SystemProgram.programId,
      data: instructionData,
    });

    // 将转账指令添加到新交易中
    const transaction = new Transaction().add(transferInstruction);
    ```
  </Tab>

  <Tab value="使用库">
    ```typescript
    // 定义转账金额
    const transferAmount = 0.01; // 0.01 SOL

    // 创建一个从 wallet_1 向 wallet_2 转账 SOL 的指令
    const transferInstruction = SystemProgram.transfer({
      fromPubkey: sender.publicKey,
      toPubkey: receiver.publicKey,
      lamports: transferAmount * LAMPORTS_PER_SOL, // 将转账金额转换为 lamports
    });

    // 将转账指令添加到新交易中
    const transaction = new Transaction().add(transferInstruction);
    ```
  </Tab>
</Tabs>
