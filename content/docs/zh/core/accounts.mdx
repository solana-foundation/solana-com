---
title: Solana账户模型
description: 了解Solana的账户模型，包括账户如何存储数据和程序、rent机制、账户所有权以及程序与数据账户之间的关系。理解Solana键值存储系统的核心概念。
---

在Solana上，所有数据都存储在所谓的"accounts"（账户）中。你可以将Solana上的数据视为一个公共数据库，其中有一个单一的"Accounts"表，这个表中的每个条目就是一个"account"。每个Solana账户都共享相同的基础
[Account类型](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L48-L60)的独立账户。

![Accounts](/assets/docs/core/accounts/accounts.png)

## 要点

* 账户最多可以存储[10MiB](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/system_instruction.rs#L85)
  数据，其中包含可执行程序代码或程序状态。
* 账户需要一笔与存储数据量成比例的lamport（SOL）[rent存款](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97)
  lamport（SOL）余额，其金额与存储的数据量成正比，当你关闭账户时可以完全恢复这些资金。
* 每个账户都有一个程序[owner](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L55)。只有拥有账户的程序才能更改其数据或扣除其lamport余额。但任何人都可以增加余额。
* **Sysvar账户**是存储网络集群状态的特殊账户。
* **Program账户**存储智能合约的可执行代码。
* **Data账户**由程序创建，用于存储和管理程序状态。

## 账户

Solana上的每个账户都有一个唯一的32字节地址，通常显示为base58编码的字符串（例如`14grJpemFaf88c8tiVb77W7TYg2W3ir6pfkKz3YjhhZ5`）。

账户与其地址之间的关系类似于键值对，其中地址是定位账户对应链上数据的键。账户地址充当"Accounts"表中每个条目的"唯一ID"。

![Account Address](/assets/docs/core/accounts/account-address.svg)

大多数Solana账户使用[Ed25519](https://ed25519.cr.yp.to/)公钥作为其地址。

<CodeTabs flags="r">
  ```ts !! title="Generate Keypair"
  import { Keypair } from "@solana/web3.js";

  const keypair = Keypair.generate();
  console.log(`Public Key: ${keypair.publicKey}`);
  console.log(`Secret Key: ${keypair.secretKey}`);

  ```
</CodeTabs>

虽然公钥通常用作账户地址，但Solana还支持一种称为Program Derived Addresses（PDAs）的功能。PDAs是特殊地址，你可以从程序ID和可选输入（seeds）确定性地派生出这些地址。详细信息在[Program Derived Address](/docs/core/pda) page.

<CodeTabs flags="r">
  ```ts !! title="Derive PDA"
  import { PublicKey } from "@solana/web3.js";

  const programAddress = new PublicKey("11111111111111111111111111111111");

  const seeds = [Buffer.from("helloWorld")];
  const [pda, bump] = await PublicKey.findProgramAddressSync(
    seeds,
    programAddress
  );

  console.log(`PDA: ${pda}`);
  console.log(`Bump: ${bump}`);
  ```
</CodeTabs>

### Account类型

账户的最大大小为
[10MiB](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/system_instruction.rs#L85)
并且Solana上的每个账户都共享相同的基础
[Account](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L48-L60)
type.

![Account Type](/assets/docs/core/accounts/account-type.svg)

Solana上的每个账户都有以下字段：

* `data`: A byte array that stores arbitrary data for an account. For
  non-executable accounts, this often stores state that's meant be read from.
  For program accounts (smart contracts), this contains the executable program
  code. The data field is commonly called "account data."
* `executable`: 此标志显示账户是否为程序。
* `lamports`: The account's balance in lamports, the smallest unit of SOL (1 SOL
  \= 1 billion lamports).
* `owner`: 拥有此账户的程序的程序ID（公钥）。只有所有者程序可以更改账户的数据或扣除其lamport余额。
* `rent_epoch`: A legacy field from when Solana had a mechanism that
  periodically deducted lamports from accounts. While this field still exists in
  the Account type, it is no longer used since rent collection was deprecated.

```rust title="Base Account Type"
pub struct Account {
    /// lamports in the account
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    pub executable: bool,
    /// the epoch at which this account will next owe rent
    pub rent_epoch: Epoch,
}
```

<CodeTabs flags="r">
  ```ts !! title="Fetch Account"
  import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";

  const keypair = Keypair.generate();
  console.log(`Public Key: ${keypair.publicKey}`);

  const connection = new Connection("http://127.0.0.1:8899", "confirmed");

  // 向地址注入SOL自动创建一个账户const signature = await
  connection.requestAirdrop( keypair.publicKey, LAMPORTS_PER_SOL ); await
  connection.confirmTransaction(signature, "confirmed");

  const accountInfo = await connection.getAccountInfo(keypair.publicKey);
  console.log(accountInfo);

  ```
</CodeTabs>

### Rent

要在链上存储数据，账户还必须保持与存储在账户上的数据量（以字节为单位）成
比例的lamport（SOL）余额。这个余额被称为"rent"，但它的工作方式更像是一种押金，
因为当你关闭账户时可以收回全部金额。你可以找到计算方法
[这里](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97)
使用这些
[constants](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L47-L70).

术语"rent"来源于一种已弃用的机制，该机制会定期从低于rent阈值的账户中扣除
lamport。这种机制现在已不再活跃。

### 程序所有者

在Solana上，"智能合约"被称为[程序](/docs/core/programs)。程序
所有权是Solana账户模型的关键部分。每个账户都有一个
指定的程序作为其所有者。只有所有者程序可以：

* 更改账户的`数据` field
* Deduct lamports from the account's balance

## System Program

默认情况下，所有新账户都归属于
[System Program](https://github.com/anza-xyz/agave/tree/v2.1.13/programs/system/src)。
System Program执行几个关键功能：

* [New Account Creation](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L146)：
  只有System Program可以创建新账户。
* [Space Allocation](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L71):
  Sets the byte capacity for the data field of each account.
* [Transfer / Assign Program Ownership](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L113)：
  一旦System Program创建了账户，它可以将指定的程序所有者重新分配给不同的程序账户。这就是自定义程序如何获取由System Program创建的新账户的所有权。

Solana上的所有"钱包"账户实际上都只是由System Program拥有的账户。这些账户中的lamport余额显示了钱包拥有的SOL数量。只有由System Program拥有的账户才能支付交易费用。

![System Account](/assets/docs/core/accounts/system-account.svg)

## Sysvar账户

Sysvar账户是位于预定义地址的特殊账户，提供对集群状态数据的访问。这些账户会随着网络集群的数据动态更新。您可以找到Sysvar账户的完整列表
[here](https://docs.anza.xyz/runtime/sysvars).

<CodeTabs flags="r">
  ```ts !! title="Fetch Sysvar Clock Account"
  import { Connection, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";

  const connection = new Connection("http://127.0.0.1:8899", "confirmed");

  const accountInfo = await connection.getAccountInfo(SYSVAR_CLOCK_PUBKEY);
  console.log(JSON.stringify(accountInfo, null, 2));
  ```
</CodeTabs>

## Program账户

部署Solana程序会创建一个可执行的程序账户。程序账户存储程序的可执行代码。

程序账户由 [Loader Program](/docs/core/programs#loader-programs).

![Program Account](/assets/docs/core/accounts/program-account-simple.svg)

为简单起见，您可以将程序账户视为程序本身。当您调用程序的指令时，您需要指定程序账户的地址（通常称为"Program
ID"）。

<CodeTabs flags="r">
  ```ts !! title="Fetch Token Program Account"
  import { Connection, PublicKey } from "@solana/web3.js";

  const connection = new Connection("http://127.0.0.1:8899", "confirmed");

  const accountInfo = await connection.getAccountInfo( new
  PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA") );
  console.log(accountInfo);

  ```
</CodeTabs>

<Callout type="info">
  当您部署Solana程序时，它会存储在程序账户中。程序账户由[加载器程序](/docs/core/programs#loader-programs)。
  加载器有几个版本，但除了loader-v3之外的所有版本都直接将可执行代码存储在程序账户中。Loader-v3将可执行代码存储在单独的"程序数据账户"中，程序账户只是指向它。当您部署新程序时，Solana CLI默认使用最新的加载器版本。
</Callout>

### 缓冲区账户

Loader-v3有一种特殊的账户类型，用于在部署或重新部署/升级期间临时暂存程序上传。在loader-v4中，仍然有缓冲区，但它们只是普通的程序账户。

### 程序数据账户

Loader-v3的工作方式与所有其他BPF加载器程序不同。程序账户只包含程序数据账户的地址，该账户存储实际的可执行代码：
![Program Data Account](/assets/docs/core/accounts/program-account-expanded.svg)

不要将这些程序数据账户与程序的数据账户（见下文）混淆。

## 数据账户

在Solana上，程序的可执行代码存储在与程序状态不同的账户中。这类似于操作系统通常为程序及其数据使用单独的文件。

为了维护状态，程序定义指令来创建它们拥有的单独账户。每个这样的账户都有自己唯一的地址，并且可以存储程序定义的任何任意数据。

![Data Account](/assets/docs/core/accounts/data-account.svg)

请注意，只有[System Program](/docs/core/accounts#system-program)可以创建新账户。一旦System Program创建了一个账户，它就可以将新账户的所有权转移或分配给另一个程序。

换句话说，为自定义程序创建数据账户需要两个步骤：

1. 调用System Program创建账户，然后将所有权转移给自定义程序
2. 调用自定义程序（该程序现在拥有该账户）来初始化
   账户数据，具体由程序的指令定义

这个账户创建过程通常被抽象为单个步骤，但了解
底层过程很有帮助。

<CodeTabs flags="r">
  ```ts !! title="Create Token Mint Account"
  import {
    Connection,
    Keypair,
    sendAndConfirmTransaction,
    SystemProgram,
    Transaction,
    LAMPORTS_PER_SOL
  } from "@solana/web3.js";
  import {
    createInitializeMintInstruction,
    TOKEN_2022_PROGRAM_ID,
    MINT_SIZE,
    getMinimumBalanceForRentExemptMint
  } from "@solana/spl-token";

  // 创建连接到本地验证器
  const connection = new Connection("http://127.0.0.1:8899", "confirmed");
  const recentBlockhash = await connection.getLatestBlockhash();

  // 为费用支付者生成新的keypair
  const feePayer = Keypair.generate();

  // 向费用支付者空投1个SOL
  const airdropSignature = await connection.requestAirdrop(
    feePayer.publicKey,
    LAMPORTS_PER_SOL
  );
  await connection.confirmTransaction({
    blockhash: recentBlockhash.blockhash,
    lastValidBlockHeight: recentBlockhash.lastValidBlockHeight,
    signature: airdropSignature
  });

  // 生成keypair作为代币铸造地址
  const mint = Keypair.generate();

  const createAccountInstruction = SystemProgram.createAccount({
    fromPubkey: feePayer.publicKey,
    newAccountPubkey: mint.publicKey,
    space: MINT_SIZE,
    lamports: await getMinimumBalanceForRentExemptMint(connection),
    programId: TOKEN_2022_PROGRAM_ID
  });

  const initializeMintInstruction = createInitializeMintInstruction(
    mint.publicKey, // 代币铸造pubkey
    9, // 小数位数
    feePayer.publicKey, // 铸造权限
    feePayer.publicKey, // 冻结权限
    TOKEN_2022_PROGRAM_ID
  );

  const transaction = new Transaction().add(
    createAccountInstruction,
    initializeMintInstruction
  );

  const transactionSignature = await sendAndConfirmTransaction(
    connection,
    transaction,
    [feePayer, mint] // 签名者
  );

  console.log("Mint Address: ", mint.publicKey.toBase58());
  console.log("Transaction Signature: ", transactionSignature);

  const accountInfo = await connection.getAccountInfo(mint.publicKey);
  console.log(accountInfo);
  ```
</CodeTabs>
