---
title: 创建确定性账户
description:
  学习如何使用程序派生地址（PDAs）和Anchor框架构建CRUD（创建、读取、更新、删除）Solana程序。本分步
  指南演示了如何使用PDAs创建、更新和删除链上消息账户，
  实现账户验证，并编写测试。非常适合
  希望了解如何在Solana程序中使用PDAs的开发者。
h1: 程序派生地址
---

在本节中，您将学习如何构建基本的创建、读取、更新、删除 (CRUD)程序。

本指南演示了一个简单的程序，用户可以创建、更新和删除消息。每条消息都存在于一个具有确定性地址的账户中，该地址由程序本身派生（程序派生地址或PDA）。

本指南将引导您使用Anchor框架构建和测试Solana程序，同时演示程序派生地址（PDAs）。有关更多详情，请参阅[程序派生地址](/docs/core/pda)页面。

作为参考，您可以查看
[最终代码](https://beta.solpg.io/668304cfcffcf4b13384d20a)，该代码是在完成PDA和跨程序调用（CPI）部分后的结果。

<Steps>
  <Step>
    ### 起始代码

    首先打开这个
    [Solana Playground链接](https://beta.solpg.io/66734b7bcffcf4b13384d1ad)，其中包含
    起始代码。然后点击"导入"按钮将程序添加到您的
    Solana Playground项目中。

    ![Import](/assets/docs/intro/quickstart/pg-import.png)

    <WithMentions>
      在`lib.rs`文件中，您会找到一个带有[`create`](mention:one)、
      [`update`](mention:two)和[`delete`](mention:three)指令的程序，
      这些指令将在接下来的步骤中添加。

      ```rs title="lib.rs"
      use anchor_lang::prelude::*;

      declare_id!("8KPzbM2Cwn4Yjak7QYAEH9wyoQh86NcBicaLuzPaejdw");

      #[program]
      pub mod pda {
          use super::*;

          // !mention one
          pub fn create(_ctx: Context<Create>) -> Result<()> {
              Ok(())
          }

          // !mention two
          pub fn update(_ctx: Context<Update>) -> Result<()> {
              Ok(())
          }

          // !mention three
          pub fn delete(_ctx: Context<Delete>) -> Result<()> {
              Ok(())
          }
      }

      #[derive(Accounts)]
      pub struct Create {}

      #[derive(Accounts)]
      pub struct Update {}

      #[derive(Accounts)]
      pub struct Delete {}

      #[account]
      pub struct MessageAccount {}
      ```
    </WithMentions>

    开始之前，在Playground终端中运行*shell`build`*&#x6765;检查
    启动程序是否能成功构建。

    ```terminal
    $ build
    构建中...
    构建成功。用时3.50秒。
    ```
  </Step>

  <Step>
    ### 定义消息账户类型

    首先，定义程序创建的消息账户的结构。
    这个结构定义了要存储在程序创建的账户中的数据。

    <WithNotes>
      在`lib.rs`中，更新*rs`MessageAccount`*&#x7ED3;构如下：

      ```rs title="lib.rs"
      // !tooltip[/account/] account
      #[account]
      pub struct MessageAccount {
          // !tooltip[/user/] user
          pub user: Pubkey,
          // !tooltip[/message/] message
          pub message: String,
          // !tooltip[/bump/] bump
          pub bump: u8,
      }
      ```

      ### !account

      在Anchor程序中，*rs`#[account]`*&#x5C5E;性用于注解表示账户数据的结构体
      （存储在账户数据字段中的数据类型）。

      ### !user

      *rs`user`*&#x5B57;段包含一个*rs`公钥`*，用于标识创建消息账户的用户。

      ### !message

      *rs`message`*&#x5B57;段包含一个*rs`String`*&#x7C7B;型，存储用户的消息内容。

      ### !bump

      *rs`bump`*&#x5B57;段存储一个*rs`u8`*
      ["bump"种子](/docs/core/pda#canonical-bump)，用于派生程序派生地址（PDA）。存储这个值可以节省计算资源，避免在后续指令中重新计算它。
    </WithNotes>

    <Accordions>
      <Accordion title="差异">
        ```diff
        - #[account]
        - pub struct MessageAccount {}

        + #[account]
        + pub struct MessageAccount {
        +    pub user: Pubkey,
        +    pub message: String,
        +    pub bump: u8,
        + }
        ```
      </Accordion>

      <Accordion title="解释">
        这个*rs`#[account]`*&#x5C5E;性在Anchor程序中用于注解表示账户数据的结构体（存储在Account的data字段中的数据类型）。

        在这个例子中，*rs`MessageAccount`*&#x7ED3;构体存储了用户创建的消息，包含三个字段：

        * `user` - *rs`Pubkey`*，用于标识创建消息账户的用户。
        * `message` - *rs`String`*，包含用户的消息内容。
        * `bump` - *rs`u8`*，用于存储["bump"种子](/docs/core/pda#canonical-bump)，用于派生程序派生地址（PDA）。存储这个值可以节省计算资源，避免在后续指令中重新计算它。

        在创建账户时，程序会序列化*rs`MessageAccount`* 数据
        并将其存储在新账户的数据字段中。

        之后，当从账户读取数据时，程序将这些数据反序列化回
        *rs`MessageAccount`* 数据类型。测试部分演示了
        创建和读取账户数据的过程。
      </Accordion>
    </Accordions>

    通过在终端中运行 *shell`build`* 再次构建程序。

    ```terminal
    $ build
    ```

    此代码定义了要存储在消息账户上的数据。接下来，你将添加
    程序指令。
  </Step>

  <Step>
    ### 添加创建指令

    现在，添加 *rs`create`* 指令，用于创建和初始化
    *rs`MessageAccount`*。

    首先，通过更新以下内容来定义指令所需的账户
    *rs`Create`* 结构：

    <WithNotes>
      ```rs title="lib.rs"
      #[derive(Accounts)]
      // !tooltip[/instruction/] 指令
      #[instruction(message: String)]
      pub struct Create<'info> {
          // !tooltip[/mut/] 可变
          #[account(mut)]
          // !tooltip[/Signer<'info>/] 签名者
          pub user: Signer<'info>,

          #[account(
              // !tooltip[/init/] 初始化
              init,
              // !tooltip[/seeds/] 种子
              seeds = [b"message", user.key().as_ref()],
              // !tooltip[/bump/] 碰撞因子
              bump,
              // !tooltip[/payer/] 支付者
              payer = user,
              // !tooltip[/space/] 空间
              space = 8 + 32 + 4 + message.len() + 1
          )]
          // !tooltip[/Account<'info, MessageAccount>/] 账户
          pub message_account: Account<'info, MessageAccount>,
          // !tooltip[/Program<'info, System>/] 程序
          pub system_program: Program<'info, System>,
      }
      ```

      ### !mut

      *rs`mut`* 约束声明账户为可变的。

      ### !init

      *rs`init`* 约束创建一个新账户。

      ### !seeds

      *rs`seeds`* 约束定义用于派生PDA的可选输入。

      ### !bump

      *rs`bump`* 约束声明PDA的碰撞种子。

      如果你不指定值，Anchor会自动计算它。

      ### !payer

      *rs`payer`* constraint 指定哪个账户为新账户创建支付费用。

      ### !space

      *rs`space`* constraint 指定为新账户的数据字段分配的字节数。

      ### !signer

      *rs`Signer<'info>`* 类型要求账户对交易进行签名。

      ### !account

      *rs`Account<'info, T>`* 类型要求账户与指定的类型匹配。

      在这种情况下，账户必须与自定义的 *rs`MessageAccount`* 类型匹配。

      ### !program

      *rs`Program<'info, T>`* 类型要求账户与程序匹配。

      在这种情况下，账户必须匹配 *rs`System`* 类型，它指的是
      系统程序（System Program）。

      ### !instruction

      *rs`#[instruction(message: String)]`* 注解允许 *rs`Create`*
      结构访问来自 *rs`message`* 参数，该参数来自 `create` 指令。
    </WithNotes>

    <Accordions>
      <Accordion title="Diff">
        ```diff
        - #[derive(Accounts)]
        - pub struct Create {}

        + #[derive(Accounts)]
        + #[instruction(message: String)]
        + pub struct Create<'info> {
        +     #[account(mut)]
        +     pub user: Signer<'info>,
        +
        +     #[account(
        +         init,
        +         seeds = [b"message", user.key().as_ref()],
        +         bump,
        +         payer = user,
        +         space = 8 + 32 + 4 + message.len() + 1
        +     )]
        +     pub message_account: Account<'info, MessageAccount>,
        +     pub system_program: Program<'info, System>,
        + }
        ```
      </Accordion>

      <Accordion title="解释">
        在Anchor程序中，*rs`#[derive(Accounts)]`* 属性用于注解那些
        定义指令所需账户的结构体。

        结构体中的每个字段代表一个通过两种方式验证的账户：

        1. 账户类型（如 *rs`Signer<'info>`* 或 *rs`Account<'info, T>`*）用于
           指定程序期望的账户类型
        2. 可选约束条件（如 *rs`#[account(mut)]`* 或 *rs`#[account(init)]`*）
           用于定义额外要求

        这些元素共同使 Anchor 能够自动验证传递给指令的账户并保障程序安全。

        结构体中的字段名称提供了在程序代码中访问账户的方式，但不影响验证。为清晰起见，应使用描述性名称。

        在此示例中，*rs`Create`* 结构体定义了
        *rs`create`* 指令所需的账户。

        1. *rs`user: Signer<'info>`*

           * 代表创建消息账户的用户
           * 需要可变状态（*rs`#[account(mut)]`*），因为它为新账户支付费用
           * 必须签署交易以批准从此账户扣除lamport

        2. *rs`message_account: Account<'info, MessageAccount>`*

           * 存储用户消息的新账户
           * `init` 约束在指令执行期间创建账户
           * `seeds` 和 `bump` 约束将账户地址派生为程序派生地址（PDA）
           * `payer = user` 标识谁为新账户的创建支付费用
           * `space` 为账户的数据字段分配所需的字节

        3. *rs`system_program: Program<'info, System>`*

           * 账户创建所必需的
           * 在后台，`init` 约束调用系统程序创建具有指定`空间` 并将所有者更改为
             当前程序。

        ***

        这个 *rs`#[instruction(message: String)]`* 注解允许 *rs`Create`*
        结构访问 *rs`message`* 参数，该参数来自 `create` 指令。

        ***

        这些 `seeds` 和 `bump` 约束共同将账户地址定义为
        程序派生地址（PDA）。

        ```rs title="lib.rs"
        seeds = [b"message", user.key().as_ref()],
        bump,
        ```

        这个 `seeds` 约束定义了用于派生PDA的可选输入。

        * *rs`b"message"`* - 作为第一个种子的固定字符串。
        * *rs`user.key().as_ref()`* - *rs`user`* 账户的公钥作为第二个种子。

        `bump` 约束告诉Anchor自动查找并使用正确的bump种子。Anchor使用 `seeds` 和 `bump` 来派生PDA。

        ***

        `space` 计算 *rs`(8 + 32 + 4 + message.len() + 1)`* 为 `MessageAccount` 数据类型分配空间：

        * Anchor账户鉴别器（标识符）：8字节
        * 用户地址（*rs`公钥`*): 32字节
        * 用户消息 (*rs`String`*): 4字节用于长度 + 可变消息长度
        * PDA碰撞种子 (*rs`u8`*): 1字节

        ```rs title="lib.rs"
        #[account]
        pub struct MessageAccount {
            pub user: Pubkey,
            pub message: String,
            pub bump: u8,
        }
        ```

        通过Anchor程序创建的所有账户需要8字节的账户鉴别器，它作为Anchor在创建账户时自动生成的账户类型标识符。

        一个*rs`String`*&#x7C7B;型需要4字节来存储字符串的长度，剩余长度包含实际数据。
      </Accordion>
    </Accordions>

    接下来，为*rs`create`*&#x6307;令添加业务逻辑，通过更新`create`函数如下：

    ```rs title="lib.rs"
    pub fn create(ctx: Context<Create>, message: String) -> Result<()> {
        msg!("Create Message: {}", message);
        let account_data = &mut ctx.accounts.message_account;
        account_data.user = ctx.accounts.user.key();
        account_data.message = message;
        account_data.bump = ctx.bumps.message_account;
        Ok(())
    }
    ```

    <Accordions>
      <Accordion title="差异">
        ```diff
        - pub fn create(_ctx: Context<Create>) -> Result<()> {
        -     Ok(())
        - }

        + pub fn create(ctx: Context<Create>, message: String) -> Result<()> {
        +     msg!("Create Message: {}", message);
        +     let account_data = &mut ctx.accounts.message_account;
        +     account_data.user = ctx.accounts.user.key();
        +     account_data.message = message;
        +     account_data.bump = ctx.bumps.message_account;
        +     Ok(())
        + }
        ```
      </Accordion>

      <Accordion title="解释">
        `create`函数实现了初始化新消息账户数据的逻辑。它接受两个参数：

        1. *rs`ctx: Context<Create>`* - 提供对*rs`Create`*&#x7ED3;构中指定账户的访问权限。
        2. *rs`message: String`* - 用于存储的用户消息。

        函数主体执行以下逻辑：

        1. 使用*rs`msg!()`*&#x5B8F;向程序日志打印消息。

           ```rs
           msg!("Create Message: {}", message);
           ```

        2. 初始化账户数据：

           * 从上下文访问`message_account`。

           ```rs
           let account_data = &mut ctx.accounts.message_account;
           ```

           * 设置`用户` 字段设置为 `用户` 账户的公钥。

           ```rs
           account_data.user = ctx.accounts.user.key();
           ```

           * 将 `message` 字段设置为函数参数中的 `消息`。

           ```rs
           account_data.message = message;
           ```

           * 设置用于派生 PDA 的 `bump` 值，该值从
             `ctx.bumps.message_account` 中获取。

           ```rs
           account_data.bump = ctx.bumps.message_account;
           ```
      </Accordion>
    </Accordions>

    重新构建程序。

    ```terminal
    $ build
    ```
  </Step>

  <Step>
    ### 添加更新指令

    接下来，添加 `update` 指令来使用新消息更改 `MessageAccount`。

    与上一步类似，首先指定`update`
    指令所需的账户。

    更新`Update`结构如下：

    <WithNotes>
      ```rs title="lib.rs"
      #[derive(Accounts)]
      #[instruction(message: String)]
      pub struct Update<'info> {
          #[account(mut)]
          pub user: Signer<'info>,

          #[account(
              mut,
              seeds = [b"message", user.key().as_ref()],
              bump = message_account.bump,
              // !tooltip[/realloc/] realloc
              realloc = 8 + 32 + 4 + message.len() + 1,
              // !tooltip[/realloc::payer/] realloc::payer
              realloc::payer = user,
              // !tooltip[/realloc::zero/] realloc::zero
              realloc::zero = true,
          )]
          pub message_account: Account<'info, MessageAccount>,
          pub system_program: Program<'info, System>,
      }
      ```

      ### !realloc

      *rs`realloc`*&#x7EA6;束用于重新分配账户的数据空间。

      ### !realloc::payer

      *rs`realloc::payer`*&#x7EA6;束指定支付重新分配费用的账户。

      ### !realloc::zero

      *rs`realloc::zero`*&#x7EA6;束将账户的数据清零。
    </WithNotes>

    <Accordions>
      <Accordion title="Diff">
        ```diff
        - #[derive(Accounts)]
        - pub struct Update {}

        + #[derive(Accounts)]
        + #[instruction(message: String)]
        + pub struct Update<'info> {
        +     #[account(mut)]
        +     pub user: Signer<'info>,
        +
        +     #[account(
        +         mut,
        +         seeds = [b"message", user.key().as_ref()],
        +         bump = message_account.bump,
        +         realloc = 8 + 32 + 4 + message.len() + 1,
        +         realloc::payer = user,
        +         realloc::zero = true,
        +     )]
        +     pub message_account: Account<'info, MessageAccount>,
        +     pub system_program: Program<'info, System>,
        + }
        ```
      </Accordion>

      <Accordion title="Explanation">
        *rs`Update`* 结构定义了 *rs`update`*
        指令所需的账户。

        1. *rs`user: Signer<'info>`*

           * 表示更新消息账户的用户
           * 标记为可变的（*rs`#[account(mut)]`*），因为在需要时它可能会为 `message_account` 支付更多空间
           * 必须签署交易

        2. *rs`message_account: Account<'info, MessageAccount>`*

           * 存储用户消息以供更新的现有账户
           * `mut` 约束表示此账户的数据修改
           * `realloc` 约束允许调整账户数据的大小
           * `seeds` 和 `bump` 约束验证账户是否为正确的 PDA

        3. *rs`system_program: Program<'info, System>`*
           * 需要用于账户空间的潜在重新分配
           * `realloc` 约束调用系统程序来调整账户的数据大小

        请注意，*rs`bump = message_account.bump`* 约束使用存储在 *rs`message_account`* 上的 bump seed，而不是让 Anchor 重新计算它。

        *rs`#[instruction(message: String)]`* 属性使 *rs`Update`* 结构能够访问 *rs`message`* 参数来自 *rs`update`* 指令。
      </Accordion>
    </Accordions>

    接下来，添加 `update` 指令的逻辑。

    ```rs title="lib.rs"
    pub fn update(ctx: Context<Update>, message: String) -> Result<()> {
        msg!("Update Message: {}", message);
        let account_data = &mut ctx.accounts.message_account;
        account_data.message = message;
        Ok(())
    }
    ```

    <Accordions>
      <Accordion title="Diff">
        ```diff
        - pub fn update(_ctx: Context<Update>) -> Result<()> {
        -     Ok(())
        - }

        + pub fn update(ctx: Context<Update>, message: String) -> Result<()> {
        +     msg!("Update Message: {}", message);
        +     let account_data = &mut ctx.accounts.message_account;
        +     account_data.message = message;
        +     Ok(())
        + }
        ```
      </Accordion>

      <Accordion title="Explanation">
        `update` 函数实现了修改现有消息账户的逻辑。它接受两个参数：

        1. *rs`ctx: Context<Update>`* - 提供对 *rs`Update`* 结构中指定账户的访问权限。
        2. *rs`message: String`* - 用于替换现有消息的新消息。

        函数主体然后：

        1. 使用 *rs`msg!()`* 宏。

        2. 更新账户数据：
           * 从上下文访问 `message_account`。
           * 将 `message` 字段设置为函数参数中的新 `message`。
      </Accordion>
    </Accordions>

    重新构建程序

    ```terminal
    $ build
    ```
  </Step>

  <Step>
    ### 添加删除指令

    接下来，添加 *rs`delete`* 指令来关闭 *rs`MessageAccount`*。

    更新 *rs`Delete`* 结构体包含以下内容：

    <WithNotes>
      ```rs title="lib.rs"
      #[derive(Accounts)]
      pub struct Delete<'info> {
          #[account(mut)]
          pub user: Signer<'info>,

          #[account(
              mut,
              // !tooltip[/seeds/] seeds
              seeds = [b"message", user.key().as_ref()],
              // !tooltip[/bump/] bump
              bump = message_account.bump,
              // !tooltip[/close/] close
              close= user,
          )]
          pub message_account: Account<'info, MessageAccount>,
      }
      ```

      ### !seeds

      *rs`seeds`* 约束指定用于派生PDA的种子。

      ### !bump

      *rs`bump`* 约束指定PDA的凸点种子。

      在这种情况下，程序使用存储在
      *rs`message_account`* 上的现有凸点种子。

      ### !close

      *rs`close`* 约束关闭账户。

      在这种情况下，*rs`user`* 账户接收来自已关闭账户的lamports
      *rs`message_account`*.
    </WithNotes>

    <Accordions>
      <Accordion title="差异">
        ```diff
        - #[derive(Accounts)]
        - pub struct Delete {}

        + #[derive(Accounts)]
        + pub struct Delete<'info> {
        +     #[account(mut)]
        +     pub user: Signer<'info>,
        +
        +     #[account(
        +         mut,
        +         seeds = [b"message", user.key().as_ref()],
        +         bump = message_account.bump,
        +         close = user,
        +     )]
        +     pub message_account: Account<'info, MessageAccount>,
        + }
        ```
      </Accordion>

      <Accordion title="解释">
        这个*rs`Delete`*&#x7ED3;构定义了*rs`delete`*
        指令所需的账户：

        1. *rs`user: Signer<'info>`*

           * 代表关闭消息账户的用户
           * 标记为可变的（*rs`#[account(mut)]`*）以接收已关闭账户的lamports
           * 必须签名以确保只有正确的用户才能关闭他们的消息账户

        2. *rs`message_account: Account<'info, MessageAccount>`*

           * 要关闭的账户
           * `mut` constraint 表示数据修改
           * `seeds` 和 `bump` constraints 验证账户是否为正确的 PDA
           * `close = user` constraint 标记此账户将被关闭并将其 lamports 转移到 `user` 账户
      </Accordion>
    </Accordions>

    接下来，添加 `delete` 指令的逻辑。

    ```rs title="lib.rs"
    pub fn delete(_ctx: Context<Delete>) -> Result<()> {
        msg!("Delete Message");
        Ok(())
    }
    ```

    <Accordions>
      <Accordion title="Diff">
        ```diff
        - pub fn delete(_ctx: Context<Delete>) -> Result<()> {
        -     Ok(())
        - }

        + pub fn delete(_ctx: Context<Delete>) -> Result<()> {
        +     msg!("Delete Message");
        +     Ok(())
        + }
        ```
      </Accordion>

      <Accordion title="Explanation">
        `delete` 函数接收一个参数：

        1. *rs`_ctx: Context<Delete>`* - 提供对 *rs`Delete`* 结构中指定账户的访问权限。*rs`_ctx`* 语法表明该函数
           在其函数体中并不使用 Context。

        函数体仅使用 *rs`msg!()`*
        宏向程序日志打印消息。该函数不需要额外的逻辑，因为 *rs`close`* 约束在
        *rs`Delete`* 结构中处理了账户关闭。
      </Accordion>
    </Accordions>

    重新构建程序。

    ```terminal
    $ build
    ```
  </Step>

  <Step>
    ### 部署程序

    您现在已完成基本的 CRUD 程序。通过在 Playground 终端中运行
    `deploy` 来部署程序。

    <Callout type="info">
      在此示例中，您将把程序部署到 devnet，这是一个用于开发测试的 Solana 集群。

      Playground 钱包默认连接到 devnet。确保您的 Playground 钱包有足够的 devnet SOL 来支付程序部署费用。您可以从
      [Solana 水龙头](https://faucet.solana.com/)获取 devnet SOL。
    </Callout>

    ```terminal
    $ deploy
    正在部署...这可能需要一些时间，取决于程序大小和网络条件。
    部署成功。17秒内完成。
    ```
  </Step>

  <Step>
    ### 设置测试文件

    入门代码还包括一个测试文件，位于`anchor.test.ts`中。

    ```ts title="anchor.test.ts"
    import { PublicKey } from "@solana/web3.js";

    describe("pda", () => {
      it("Create Message Account", async () => {});

      it("Update Message Account", async () => {});

      it("Delete Message Account", async () => {});
    });
    ```

    在*ts`describe()`*&#x5185;部但在*ts`it()`*&#x90E8;分之前添加以下代码。

    ```ts title="anchor.test.ts"
    const program = pg.program;
    const wallet = pg.wallet;

    const [messagePda, messageBump] = PublicKey.findProgramAddressSync(
      [Buffer.from("message"), wallet.publicKey.toBuffer()],
      program.programId
    );
    ```

    <Accordions>
      <Accordion title="差异">
        ```diff
          import { PublicKey } from "@solana/web3.js";

          describe("pda", () => {
        +    const program = pg.program;
        +    const wallet = pg.wallet;
        +
        +    const [messagePda, messageBump] = PublicKey.findProgramAddressSync(
        +      [Buffer.from("message"), wallet.publicKey.toBuffer()],
        +      program.programId
        +    );

            it("Create Message Account", async () => {});

            it("Update Message Account", async () => {});

            it("Delete Message Account", async () => {});
          });
        ```
      </Accordion>

      <Accordion title="解释">
        在这一部分，此代码只是设置测试文件。

        <WithMentions>
          Solana Playground 移除了一些样板设置，其中
          [`pg.program`](mention:one)允许访问与程序交互的方法，而[`pg.wallet`](mention:two)则提供对你的playground钱包的访问权限。

          ```ts title="anchor.test.ts"
          // !mention one
          const program = pg.program;
          // !mention two
          const wallet = pg.wallet;
          ```
        </WithMentions>

        作为设置的一部分，测试文件派生出消息账户PDA。这展示了如何在Javascript中使用与程序中指定的相同种子来派生PDA。

        ```ts title="anchor.test.ts"
        const [messagePda, messageBump] = PublicKey.findProgramAddressSync(
          [Buffer.from("message"), wallet.publicKey.toBuffer()],
          program.programId
        );
        ```
      </Accordion>
    </Accordions>

    通过在Playground终端中运行*shell`test`*&#x6765;运行测试文件，检查
    它是否按预期运行。接下来的步骤将添加实际测试。

    ```terminal
    $ test
    Running tests...
      anchor.test.ts:
      pda
        ✔ Create Message Account
        ✔ Update Message Account
        ✔ Delete Message Account
      3 passing (4ms)
    ```
  </Step>

  <Step>
    ### 调用创建指令

    <WithNotes>
      使用以下内容更新第一个测试：

      ```ts title="anchor.test.ts"
      it("Create Message Account", async () => {
        const message = "Hello, World!";
        const transactionSignature = await program.methods
          // !tooltip[/create/] create
          .create(message)
          // !tooltip[/accounts/] accounts
          .accounts({
            messageAccount: messagePda
          })
          // !tooltip[/rpc/] rpc
          .rpc({ commitment: "confirmed" });

        // !tooltip[/fetch/] fetch
        const messageAccount = await program.account.messageAccount.fetch(
          messagePda,
          "confirmed"
        );

        console.log(JSON.stringify(messageAccount, null, 2));
        console.log(
          "Transaction Signature:",
          `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
        );
      });
      ```

      ### !create

      *ts`create()`*&#x65B9;法调用`create`指令。

      ### !accounts

      *ts`accounts()`*&#x65B9;法指定了
      *ts`create()`*&#x6307;令所需的账户。

      ### !rpc

      *ts`rpc()`* 方法将交易发送到网络。

      ### !fetch

      *ts`fetch()`* 方法从网络中检索账户数据。
    </WithNotes>

    <Accordions>
      <Accordion title="Diff">
        ```diff
        - it("Create Message Account", async () => {});

        + it("Create Message Account", async () => {
        +   const message = "Hello, World!";
        +   const transactionSignature = await program.methods
        +     .create(message)
        +     .accounts({
        +       messageAccount: messagePda,
        +     })
        +     .rpc({ commitment: "confirmed" });
        +
        +   const messageAccount = await program.account.messageAccount.fetch(
        +     messagePda,
        +     "confirmed"
        +   );
        +
        +   console.log(JSON.stringify(messageAccount, null, 2));
        +   console.log(
        +     "Transaction Signature:",
        +     `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
        +   );
        + });
        ```
      </Accordion>

      <Accordion title="解释">
        首先，测试文件发送一个调用 `create` 指令的交易，
        传递"Hello, World!"作为消息。

        ```ts title="anchor.test.ts"
        const message = "Hello, World!";
        const transactionSignature = await program.methods
          .create(message)
          .accounts({
            messageAccount: messagePda
          })
          .rpc({ commitment: "confirmed" });
        ```

        发送交易并创建账户后，测试文件使用其地址（`messagePda`）获取账户。

        ```ts title="anchor.test.ts"
        const messageAccount = await program.account.messageAccount.fetch(
          messagePda,
          "confirmed"
        );
        ```

        最后，测试文件记录账户数据和交易详情的链接。

        ```ts title="anchor.test.ts"
        console.log(JSON.stringify(messageAccount, null, 2));
        console.log(
          "Transaction Signature:",
          `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
        );
        ```
      </Accordion>
    </Accordions>
  </Step>

  <Step>
    ### 调用更新指令

    <WithNotes>
      使用以下内容更新第二个测试：

      ```ts title="anchor.test.ts"
      it("Update Message Account", async () => {
        const message = "Hello, Solana!";
        const transactionSignature = await program.methods
          // !tooltip[/update/] update
          .update(message)
          // !tooltip[/accounts/] accounts
          .accounts({
            messageAccount: messagePda
          })
          // !tooltip[/rpc/] rpc
          .rpc({ commitment: "confirmed" });

        // !tooltip[/fetch/] fetch
        const messageAccount = await program.account.messageAccount.fetch(
          messagePda,
          "confirmed"
        );

        console.log(JSON.stringify(messageAccount, null, 2));
        console.log(
          "Transaction Signature:",
          `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
        );
      });
      ```

      ### !update

      *ts`update()`* 方法调用 `update` 指令。

      ### !accounts

      *ts`accounts()`* 方法指定了
      *ts`update()`* 指令所需的账户。

      ### !rpc

      *ts`rpc()`* 方法将交易发送到网络。

      ### !fetch

      *ts`fetch()`* 方法从网络中检索账户数据。
    </WithNotes>

    <Accordions>
      <Accordion title="Diff">
        ```diff
        - it("Update Message Account", async () => {});

        + it("Update Message Account", async () => {
        +   const message = "Hello, Solana!";
        +   const transactionSignature = await program.methods
        +     .update(message)
        +     .accounts({
        +       messageAccount: messagePda,
        +     })
        +     .rpc({ commitment: "confirmed" });
        +
        +   const messageAccount = await program.account.messageAccount.fetch(
        +     messagePda,
        +     "confirmed"
        +   );
        +
        +   console.log(JSON.stringify(messageAccount, null, 2));
        +   console.log(
        +     "Transaction Signature:",
        +     `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
        +   );
        + });
        ```
      </Accordion>

      <Accordion title="解释">
        首先，测试文件发送一个调用`update`指令的交易，传递
        "Hello, Solana!"作为新消息。

        ```ts title="anchor.test.ts"
        const message = "Hello, Solana!";
        const transactionSignature = await program.methods
          .update(message)
          .accounts({
            messageAccount: messagePda
          })
          .rpc({ commitment: "confirmed" });
        ```

        发送交易并更新账户后，测试文件使用其地址（`messagePda`）获取账户。

        ```ts title="anchor.test.ts"
        const messageAccount = await program.account.messageAccount.fetch(
          messagePda,
          "confirmed"
        );
        ```

        最后，测试文件记录账户数据和交易详情链接。

        ```ts title="anchor.test.ts"
        console.log(JSON.stringify(messageAccount, null, 2));
        console.log(
          "Transaction Signature:",
          `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
        );
        ```
      </Accordion>
    </Accordions>
  </Step>

  <Step>
    ### 调用删除指令

    <WithNotes>
      使用以下内容更新第三个测试：

      ```ts title="anchor.test.ts"
      it("Delete Message Account", async () => {
        const transactionSignature = await program.methods
          // !tooltip[/delete/] delete
          .delete()
          // !tooltip[/accounts/] accounts
          .accounts({
            messageAccount: messagePda
          })
          // !tooltip[/rpc/] rpc
          .rpc({ commitment: "confirmed" });

        // !tooltip[/fetchNullable/] fetchNullable
        const messageAccount = await program.account.messageAccount.fetchNullable(
          messagePda,
          "confirmed"
        );

        console.log("Expect Null:", JSON.stringify(messageAccount, null, 2));
        console.log(
          "Transaction Signature:",
          `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
        );
      });
      ```

      ### !delete

      *ts`delete()`*&#x65B9;法调用`delete`指令。

      ### !accounts

      *ts`accounts()`* 方法指定了&#x20;
      *ts`delete()`* 指令所需的账户。

      ### !rpc

      *ts`rpc()`* 方法将交易发送到网络。

      ### !fetchNullable

      *ts`fetchNullable()`* 方法从网络中检索可能不存在的账户数据。

      测试文件使用这个方法是因为账户关闭后数据变得不可用。
    </WithNotes>

    <Accordions>
      <Accordion title="Diff">
        ```diff
        - it("Delete Message Account", async () => {});

        + it("Delete Message Account", async () => {
        +   const transactionSignature = await program.methods
        +     .delete()
        +     .accounts({
        +       messageAccount: messagePda,
        +     })
        +     .rpc({ commitment: "confirmed" });
        +
        +   const messageAccount = await program.account.messageAccount.fetchNullable(
        +     messagePda,
        +     "confirmed"
        +   );
        +
        +   console.log("Expect Null:", JSON.stringify(messageAccount, null, 2));
        +   console.log(
        +     "Transaction Signature:",
        +     `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
        +   );
        + });
        ```
      </Accordion>

      <Accordion title="Explanation">
        首先，这段代码发送一个调用 `delete` 指令的交易来关闭消息账户。

        ```ts title="anchor.test.ts"
        const transactionSignature = await program.methods
          .delete()
          .accounts({
            messageAccount: messagePda
          })
          .rpc({ commitment: "confirmed" });
        ```

        发送交易并关闭账户后，示例尝试使用其地址（`messagePda`) 与 `fetchNullable`。此方法在账户关闭后不再存在时返回 null。

        ```ts title="anchor.test.ts"
        const messageAccount = await program.account.messageAccount.fetchNullable(
          messagePda,
          "confirmed"
        );
        ```

        最后，测试文件记录账户数据和交易详情的链接。由于账户不再存在，账户数据显示为 null。

        ```ts title="anchor.test.ts"
        console.log(JSON.stringify(messageAccount, null, 2));
        console.log(
          "交易签名:",
          `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
        );
        ```
      </Accordion>
    </Accordions>
  </Step>

  <Step>
    ### 运行测试

    准备好测试后，在 Playground 终端中使用 *shell`test`* 运行测试文件。此命令针对部署在 devnet 上的程序运行测试，并记录 SolanaFM 的链接以查看交易详情。

    ```terminal
    $ test
    运行测试...
      anchor.test.ts:
      pda
        {
      "user": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "message": "Hello, World!",
      "bump": 254
    }
        交易签名: https://solana.fm/tx/5oBT4jEdUR6CRYsFNGoqvyMBTRDvFqRWTAAmCGM9rEvYRBWy3B2bkb6GVFpVPKBnkr714UCFUurBSDKSa7nLHo8e?cluster=devnet-solana
        ✔ 创建消息账户 (1025ms)
        {
      "user": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "message": "Hello, Solana!",
      "bump": 254
    }
        交易签名: https://solana.fm/tx/42veGAsQjHbJP1SxWBGcfYF7EdRN9X7bACNv23NSZNe4U7w2dmaYgSv8UUWXYzwgJPoNHejhtWdKZModHiMaTWYK?cluster=devnet-solana
        ✔ 更新消息账户 (713ms)
        预期为 Null: null
        交易签名: https://solana.fm/tx/Sseog2i2X7uDEn2DyDMMJKVHeZEzmuhnqUwicwGhnGhstZo8URNwUZgED8o6HANiojJkfQbhXVbGNLdhsFtWrd6?cluster=devnet-solana
        ✔ 删除消息账户 (812ms)
      3 个测试通过 (3s)
    ```

    查看 SolanaFM 链接以了解交易详情。

    <Callout type="info">
      请注意，在此示例中，如果再次运行测试，`create` 指令将失败，因为 `messageAccount` 已作为账户存在。对于给定的 PDA，只能存在一个账户。
    </Callout>
  </Step>
</Steps>
