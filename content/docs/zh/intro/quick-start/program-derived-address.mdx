---
title: 创建确定性账户
description:
  学习如何使用程序派生地址（PDAs）和Anchor框架构建CRUD（创建、读取、更新、删除）Solana程序。本分步
  指南演示了如何使用PDAs创建、更新和删除链上消息账户，
  实现账户验证，并编写测试。非常适合
  希望了解如何在Solana程序中使用PDAs的开发者。
h1: 程序派生地址
---

在本节中，您将学习如何构建基本的创建、读取、更新、删除 (CRUD)程序。

本指南演示了一个简单的程序，用户可以创建、更新和删除消息。每条消息都存在于一个具有确定性地址的账户中，该地址由程序本身派生（程序派生地址或PDA）。

本指南将引导您使用Anchor框架构建和测试Solana程序，同时演示程序派生地址（PDAs）。有关更多详情，请参阅[程序派生地址](/docs/core/pda)页面。

作为参考，您可以查看
[最终代码](https://beta.solpg.io/668304cfcffcf4b13384d20a)，该代码是在完成PDA和跨程序调用（CPI）部分后的结果。

<Steps>
  <Step>
    ### 起始代码

### Starter Code

Start by opening this
[Solana Playground link](https://beta.solpg.io/66734b7bcffcf4b13384d1ad) with
the starter code. Then click the "Import" button to add the program to your
Solana Playground projects.

![Import](/assets/docs/intro/quickstart/pg-import.png)

<WithMentions>

In the `lib.rs` file, you'll find a program with the [`create`](mention:one),
[`update`](mention:two), and [`delete`](mention:three) instructions to add in
the following steps.

```rs title="lib.rs"
use anchor_lang::prelude::*;

declare_id!("8KPzbM2Cwn4Yjak7QYAEH9wyoQh86NcBicaLuzPaejdw");

#[program]
pub mod pda {
    use super::*;

    // !mention one
    pub fn create(_ctx: Context<Create>) -> Result<()> {
        Ok(())
    }

    // !mention two
    pub fn update(_ctx: Context<Update>) -> Result<()> {
        Ok(())
    }

    // !mention three
    pub fn delete(_ctx: Context<Delete>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create {}

#[derive(Accounts)]
pub struct Update {}

#[derive(Accounts)]
pub struct Delete {}

#[account]
pub struct MessageAccount {}
```

</WithMentions>

Before beginning, run *shell`build`* in the Playground terminal to check the
starter program builds successfully.

```terminal
$ build
Building...
Build successful. Completed in 3.50s.
```

</Step>
<Step>

### Define Message Account Type

First, define the structure for the message account that the program creates.
This structure defines the data to store in the account created by the program.

<WithNotes>

In `lib.rs`, update the *rs`MessageAccount`* struct with the following:

```rs title="lib.rs"
// !tooltip[/account/] account
#[account]
pub struct MessageAccount {
    // !tooltip[/user/] user
    pub user: Pubkey,
    // !tooltip[/message/] message
    pub message: String,
    // !tooltip[/bump/] bump
    pub bump: u8,
}
```

### !account

The *rs`#[account]`* attribute in an Anchor program annotates structs that
represent account data (data type to store in the Account's data field).

### !user

The *rs`user`* field contains a *rs`Pubkey`* that identifies the user who
created the message account.

### !message

The *rs`message`* field holds a *rs`String`* containing the user's message.

### !bump

The *rs`bump`* field stores a *rs`u8`*
["bump" seed](/docs/core/pda#canonical-bump) used to derive a program derived
address (PDA). Storing this value saves compute by eliminating the need to
recalculate it in later instructions.

  <Step>
    ### 调用更新指令

<Accordions>
<Accordion title="Diff">

```diff
- #[account]
- pub struct MessageAccount {}

+ #[account]
+ pub struct MessageAccount {
+    pub user: Pubkey,
+    pub message: String,
+    pub bump: u8,
+ }
```

  <Step>
    ### 调用删除指令

The *rs`#[account]`* attribute in an Anchor program annotates structs that
represent account data (data type to store in the Account's data field).

In this example, the *rs`MessageAccount`* struct stores a message created by
users that contains three fields:

* `user` - *rs`Pubkey`* that identifies the user who created the message
  account.
* `message` - *rs`String`* that contains the user's message.
* `bump` - *rs`u8`* that stores the ["bump" seed](/docs/core/pda#canonical-bump)
  for deriving the program derived address (PDA). Storing this value saves
  compute by eliminating the need to recalculate it in later instructions.

When creating an account, the program serializes the *rs`MessageAccount`* data
and stores it in the new account's data field.

Later, when reading from the account, the program deserializes this data back
into the *rs`MessageAccount`* data type. The testing section demonstrates the
process of creating and reading account data.

</Accordion>
</Accordions>

Build the program again by running *shell`build`* in the terminal.

```terminal
$ build
```

This code defines what data to store on the message account. Next, you'll add
the program instructions.

</Step>
<Step>

### Add Create Instruction

Now, add the *rs`create`* instruction that creates and initializes the
*rs`MessageAccount`*.

Start by defining the accounts required for the instruction by updating the
*rs`Create`* struct with the following:

<WithNotes>

```rs title="lib.rs"
#[derive(Accounts)]
// !tooltip[/instruction/] instruction
#[instruction(message: String)]
pub struct Create<'info> {
    // !tooltip[/mut/] mut
    #[account(mut)]
    // !tooltip[/Signer<'info>/] signer
    pub user: Signer<'info>,

    #[account(
        // !tooltip[/init/] init
        init,
        // !tooltip[/seeds/] seeds
        seeds = [b"message", user.key().as_ref()],
        // !tooltip[/bump/] bump
        bump,
        // !tooltip[/payer/] payer
        payer = user,
        // !tooltip[/space/] space
        space = 8 + 32 + 4 + message.len() + 1
    )]
    // !tooltip[/Account<'info, MessageAccount>/] account
    pub message_account: Account<'info, MessageAccount>,
    // !tooltip[/Program<'info, System>/] program
    pub system_program: Program<'info, System>,
}
```

### !mut

The *rs`mut`* constraint declares the account as mutable.

### !init

The *rs`init`* constraint creates a new account.

### !seeds

The *rs`seeds`* constraint defines the optional inputs used to derive the PDA.

### !bump

The *rs`bump`* constraint declares the bump seed for the PDA.

If you don't specify a value, Anchor automatically calculates it.

### !payer

The *rs`payer`* constraint specifies which account pays for the new account
creation.

### !space

The *rs`space`* constraint specifies the number of bytes to assign for the new
account's data field.

### !signer

The *rs`Signer<'info>`* type requires that the account sign the transaction.

### !account

The *rs`Account<'info, T>`* type requires that the account match the specified
type.

In this case, the account must match the custom *rs`MessageAccount`* type.

### !program

The *rs`Program<'info, T>`* type requires the account to match a program.

In this case, the account must match the *rs`System`* type, which refers to the
System Program.

### !instruction

The *rs`#[instruction(message: String)]`* annotation lets the *rs`Create`*
struct access the *rs`message`* parameter from the `create` instruction.

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- #[derive(Accounts)]
- pub struct Create {}

+ #[derive(Accounts)]
+ #[instruction(message: String)]
+ pub struct Create<'info> {
+     #[account(mut)]
+     pub user: Signer<'info>,
+
+     #[account(
+         init,
+         seeds = [b"message", user.key().as_ref()],
+         bump,
+         payer = user,
+         space = 8 + 32 + 4 + message.len() + 1
+     )]
+     pub message_account: Account<'info, MessageAccount>,
+     pub system_program: Program<'info, System>,
+ }
```

</Accordion>
<Accordion title="Explanation">

The *rs`#[derive(Accounts)]`* attribute in an Anchor program annotates structs
that define the accounts required by an instruction.

Each field in the struct represents an account validated in two ways:

1. The account type (like *rs`Signer<'info>`* or *rs`Account<'info, T>`*) that
   specifies what kind of account the program expects
2. Optional constraints (like *rs`#[account(mut)]`* or *rs`#[account(init)]`*)
   that define extra requirements

Together, these enable Anchor to automatically verify accounts passed to the
instruction and secure the program.

The field names in the struct provide access to the accounts in your program
code, but don't affect validation. You should use descriptive names for clarity.

In this example, the *rs`Create`* struct defines the accounts required for the
*rs`create`* instruction.

1. *rs`user: Signer<'info>`*

   * Represents the user creating the message account
   * Needs mutable status (*rs`#[account(mut)]`*) since it pays for the new
     account
   * Must sign the transaction to approve lamport deduction from this account

2. *rs`message_account: Account<'info, MessageAccount>`*

   * The new account that stores the user's message
   * `init` constraint creates the account during instruction execution
   * `seeds` and `bump` constraints derive the account address as a Program
     Derived Address (PDA)
   * `payer = user` identifies who pays for the creation of the new account
   * `space` allocates the required bytes for the account's data field

3. *rs`system_program: Program<'info, System>`*

   * Necessary for account creation
   * Behind the scenes, the `init` constraint calls the System Program to create
     a new account with the specified `space` and changes the owner to the
     current program.

***

The *rs`#[instruction(message: String)]`* annotation lets the *rs`Create`*
struct access the *rs`message`* parameter from the `create` instruction.

***

代币程序上的`seeds` and `bump` constraints together define an account's address
as a Program Derived Address (PDA).

```rs title="lib.rs"
seeds = [b"message", user.key().as_ref()],
bump,
```

The `seeds` constraint defines the optional inputs used to derive the PDA.

* *rs`b"message"`* - A fixed string as the first seed.
* *rs`user.key().as_ref()`* - The public key of the *rs`user`* account as the
  second seed.

The `bump` constraint tells Anchor to automatically find and use the correct
bump seed. Anchor uses the `seeds` and `bump` to derive the PDA.

***

The `space` calculation *rs`(8 + 32 + 4 + message.len() + 1)`* allocates space
for `MessageAccount` data type:

* Anchor Account discriminator (identifier): 8 bytes
* User Address (*rs`Pubkey`*): 32 bytes
* User Message (*rs`String`*): 4 bytes for length + variable message length
* PDA Bump seed (*rs`u8`*): 1 byte

```rs title="lib.rs"
#[account]
pub struct MessageAccount {
    pub user: Pubkey,
    pub message: String,
    pub bump: u8,
}
```

All accounts created through an Anchor program need 8 bytes for an account
discriminator, which serves as an identifier for the account type that Anchor
automatically generates when creating the account.

A *rs`String`* type needs 4 bytes to store the length of the string, and the
remaining length contains the actual data.

</Accordion>
</Accordions>

Next, add the business logic for the *rs`create`* instruction by updating the
`create` function with the following:

```rs title="lib.rs"
pub fn create(ctx: Context<Create>, message: String) -> Result<()> {
    msg!("Create Message: {}", message);
    let account_data = &mut ctx.accounts.message_account;
    account_data.user = ctx.accounts.user.key();
    account_data.message = message;
    account_data.bump = ctx.bumps.message_account;
    Ok(())
}
```

<Accordions>
<Accordion title="Diff">

```diff
- pub fn create(_ctx: Context<Create>) -> Result<()> {
-     Ok(())
- }

+ pub fn create(ctx: Context<Create>, message: String) -> Result<()> {
+     msg!("Create Message: {}", message);
+     let account_data = &mut ctx.accounts.message_account;
+     account_data.user = ctx.accounts.user.key();
+     account_data.message = message;
+     account_data.bump = ctx.bumps.message_account;
+     Ok(())
+ }
```

</Accordion>
<Accordion title="Explanation">

The `create` function implements the logic for initializing a new message
account's data. It takes two parameters:

1. *rs`ctx: Context<Create>`* - Provides access to the accounts specified in the
   *rs`Create`* struct.
2. *rs`message: String`* - The user's message for storage.

The body of the function then performs the following logic:

1. Print a message to program logs using the *rs`msg!()`* macro.

   ```rs
   msg!("Create Message: {}", message);
   ```

2. Initializing Account Data:

   * Accesses the `message_account` from the context.

   ```rs
   let account_data = &mut ctx.accounts.message_account;
   ```

   * Sets the `user` field to the public key of the `user` account.

   ```rs
   account_data.user = ctx.accounts.user.key();
   ```

   * Sets the `message` field to the `message` from the function argument.

   ```rs
   account_data.message = message;
   ```

   * Sets the `bump` value used to derive the PDA, retrieved from
     `ctx.bumps.message_account`.

   ```rs
   account_data.bump = ctx.bumps.message_account;
   ```

</Accordion>
</Accordions>

Rebuild the program.

```terminal
$ build
```

</Step>
<Step>

### Add Update Instruction

Next, add the `update` instruction to change the `MessageAccount` with a new
message.

Like the previous step, first specify the accounts required by the `update`
instruction.

Update the `Update` struct with the following:

<WithNotes>

```rs title="lib.rs"
#[derive(Accounts)]
#[instruction(message: String)]
pub struct Update<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        mut,
        seeds = [b"message", user.key().as_ref()],
        bump = message_account.bump,
        // !tooltip[/realloc/] realloc
        realloc = 8 + 32 + 4 + message.len() + 1,
        // !tooltip[/realloc::payer/] realloc::payer
        realloc::payer = user,
        // !tooltip[/realloc::zero/] realloc::zero
        realloc::zero = true,
    )]
    pub message_account: Account<'info, MessageAccount>,
    pub system_program: Program<'info, System>,
}
```

### !realloc

The *rs`realloc`* constraint reallocates the account's data.

### !realloc::payer

The *rs`realloc::payer`* constraint specifies the account paying for the
reallocation.

### !realloc::zero

The *rs`realloc::zero`* constraint zeros out the account's data.

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- #[derive(Accounts)]
- pub struct Update {}

+ #[derive(Accounts)]
+ #[instruction(message: String)]
+ pub struct Update<'info> {
+     #[account(mut)]
+     pub user: Signer<'info>,
+
+     #[account(
+         mut,
+         seeds = [b"message", user.key().as_ref()],
+         bump = message_account.bump,
+         realloc = 8 + 32 + 4 + message.len() + 1,
+         realloc::payer = user,
+         realloc::zero = true,
+     )]
+     pub message_account: Account<'info, MessageAccount>,
+     pub system_program: Program<'info, System>,
+ }
```

</Accordion>
<Accordion title="Explanation">

The *rs`Update`* struct defines the accounts required for the *rs`update`*
instruction.

1. *rs`user: Signer<'info>`*

   * Represents the user updating the message account
   * Marked as mutable (*rs`#[account(mut)]`*) as it might pay for more space
     for the `message_account` when needed
   * Must sign the transaction

2. *rs`message_account: Account<'info, MessageAccount>`*

   * The existing account storing the user's message for updating
   * `mut` constraint indicates data modification for this account
   * `realloc` constraint allows resizing of the account's data
   * `seeds` and `bump` constraints verify the account as the correct PDA

3. *rs`system_program: Program<'info, System>`*
   * Required for potential reallocation of account space
   * The `realloc` constraint invokes the System Program to adjust the account's
     data size

Note that the *rs`bump = message_account.bump`* constraint uses the bump seed
stored on the *rs`message_account`*, rather than having Anchor recalculate it.

The *rs`#[instruction(message: String)]`* attribute enables the *rs`Update`*
struct to access the *rs`message`* parameter from the *rs`update`* instruction.

</Accordion>
</Accordions>

Next, add the logic for the `update` instruction.

```rs title="lib.rs"
pub fn update(ctx: Context<Update>, message: String) -> Result<()> {
    msg!("Update Message: {}", message);
    let account_data = &mut ctx.accounts.message_account;
    account_data.message = message;
    Ok(())
}
```

<Accordions>
<Accordion title="Diff">

```diff
- pub fn update(_ctx: Context<Update>) -> Result<()> {
-     Ok(())
- }

+ pub fn update(ctx: Context<Update>, message: String) -> Result<()> {
+     msg!("Update Message: {}", message);
+     let account_data = &mut ctx.accounts.message_account;
+     account_data.message = message;
+     Ok(())
+ }
```

</Accordion>
<Accordion title="Explanation">

The `update` function implements the logic for modifying an existing message
account. It takes two parameters:

1. *rs`ctx: Context<Update>`* - Provides access to the accounts specified in the
   *rs`Update`* struct.
2. *rs`message: String`* - The new message to replace the existing one.

The body of the function then:

1. Print a message to program logs using the *rs`msg!()`* macro.

2. Updates Account Data:
   * Accesses the `message_account` from the context.
   * Sets the `message` field to the new `message` from the function argument.

</Accordion>
</Accordions>

Rebuild the program

```terminal
$ build
```

</Step>
<Step>

### Add Delete Instruction

Next, add the *rs`delete`* instruction to close the *rs`MessageAccount`*.

Update the *rs`Delete`* struct with the following:

<WithNotes>

```rs title="lib.rs"
#[derive(Accounts)]
pub struct Delete<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        mut,
        // !tooltip[/seeds/] seeds
        seeds = [b"message", user.key().as_ref()],
        // !tooltip[/bump/] bump
        bump = message_account.bump,
        // !tooltip[/close/] close
        close= user,
    )]
    pub message_account: Account<'info, MessageAccount>,
}
```

### !seeds

The *rs`seeds`* constraint specifies the seeds used to derive the PDA.

### !bump

The *rs`bump`* constraint specifies the bump seed for the PDA.

In this case, the program uses the existing bump seed stored on the
*rs`message_account`*.

### !close

The *rs`close`* constraint closes the account.

In this case, the *rs`user`* account receives the lamports from the closed
*rs`message_account`*.

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- #[derive(Accounts)]
- pub struct Delete {}

+ #[derive(Accounts)]
+ pub struct Delete<'info> {
+     #[account(mut)]
+     pub user: Signer<'info>,
+
+     #[account(
+         mut,
+         seeds = [b"message", user.key().as_ref()],
+         bump = message_account.bump,
+         close = user,
+     )]
+     pub message_account: Account<'info, MessageAccount>,
+ }
```

</Accordion>
<Accordion title="Explanation">

The *rs`Delete`* struct defines the accounts required for the *rs`delete`*
instruction:

1. *rs`user: Signer<'info>`*

   * Represents the user closing the message account
   * Marked as mutable (*rs`#[account(mut)]`*) to receive the lamports from the
     closed account
   * Must sign to ensure only the correct user can close their message account

2. *rs`message_account: Account<'info, MessageAccount>`*

   * The account for closing
   * `mut` constraint indicates data modification
   * `seeds` and `bump` constraints verify the account as the correct PDA
   * `close = user` constraint marks this account for closing and transfers its
     lamports to the `user` account

</Accordion>
</Accordions>

Next, add the logic for the `delete` instruction.

```rs title="lib.rs"
pub fn delete(_ctx: Context<Delete>) -> Result<()> {
    msg!("Delete Message");
    Ok(())
}
```

<Accordions>
<Accordion title="Diff">

```diff
- pub fn delete(_ctx: Context<Delete>) -> Result<()> {
-     Ok(())
- }

+ pub fn delete(_ctx: Context<Delete>) -> Result<()> {
+     msg!("Delete Message");
+     Ok(())
+ }
```

</Accordion>
<Accordion title="Explanation">

The `delete` function takes one parameter:

1. *rs`_ctx: Context<Delete>`* - Provides access to the accounts specified in
   the *rs`Delete`* struct. The *rs`_ctx`* syntax shows that the function
   doesn't use the Context in its body.

The function body just prints a message to program logs using the *rs`msg!()`*
macro. The function needs no extra logic because the *rs`close`* constraint in
the *rs`Delete`* struct handles the account closing.

</Accordion>
</Accordions>

Rebuild the program.

```terminal
$ build
```

</Step>
<Step>

### Deploy Program

You've now completed the basic CRUD program. Deploy the program by running
`deploy` in the Playground terminal.

<Callout type="info">
In this example, you'll deploy the program to the devnet, a Solana cluster
for development testing.

The Playground wallet connects to the devnet by default. Ensure your Playground
wallet has devnet SOL to pay for the program deployment. Get devnet SOL from the
[Solana Faucet](https://faucet.solana.com/).

</Callout>

```terminal
$ deploy
Deploying... This could take a while depending on the program size and network conditions.
Deployment successful. Completed in 17s.
```

</Step>
<Step>

### Set Up Test File

The starter code also includes a test file in `anchor.test.ts`.

```ts title="anchor.test.ts"
import { PublicKey } from "@solana/web3.js";

describe("pda", () => {
  it("Create Message Account", async () => {});

  it("Update Message Account", async () => {});

  it("Delete Message Account", async () => {});
});
```

Add the code below inside *ts`describe()`*, but before the *ts`it()`* sections.

```ts title="anchor.test.ts"
const program = pg.program;
const wallet = pg.wallet;

const [messagePda, messageBump] = PublicKey.findProgramAddressSync(
  [Buffer.from("message"), wallet.publicKey.toBuffer()],
  program.programId
);
```

<Accordions>
<Accordion title="Diff">

```diff
  import { PublicKey } from "@solana/web3.js";

  describe("pda", () => {
+    const program = pg.program;
+    const wallet = pg.wallet;
+
+    const [messagePda, messageBump] = PublicKey.findProgramAddressSync(
+      [Buffer.from("message"), wallet.publicKey.toBuffer()],
+      program.programId
+    );

    it("Create Message Account", async () => {});

    it("Update Message Account", async () => {});

    it("Delete Message Account", async () => {});
  });
```

</Accordion>
<Accordion title="Explanation">

In this section, this code simply sets up the test file.

<WithMentions>

Solana Playground removes some boilerplate setup where
[`pg.program`](mention:one) allows access to methods for interacting with the
program, while [`pg.wallet`](mention:two) gives access to your playground
wallet.

```ts title="anchor.test.ts"
// !mention one
const program = pg.program;
// !mention two
const wallet = pg.wallet;
```

</WithMentions>

As part of the setup, the test file derives the message account PDA. This
demonstrates how to derive the PDA in Javascript using the same seeds specified
in the program.

```ts title="anchor.test.ts"
const [messagePda, messageBump] = PublicKey.findProgramAddressSync(
  [Buffer.from("message"), wallet.publicKey.toBuffer()],
  program.programId
);
```

</Accordion>
</Accordions>

Run the test file by running *shell`test`* in the Playground terminal to check
that it runs as expected. The next steps add the actual tests.

```terminal
$ test
Running tests...
  anchor.test.ts:
  pda
    ✔ Create Message Account
    ✔ Update Message Account
    ✔ Delete Message Account
  3 passing (4ms)
```

</Step>
<Step>

### Invoke Create Instruction

<WithNotes>

Update the first test with the following:

```ts title="anchor.test.ts"
it("Create Message Account", async () => {
  const message = "Hello, World!";
  const transactionSignature = await program.methods
    // !tooltip[/create/] create
    .create(message)
    // !tooltip[/accounts/] accounts
    .accounts({
      messageAccount: messagePda
    })
    // !tooltip[/rpc/] rpc
    .rpc({ commitment: "confirmed" });

  // !tooltip[/fetch/] fetch
  const messageAccount = await program.account.messageAccount.fetch(
    messagePda,
    "confirmed"
  );

  console.log(JSON.stringify(messageAccount, null, 2));
  console.log(
    "Transaction Signature:",
    `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
  );
});
```

### !create

The *ts`create()`* method invokes the `create` instruction.

### !accounts

The *ts`accounts()`* method specifies the accounts required for the
*ts`create()`* instruction.

### !rpc

The *ts`rpc()`* method sends the transaction to the network.

### !fetch

The *ts`fetch()`* method retrieves the account data from the network.

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- it("Create Message Account", async () => {});

+ it("Create Message Account", async () => {
+   const message = "Hello, World!";
+   const transactionSignature = await program.methods
+     .create(message)
+     .accounts({
+       messageAccount: messagePda,
+     })
+     .rpc({ commitment: "confirmed" });
+
+   const messageAccount = await program.account.messageAccount.fetch(
+     messagePda,
+     "confirmed"
+   );
+
+   console.log(JSON.stringify(messageAccount, null, 2));
+   console.log(
+     "Transaction Signature:",
+     `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
+   );
+ });
```

</Accordion>
<Accordion title="Explanation">

First, the test file sends a transaction that invokes the `create` instruction,
passing "Hello, World!" as the message.

```ts title="anchor.test.ts"
const message = "Hello, World!";
const transactionSignature = await program.methods
  .create(message)
  .accounts({
    messageAccount: messagePda
  })
  .rpc({ commitment: "confirmed" });
```

After sending the transaction and creating the account, the test file fetches
the account using its address (`messagePda`).

```ts title="anchor.test.ts"
const messageAccount = await program.account.messageAccount.fetch(
  messagePda,
  "confirmed"
);
```

Lastly, the test file logs the account data and a link to the transaction
details.

```ts title="anchor.test.ts"
console.log(JSON.stringify(messageAccount, null, 2));
console.log(
  "Transaction Signature:",
  `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
);
```

</Accordion>
</Accordions>

</Step>
<Step>

### Invoke Update Instruction

<WithNotes>
Update the second test with the following:

```ts title="anchor.test.ts"
it("Update Message Account", async () => {
  const message = "Hello, Solana!";
  const transactionSignature = await program.methods
    // !tooltip[/update/] update
    .update(message)
    // !tooltip[/accounts/] accounts
    .accounts({
      messageAccount: messagePda
    })
    // !tooltip[/rpc/] rpc
    .rpc({ commitment: "confirmed" });

  // !tooltip[/fetch/] fetch
  const messageAccount = await program.account.messageAccount.fetch(
    messagePda,
    "confirmed"
  );

  console.log(JSON.stringify(messageAccount, null, 2));
  console.log(
    "Transaction Signature:",
    `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
  );
});
```

### !update

The *ts`update()`* method invokes the `update` instruction.

### !accounts

The *ts`accounts()`* method specifies the accounts required for the
*ts`update()`* instruction.

### !rpc

The *ts`rpc()`* method sends the transaction to the network.

### !fetch

The *ts`fetch()`* method retrieves the account data from the network.

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- it("Update Message Account", async () => {});

+ it("Update Message Account", async () => {
+   const message = "Hello, Solana!";
+   const transactionSignature = await program.methods
+     .update(message)
+     .accounts({
+       messageAccount: messagePda,
+     })
+     .rpc({ commitment: "confirmed" });
+
+   const messageAccount = await program.account.messageAccount.fetch(
+     messagePda,
+     "confirmed"
+   );
+
+   console.log(JSON.stringify(messageAccount, null, 2));
+   console.log(
+     "Transaction Signature:",
+     `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
+   );
+ });
```

</Accordion>
<Accordion title="Explanation">

First, test file sends a transaction invoking the `update` instruction, passing
"Hello, Solana!" as the new message.

```ts title="anchor.test.ts"
const message = "Hello, Solana!";
const transactionSignature = await program.methods
  .update(message)
  .accounts({
    messageAccount: messagePda
  })
  .rpc({ commitment: "confirmed" });
```

After sending the transaction and updating the account, the test file fetches
the account using its address (`messagePda`).

```ts title="anchor.test.ts"
const messageAccount = await program.account.messageAccount.fetch(
  messagePda,
  "confirmed"
);
```

Lastly, the test file logs the account data and a link to the transaction
details.

```ts title="anchor.test.ts"
console.log(JSON.stringify(messageAccount, null, 2));
console.log(
  "Transaction Signature:",
  `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
);
```

</Accordion>
</Accordions>

</Step>
<Step>

### Invoke Delete Instruction

<WithNotes>

Update the third test with the following:

```ts title="anchor.test.ts"
it("Delete Message Account", async () => {
  const transactionSignature = await program.methods
    // !tooltip[/delete/] delete
    .delete()
    // !tooltip[/accounts/] accounts
    .accounts({
      messageAccount: messagePda
    })
    // !tooltip[/rpc/] rpc
    .rpc({ commitment: "confirmed" });

  // !tooltip[/fetchNullable/] fetchNullable
  const messageAccount = await program.account.messageAccount.fetchNullable(
    messagePda,
    "confirmed"
  );

  console.log("Expect Null:", JSON.stringify(messageAccount, null, 2));
  console.log(
    "Transaction Signature:",
    `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
  );
});
```

### !delete

The *ts`delete()`* method invokes the `delete` instruction.

### !accounts

The *ts`accounts()`* method specifies the accounts required for the
*ts`delete()`* instruction.

### !rpc

The *ts`rpc()`* method sends the transaction to the network.

### !fetchNullable

The *ts`fetchNullable()`* method retrieves account data from the network that
might not exist.

The test file uses this because the account closes and the data becomes
unavailable.

</WithNotes>

<Accordions>
<Accordion title="Diff">

```diff
- it("Delete Message Account", async () => {});

+ it("Delete Message Account", async () => {
+   const transactionSignature = await program.methods
+     .delete()
+     .accounts({
+       messageAccount: messagePda,
+     })
+     .rpc({ commitment: "confirmed" });
+
+   const messageAccount = await program.account.messageAccount.fetchNullable(
+     messagePda,
+     "confirmed"
+   );
+
+   console.log("Expect Null:", JSON.stringify(messageAccount, null, 2));
+   console.log(
+     "Transaction Signature:",
+     `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
+   );
+ });
```

</Accordion>
<Accordion title="Explanation">

First, this code sends a transaction invoking the `delete` instruction to close
the message account.

```ts title="anchor.test.ts"
const transactionSignature = await program.methods
  .delete()
  .accounts({
    messageAccount: messagePda
  })
  .rpc({ commitment: "confirmed" });
```

After sending the transaction and closing the account, the example tries to
fetch the account using its address (`messagePda`) with `fetchNullable`. This
method returns null when the account no longer exists after closing.

```ts title="anchor.test.ts"
const messageAccount = await program.account.messageAccount.fetchNullable(
  messagePda,
  "confirmed"
);
```

Finally, the test file logs the account data and a link to the transaction
details. The account data shows as null since the account no longer exists.

```ts title="anchor.test.ts"
console.log(JSON.stringify(messageAccount, null, 2));
console.log(
  "Transaction Signature:",
  `https://solana.fm/tx/${transactionSignature}?cluster=devnet-solana`
);
```

</Accordion>
</Accordions>

</Step>
<Step>

### Run Test

After preparing your tests, run the test file with *shell`test`* in the
Playground terminal. This command runs the tests against the program deployed on
the devnet and logs links to SolanaFM to view the transaction details.

```terminal
$ test
Running tests...
  anchor.test.ts:
  pda
    {
  "user": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
  "message": "Hello, World!",
  "bump": 254
}
    Transaction Signature: https://solana.fm/tx/5oBT4jEdUR6CRYsFNGoqvyMBTRDvFqRWTAAmCGM9rEvYRBWy3B2bkb6GVFpVPKBnkr714UCFUurBSDKSa7nLHo8e?cluster=devnet-solana
    ✔ Create Message Account (1025ms)
    {
  "user": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
  "message": "Hello, Solana!",
  "bump": 254
}
    Transaction Signature: https://solana.fm/tx/42veGAsQjHbJP1SxWBGcfYF7EdRN9X7bACNv23NSZNe4U7w2dmaYgSv8UUWXYzwgJPoNHejhtWdKZModHiMaTWYK?cluster=devnet-solana
    ✔ Update Message Account (713ms)
    Expect Null: null
    Transaction Signature: https://solana.fm/tx/Sseog2i2X7uDEn2DyDMMJKVHeZEzmuhnqUwicwGhnGhstZo8URNwUZgED8o6HANiojJkfQbhXVbGNLdhsFtWrd6?cluster=devnet-solana
    ✔ Delete Message Account (812ms)
  3 passing (3s)
```

Inspect the SolanaFM links to view the transaction details.

<Callout type="info">
  Note that in this example, if you run the test again, the `create` instruction
  fails because `messageAccount` already exists as an account. Only one account
  can exist for a given PDA.
</Callout>

</Step>
</Steps>
