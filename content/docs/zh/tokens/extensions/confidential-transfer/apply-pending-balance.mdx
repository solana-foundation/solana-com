---
title: 应用待处理余额
description: 了解如何应用待处理余额使资金可用。
---

## 如何将待处理余额应用到可用余额

在代币可以进行保密转账之前，公开代币余额必须转换为保密余额。这种转换分为两个阶段：

1. **保密待处理余额**：最初，代币从公开余额"存入"到"待处理"的保密余额中。
2. **保密可用余额**：然后将待处理余额"应用"到可用余额，使代币可用于保密转账。

本节解释第二阶段：将待处理余额应用到可用余额。

当代币从公开余额"存入"或者当代币从一个代币账户保密转账到另一个账户时，这些代币最初会添加到保密待处理余额中。在代币可以用于保密转账之前，待处理余额必须"应用"到可用余额。

```mermaid title="Apply Pending Balance"
sequenceDiagram

participant A as Sender Wallet
participant AA as Sender Token Account
participant CC as Sender Token Account
participant BB as Receiver Token Account
participant B as Receiver Wallet
note over A,AA: Deposit Operation
note over B,CC: Transfer Operation

A->>AA: Deposit
A->>AA: Apply

CC->>BB: Transfer
B->>BB: Apply
```

下图显示了将待处理余额应用到可用余额所涉及的步骤：

```mermaid title="Apply Pending Balance"
sequenceDiagram
    participant Owner as Wallet
    participant Token22 as Token Extensions Program
    participant TokenAccount as Token Account

    Note over TokenAccount: Tokens in pending confidential balance<br>after deposit or transfer

 Owner->>Owner: Use encryption keys (ElGamal & AES)<br>for decryption and encryption

    Owner->>Token22: confidential_transfer_apply_pending_balance()
    activate Token22
    Token22-->>TokenAccount: Reset pending balance
    Token22-->>TokenAccount: Add to available balance
    deactivate Token22

    Note over TokenAccount: Tokens now in available confidential balance<br>ready for confidential transfers
```

### 必要指令

要将待处理余额转换为可用余额，请调用
[ConfidentialTransferInstruction::ApplyPendingBalance](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/extension/confidential_transfer/processor.rs#L1152)
指令。

`spl_token_client` crate提供了 `confidential_transfer_apply_pending_balance`
方法，用于构建并发送包含 `ApplyPendingBalance` 指令的交易，如下面的示例所示。

### 示例代码

以下示例演示了如何将机密待处理余额应用到机密可用余额。

要运行此示例，请使用以下命令启动一个从主网克隆了Token Extension
Program的本地验证节点。您必须安装Solana CLI才能启动本地验证节点。

```terminal
$ solana-test-validator --clone-upgradeable-program TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb --url https://api.mainnet-beta.solana.com -r
```

<Callout type="info">
  在撰写本文时，默认的本地验证节点上尚未启用机密转账功能。您必须克隆主网上的Token
  Extension Program才能运行示例代码。
</Callout>

<CodeTabs flags="r">
  ```rust !! title="main.rs"
  use anyhow::{Context, Result};
  use solana_client::nonblocking::rpc_client::RpcClient;
  use solana_sdk::{
      commitment_config::CommitmentConfig,
      signature::{Keypair, Signer},
      transaction::Transaction,
  };
  use spl_associated_token_account::{
      get_associated_token_address_with_program_id, instruction::create_associated_token_account,
  };
  use spl_token_client::{
      client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
      spl_token_2022::{
          extension::{
              confidential_transfer::instruction::{configure_account, PubkeyValidityProofData},
              ExtensionType,
          },
          id as token_2022_program_id,
          instruction::reallocate,
          solana_zk_sdk::encryption::{auth_encryption::*, elgamal::*},
      },
      token::{ExtensionInitializationParams, Token},
  };
  use spl_token_confidential_transfer_proof_extraction::instruction::{ProofData, ProofLocation};
  use std::sync::Arc;

  #[tokio::main] async fn main() -> Result<()> { // 创建连接到本地测试验证节点 let
  rpc_client = Arc::new(RpcClient::new_with_commitment(
  String::from("http://localhost:8899"), CommitmentConfig::confirmed(), ));

      // 加载默认的Solana CLI密钥对作为费用支付者
      // 这将是支付交易费用的钱包
      // 使用Arc防止密钥对被多次克隆
      let payer = Arc::new(load_keypair()?);
      println!("Using payer: {}", payer.pubkey());

      // 生成一个新的密钥对作为代币铸造地址
      let mint = Keypair::new();
      println!("Mint keypair generated: {}", mint.pubkey());

      // 为Token客户端设置程序客户端
      let program_client = ProgramRpcClient::new(rpc_client.clone(), ProgramRpcClientSendTransaction);

      // 铸造的小数位数
      let decimals = 9;

      // 为Token-2022程序创建一个代币客户端
      // 这提供了代币操作的高级方法
      let token = Token::new(
          Arc::new(program_client),
          &token_2022_program_id(), // 使用Token-2022程序（带扩展的新版本）
          &mint.pubkey(),           // 新代币铸造的地址
          Some(decimals),           // 小数位数
          payer.clone(),            // 交易费用支付者
      );

      // 为铸造创建扩展初始化参数
      // ConfidentialTransferMint扩展启用代币的机密（私密）转账
      let extension_initialization_params =
          vec![ExtensionInitializationParams::ConfidentialTransferMint {
              authority: Some(payer.pubkey()), // 可以修改机密转账设置的权限
              auto_approve_new_accounts: true, // 自动批准新的机密账户
              auditor_elgamal_pubkey: None,    // 可选的审计员ElGamal公钥
          }];

      // 创建并初始化带有ConfidentialTransferMint扩展的铸造
      // 这会发送一个交易来创建新的代币铸造
      let transaction_signature = token
          .create_mint(
              &payer.pubkey(),                 // 铸造权限 - 可以铸造新代币
              Some(&payer.pubkey()),           // 冻结权限 - 可以冻结代币账户
              extension_initialization_params, // 添加ConfidentialTransferMint扩展
              &[&mint],                        // 需要铸造密钥对作为签名者
          )
          .await?;

      // 打印结果供用户验证
      println!("Mint Address: {}", mint.pubkey());
      println!(
          "Mint Creation Transaction Signature: {}",
          transaction_signature
      );

      // ===== 创建并配置用于机密转账的代币账户 =====
      println!("\nCreate and configure token account for confidential transfers");

      // 获取所有者的关联代币账户地址
      let token_account_pubkey = get_associated_token_address_with_program_id(
          &payer.pubkey(),          // 代币账户所有者
          &mint.pubkey(),           // 铸造
          &token_2022_program_id(), // 代币程序ID
      );
      println!("Token Account Address: {}", token_account_pubkey);

      // 步骤1：创建关联代币账户
      let create_associated_token_account_instruction = create_associated_token_account(
          &payer.pubkey(),          // 资金账户
          &payer.pubkey(),          // 代币账户所有者
          &mint.pubkey(),           // 铸造
          &token_2022_program_id(), // 代币程序ID
      );

      // 步骤2：重新分配代币账户空间以包含ConfidentialTransferAccount扩展
      let reallocate_instruction = reallocate(
          &token_2022_program_id(),                      // 代币程序ID
          &token_account_pubkey,                         // 代币账户
          &payer.pubkey(),                               // 支付者
          &payer.pubkey(),                               // 代币账户所有者
          &[&payer.pubkey()],                            // 签名者
          &[ExtensionType::ConfidentialTransferAccount], // 需要重新分配空间的扩展
      )?;

      // 步骤3：为代币账户生成ElGamal密钥对和AES密钥
      let elgamal_keypair = ElGamalKeypair::new_from_signer(&payer, &token_account_pubkey.to_bytes())
          .expect("Failed to create ElGamal keypair");
      let aes_key = AeKey::new_from_signer(&payer, &token_account_pubkey.to_bytes())
          .expect("Failed to create AES key");

      // 在执行ApplyPendingBalance指令之前，可以为pending_balance增加信用的
      // Deposit和Transfer指令的最大数量
      let maximum_pending_balance_credit_counter = 65536;

      // 初始代币余额为0
      let decryptable_balance = aes_key.encrypt(0);

      // 在客户端生成证明数据
      let proof_data = PubkeyValidityProofData::new(&elgamal_keypair)
          .map_err(|_| anyhow::anyhow!("Failed to generate proof data"))?;

      // 指示证明包含在同一交易中
      let proof_location =
          ProofLocation::InstructionOffset(1.try_into()?, ProofData::InstructionData(&proof_data));

      // 步骤4：创建配置账户用于机密转账的指令
      let configure_account_instructions = configure_account(
          &token_2022_program_id(),               // 程序ID
          &token_account_pubkey,                  // 代币账户
          &mint.pubkey(),                         // 铸造
          &decryptable_balance.into(),            // 初始余额
          maximum_pending_balance_credit_counter, // 最大待处理余额信用计数器
          &payer.pubkey(),                        // 代币账户所有者
          &[],                                    // 额外签名者
          proof_location,                         // 证明位置
      )?;

      // 合并所有指令
      let mut instructions = vec![
          create_associated_token_account_instruction,
          reallocate_instruction,
      ];
      instructions.extend(configure_account_instructions);

      // 创建并发送交易
      let recent_blockhash = rpc_client.get_latest_blockhash().await?;
      let transaction = Transaction::new_signed_with_payer(
          &instructions,
          Some(&payer.pubkey()),
          &[&payer],
          recent_blockhash,
      );

      let transaction_signature = rpc_client
          .send_and_confirm_transaction(&transaction)
          .await?;
      println!(
          "Create Token Account Transaction Signature: {}",
          transaction_signature
      );

      // 向新创建的代币账户铸造一些代币
      // 这给账户提供了一些可以使用的代币
      let mint_signature = token
          .mint_to(
              &token_account_pubkey,            // 目标账户
              &payer.pubkey(),                  // 铸造权限
              100 * 10u64.pow(decimals as u32), // 数量（100个代币，带小数精度）
              &[&payer],                        // 签名者
          )
          .await?;

      println!("Mint Tokens Transaction Signature: {}", mint_signature);

      // 将代币存入机密状态
      // 这将常规代币转换为机密代币
      println!("Deposit tokens to confidential state pending balance");
      let deposit_signature = token
          .confidential_transfer_deposit(
              &token_account_pubkey,            // 代币账户
              &payer.pubkey(),                  // 账户的权限（所有者）
              100 * 10u64.pow(decimals as u32), // 存入金额（100个代币）
              decimals,                         // 代币的小数位数
              &[&payer],                        // 签名者（所有者必须签名）
          )
          .await?;

      println!(
          "Confidential Transfer Deposit Signature: {}",
          deposit_signature
      );

      // 应用待处理余额使资金可用
      println!("Apply pending balance to available balance");
      let apply_signature = token
          .confidential_transfer_apply_pending_balance(
              &token_account_pubkey,    // 代币账户
              &payer.pubkey(),          // 账户的权限（所有者）
              None,                     // 可选的新可解密可用余额
              elgamal_keypair.secret(), // ElGamal密钥对用于公钥加密（解密和零知识证明）
              &aes_key,                 // AES密钥用于余额和转账金额的加密
              &[&payer],                // 签名者（所有者必须签名）
          )
          .await?;

      println!("Apply Pending Balance Signature: {}", apply_signature);

      println!("Confidential transfer setup complete. Tokens are now in available balance.");
      println!(
          "Associated Token Account with confidential transfers: {}",
          token_account_pubkey
      );

      Ok(())

  }

  // 从默认的Solana
  CLI密钥对路径（~/.config/solana/id.json）加载密钥对 // 这使得可以使用与Solana
  CLI工具相同的钱包fn load_keypair() -> Result<Keypair> {
  // 获取默认密钥对路径 let keypair_path = dirs::home_dir() .context("Could not
  find home directory")? .join(".config/solana/id.json");

      // 使用serde_json直接将密钥对文件读入字节
      // 密钥对文件是一个字节的JSON数组
      let file = std::fs::File::open(&keypair_path)?;
      let keypair_bytes: Vec<u8> = serde_json::from_reader(file)?;

      // 从加载的字节创建密钥对
      // 这将字节数组转换为密钥对
      let keypair = Keypair::from_bytes(&keypair_bytes)?;

      Ok(keypair)

  }

  ```

  ```toml !! title="Cargo.toml"
  [package]
  name = "confidential-transfer"
  version = "0.1.0"
  edition = "2021"

  [dependencies]
  solana-client = "2.2.2"
  solana-sdk = "2.2.2"
  spl-associated-token-account = "6.0.0"
  spl-token-client = "0.14.0"
  spl-token-confidential-transfer-proof-extraction = "0.2.1"
  spl-token-confidential-transfer-proof-generation = "0.3.0"

  anyhow = "1.0.95"
  dirs = "6.0.0"
  serde_json = "1.0.135"
  tokio = { version = "1.44.2", features = ["full"] }
  ```
</CodeTabs>
