---
title: Programmstruktur
description:
  Erfahren Sie, wie Sie Solana-Programme in Rust strukturieren, einschließlich
  Einstiegspunkten, Zustandsverwaltung, Anweisungsverarbeitung und Tests.
h1: Rust-Programmstruktur
---

Solana-Programme, die in Rust geschrieben sind, haben minimale strukturelle
Anforderungen und bieten Flexibilität bei der Organisation des Codes. Die
einzige Anforderung ist, dass ein Programm einen `entrypoint` haben muss, der
definiert, wo die Ausführung eines Programms beginnt.

## Programmstruktur

Obwohl es keine strengen Regeln für die Dateistruktur gibt, folgen
Solana-Programme typischerweise einem gemeinsamen Muster:

- `entrypoint.rs`: Definiert den Einstiegspunkt, der eingehende Anweisungen
  weiterleitet.
- `state.rs`: Definieren programmspezifischen Zustand (Kontendaten).
- `instructions.rs`: Definiert die Anweisungen, die das Programm ausführen kann.
- `processor.rs`: Definiert die Anweisungshandler (Funktionen), die die
  Geschäftslogik für jede Anweisung implementieren.
- `error.rs`: Definiert benutzerdefinierte Fehler, die das Programm zurückgeben
  kann.

Beispiele finden Sie in der
[Solana Program Library](https://github.com/solana-program/token/tree/main/program/src).

## Beispielprogramm

Um zu demonstrieren, wie man ein natives Rust-Programm mit mehreren Anweisungen
erstellt, werden wir ein einfaches Zählerprogramm durchgehen, das zwei
Anweisungen implementiert:

1. `InitializeCounter`: Erstellt und initialisiert ein neues Konto mit einem
   Anfangswert.
2. `IncrementCounter`: Erhöht den in einem bestehenden Konto gespeicherten Wert.

Der Einfachheit halber wird das Programm in einer einzigen `lib.rs`-Datei
implementiert, obwohl Sie in der Praxis größere Programme möglicherweise auf
mehrere Dateien aufteilen möchten.

<Accordions>
<Accordion title="Vollständiger Programmcode">

```rs title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

// Program entrypoint
entrypoint!(process_instruction);

// Function to route instructions to the correct handler
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Unpack instruction data
    let instruction = CounterInstruction::unpack(instruction_data)?;

    // Match instruction type
    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => process_increment_counter(program_id, accounts)?,
    };
    Ok(())
}

// Instructions that our program can execute
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 }, // variant 0
    IncrementCounter,                         // variant 1
}

impl CounterInstruction {
    pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        // Get the instruction variant from the first byte
        let (&variant, rest) = input
            .split_first()
            .ok_or(ProgramError::InvalidInstructionData)?;

        // Match instruction type and parse the remaining bytes based on the variant
        match variant {
            0 => {
                // For InitializeCounter, parse a u64 from the remaining bytes
                let initial_value = u64::from_le_bytes(
                    rest.try_into()
                        .map_err(|_| ProgramError::InvalidInstructionData)?,
                );
                Ok(Self::InitializeCounter { initial_value })
            }
            1 => Ok(Self::IncrementCounter), // No additional data needed
            _ => Err(ProgramError::InvalidInstructionData),
        }
    }
}

// Initialize a new counter account
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // Size in bytes to store a u64

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for the new account
            counter_account.key,  // Account to be created
            required_lamports,    // Amount of lamports to transfer to the new account
            account_space as u64, // Size in bytes to allocate for the data field
            program_id,           // Set program owner to our program
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Create a new CounterAccount struct with the initial value
    let counter_data = CounterAccount {
        count: initial_value,
    };

    // Get a mutable reference to the counter account's data
    let mut account_data = &mut counter_account.data.borrow_mut()[..];

    // Serialize the CounterAccount struct into the account's data
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}

// Update an existing counter's value
fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify account ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Mutable borrow the account data
    let mut data = counter_account.data.borrow_mut();

    // Deserialize the account data into our CounterAccount struct
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    // Increment the counter value
    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    // Serialize the updated counter data back into the account
    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);
    Ok(())
}

// Struct representing our counter account's data
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    count: u64,
}

#[cfg(test)]
mod test {
    use super::*;
    use solana_program_test::*;
    use solana_sdk::{
        instruction::{AccountMeta, Instruction},
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[tokio::test]
    async fn test_counter_program() {
        let program_id = Pubkey::new_unique();
        let (mut banks_client, payer, recent_blockhash) = ProgramTest::new(
            "counter_program",
            program_id,
            processor!(process_instruction),
        )
        .start()
        .await;

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Create initialization instruction
        let mut init_instruction_data = vec![0]; // 0 = initialize instruction
        init_instruction_data.extend_from_slice(&initial_value.to_le_bytes());

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Send transaction with initialize instruction
        let mut transaction =
            Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 42);
            println!(
                "✅ Counter initialized successfully with value: {}",
                counter.count
            );
        }

        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Create increment instruction
        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &[1], // 1 = increment instruction
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Send transaction with increment instruction
        let mut transaction =
            Transaction::new_with_payer(&[increment_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 43);
            println!("✅ Counter incremented successfully to: {}", counter.count);
        }
    }
}
```

```toml title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
borsh = "1.5.1"
solana-program = "1.18.26"

[dev-dependencies]
solana-program-test = "1.18.26"
solana-sdk = "1.18.26"
tokio = "1.41.0"
```

</Accordion>
</Accordions>

<Steps>
<Step>

### Ein neues Programm erstellen

Erstellen Sie zunächst ein neues Rust-Projekt mit dem Standard
`cargo init`-Befehl und der `--lib`-Flag.

```shell title="Terminal"
cargo init counter_program --lib
```

Navigieren Sie zum Projektverzeichnis. Sie sollten die Standard `src/lib.rs` und
`Cargo.toml` Dateien sehen

```shell title="Terminal"
cd counter_program
```

Füge als Nächstes die `solana-program` Abhängigkeit hinzu. Dies ist die minimale
Abhängigkeit, die zum Erstellen eines Solana-Programms erforderlich ist.

```shell title="Terminal"
cargo add solana-program@1.18.26
```

Füge als Nächstes den folgenden Ausschnitt zu `Cargo.toml` hinzu. Wenn du diese
Konfiguration nicht einschließt, wird das `target/deploy` Verzeichnis beim
Erstellen des Programms nicht generiert.

```toml title="Cargo.toml"
[lib]
crate-type = ["cdylib", "lib"]
```

Deine `Cargo.toml` Datei sollte wie folgt aussehen:

```toml title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
solana-program = "1.18.26"
```

</Step>
<Step>

### Programm-Einstiegspunkt

Ein Solana-Programm-Einstiegspunkt ist die Funktion, die aufgerufen wird, wenn
ein Programm ausgeführt wird. Der Einstiegspunkt hat die folgende grundlegende
Definition, und Entwickler können ihre eigene Implementierung der
Einstiegspunktfunktion erstellen.

Der Einfachheit halber verwende das
[`entrypoint!`](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/entrypoint.rs#L124-L140)
Makro aus dem `solana_program` Crate, um den Einstiegspunkt in deinem Programm
zu definieren.

```rs
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64;
```

Ersetze den Standardcode in `lib.rs` durch den folgenden Code. Dieser
Ausschnitt:

1. Importiert die erforderlichen Abhängigkeiten aus `solana_program`
2. Definiert den Programm-Einstiegspunkt mit dem `entrypoint!` Makro
3. Implementiert die `process_instruction` Funktion, die Anweisungen an die
   entsprechenden Handler-Funktionen weiterleitet

```rs title="lib.rs" {13} /process_instruction/
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Your program logic
    Ok(())
}
```

Das `entrypoint!` Makro erfordert eine Funktion mit der folgenden
[Typsignatur](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/entrypoint.rs#L28-L29)
als Argument:

```rs
pub type ProcessInstruction =
    fn(program_id: &Pubkey, accounts: &[AccountInfo], instruction_data: &[u8]) -> ProgramResult;
```

Wenn ein Solana-Programm aufgerufen wird,
[deserialisiert](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/entrypoint.rs#L277)
der Einstiegspunkt die
[Eingabedaten](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/entrypoint.rs#L129-L131)
(bereitgestellt als Bytes) in drei Werte und übergibt sie an die
[`process_instruction`](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/entrypoint.rs#L132)
Funktion:

- `program_id`: Der öffentliche Schlüssel des aufgerufenen Programms (aktuelles
  Programm)
- `accounts`: Die `AccountInfo` für Konten, die von der aufgerufenen Anweisung
  benötigt werden
- `instruction_data`: Zusätzliche Daten, die an das Programm übergeben werden
  und die auszuführende Anweisung sowie ihre erforderlichen Argumente angeben

Diese drei Parameter entsprechen direkt den Daten, die Clients bereitstellen
müssen, wenn sie eine Anweisung zum Aufrufen eines Programms erstellen.

</Step>
<Step>

### Programm-Status definieren

Beim Erstellen eines Solana-Programms beginnt man typischerweise mit der
Definition des Programm-Status - den Daten, die in Konten gespeichert werden,
die von deinem Programm erstellt und verwaltet werden.

Der Programm-Status wird mit Rust-Strukturen definiert, die das Datenlayout der
Konten deines Programms repräsentieren. Du kannst mehrere Strukturen definieren,
um verschiedene Arten von Konten für dein Programm darzustellen.

Bei der Arbeit mit Konten benötigst du eine Möglichkeit, die Datentypen deines
Programms in die rohen Bytes umzuwandeln, die im Datenfeld eines Kontos
gespeichert werden, und umgekehrt:

- Serialisierung: Umwandlung deiner Datentypen in Bytes zur Speicherung im
  Datenfeld eines Kontos
- Deserialisierung: Umwandlung der in einem Konto gespeicherten Bytes zurück in
  deine Datentypen

Obwohl du jedes Serialisierungsformat für die Solana-Programmentwicklung
verwenden kannst, wird [Borsh](https://borsh.io/) häufig verwendet. Um Borsh in
deinem Solana-Programm zu verwenden:

1. Füge die `borsh` Crate als Abhängigkeit zu deiner `Cargo.toml` hinzu:

```shell title="Terminal"
cargo add borsh
```

2. Importiere die Borsh-Traits und verwende das Derive-Makro, um die Traits für
   deine Strukturen zu implementieren:

```rust
use borsh::{BorshSerialize, BorshDeserialize};

// Define struct representing our counter account's data
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    count: u64,
}
```

Füge die `CounterAccount` Struktur zu `lib.rs` hinzu, um den Programm-Status zu
definieren. Diese Struktur wird sowohl in den Initialisierungs- als auch in den
Inkrement-Anweisungen verwendet.

```rs title="lib.rs" {12} {25-29}
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};
use borsh::{BorshSerialize, BorshDeserialize};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Your program logic
    Ok(())
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    count: u64,
}
```

</Step>
<Step>

### Anweisungen definieren

Anweisungen beziehen sich auf die verschiedenen Operationen, die dein
Solana-Programm ausführen kann. Betrachte sie als öffentliche APIs für dein
Programm - sie definieren, welche Aktionen Benutzer ausführen können, wenn sie
mit deinem Programm interagieren.

Anweisungen werden typischerweise mit einem Rust-Enum definiert, wobei:

- Jede Enum-Variante eine andere Anweisung repräsentiert
- Die Nutzlast der Variante die Parameter der Anweisung darstellt

Beachte, dass Rust-Enum-Varianten implizit beginnend mit 0 nummeriert werden.

Hier ist ein Beispiel für ein Enum, das zwei Anweisungen definiert:

```rust
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 }, // variant 0
    IncrementCounter,                         // variant 1
}
```

Wenn ein Client dein Programm aufruft, muss er instruction data (als
Byte-Puffer) bereitstellen, wobei:

- Das erste Byte identifiziert, welche Anweisungsvariante ausgeführt werden soll
  (0, 1, usw.)
- Die verbleibenden Bytes enthalten die serialisierten Anweisungsparameter
  (falls erforderlich)

Um die instruction data (Bytes) in eine Variante des Enums umzuwandeln, ist es
üblich, eine Hilfsmethode zu implementieren. Diese Methode:

1. Trennt das erste Byte ab, um die Anweisungsvariante zu erhalten
2. Prüft die Variante und analysiert alle zusätzlichen Parameter aus den
   verbleibenden Bytes
3. Gibt die entsprechende Enum-Variante zurück

Zum Beispiel die `unpack` Methode für das `CounterInstruction` Enum:

```rust
impl CounterInstruction {
    pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        // Get the instruction variant from the first byte
        let (&variant, rest) = input
            .split_first()
            .ok_or(ProgramError::InvalidInstructionData)?;

        // Match instruction type and parse the remaining bytes based on the variant
        match variant {
            0 => {
                // For InitializeCounter, parse a u64 from the remaining bytes
                let initial_value = u64::from_le_bytes(
                    rest.try_into()
                        .map_err(|_| ProgramError::InvalidInstructionData)?
                );
                Ok(Self::InitializeCounter { initial_value })
            }
            1 => Ok(Self::IncrementCounter), // No additional data needed
            _ => Err(ProgramError::InvalidInstructionData),
        }
    }
}
```

Füge den folgenden Code zu `lib.rs` hinzu, um die Anweisungen für das
Counter-Programm zu definieren.

```rs title="lib.rs" {18-46}
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::AccountInfo, entrypoint, entrypoint::ProgramResult, msg,
    program_error::ProgramError, pubkey::Pubkey,
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Your program logic
    Ok(())
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 }, // variant 0
    IncrementCounter,                         // variant 1
}

impl CounterInstruction {
    pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        // Get the instruction variant from the first byte
        let (&variant, rest) = input
            .split_first()
            .ok_or(ProgramError::InvalidInstructionData)?;

        // Match instruction type and parse the remaining bytes based on the variant
        match variant {
            0 => {
                // For InitializeCounter, parse a u64 from the remaining bytes
                let initial_value = u64::from_le_bytes(
                    rest.try_into()
                        .map_err(|_| ProgramError::InvalidInstructionData)?,
                );
                Ok(Self::InitializeCounter { initial_value })
            }
            1 => Ok(Self::IncrementCounter), // No additional data needed
            _ => Err(ProgramError::InvalidInstructionData),
        }
    }
}
```

</Step>
<Step>

### Anweisungshandler

Anweisungshandler beziehen sich auf die Funktionen, die die Geschäftslogik für
jede Anweisung enthalten. Es ist üblich, Handler-Funktionen als
`process_<instruction_name>` zu benennen, aber du kannst jede beliebige
Namenskonvention wählen.

Füge den folgenden Code zu `lib.rs` hinzu. Dieser Code verwendet das
`CounterInstruction` Enum und die `unpack` Methode, die im vorherigen Schritt
definiert wurden, um eingehende Anweisungen an die entsprechenden
Handler-Funktionen weiterzuleiten:

```rs title="lib.rs" {8-17} {20-32} /process_initialize_counter/1 /process_increment_counter/1
entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Unpack instruction data
    let instruction = CounterInstruction::unpack(instruction_data)?;

    // Match instruction type
    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => process_increment_counter(program_id, accounts)?,
    };
}

fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    // Implementation details...
    Ok(())
}

fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    // Implementation details...
    Ok(())
}
```

Als Nächstes füge die Implementierung der `process_initialize_counter` Funktion
hinzu. Dieser Anweisungshandler:

1. Erstellt ein neues Konto und weist Speicherplatz für die Counter-Daten zu
2. Initialisiert die Kontodaten mit `initial_value`, das an die Anweisung
   übergeben wurde

<Accordions>
<Accordion title="Erklärung">

Die `process_initialize_counter` Funktion benötigt drei Konten:

1. Das Counter-Konto, das erstellt und initialisiert wird
2. Das Zahler-Konto, das die Erstellung des neuen Kontos finanziert
3. Das System-Programm, das wir aufrufen, um das neue Konto zu erstellen

Um die für die Anweisung erforderlichen Konten zu definieren, erstellen wir
einen Iterator über das `accounts` Slice und verwenden die `next_account_info`
Funktion, um jedes Konto zu erhalten. Die Anzahl der definierten Konten sind die
von der Anweisung benötigten Konten.

Die Reihenfolge der Konten ist wichtig - beim Erstellen der Anweisung auf der
Client-Seite müssen die Konten in derselben Reihenfolge angegeben werden, wie
sie im Programm definiert sind, damit die Anweisung erfolgreich ausgeführt
werden kann.

Obwohl die Variablennamen für die Konten keine Auswirkung auf die Funktionalität
des Programms haben, wird die Verwendung beschreibender Namen empfohlen.

```rs title="lib.rs" {6-10}
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    Ok(())
}
```

Bevor wir ein Konto erstellen, müssen wir:

1. Den Speicherplatz (in Bytes) angeben, der dem Datenfeld des Kontos zugewiesen
   werden soll. Da wir einen u64-Wert (`count`) speichern, benötigen wir 8
   Bytes.

2. Den erforderlichen Mindestbetrag an "rent" berechnen. Auf Solana müssen
   Konten ein Mindestguthaben an Lamports (rent) basierend auf der Menge der im
   Konto gespeicherten Daten aufrechterhalten.

```rs title="lib.rs" {12-17}
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // Size in bytes to store a u64

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    Ok(())
}
```

Sobald der Speicherplatz definiert und die rent berechnet ist, erstellen Sie das
Konto durch Aufrufen der `create_account` Anweisung des System-Programms.

Auf Solana können neue Konten nur vom System-Programm erstellt werden. Bei der
Erstellung eines Kontos geben wir die Anzahl der zu reservierenden Bytes und den
Programmeigentümer des neuen Kontos an. Das System-Programm:

1. Erstellt das neue Konto
2. Weist den angegebenen Speicherplatz für das Datenfeld des Kontos zu
3. Überträgt die Eigentümerschaft an das angegebene Programm

Diese Eigentumsübertragung ist wichtig, da nur der Programmeigentümer eines
Kontos die Daten des Kontos ändern kann. In diesem Fall setzen wir unser
Programm als Eigentümer, was uns ermöglicht, die Daten des Kontos zu ändern, um
den Zählerwert zu speichern.

Um das System Program aus der Anweisung unseres Programms aufzurufen, führen wir
eine Cross Program Invocation (CPI) über die `invoke` Funktion durch. Eine CPI
ermöglicht es einem Programm, Anweisungen auf anderen Programmen aufzurufen - in
diesem Fall die `create_account` Anweisung des System Programs.

```rs title="lib.rs" {19-33}
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // Size in bytes to store a u64

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for the new account
            counter_account.key,  // Account to be created
            required_lamports,    // Amount of lamports to transfer to the new account
            account_space as u64, // Size in bytes to allocate for the data field
            program_id,           // Set program owner to our program
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    Ok(())
}
```

Sobald das Konto erstellt ist, initialisieren wir die Kontodaten durch:

1. Erstellen einer neuen `CounterAccount` Struktur mit dem `initial_value`, das
   der Anweisung bereitgestellt wurde.
2. Abrufen einer veränderbaren Referenz auf das Datenfeld des neuen Kontos.
3. Serialisieren der `CounterAccount` Struktur in das Datenfeld des Kontos,
   wodurch der `initial_value` effektiv im Konto gespeichert wird.

```rs title="lib.rs" {35-44} /initial_value/
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // Size in bytes to store a u64

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for the new account
            counter_account.key,  // Account to be created
            required_lamports,    // Amount of lamports to transfer to the new account
            account_space as u64, // Size in bytes to allocate for the data field
            program_id,           // Set program owner to our program
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Create a new CounterAccount struct with the initial value
    let counter_data = CounterAccount {
        count: initial_value,
    };

    // Get a mutable reference to the counter account's data
    let mut account_data = &mut counter_account.data.borrow_mut()[..];

    // Serialize the CounterAccount struct into the account's data
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}
```

</Accordion>
</Accordions>

```rs title="lib.rs"
// Initialize a new counter account
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // Size in bytes to store a u64

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for the new account
            counter_account.key,  // Account to be created
            required_lamports,    // Amount of lamports to transfer to the new account
            account_space as u64, // Size in bytes to allocate for the data field
            program_id,           // Set program owner to our program
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Create a new CounterAccount struct with the initial value
    let counter_data = CounterAccount {
        count: initial_value,
    };

    // Get a mutable reference to the counter account's data
    let mut account_data = &mut counter_account.data.borrow_mut()[..];

    // Serialize the CounterAccount struct into the account's data
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}
```

Als nächstes fügen wir die Implementierung der `process_increment_counter`
Funktion hinzu. Diese Anweisung erhöht den Wert eines bestehenden Zählerkontos.

<Accordions>
<Accordion title="Erklärung">

Genau wie bei der `process_initialize_counter` Funktion beginnen wir mit der
Erstellung eines Iterators über die Konten. In diesem Fall erwarten wir nur ein
Konto, welches das zu aktualisierende Konto ist.

Beachten Sie, dass ein Entwickler in der Praxis verschiedene
Sicherheitsprüfungen implementieren muss, um die an das Programm übergebenen
Konten zu validieren. Da alle Konten vom Aufrufer der Anweisung bereitgestellt
werden, gibt es keine Garantie, dass die bereitgestellten Konten diejenigen
sind, die das Programm erwartet. Fehlende Kontovalidierungsprüfungen sind eine
häufige Quelle für Programmvulnerabilitäten.

Das folgende Beispiel enthält eine Prüfung, um sicherzustellen, dass das Konto,
das wir als `counter_account` bezeichnen, dem ausführenden Programm gehört.

```rs title="lib.rs" {6-9}
// Update an existing counter's value
fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify account ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    Ok(())
}
```

Um die Kontodaten zu aktualisieren:

- Leihen wir uns veränderbar das Datenfeld des bestehenden Kontos aus
- Deserialisieren die Rohbytes in unsere `CounterAccount` Struktur
- Aktualisieren den `count` Wert
- Serialisieren die modifizierte Struktur zurück in das Datenfeld des Kontos

```rs title="lib.rs" {11-24}
// Update an existing counter's value
fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify account ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Mutable borrow the account data
    let mut data = counter_account.data.borrow_mut();

    // Deserialize the account data into our CounterAccount struct
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    // Increment the counter value
    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    // Serialize the updated counter data back into the account
    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);
    Ok(())
}
```

</Accordion>
</Accordions>

```rs title="lib.rs"
// Update an existing counter's value
fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify account ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Mutable borrow the account data
    let mut data = counter_account.data.borrow_mut();

    // Deserialize the account data into our CounterAccount struct
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    // Increment the counter value
    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    // Serialize the updated counter data back into the account
    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);
    Ok(())
}
```

</Step>
<Step>

### Anweisungen testen

Um die Programm-Anweisungen zu testen, fügen Sie die folgenden Abhängigkeiten zu
`Cargo.toml` hinzu.

```shell title="Terminal"
cargo add solana-program-test@1.18.26 --dev
cargo add solana-sdk@1.18.26 --dev
cargo add tokio --dev
```

Fügen Sie dann das folgende Test-Modul zu `lib.rs` hinzu und führen Sie
`cargo test-sbf` aus, um die Tests auszuführen. Optional können Sie das Flag
`--nocapture` verwenden, um die Print- Anweisungen in der Ausgabe zu sehen.

```shell title="Terminal"
cargo test-sbf -- --nocapture
```

<Accordions>
<Accordion title="Erklärung">

Zuerst richten wir das Test-Modul ein und importieren die erforderlichen
Abhängigkeiten:

```rs title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use solana_program_test::*;
    use solana_sdk::{
        instruction::{AccountMeta, Instruction},
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[tokio::test]
    async fn test_counter_program() {
        // Test code will go here
    }
}
```

Als Nächstes richten wir den Test mit `ProgramTest` ein. Dann erstellen wir ein
neues keypair, das als Adresse für das Counter-Konto verwendet wird, das wir
initialisieren werden, und definieren einen Anfangswert für den Zähler.

```rs title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use solana_program_test::*;
    use solana_sdk::{
        instruction::{AccountMeta, Instruction},
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[tokio::test]
    async fn test_counter_program() {
        let program_id = Pubkey::new_unique();
        let (mut banks_client, payer, recent_blockhash) = ProgramTest::new(
            "counter_program",
            program_id,
            processor!(process_instruction),
        )
        .start()
        .await;

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;
    }
}
```

Beim Erstellen einer Anweisung muss jedes Konto als
[`AccountMeta`](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/instruction.rs#L539-L545)
bereitgestellt werden, das Folgendes angibt:

- Den öffentlichen Schlüssel des Kontos (`Pubkey`)
- `is_writable`: Ob die Kontodaten geändert werden
- `is_signer`: Ob das Konto die Transaktion signieren muss

```rs
AccountMeta::new(account1_pubkey, true),           // writable, signer
AccountMeta::new(account2_pubkey, false),          // writable, not signer
AccountMeta::new_readonly(account3_pubkey, false), // not writable, not signer
AccountMeta::new_readonly(account4_pubkey, true),  // writable, signer
```

Um die Initialisierungs-Anweisung zu testen:

- Erstellen Sie instruction data mit Variante 0 (`InitializeCounter`) und
  Anfangswert
- Bauen Sie die Anweisung mit der Programm-ID, den instruction data und den
  erforderlichen Konten
- Senden Sie eine Transaktion mit der Initialisierungs-Anweisung
- Überprüfen Sie, ob das Konto mit dem richtigen Anfangswert erstellt wurde

```rs title="lib.rs" {16-53}
    #[tokio::test]
    async fn test_counter_program() {
        let program_id = Pubkey::new_unique();
        let (mut banks_client, payer, recent_blockhash) = ProgramTest::new(
            "counter_program",
            program_id,
            processor!(process_instruction),
        )
        .start()
        .await;

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Create initialization instruction
        let mut init_instruction_data = vec![0]; // 0 = initialize instruction
        init_instruction_data.extend_from_slice(&initial_value.to_le_bytes());

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Send transaction with initialize instruction
        let mut transaction =
            Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 42);
            println!(
                "✅ Counter initialized successfully with value: {}",
                counter.count
            );
        }
    }
```

Um die Inkrement-Anweisung zu testen:

- Bauen Sie die Anweisung mit der Programm-ID, den instruction data und den
  erforderlichen Konten
- Senden Sie eine Transaktion mit der Inkrement-Anweisung
- Überprüfen Sie, ob das Konto auf den richtigen Wert erhöht wurde

Beachten Sie, dass die instruction data für die Inkrement-Anweisung `[1]` ist,
was der Variante 1 (`IncrementCounter`) entspricht. Da es keine zusätzlichen
Parameter für die Inkrement-Anweisung gibt, sind die Daten einfach die
Anweisungs- Variante.

```rs title="lib.rs" {55-82}
    #[tokio::test]
    async fn test_counter_program() {
        let program_id = Pubkey::new_unique();
        let (mut banks_client, payer, recent_blockhash) = ProgramTest::new(
            "counter_program",
            program_id,
            processor!(process_instruction),
        )
        .start()
        .await;

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Create initialization instruction
        let mut init_instruction_data = vec![0]; // 0 = initialize instruction
        init_instruction_data.extend_from_slice(&initial_value.to_le_bytes());

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Send transaction with initialize instruction
        let mut transaction =
            Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 42);
            println!(
                "✅ Counter initialized successfully with value: {}",
                counter.count
            );
        }

        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Create increment instruction
        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &[1], // 1 = increment instruction
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Send transaction with increment instruction
        let mut transaction =
            Transaction::new_with_payer(&[increment_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 43);
            println!("✅ Counter incremented successfully to: {}", counter.count);
        }
    }
```

</Accordion>
</Accordions>

```rs title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use solana_program_test::*;
    use solana_sdk::{
        instruction::{AccountMeta, Instruction},
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[tokio::test]
    async fn test_counter_program() {
        let program_id = Pubkey::new_unique();
        let (mut banks_client, payer, recent_blockhash) = ProgramTest::new(
            "counter_program",
            program_id,
            processor!(process_instruction),
        )
        .start()
        .await;

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Create initialization instruction
        let mut init_instruction_data = vec![0]; // 0 = initialize instruction
        init_instruction_data.extend_from_slice(&initial_value.to_le_bytes());

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Send transaction with initialize instruction
        let mut transaction =
            Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 42);
            println!(
                "✅ Counter initialized successfully with value: {}",
                counter.count
            );
        }

        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Create increment instruction
        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &[1], // 1 = increment instruction
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Send transaction with increment instruction
        let mut transaction =
            Transaction::new_with_payer(&[increment_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 43);
            println!("✅ Counter incremented successfully to: {}", counter.count);
        }
    }
}
```

Beispielausgabe:

```shell title="Terminal" {6} {10}
running 1 test
[2024-10-29T20:51:13.783708000Z INFO  solana_program_test] "counter_program" SBF program from /counter_program/target/deploy/counter_program.so, modified 2 seconds, 169 ms, 153 µs and 461 ns ago
[2024-10-29T20:51:13.855204000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM invoke [1]
[2024-10-29T20:51:13.856052000Z DEBUG solana_runtime::message_processor::stable_log] Program 11111111111111111111111111111111 invoke [2]
[2024-10-29T20:51:13.856135000Z DEBUG solana_runtime::message_processor::stable_log] Program 11111111111111111111111111111111 success
[2024-10-29T20:51:13.856242000Z DEBUG solana_runtime::message_processor::stable_log] Program log: Counter initialized with value: 42
[2024-10-29T20:51:13.856285000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM consumed 3791 of 200000 compute units
[2024-10-29T20:51:13.856307000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM success
[2024-10-29T20:51:13.860038000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM invoke [1]
[2024-10-29T20:51:13.860333000Z DEBUG solana_runtime::message_processor::stable_log] Program log: Counter incremented to: 43
[2024-10-29T20:51:13.860355000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM consumed 756 of 200000 compute units
[2024-10-29T20:51:13.860375000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM success
test test::test_counter_program ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.08s
```

</Step>
</Steps>
