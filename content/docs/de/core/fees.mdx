---
title: Transaktionsgebühren
description:
  Erfahren Sie mehr über Solanas Transaktionsgebühren, einschließlich der Basis-
  und Prioritätsgebühren, wie jede angewendet wird und bewährte Methoden zur
  Verwaltung von Recheneinheiten in Ihren Transaktionen.
---

## Kernpunkte

## Schlüsselpunkte

- Die **Grundgebühr** für eine Transaktion beträgt mindestens 5000 Lamports pro
  Signatur auf der Transaktion.
- Die **Priorisierungsgebühr** (optional) ist eine zusätzliche Gebühr, die an
  den Validator gezahlt wird, um die Wahrscheinlichkeit zu erhöhen, dass die
  Transaktion verarbeitet wird.
- Die Priorisierungsgebühr wird berechnet als: **(Compute-Unit-Limit \*
  Compute-Unit- Preis)**.
- Das **Compute-Unit-Limit** ist die maximale Anzahl an Compute-Units, die die
  Transaktion verbrauchen kann.
- Der **Compute-Unit-Preis** ist der Preis pro Compute-Unit in Mikro-Lamports.
- 1.000.000 Mikro-Lamports = 1 Lamport
- Der Zahler der Transaktionsgebühr muss ein Konto sein, das dem System Program
  gehört.

## Basis-Transaktionsgebühr

Die Grundgebühr ist die Mindestkosten für das Senden einer Transaktion. Die
Kosten betragen 5000 Lamports pro Signatur, die in der Transaktion enthalten
ist.

Die Grundgebühr wird automatisch vom Zahler der Transaktionsgebühr bezahlt,
welcher der erste Unterzeichner der Transaktion ist. Der Gebührenzahler muss ein
Konto sein, das dem System Program gehört.

- [50% verbrannt](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70):
  Die Hälfte der Grundgebühr wird verbrannt.
- [50% Verteilung](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62):
  Die Hälfte wird an den Validator gezahlt, der die Transaktion verarbeitet hat.

## Priorisierungsgebühr

Die Priorisierungsgebühr ist eine optionale Gebühr, die an den Validator gezahlt
wird, um die Wahrscheinlichkeit zu erhöhen, dass die Transaktion verarbeitet
wird.

- [SIMD-0096](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md):
  100% der Priorisierungsgebühr werden direkt an den Validator gezahlt, der die
  Transaktion verarbeitet.

### Compute-Units und Limits

Wenn eine Transaktion ausgeführt wird, verbraucht sie Rechenressourcen, die in
Compute-Units (CU) gemessen werden. Jede Anweisung zieht vom Compute-Unit-Budget
der Transaktion ab.

- Maximales Limit: Eine Transaktion kann bis zu
  [1,4 Millionen Compute-Units](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14)
  verwenden.
- Standard-Limit: Standardmäßig ist jede Anweisung auf
  [200.000 Compute-Units](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
  begrenzt.
- Benutzerdefiniertes Limit: Sie können ein spezifisches Compute-Unit-Limit
  anfordern, indem Sie eine `SetComputeUnitLimit`-Anweisung in Ihre Transaktion
  einfügen.

Für zusätzliche Details zur Nutzung von Compute-Units:

- [ComputeBudget-Typ](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L22-L130)
- [Compute-Unit-Verbrauch Standardwerte](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197)

Siehe

[Wie man optimale Rechenleistung anfordert](/developers/guides/advanced/how-to-request-optimal-compute)

Leitfaden für weitere Details zur Nutzung von Recheneinheiten.

### Preis der Recheneinheit

Der Preis der Recheneinheit, angegeben in Mikro-Lamports, ist der optionale
Preis, der pro Recheneinheit gezahlt wird, um die Priorisierungsgebühr zu
berechnen.

<Callout>1.000.000 Mikro-Lamports = 1 Lamport</Callout>

Nutzen Sie die folgenden Ressourcen, um Echtzeit-Empfehlungen zum aktuellen
Preis der Recheneinheit zu erhalten:

- [Priority Fee API](https://docs.helius.dev/solana-apis/priority-fee-api) von
  Helius
- [Global Priority Fee Tracker](https://triton.one/solana-prioritization-fees/)
  von Triton

Siehe den

[Wie man Prioritätsgebühren verwendet](/developers/guides/advanced/how-to-use-priority-fees)

Leitfaden für weitere Details zu Prioritätsgebühren.

### Berechnung der Priorisierungsgebühr

Die Priorisierungsgebühr wird wie folgt berechnet:

**Priorisierungsgebühr = Recheneinheitslimit × Preis der Recheneinheit**

Verwenden Sie die folgenden Anweisungen, um das Recheneinheitslimit und den
Preis für eine Transaktion festzulegen:

- [`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
  um ein spezifisches Einheitenlimit festzulegen.
- [`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
  um den Preis pro Recheneinheit zu definieren.

<Callout>

Wenn diese Anweisungen nicht angegeben werden, verwendet die Transaktion
automatisch das Standard-Recheneinheitslimit mit einem Recheneinheitspreis von 0
(keine Priorisierungsgebühr).

Die Prioritätsgebühr basiert auf den für die Transaktion angeforderten
Recheneinheiten, nicht auf den tatsächlich von der Transaktion verwendeten
Recheneinheiten. Wenn Sie ein Recheneinheitslimit festlegen, das zu hoch ist
oder den Standardbetrag verwenden, zahlen Sie möglicherweise für ungenutzte
Recheneinheiten.

</Callout>

### Beispiele

Nachfolgend finden Sie Beispiele für die Anweisungen, die verwendet werden, um
das Recheneinheitslimit und den Preis für eine Transaktion festzulegen.

#### Rust

Die `solana-sdk` bietet Methoden über den

[`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)

Typ:

```rust
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

#### JavaScript

Die `@solana/web3.js` Bibliothek (v1) stellt Methoden über die

[`ComputeBudgetProgram`](https://solana-labs.github.io/solana-web3.js/v1.x/classes/ComputeBudgetProgram.html)

Klasse bereit:

```js
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```
