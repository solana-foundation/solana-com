---
title: "Transaktionen und Anweisungen"
description:
  Erfahren Sie mehr über Solana-Transaktionen und -Anweisungen - die grundlegenden Bausteine
  für die Interaktion mit der Solana-Blockchain. Verstehen Sie die Struktur von Transaktionen
  und die Zusammensetzung von Anweisungen anhand praktischer Beispiele.
---

Auf Solana senden wir [Transaktionen](/docs/core/transactions#transaction), um
mit dem Netzwerk zu interagieren. Transaktionen enthalten eine oder mehrere
[Anweisungen](/docs/core/transactions#instruction), die die zu verarbeitenden Operationen
spezifizieren. Die Ausführungslogik für Anweisungen wird auf
[Programmen](/docs/core/programs) gespeichert, die im Solana-Netzwerk bereitgestellt werden, wobei jedes
Programm seine eigene Menge an Anweisungen definiert.

Im Folgenden sind wichtige Details zur Verarbeitung von Transaktionen aufgeführt:

- Wenn eine Transaktion mehrere Anweisungen enthält, werden die Anweisungen in
  der Reihenfolge ausgeführt, in der sie zur Transaktion hinzugefügt werden.
- Transaktionen sind "atomar" - entweder werden alle Anweisungen erfolgreich verarbeitet,
  oder die gesamte Transaktion schlägt fehl und es werden keine Änderungen vorgenommen.

Zur Vereinfachung kann eine Transaktion als eine Anfrage betrachtet werden, um eine oder
mehrere Anweisungen zu verarbeiten.

![Transaktion vereinfacht](/assets/docs/core/transactions/transaction-simple.svg)

Denken Sie an eine Transaktion wie an einen Umschlag, der Formulare enthält. Jedes Formular ist eine
Anweisung, die dem Netzwerk mitteilt, was wir anfordern möchten. Wenn Sie die
Transaktion senden, ist es, als würden Sie den Umschlag verschicken, um die Formulare zu verarbeiten.

## Wichtige Punkte

- Solana-Transaktionen enthalten Anweisungen, die Anfragen sind, um Programme
  im Netzwerk aufzurufen.
- Transaktionen sind **atomar** - wenn eine Anweisung fehlschlägt, schlägt die gesamte Transaktion
  fehl und es treten keine Änderungen auf.
- Anweisungen in einer Transaktion werden **in der Reihenfolge verarbeitet**.
- Die maximale Größe einer Transaktion beträgt
  [1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
  Bytes.
- Jede Anweisung benötigt 3 Informationen:
  1. Die Adresse des Programms, das aufgerufen werden soll
  2. Die Konten, von denen die Anweisung lesen oder in die sie schreiben wird
  3. Alle zusätzlichen Daten, die von der Anweisung benötigt werden (z.B. Funktionsargumente)

## Einfaches Beispiel

Im Folgenden ist ein Diagramm dargestellt, das eine Transaktion mit einer einzelnen Anweisung zur
Übertragung von SOL von einem Absender zu einem Empfänger zeigt.

Auf Solana werden Konten, die wir als "Wallets" bezeichnen, vom
[Systemprogramm](/docs/core/accounts#system-program) verwaltet. Nur der Programm-Eigentümer kann
Daten eines Kontos ändern, daher erfordert die Übertragung von SOL das Senden einer Transaktion, um
das Systemprogramm aufzurufen.

![SOL-Übertragung](/assets/docs/core/transactions/sol-transfer.svg)

Das Absenderkonto muss die Transaktion signieren (`is_signer`), um die
Abbuchung seines Lamport-Saldos zu autorisieren. Sowohl das Absender- als auch das Empfängerkonto
müssen als beschreibbar (`is_writable`) markiert sein, da sich die Lamport-Salden auf diesen Konten
ändern werden.

Sobald die Transaktion gesendet wird, wird das Systemprogramm aufgerufen, um die
Überweisungsanweisung zu verarbeiten. Das Systemprogramm aktualisiert dann die Lamport-Salden von
sowohl dem Absender- als auch dem Empfängerkonto entsprechend.

![SOL-Übertragungsprozess](/assets/docs/core/transactions/sol-transfer-process.svg)

### SOL Übertragen

Hier ist ein [Solana Playground](https://beta.solpg.io/656a0ea7fb53fa325bfd0c3e)
Beispiel, wie man eine SOL-Überweisungsanweisung mit der
`SystemProgram.transfer`-Methode erstellt:

```typescript title="SOL Übertragen"
// Definieren Sie den zu übertragenden Betrag
const transferAmount = 0.01; // 0.01 SOL

// Erstellen Sie eine Überweisungsanweisung zur Übertragung von SOL von wallet_1 nach wallet_2
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL, // Übertragungsbetrag in Lamports umrechnen
});

// Fügen Sie die Überweisungsanweisung zu einer neuen Transaktion hinzu
const transaction = new Transaction().add(transferInstruction);
```

Führen Sie das Beispiel aus, indem Sie den Befehl `run` im Playground-Terminal verwenden oder
auf die Schaltfläche "Ausführen" klicken.

<Callout type="info">

Stellen Sie sicher, dass Ihre Playground-Wallet über Devnet SOL verfügt. Holen Sie sich Devnet SOL von der
[Solana Faucet](https://faucet.solana.com/).

</Callout>

In den folgenden Abschnitten werden wir die Details von Transaktionen und
Anweisungen durchgehen.

## Transaktion

Eine Solana
[Transaktion](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
besteht aus:

1. [Signaturen](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30):
   Ein Array von Signaturen, die in der Transaktion enthalten sind.
2. [Nachricht](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131):
   Liste von Anweisungen, die atomar verarbeitet werden sollen.

```rust title="Transaktion"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    pub message: Message,
}
```

![Transaktionsformat](/assets/docs/core/transactions/tx_format.png)

Die Struktur einer Transaktionsnachricht besteht aus:

- [Nachrichtenkopf](/docs/core/transactions#message-header): Gibt die Anzahl
  der Unterzeichner und der nur lesenden Konten an.
- [Kontoadressen](/docs/core/transactions#array-of-account-addresses): Ein
  Array von Kontoadressen, die von den Anweisungen in der Transaktion benötigt werden.
- [Aktueller Blockhash](/docs/core/transactions#recent-blockhash): Dient als
  Zeitstempel für die Transaktion.
- [Anweisungen](/docs/core/transactions#array-of-instructions): Ein Array von
  Anweisungen, die ausgeführt werden sollen.

```rust title="Nachricht"
pub struct Message {
    /// Der Nachrichtenkopf, der die unterzeichneten und nur lesenden `account_keys` identifiziert.
    pub header: MessageHeader,

    /// Alle Kontoschlüssel, die von dieser Transaktion verwendet werden.
    #[serde(with = "short_vec")]
    pub account_keys: Vec<Pubkey>,

    /// Die ID eines aktuellen Ledger-Eintrags.
    pub recent_blockhash: Hash,

    /// Programme, die in der Reihenfolge ausgeführt und in
    /// einer atomaren Transaktion festgeschrieben werden, wenn alle erfolgreich sind.
    #[serde(with = "short_vec")]
    pub instructions: Vec<CompiledInstruction>,
}
```

![Transaktionsnachricht](/assets/docs/core/transactions/legacy_message.png)

### Transaktionsgröße

Solana-Transaktionen sind auf
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
Bytes begrenzt. Dieses Limit ergibt sich aus der IPv6 MTU-Größe von 1280 Bytes, abzüglich 48 Bytes für
Netzwerkheader (40 Bytes IPv6 + 8 Bytes Fragmentheader).

Die Gesamtgröße einer Transaktion (Signaturen und Nachricht) muss unter diesem Limit
liegen und besteht aus:

- Signaturen: jeweils 64 Bytes
- Nachricht: Kopf (3 Bytes), Kontoschlüssel (jeweils 32 Bytes), aktueller Blockhash (32
  Bytes) und Anweisungen

![Transaktionsformat](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### Nachrichtenkopf

Der
[Nachrichtenkopf](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
verwendet drei Bytes, um die Kontoberechtigungen zu definieren:

1. Erforderliche Signaturen und
   [Nachrichtenversion](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/versions/mod.rs#L220-L231)
   (z.B. legacy vs v0)
2. Anzahl der nur lesenden unterzeichneten Konten
3. Anzahl der nur lesenden nicht unterzeichneten Konten

```rust title="Nachrichtenkopf"
pub struct MessageHeader {
    /// Die Anzahl der Signaturen, die erforderlich sind, damit diese Nachricht als
    /// gültig betrachtet wird. Die Unterzeichner dieser Signaturen müssen mit den ersten
    /// `num_required_signatures` von [`Message::account_keys`] übereinstimmen.
    pub num_required_signatures: u8,

    /// Die letzten `num_readonly_signed_accounts` der unterzeichneten Schlüssel sind nur lesende
    /// Konten.
    pub num_readonly_signed_accounts: u8,

    /// Die letzten `num_readonly_unsigned_accounts` der nicht unterzeichneten Schlüssel sind
    /// nur lesende Konten.
    pub num_readonly_unsigned_accounts: u8,
}
```

![Nachrichtenkopf](/assets/docs/core/transactions/message_header.png)

### Kompakt-Array-Format

Ein kompaktes Array in einer Transaktionsnachricht bezieht sich auf ein Array, das im
folgenden Format serialisiert ist:

1. Die Array-Länge (kodiert als
   [compact-u16](https://github.com/anza-xyz/agave/blob/v2.1.13/short-vec/src/lib.rs))
2. Die Array-Elemente, die nacheinander aufgelistet sind

![Kompakt-Array-Format](/assets/docs/core/transactions/compact_array_format.png)

Dieses Format wird verwendet, um die Längen der
[Kontoadressen](/docs/core/transactions#array-of-account-addresses) und
[Anweisungen](/docs/core/transactions#array-of-instructions) Arrays in
Transaktionsnachrichten zu kodieren.

### Array von Kontoadressen

Eine Transaktionsnachricht enthält ein Array von
[Kontoadressen](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138),
die von ihren Anweisungen benötigt werden. Das Array beginnt mit einer
[compact-u16](/docs/core/transactions#compact-array-format) Zahl, die angibt,
wie viele Adressen es enthält. Die Adressen werden dann basierend auf ihren
Berechtigungen angeordnet, die durch den Nachrichtenkopf bestimmt werden.

- Konten, die beschreibbar und Unterzeichner sind
- Konten, die nur lesend und Unterzeichner sind
- Konten, die beschreibbar und keine Unterzeichner sind
- Konten, die nur lesend und keine Unterzeichner sind

![Kompaktes Array von Kontoadressen](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Aktueller Blockhash

Jede Transaktion benötigt einen
[aktuellen Blockhash](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L141),
der zwei Zwecke erfüllt:

1. Dient als Zeitstempel
2. Verhindert doppelte Transaktionen

Ein Blockhash läuft nach
[150](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)
Blöcken (etwa 1 Minute bei 400 ms Blockzeiten) ab, nach dem die Transaktion
nicht mehr verarbeitet werden kann.

Sie können die [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) RPC-
Methode verwenden, um den aktuellen Blockhash und die letzte Blockhöhe zu erhalten, bei der der Blockhash
gültig ist. Hier ist ein Beispiel auf
[Solana Playground](https://beta.solpg.io/661a06e1cffcf4b13384d046).

### Array von Anweisungen

Eine Transaktionsnachricht enthält ein Array von
[Anweisungen](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
in der
[CompiledInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
Typ. Anweisungen werden in diesen Typ umgewandelt, wenn sie zu einer Transaktion hinzugefügt werden.

Wie das Array der Kontoadressen in der Nachricht beginnt es mit einer
[compact-u16](/docs/core/transactions#compact-array-format) Länge, gefolgt von
den Anweisungsdaten. Jede Anweisung enthält:

1. Programm-ID-Index: Ein u8-Index, der auf die Adresse des Programms im
   Array der Kontoadressen verweist. Dies gibt an, welches Programm die
   Anweisung verarbeiten wird.
2. Kontoindizes: Ein Array von u8-Indizes, die auf die Kontoadressen
   verweisen, die für diese Anweisung erforderlich sind.
3. Anweisungsdaten: Ein Byte-Array, das angibt, welche Anweisung im
   Programm aufgerufen werden soll und welche zusätzlichen Daten von der Anweisung benötigt werden (z.B. Funktionsargumente).

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index in das Transaktionsschlüssel-Array, das das Programmkonto angibt, das diese Anweisung ausführt.
    pub program_id_index: u8,
    /// Geordnete Indizes in das Transaktionsschlüssel-Array, die angeben, welche Konten an das Programm übergeben werden sollen.
    #[serde(with = "short_vec")]
    pub accounts: Vec<u8>,
    /// Die Programmdaten.
    #[serde(with = "short_vec")]
    pub data: Vec<u8>,
}
```

![Kompaktes Array von Anweisungen](/assets/docs/core/transactions/compact_array_of_ixs.png)

### Beispiel für die Transaktionsstruktur

Im Folgenden ist ein Beispiel für eine Transaktion dargestellt, die eine einzelne
[SOL-Überweisungsanweisung](/docs/core/transactions#basic-example) enthält. Die
Komponenten der Transaktion umfassen:

- `header`: Gibt die Lese-/Schreib- und Unterzeichnerberechtigungen für die Adressen im
  `accountKeys`-Array an.

- `accountKeys`: Array aller Kontoadressen, die in den Anweisungen der Transaktion verwendet werden.

- `recentBlockhash`: Blockhash, der verwendet wird, um die Transaktion zu timestampen.

- `instructions`: Array von Anweisungen, die ausgeführt werden sollen. Jede `account` und
  `programIdIndex` in einer Anweisung verweist durch Index auf das `accountKeys`-Array.

- `signatures`: Array, das Signaturen für alle Konten enthält, die als Unterzeichner
  von den Anweisungen in der Transaktion erforderlich sind. Eine Signatur wird erstellt, indem die
  Transaktionsnachricht mit dem entsprechenden privaten Schlüssel für ein Konto signiert wird.

```json
"transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
        "5snoUseZG8s8CDFHrXY2ZHaCrJYsW457piktDmhyb5Jd",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "DzfXchZJoLMG3cNftcf2sw7qatkkuwQf4xH15N5wkKAb",
      "instructions": [
        {
          "accounts": [
            0,
            1
          ],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "5LrcE2f6uvydKRquEJ8xp19heGxSvqsVbcqUeFoiWbXe8JNip7ftPQNTAVPyTK7ijVdpkzmKKaAQR7MWMmujAhXD"
    ]
  }
```

## Anweisung

Eine
[Anweisung](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)
auf einem bereitgestellten [Programm](/docs/core/accounts#program-account) kann als eine öffentliche Funktion betrachtet werden,
die von jedem, der das Solana-Netzwerk nutzt, aufgerufen werden kann.

Das Aufrufen einer Anweisung eines Programms erfordert die Bereitstellung von drei wichtigen
Informationen:

- Programm-ID: Das Programm, das aufgerufen wird, um die Anweisung auszuführen
- Konten: Liste der Konten, die die Anweisung benötigt
- Anweisungsdaten: Byte-Array, das die Anweisung im Programm angibt, die aufgerufen werden soll, und alle Funktionsargumente, die von der Anweisung benötigt werden

```rust title="Anweisung"
pub struct Instruction {
    /// Pubkey des Programms, das diese Anweisung ausführt.
    pub program_id: Pubkey,
    /// Metadaten, die die Konten beschreiben, die an das Programm übergeben werden sollen.
    pub accounts: Vec<AccountMeta>,
    /// Opake Daten, die an das Programm zur eigenen Interpretation übergeben werden.
    pub data: Vec<u8>,
}
```

![Transaktionsanweisung](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

Jedes Konto, das von einer Anweisung benötigt wird, muss als
[AccountMeta](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25)
bereitgestellt werden, das enthält:

- `pubkey`: Adresse des Kontos
- `is_signer`: Ob das Konto die Transaktion signieren muss
- `is_writable`: Ob die Anweisung die Daten des Kontos ändern wird

```rust title="AccountMeta"
pub struct AccountMeta {
    /// Der öffentliche Schlüssel eines Kontos.
    pub pubkey: Pubkey,
    /// Wahr, wenn eine `Anweisung` eine `Transaktions`-Signatur benötigt, die mit `pubkey` übereinstimmt.
    pub is_signer: bool,
    /// Wahr, wenn die Kontodaten oder Metadaten während der Programmausführung geändert werden können.
    pub is_writable: bool,
}
```

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

Durch die vorherige Angabe, von welchen Konten eine Anweisung lesen oder in welche sie schreiben wird,
können Transaktionen, die nicht dieselben Konten ändern, parallel verarbeitet werden.

### Beispiel für die Anweisungsstruktur

Im Folgenden ist ein einfaches Beispiel dargestellt, das die Struktur einer SOL-Überweisungsanweisung zeigt:

- `keys`: Enthält das `AccountMeta` für jedes Konto, das von einer
  Anweisung benötigt wird.
- `programId`: Die Adresse des Programms, das die Ausführungslogik für
  die aufgerufene Anweisung enthält.
- `data`: Die Anweisungsdaten für die Anweisung als Byte-Puffer

```json
{
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  "programId": "11111111111111111111111111111111",
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

## Ausführliches Beispiel

Die Details zum Erstellen von Programm-Anweisungen werden oft von
Client-Bibliotheken abstrahiert. Wenn jedoch keine verfügbar ist, können Sie immer auf
manuelles Erstellen der Anweisung zurückgreifen.

### SOL Übertragen

Hier ist ein [Solana Playground](https://beta.solpg.io/656a102efb53fa325bfd0c3f)
Beispiel, wie man manuell eine SOL-Überweisungsanweisung erstellt.

Im Hintergrund ist das
[einfaches Beispiel](/docs/core/transactions#simple-sol-transfer), das die
`SystemProgram.transfer`-Methode verwendet, funktional äquivalent zu dem ausführlicheren
Beispiel unten. Die `SystemProgram.transfer`-Methode abstrahiert einfach die
Details zur Erstellung des Anweisungsdatenpuffers und `AccountMeta` für jedes
Konto, das von der Anweisung benötigt wird.

Die Snippets in den beiden untenstehenden Tabs sind funktional äquivalent.

<Tabs items={['Anweisung manuell erstellen', 'Bibliothek verwenden']}>
<Tab value="Anweisung manuell erstellen">

```typescript
// Definieren Sie den zu übertragenden Betrag
const transferAmount = 0.01; // 0.01 SOL

// Anweisungsindex für die Überweisungsanweisung des Systemprogramms
const transferInstructionIndex = 2;

// Erstellen Sie einen Puffer für die Daten, die an die Überweisungsanweisung übergeben werden sollen
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
// Schreiben Sie den Anweisungsindex in den Puffer
instructionData.writeUInt32LE(transferInstructionIndex, 0);
// Schreiben Sie den Übertragungsbetrag in den Puffer
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// Manuell eine Überweisungsanweisung zur Übertragung von SOL vom Absender zum Empfänger erstellen
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true },
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true },
  ],
  programId: SystemProgram.programId,
  data: instructionData,
});

// Fügen Sie die Überweisungsanweisung zu einer neuen Transaktion hinzu
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
<Tab value="Bibliothek verwenden">

```typescript
// Definieren Sie den zu übertragenden Betrag
const transferAmount = 0.01; // 0.01 SOL

// Erstellen Sie eine Überweisungsanweisung zur Übertragung von SOL von wallet_1 nach wallet_2
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL, // Übertragungsbetrag in Lamports umrechnen
});

// Fügen Sie die Überweisungsanweisung zu einer neuen Transaktion hinzu
const transaction = new Transaction().add(transferInstruction);
```

</Tab>
</Tabs>
