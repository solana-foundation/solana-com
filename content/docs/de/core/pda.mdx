---
title: Programm-abgeleitete Adresse
description:
  Erfahren Sie mehr über programm-abgeleitete Adressen (PDAs) auf Solana -
  deterministische Kontoadressen, die sichere Programmunterschriften
  ermöglichen. Verstehen Sie PDA-Ableitung, kanonische Bumps und wie man
  PDA-Konten erstellt.
h1: Programm-abgeleitete Adresse (PDA)
---

Program Derived Addresses (PDAs) bieten Entwicklern auf Solana zwei
hauptsächliche Anwendungsfälle:

- **Deterministische Kontoadressen**: PDAs bieten einen Mechanismus, um eine
  Adresse deterministisch abzuleiten, indem eine Kombination aus optionalen
  "Seeds" (vordefinierten Eingaben) und einer spezifischen Programm-ID verwendet
  wird.
- **Ermöglichen von Programmunterschriften**: Die Solana-Laufzeitumgebung
  ermöglicht es Programmen, für PDAs zu "unterschreiben", die von ihrer
  Programm-ID abgeleitet sind.

Man kann sich PDAs als eine Möglichkeit vorstellen, hashmap-ähnliche Strukturen
on-chain aus einer vordefinierten Menge von Eingaben (z.B. Strings, Zahlen und
andere Kontoadressen) zu erstellen.

Der Vorteil dieses Ansatzes ist, dass es nicht notwendig ist, eine exakte
Adresse zu verfolgen. Stattdessen müssen Sie sich nur an die spezifischen
Eingaben erinnern, die für die Ableitung verwendet wurden.

![Program Derived Address](/assets/docs/core/pda/pda.svg)

Es ist wichtig zu verstehen, dass das einfache Ableiten einer Program Derived
Address (PDA) nicht automatisch ein On-Chain-Konto an dieser Adresse erstellt.
Konten mit einer PDA als On-Chain-Adresse müssen explizit durch das Programm
erstellt werden, das zur Ableitung der Adresse verwendet wurde. Man kann sich
das Ableiten einer PDA wie das Finden einer Adresse auf einer Karte vorstellen.
Nur weil man eine Adresse hat, bedeutet das nicht, dass an diesem Ort etwas
gebaut wurde.

> Dieser Abschnitt behandelt die Details zur Ableitung von PDAs. Die Details
> darüber, wie Programme PDAs für Unterschriften verwenden, werden im Abschnitt
> über [Cross Program Invocations (CPIs)](/docs/core/cpi) behandelt, da dies
> Kontext für beide Konzepte erfordert.

## Kernpunkte

- PDAs sind Adressen, die **deterministisch abgeleitet** werden, indem eine
  Kombination aus benutzerdefinierten Seeds, einem Bump-Seed und einer
  Programm-ID verwendet wird.
- PDAs sind Adressen, die außerhalb der Ed25519-Kurve liegen und **keinen
  entsprechenden privaten Schlüssel haben**.
- Solana-Programme können **im Namen von PDAs unterschreiben, die mit ihrer
  Programm-ID abgeleitet wurden**.
- Das Ableiten einer PDA erstellt nicht automatisch ein On-Chain-Konto.
- Ein Konto, das eine PDA als Adresse verwendet, muss explizit durch eine
  dedizierte Anweisung innerhalb eines Solana-Programms erstellt werden.

## Was ist eine PDA

PDAs sind Adressen, die deterministisch abgeleitet werden und wie standardmäßige
öffentliche Schlüssel aussehen, aber keine zugehörigen privaten Schlüssel haben.
Das bedeutet, dass kein externer Benutzer eine gültige Signatur für die Adresse
generieren kann. Die Solana-Laufzeitumgebung ermöglicht es Programmen jedoch,
PDAs programmatisch zu "signieren", ohne einen privaten Schlüssel zu benötigen.

Zum Kontext, Solana

[Keypairs](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/src/signer/keypair.rs#L25)

sind Punkte auf der Ed25519-Kurve (elliptische Kurven-Kryptographie), die einen
öffentlichen Schlüssel und einen entsprechenden privaten Schlüssel haben. Wir
verwenden oft öffentliche Schlüssel als eindeutige IDs für neue On-Chain-Konten
und private Schlüssel zum Signieren.

![Adresse auf der Kurve](/assets/docs/core/pda/address-on-curve.svg)

Eine PDA ist ein Punkt, der absichtlich so abgeleitet wird, dass er außerhalb
der Ed25519-Kurve liegt, unter Verwendung eines vordefinierten Satzes von
Eingaben. Ein Punkt, der nicht auf der Ed25519-Kurve liegt, hat keinen gültigen
entsprechenden privaten Schlüssel und kann nicht für kryptografische Operationen
(Signieren) verwendet werden.

Eine PDA kann dann als Adresse (eindeutige Kennung) für ein On-Chain- Konto
verwendet werden, was eine Methode bietet, um Programmzustände einfach zu
speichern, zuzuordnen und abzurufen.

![Adresse außerhalb der Kurve](/assets/docs/core/pda/address-off-curve.svg)

## Wie man eine PDA ableitet

Die Ableitung einer PDA erfordert 3 Eingaben.

- **Optionale Seeds**: Vordefinierte Eingaben (z.B. String, Zahl, andere Konto-
  Adressen), die zur Ableitung einer PDA verwendet werden. Diese Eingaben werden
  in einen Puffer von Bytes umgewandelt.
- **Bump Seed**: Eine zusätzliche Eingabe (mit einem Wert zwischen 255-0), die
  verwendet wird, um zu garantieren, dass eine gültige PDA (außerhalb der Kurve)
  generiert wird. Dieser Bump Seed (beginnend mit 255) wird den optionalen Seeds
  beim Generieren einer PDA angehängt, um den Punkt von der Ed25519-Kurve
  "wegzustoßen". Der Bump Seed wird manchmal als "Nonce" bezeichnet.
- **Programm-ID**: Die Adresse des Programms, von dem die PDA abgeleitet wird.
  Dies ist auch das Programm, das im Namen der PDA "signieren" kann

![PDA-Ableitung](/assets/docs/core/pda/pda-derivation.svg)

Die folgenden Beispiele enthalten Links zu Solana Playground, wo du die
Beispiele in einem browserbasierten Editor ausführen kannst.

### FindProgramAddress

Um eine PDA abzuleiten, können wir die

[`findProgramAddressSync`](https://github.com/solana-labs/solana-web3.js/blob/ca9da583a39cdf8fd874a2e03fccdc849e29de34/packages/library-legacy/src/publickey.ts#L212)

Methode aus [`@solana/web3.js`](https://www.npmjs.com/package/@solana/web3.js)
verwenden. Es gibt Äquivalente dieser Funktion in anderen Programmiersprachen
(z.B.
[Rust](https://github.com/solana-labs/solana/blob/27eff8408b7223bb3c4ab70523f8a8dca3ca6645/sdk/program/src/pubkey.rs#L484)),
aber in diesem Abschnitt werden wir Beispiele mit Javascript durchgehen.

Bei der Verwendung der `findProgramAddressSync`-Methode übergeben wir:

- die vordefinierten optionalen Seeds, die in einen Byte-Puffer umgewandelt
  wurden, und
- die Programm-ID (Adresse), die zur Ableitung der PDA verwendet wird

Sobald eine gültige PDA gefunden wird, gibt `findProgramAddressSync` sowohl die
Adresse (PDA) als auch den Bump-Seed zurück, der zur Ableitung der PDA verwendet
wurde.

Das folgende Beispiel leitet eine PDA ab, ohne optionale Seeds anzugeben.

```ts /[]/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");

const [PDA, bump] = PublicKey.findProgramAddressSync([], programId);

console.log(`PDA: ${PDA}`);
console.log(`Bump: ${bump}`);
```

Du kannst dieses Beispiel auf
[Solana Playground](https://beta.solpg.io/66031e5acffcf4b13384cfef) ausführen.
Die PDA und der Bump-Seed-Output werden immer gleich sein:

```
PDA: Cu7NwqCXSmsR5vgGA3Vw9uYVViPi3kQvkbKByVQ8nPY9
Bump: 255
```

Das nächste Beispiel fügt einen optionalen Seed "helloWorld" hinzu.

```ts /string/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";

const [PDA, bump] = PublicKey.findProgramAddressSync(
  [Buffer.from(string)],
  programId
);

console.log(`PDA: ${PDA}`);
console.log(`Bump: ${bump}`);
```

Du kannst auch dieses Beispiel auf
[Solana Playground](https://beta.solpg.io/66031ee5cffcf4b13384cff0) ausführen.
Die PDA und der Bump-Seed-Output werden immer gleich sein:

```
PDA: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
Bump: 254
```

Beachte, dass der Bump-Seed 254 ist. Das bedeutet, dass 255 einen Punkt auf der
Ed25519-Kurve abgeleitet hat und keine gültige PDA ist.

Der von `findProgramAddressSync` zurückgegebene Bump-Seed ist der erste Wert
(zwischen 255-0) für die gegebene Kombination aus optionalen Seeds und
Programm-ID, der eine gültige PDA ableitet.

> Dieser erste gültige Bump-Seed wird als "kanonischer Bump" bezeichnet. Für die
> Programmsicherheit wird empfohlen, nur den kanonischen Bump bei der Arbeit mit
> PDAs zu verwenden.

### CreateProgramAddress

Unter der Haube wird `findProgramAddressSync` iterativ einen zusätzlichen
Bump-Seed (Nonce) an den Seeds-Puffer anhängen und die

[`createProgramAddressSync`](https://github.com/solana-labs/solana-web3.js/blob/ca9da583a39cdf8fd874a2e03fccdc849e29de34/packages/library-legacy/src/publickey.ts#L168)

Methode aufrufen. Der Bump-Seed beginnt mit einem Wert von 255 und wird um 1
verringert, bis eine gültige PDA (off curve) gefunden wird.

Sie können das vorherige Beispiel replizieren, indem Sie
`createProgramAddressSync` verwenden und explizit den Bump-Seed von 254
übergeben.

```ts /bump/
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";
const bump = 254;

const PDA = PublicKey.createProgramAddressSync(
  [Buffer.from(string), Buffer.from([bump])],
  programId
);

console.log(`PDA: ${PDA}`);
```

Führen Sie dieses Beispiel auf
[Solana Playground](https://beta.solpg.io/66031f8ecffcf4b13384cff1) aus. Bei den
gleichen Seeds und der gleichen Program-ID wird die PDA-Ausgabe mit der
vorherigen übereinstimmen:

```
PDA: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
```

### Kanonischer Bump

Der "kanonische Bump" bezieht sich auf den ersten Bump-Seed (beginnend bei 255
und dekrementierend um 1), der eine gültige PDA ableitet. Für die
Programmsicherheit wird empfohlen, nur PDAs zu verwenden, die von einem
kanonischen Bump abgeleitet wurden.

Unter Verwendung des vorherigen Beispiels als Referenz versucht das folgende
Beispiel, eine PDA mit jedem Bump-Seed von 255-0 abzuleiten.

```ts
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const string = "helloWorld";

// Schleife durch alle Bump-Seeds zur Demonstration
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(string), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

Führen Sie das Beispiel auf
[Solana Playground](https://beta.solpg.io/66032009cffcf4b13384cff2) aus und Sie
sollten folgende Ausgabe sehen:

```
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// verbleibende Bump-Ausgaben
```

Wie erwartet wirft der Bump-Seed 255 einen Fehler und der erste Bump-Seed, der
eine gültige PDA ableitet, ist 254.

Beachten Sie jedoch, dass die Bump-Seeds 253-251 alle gültige PDAs mit
unterschiedlichen Adressen ableiten. Das bedeutet, dass bei gleichen optionalen
Seeds und `programId` ein Bump- Seed mit einem anderen Wert immer noch eine
gültige PDA ableiten kann.

<Callout type="warn">
  Beim Erstellen von Solana-Programmen wird empfohlen, Sicherheitsprüfungen einzubauen,
  die validieren, dass eine an das Programm übergebene PDA mit dem kanonischen Bump abgeleitet wurde.
  Wenn dies nicht erfolgt, können Schwachstellen entstehen, die es ermöglichen, unerwartete
  Konten an ein Programm zu übergeben.
</Callout>

## PDA-Konten erstellen

Dieses Beispielprogramm auf

[Solana Playground](https://beta.solpg.io/github.com/ZYJLiu/doc-examples/tree/main/pda-account)

zeigt, wie man ein Konto erstellt, indem man eine PDA als Adresse des neuen
Kontos verwendet. Das Beispielprogramm wurde mit dem Anchor-Framework
geschrieben.

In der Datei `lib.rs` finden Sie das folgende Programm, das eine einzige
Anweisung enthält, um ein neues Konto zu erstellen, wobei eine PDA als Adresse
des Kontos verwendet wird. Das neue Konto speichert die Adresse des `user` und
den `bump`-Seed, der zur Ableitung der PDA verwendet wurde.

```rust title="lib.rs" {11-14,26-29}
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // speichere die Adresse des `user`
        account_data.user = *ctx.accounts.user.key;
        // speichere den kanonischen bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(
        init,
        // setze die seeds zur Ableitung der PDA
        seeds = [b"data", user.key().as_ref()],
        // verwende den kanonischen bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]

#[derive(InitSpace)]
pub struct DataAccount {
    pub user: Pubkey,
    pub bump: u8,
}
```

Die Seeds, die zur Ableitung der PDA verwendet werden, beinhalten den
hartcodierten String `data` und die Adresse des `user`-Kontos, das in der
Anweisung angegeben wurde. Das Anchor-Framework leitet automatisch den
kanonischen `bump`-Seed ab.

```rust /data/ /user.key()/ /bump/
#[account(
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

Die `init`-Einschränkung weist Anchor an, das System-Programm aufzurufen, um ein
neues Konto zu erstellen, wobei die PDA als Adresse verwendet wird. Unter der
Haube geschieht dies durch einen [CPI](/docs/core/cpi).

```rust /init/
#[account(
    init,
    seeds = [b"data", user.key().as_ref()],
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

In der Testdatei (`pda-account.test.ts`), die sich im oben bereitgestellten
Solana Playground-Link befindet, finden Sie das Javascript-Äquivalent zur
Ableitung der PDA.

```ts /data/ /user.publicKey/
const [PDA] = PublicKey.findProgramAddressSync(
  [Buffer.from("data"), user.publicKey.toBuffer()],
  program.programId
);
```

Dann wird eine Transaktion gesendet, um die `initialize`-Anweisung aufzurufen
und ein neues On-Chain-Konto zu erstellen, wobei die PDA als Adresse verwendet
wird. Nachdem die Transaktion gesendet wurde, wird die PDA verwendet, um das
On-Chain-Konto abzurufen, das unter der Adresse erstellt wurde.

```ts /initialize()/ /PDA/  {14}
it("Is initialized!", async () => {
  const transactionSignature = await program.methods
    .initialize()
    .accounts({
      user: user.publicKey,
      pdaAccount: PDA
    })
    .rpc();

  console.log("Transaction Signature:", transactionSignature);
});

it("Fetch Account", async () => {
  const pdaAccount = await program.account.dataAccount.fetch(PDA);
  console.log(JSON.stringify(pdaAccount, null, 2));
});
```

Beachten Sie, dass wenn Sie die `initialize`-Anweisung mehr als einmal mit
derselben `user`-Adresse als Seed aufrufen, die Transaktion fehlschlagen wird.
Dies liegt daran, dass bereits ein Konto unter der abgeleiteten Adresse
existiert.
