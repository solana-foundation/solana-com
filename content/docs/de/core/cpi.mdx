---
title: Cross Program Invocation
description:
  Erfahren Sie mehr über die Cross Program Invocation (CPI) auf Solana - wie Programme
  Anweisungen in anderen Programmen aufrufen, PDA-Signer verwalten und Funktionalitäten
  im Solana-Netzwerk zusammensetzen können.
h1: Cross Program Invocation (CPI)
---

Eine Cross Program Invocation (CPI) bezieht sich darauf, wenn ein Programm die
Anweisungen eines anderen Programms aufruft. Dies ermöglicht die Komponierbarkeit von Solana
Programmen.

Sie können sich Anweisungen als API-Endpunkte vorstellen, die ein Programm dem
Netzwerk zur Verfügung stellt, und eine CPI als eine interne API, die eine andere API aufruft.

![Cross Program Invocation](/assets/docs/core/cpi/cpi.svg)

## Wichtige Punkte

- **Cross Program Invocations** ermöglichen es Solana-Programmanweisungen, direkt
  Anweisungen in einem anderen Programm aufzurufen.
- **Signer-Rechte** von einem aufrufenden Programm erstrecken sich auf das aufgerufene Programm.
- Bei einer Cross Program Invocation können **Programme im Namen von
  PDAs** signieren, die aus ihrer eigenen Programm-ID abgeleitet sind.
- Das aufgerufene Programm kann weitere CPIs zu anderen Programmen machen, bis zu einer Tiefe
  von 4.

## Was ist eine CPI?

Eine Cross Program Invocation (CPI) ist, wenn ein Programm die Anweisungen eines
anderen Programms aufruft.

Das Schreiben einer Programmanweisung mit einer CPI folgt dem gleichen Muster wie das Erstellen einer
[instruction](/docs/core/transactions#instruction), die zu einer Transaktion hinzugefügt wird.
Im Hintergrund muss jede CPI-Anweisung Folgendes angeben:

- **Programmadresse**: Gibt das Programm an, das aufgerufen werden soll
- **Konten**: Listet jedes Konto auf, von dem die Anweisung liest oder in das sie schreibt,
  einschließlich anderer Programme
- **Anweisungsdaten**: Gibt an, welche Anweisung im Programm aufgerufen werden soll,
  sowie alle Daten, die die Anweisung benötigt (Funktionsargumente)

Wenn ein Programm eine Cross Program Invocation (CPI) zu einem anderen Programm macht:

- Die Signer-Rechte aus der ursprünglichen Transaktion erstrecken sich auf das aufgerufene
  Programm (z. B. A->B)
- Das aufgerufene Programm kann weitere CPIs zu anderen Programmen machen, bis zu einer Tiefe von 4
  (z. B. B->C, C->D)
- Die Programme können im Namen der [PDAs](/docs/core/pda) signieren, die aus
  ihrer Programm-ID abgeleitet sind.

<Callout>
  Die Solana-Programmlaufzeit setzt eine
  [`max_instruction_stack_depth`](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L38)
  Konstante
  [MAX_INSTRUCTION_STACK_DEPTH](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L13)
  von 5. Dies stellt die maximale Höhe des Stapels für Programmanrufanweisungen dar.
  Die Stapelhöhe beginnt bei 1 für die ursprüngliche Transaktion und erhöht sich
  um 1, jedes Mal, wenn ein Programm eine andere Anweisung aufruft. Diese Einstellung begrenzt
  die Aufruftiefe für CPIs auf 4.
</Callout>

Wenn eine Transaktion verarbeitet wird, erstrecken sich die Kontorechte von einem Programm auf
ein anderes. Das bedeutet Folgendes:

Angenommen, Programm A erhält eine Anweisung mit:

- Einem Konto, das die Transaktion signiert hat
- Einem Konto, in das geschrieben werden kann (veränderlich)

Wenn Programm A eine CPI zu Programm B macht:

- Programm B kann diese gleichen Konten mit ihren ursprünglichen Berechtigungen verwenden
- Programm B kann mit dem Signerkonto signieren
- Programm B kann in das schreibbare Konto schreiben
- Programm B kann sogar diese gleichen Berechtigungen weitergeben, wenn es seine eigenen
  CPIs macht.

## Cross Program Invocations

Die
[`invoke`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/program.rs#L26-L28)
Funktion behandelt CPIs, die keine PDA-Signer erfordern. Die Funktion ruft die
`invoke_signed`-Funktion mit einem leeren `signers_seeds`-Array auf, was darauf hinweist, dass keine PDAs
zum Signieren erforderlich sind.

```rust title="Invoke Function"
pub fn invoke(instruction: &Instruction, account_infos: &[AccountInfo]) -> ProgramResult {
    invoke_signed(instruction, account_infos, &[])
}
```

Die folgenden Beispiele zeigen, wie man eine CPI mit dem
[Anchor Framework](https://www.anchor-lang.com/docs) und Native Rust erstellt. Die
Beispielprogramme enthalten eine einzelne Anweisung, die SOL von einem
Konto auf ein anderes über eine CPI überträgt.

### Anchor Framework

Die folgenden Beispiele präsentieren drei Möglichkeiten zur Erstellung von Cross Program Invocations
(CPIs) in einem Anchor-Programm, jeweils auf einem anderen Abstraktionsniveau. Alle
Beispiele funktionieren gleich. Der Hauptzweck besteht darin, die Implementierungsdetails einer CPI zu zeigen.

- Beispiel 1: Verwendet Anchors _rs`CpiContext`_ und eine Hilfsfunktion, um die
  CPI-Anweisung zu konstruieren.
- Beispiel 2: Verwendet die _rs`system_instruction::transfer`_ Funktion aus dem
  `solana_program`-Crate, um die CPI-Anweisung zu konstruieren. Beispiel 1 abstrahiert
  diese Implementierung.
- Beispiel 3: Konstruiert die CPI-Anweisung manuell. Dieser Ansatz ist nützlich,
  wenn kein Crate vorhanden ist, um die Anweisung zu erstellen.

<CodeTabs>

```rs !! title="Beispiel 1"
use anchor_lang::prelude::*;
use anchor_lang::system_program::{transfer, Transfer};

declare_id!("9AvUNHjxscdkiKQ8tUn12QCMXtcnbR9BVGq3ULNzFMRi");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let cpi_context = CpiContext::new(
            program_id,
            Transfer {
                from: from_pubkey,
                to: to_pubkey,
            },
        );

        transfer(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Beispiel 2"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke, system_instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let instruction =
            &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

        invoke(instruction, &[from_pubkey, to_pubkey, program_id])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Beispiel 3"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke, instruction::Instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        // Bereiten Sie die Anweisung AccountMetas vor
        let account_metas = vec![
            AccountMeta::new(from_pubkey.key(), true),
            AccountMeta::new(to_pubkey.key(), false),
        ];

        // SOL-Überweisungsanweisungsdiskriminator
        let instruction_discriminator: u32 = 2;

        // Bereiten Sie die Anweisungsdaten vor
        let mut instruction_data = Vec::with_capacity(4 + 8);
        instruction_data.extend_from_slice(&instruction_discriminator.to_le_bytes());
        instruction_data.extend_from_slice(&amount.to_le_bytes());

        // Erstellen Sie die Anweisung
        let instruction = Instruction {
            program_id: program_id.key(),
            accounts: account_metas,
            data: instruction_data,
        };

        // Anweisung aufrufen
        invoke(&instruction, &[from_pubkey, to_pubkey, program_id])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```ts !! title="Test"
import * as anchor from "@coral-xyz/anchor";
import { BN, Program } from "@coral-xyz/anchor";
import { Cpi } from "../target/types/cpi";
import { Keypair, LAMPORTS_PER_SOL } from "@solana/web3.js";

describe("cpi", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Cpi as Program<Cpi>;
  const sender = provider.wallet as anchor.Wallet;
  const recipient = new Keypair();

  const transferAmount = 0.01 * LAMPORTS_PER_SOL;

  it("SOL Transfer Anchor", async () => {
    const transactionSignature = await program.methods
      .solTransfer(new BN(transferAmount))
      .accounts({
        sender: sender.publicKey,
        recipient: recipient.publicKey
      })
      .rpc();

    console.log(`\nTransaktionssignatur: ${transactionSignature}`);
  });
});
```

</CodeTabs>

### Native Rust

Das folgende Beispiel zeigt, wie man eine CPI aus einem in Native
Rust geschriebenen Programm erstellt. Das Programm enthält eine einzelne Anweisung, die SOL von einem
Konto auf ein anderes über eine CPI überträgt. Die Testdatei verwendet die
[LiteSVM](https://github.com/LiteSVM/litesvm), um das Programm zu testen.

<CodeTabs>

```rs !! title="Beispiel"
use borsh::BorshDeserialize;
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
};

// Deklarieren Sie den Programmanfang
entrypoint!(process_instruction);

// Definieren Sie Programmanweisungen
#[derive(BorshDeserialize)]
enum ProgramInstruction {
    SolTransfer { amount: u64 },
}

impl ProgramInstruction {
    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        Self::try_from_slice(input).map_err(|_| ProgramError::InvalidInstructionData)
    }
}

pub fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Anweisungsdaten deserialisieren
    let instruction = ProgramInstruction::unpack(instruction_data)?;

    // Anweisung verarbeiten
    match instruction {
        ProgramInstruction::SolTransfer { amount } => {
            // Konten analysieren
            let [sender_info, recipient_info, system_program_info] = accounts else {
                return Err(ProgramError::NotEnoughAccountKeys);
            };

            // Überprüfen, ob der Absender ein Unterzeichner ist
            if !sender_info.is_signer {
                return Err(ProgramError::MissingRequiredSignature);
            }

            // Erstellen und die Überweisungsanweisung aufrufen
            let transfer_ix = system_instruction::transfer(
                sender_info.key,
                recipient_info.key,
                amount,
            );

            invoke(
                &transfer_ix,
                &[
                    sender_info.clone(),
                    recipient_info.clone(),
                    system_program_info.clone(),
                ],
            )?;

            Ok(())
        }
    }
}
```

```ts !! title="Test"
import * as path from "path";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from "@solana/web3.js";
import { LiteSVM } from "litesvm";

test("sol transfer cpi", () => {
  const svm = new LiteSVM();

  const programId = PublicKey.unique();
  const programPath = path.join(__dirname, "program.so");
  svm.addProgramFromFile(programId, programPath);

  // Erstellen Sie Absender und Empfänger
  const sender = new Keypair();
  const recipient = new Keypair();

  // Absender finanzieren
  const amount = BigInt(LAMPORTS_PER_SOL);
  svm.airdrop(sender.publicKey, amount); // 1 SOL

  // Erstellen Sie den Anweisungsdatenpuffer
  const transferAmount = amount / BigInt(2); // 0.5 SOL
  const instructionIndex = 0; // Anweisungsindex 0 für SolTransfer-Enum

  const data = Buffer.alloc(9); // 1 Byte für Anweisungs-Enum + 8 Bytes für u64
  data.writeUInt8(instructionIndex, 0); // Das erste Byte identifiziert die Anweisung
  data.writeBigUInt64LE(transferAmount, 1); // Die verbleibenden Bytes sind Anweisungsargumente

  // Erstellen Sie die Anweisung
  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: sender.publicKey, isSigner: true, isWritable: true },
      { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ],
    data
  });

  // Transaktion erstellen und senden
  const transaction = new Transaction().add(instruction);
  transaction.recentBlockhash = svm.latestBlockhash();
  transaction.sign(sender);

  svm.sendTransaction(transaction);

  // Überprüfen Sie die Salden
  const recipientBalance = svm.getBalance(recipient.publicKey);
  const senderBalance = svm.getBalance(sender.publicKey);

  const transactionFee = BigInt(5000);
  expect(recipientBalance).toBe(transferAmount);
  expect(senderBalance).toBe(amount - transferAmount - transactionFee);
});
```

</CodeTabs>

## Cross Program Invocations mit PDA-Signern

Die
[`invoke_signed`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/program.rs#L51-L73)
Funktion behandelt CPIs, die PDA-Signer erfordern. Die Funktion nimmt die Seeds für
deriving signer PDAs als `signer_seeds`.

Sie können die Seite [Program Derived Address](/docs/core/pda) für Details
zum Ableiten von PDAs konsultieren.

```rust title="Invoke Signed"
pub fn invoke_signed(
    instruction: &Instruction,
    account_infos: &[AccountInfo],
    signers_seeds: &[&[&[u8]]],
) -> ProgramResult {
    // --snip--
    invoke_signed_unchecked(instruction, account_infos, signers_seeds)
}
```

Beim Verarbeiten einer Anweisung, die eine CPI enthält, ruft die Solana-Laufzeit
intern die
[`create_program_address`](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/syscalls/cpi.rs#L552)
unter Verwendung der `signers_seeds` und der `program_id` des aufrufenden Programms auf. Wenn ein
gültiger PDA verifiziert wird, wird die Adresse
[als gültiger Unterzeichner hinzugefügt](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/syscalls/cpi.rs#L554).

Die folgenden Beispiele zeigen, wie man eine CPI mit PDA-Signern unter Verwendung des
[Anchor Framework](https://www.anchor-lang.com/docs) und Native Rust erstellt. Die
Beispielprogramme enthalten eine einzelne Anweisung, die SOL von einem PDA auf das
Empfängerkonto überträgt, wobei eine CPI verwendet wird, die vom PDA signiert wird.

### Anchor Framework

Die folgenden Beispiele enthalten drei Ansätze zur Implementierung von Cross Program
Invocations (CPIs) in einem Anchor-Programm, jeweils auf einem anderen Abstraktionsniveau. Alle Beispiele sind funktional äquivalent. Der Hauptzweck besteht darin, die Implementierungsdetails einer CPI zu veranschaulichen.

- Beispiel 1: Verwendet Anchors _rs`CpiContext`_ und eine Hilfsfunktion, um die
  CPI-Anweisung zu konstruieren.
- Beispiel 2: Verwendet die _rs`system_instruction::transfer`_ Funktion aus
  dem `solana_program`-Crate, um die CPI-Anweisung zu konstruieren. Beispiel 1 ist eine
  Abstraktion dieser Implementierung.
- Beispiel 3: Konstruiert die CPI-Anweisung manuell. Dieser Ansatz ist nützlich,
  wenn kein Crate verfügbar ist, um die Anweisung zu erstellen, die Sie aufrufen möchten.

<CodeTabs>

```rs !! title="Beispiel 1"
use anchor_lang::prelude::*;
use anchor_lang::system_program::{transfer, Transfer};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;
        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        let cpi_context = CpiContext::new(
            program_id,
            Transfer {
                from: from_pubkey,
                to: to_pubkey,
            },
        )
        .with_signer(signer_seeds);

        transfer(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Beispiel 2"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke_signed, system_instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;

        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        let instruction =
            &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

        invoke_signed(instruction, &[from_pubkey, to_pubkey, program_id], signer_seeds)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Beispiel 3"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke_signed, instruction::{Instruction, AccountMeta}};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        // Holen Sie sich die PDA-Signer-Seeds
        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;
        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        // Bereiten Sie die Anweisung AccountMetas vor
        let account_metas = vec![
            AccountMeta::new(from_pubkey.key(), true),
            AccountMeta::new(to_pubkey.key(), false),
        ];

        // SOL-Überweisungsanweisungsdiskriminator
        let instruction_discriminator: u32 = 2;

        // Bereiten Sie die Anweisungsdaten vor
        let mut instruction_data = Vec::with_capacity(4 + 8);
        instruction_data.extend_from_slice(&instruction_discriminator.to_le_bytes());
        instruction_data.extend_from_slice(&amount.to_le_bytes());

        // Erstellen Sie die Anweisung
        let instruction = Instruction {
            program_id: program_id.key(),
            accounts: account_metas,
            data: instruction_data,
        };

        // Anweisung mit PDA-Signer aufrufen
        invoke_signed(&instruction, &[from_pubkey, to_pubkey, program_id], signer_seeds)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```ts !! title="Test"
import * as anchor from "@coral-xyz/anchor";

import { BN, Program } from "@coral-xyz/anchor";
import { LAMPORTS_PER_SOL, PublicKey } from "@solana/web3.js";

import { Cpi } from "../target/types/cpi";

describe("cpi", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Cpi as Program<Cpi>;
  const connection = program.provider.connection;
  const wallet = provider.wallet as anchor.Wallet;

  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("pda"), wallet.publicKey.toBuffer()],
    program.programId
  );

  const transferAmount = 0.1 * LAMPORTS_PER_SOL;

  before(async () => {
    // Airdrop anfordern, um PDA zu finanzieren
    const signature = await connection.requestAirdrop(PDA, transferAmount);

    const { blockhash, lastValidBlockHeight } =
      await connection.getLatestBlockhash();

    await connection.confirmTransaction({
      signature,
      blockhash,
      lastValidBlockHeight
    });
  });

  it("SOL Transfer mit PDA-Signer", async () => {
    const transactionSignature = await program.methods
      .solTransfer(new BN(transferAmount))
      .accounts({
        recipient: wallet.publicKey
      })
      .rpc();

    console.log(`\nTransaktionssignatur: ${transactionSignature}`);
  });
});
```

</CodeTabs>

### Native Rust

Das folgende Beispiel zeigt, wie man eine CPI mit PDA-Signern aus einem Programm
schreibt, das in Native Rust geschrieben ist. Das Programm enthält eine einzelne Anweisung, die SOL von einem PDA auf das Empfängerkonto überträgt, wobei eine CPI verwendet wird, die vom PDA signiert wird. Die Testdatei verwendet die [LiteSVM](https://github.com/LiteSVM/litesvm), um das Programm zu testen.

<CodeTabs>

```rs !! title="Beispiel"
use borsh::BorshDeserialize;
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke_signed,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
};

// Deklarieren Sie den Programmanfang
entrypoint!(process_instruction);

// Definieren Sie Programmanweisungen
#[derive(BorshDeserialize)]
enum ProgramInstruction {
    SolTransfer { amount: u64 },
}

impl ProgramInstruction {
    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        Self::try_from_slice(input).map_err(|_| ProgramError::InvalidInstructionData)
    }
}

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Anweisungsdaten deserialisieren
    let instruction = ProgramInstruction::unpack(instruction_data)?;

    // Anweisung verarbeiten
    match instruction {
        ProgramInstruction::SolTransfer { amount } => {
            // Konten analysieren
            let [pda_account_info, recipient_info, system_program_info] = accounts else {
                return Err(ProgramError::NotEnoughAccountKeys);
            };

            // PDA ableiten und überprüfen, ob es mit dem vom Client bereitgestellten Konto übereinstimmt
            let recipient_pubkey = recipient_info.key;
            let seeds = &[b"pda", recipient_pubkey.as_ref()];
            let (expected_pda, bump_seed) = Pubkey::find_program_address(seeds, program_id);

            if expected_pda != *pda_account_info.key {
                return Err(ProgramError::InvalidArgument);
            }

            // Erstellen Sie die Überweisungsanweisung
            let transfer_ix = system_instruction::transfer(
                pda_account_info.key,
                recipient_info.key,
                amount,
            );

            // Erstellen Sie die Signer-Seeds für PDA
            let signer_seeds: &[&[&[u8]]] = &[&[b"pda", recipient_pubkey.as_ref(), &[bump_seed]]];

            // Rufen Sie die Überweisungsanweisung mit PDA als Unterzeichner auf
            invoke_signed(
                &transfer_ix,
                &[
                    pda_account_info.clone(),
                    recipient_info.clone(),
                    system_program_info.clone(),
                ],
                signer_seeds,
            )?;

            Ok(())
        }
    }
}
```

```ts !! title="Test"
import * as path from "path";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from "@solana/web3.js";
import { LiteSVM } from "litesvm";

test("sol transfer cpi mit pda signer", () => {
  const svm = new LiteSVM();

  const programId = PublicKey.unique();
  const programPath = path.join(__dirname, "program.so");
  svm.addProgramFromFile(programId, programPath);

  // Erstellen Sie den Empfänger
  const recipient = new Keypair();

  // PDA ableiten, die Gelder halten und senden wird
  const [pdaAddress] = PublicKey.findProgramAddressSync(
    [Buffer.from("pda"), recipient.publicKey.toBuffer()],
    programId
  );

  // Konten finanzieren
  const amount = BigInt(LAMPORTS_PER_SOL);
  svm.airdrop(recipient.publicKey, amount); // 1 SOL
  svm.airdrop(pdaAddress, amount); // 1 SOL

  // Erstellen Sie den Anweisungsdatenpuffer
  const transferAmount = amount / BigInt(2); // 0.5 SOL
  const instructionIndex = 0; // Anweisungsindex 0 für SolTransfer-Enum

  const data = Buffer.alloc(9); // 1 Byte für Anweisungs-Enum + 8 Bytes für u64
  data.writeUInt8(instructionIndex, 0); // Das erste Byte identifiziert die Anweisung
  data.writeBigUInt64LE(transferAmount, 1); // Die verbleibenden Bytes sind Anweisungsargumente

  // Erstellen Sie die Anweisung
  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: pdaAddress, isSigner: false, isWritable: true },
      { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ],
    data
  });

  // Transaktion erstellen und senden
  const transaction = new Transaction().add(instruction);
  transaction.recentBlockhash = svm.latestBlockhash();
  transaction.sign(recipient);

  svm.sendTransaction(transaction);

  // Überprüfen Sie die Salden
  const recipientBalance = svm.getBalance(recipient.publicKey);
  const pdaBalance = svm.getBalance(pdaAddress);

  const transactionFee = BigInt(5000);
  // Der Empfänger beginnt mit 1 SOL, erhält 0.5 SOL, zahlt Transaktionsgebühr
  expect(recipientBalance).toBe(amount + transferAmount - transactionFee);
  // PDA beginnt mit 1 SOL, sendet 0.5 SOL
  expect(pdaBalance).toBe(amount - transferAmount);
});
```

</CodeTabs>
