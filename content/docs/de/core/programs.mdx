---
title: Programme auf Solana
description:
  Erfahren Sie mehr über Solana-Programme (Smart Contracts) und wie man sie mit
  Rust oder dem Anchor-Framework entwickelt. Verstehen Sie Programm-Deployment,
  Upgrades und Verifizierung im Solana-Netzwerk.
h1: Programme
---

Auf Solana werden "Smart Contracts" als Programme bezeichnet.
[Programme](/docs/core/accounts#program-account) werden auf der Blockchain in
Konten bereitgestellt, die die kompilierte ausführbare Binärdatei des Programms
enthalten. Benutzer interagieren mit Programmen, indem sie Transaktionen mit
[Anweisungen](/docs/core/transactions#instruction) senden, die dem Programm
mitteilen, was zu tun ist.

## Kernpunkte

- Programme sind Konten, die **ausführbaren Code** enthalten, organisiert in
  Funktionen, die als **Anweisungen** bezeichnet werden.
- Während Programme **zustandslos** sind, können sie Anweisungen enthalten, die
  andere Konten erstellen und aktualisieren, um Daten zu speichern.
- Eine **Upgrade-Autorität** kann Programme aktualisieren. Sobald diese
  Autorität entfernt wird, wird das Programm unveränderlich.
- Benutzer können überprüfen, ob die Daten eines Programmkontos auf der
  Blockchain mit seinem öffentlichen Quellcode übereinstimmen, durch
  verifizierbare Builds.

## Solana-Programme schreiben

Solana-Programme werden überwiegend in der
[Rust](https://rust-book.cs.brown.edu/title-page.html)-Programmiersprache
geschrieben, mit zwei gängigen Ansätzen für die Entwicklung:

- [Anchor](https://www.anchor-lang.com/docs): Ein Framework für die Entwicklung
  von Solana- Programmen. Es bietet eine schnellere und einfachere Möglichkeit,
  Programme zu schreiben, indem es Rust-Makros verwendet, um Boilerplate-Code
  erheblich zu reduzieren. Für Anfänger wird empfohlen, mit dem Anchor-Framework
  zu beginnen.

- [Native Rust](/docs/programs/rust): Dieser Ansatz beinhaltet das Schreiben von
  Solana- Programmen in Rust ohne Verwendung von Frameworks. Er bietet mehr
  Flexibilität, bringt aber auch erhöhte Komplexität mit sich.

## Aktualisieren von Solana-Programmen

Um mehr über die Bereitstellung und Aktualisierung von Programmen zu erfahren,
siehe die [Programme bereitstellen](/docs/programs/deploying)-Seite.

Programme auf der Blockchain können

[direkt modifiziert](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L704)

werden durch ein Konto, das als "Upgrade-Autorität" bezeichnet wird,
typischerweise das Konto, das ursprünglich das Programm bereitgestellt hat. Wenn
die

[Upgrade-Autorität](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L894)

widerrufen und auf `None` gesetzt wird, wird das Programm unveränderlich und
kann nicht mehr aktualisiert werden.

## Verifizierbare Programme

Verifizierbare Builds ermöglichen es jedem, zu überprüfen, ob der Code eines
Programms auf der Blockchain mit seinem öffentlichen Quellcode übereinstimmt,
wodurch es möglich wird, Diskrepanzen zwischen Quellcode und bereitgestellten
Versionen zu erkennen.

Die Solana-Entwicklergemeinschaft hat Tools eingeführt, die verifizierbare
Builds unterstützen und es sowohl Entwicklern als auch Benutzern ermöglichen, zu
überprüfen, dass Programme auf der Blockchain genau ihren öffentlich geteilten
Quellcode widerspiegeln.

- **Suche nach verifizierten Programmen**: Um schnell nach verifizierten
  Programmen zu suchen, können Benutzer nach einer Programmadresse im
  [SolanaFM](https://solana.fm/) Explorer suchen und zum Tab "Verification"
  navigieren. Ein Beispiel für ein verifiziertes Programm finden Sie
  [hier](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY).

- **Verifizierungstools**: Das
  [Solana Verifiable Build CLI](https://github.com/Ellipsis-Labs/solana-verifiable-build)
  von Ellipsis Labs ermöglicht es Benutzern, Programme auf der Blockchain
  unabhängig gegen veröffentlichten Quellcode zu verifizieren.

- **Unterstützung für verifizierbare Builds in Anchor**: Anchor bietet
  integrierte Unterstützung für verifizierbare Builds. Details finden Sie in der
  [Anchor-Dokumentation](https://www.anchor-lang.com/docs/verifiable-builds).

## Berkeley Packet Filter (BPF)

Solana verwendet [LLVM](https://llvm.org/), um Programme in
[ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)-Dateien zu
kompilieren. Diese Dateien enthalten Solanas angepasste Version des
[eBPF](https://en.wikipedia.org/wiki/EBPF)-Bytecodes, genannt "Solana Bytecode
Format" (sBPF). Die ELF-Datei enthält den Binärcode des Programms und wird bei
der Bereitstellung des Programms in einem ausführbaren Konto on-chain
gespeichert.

## Integrierte Programme

### Loader-Programme

Jedes Programm selbst gehört einem anderen Programm, seinem Loader. Es gibt
derzeit fünf Loader:

1. Native Loader:

- Programm-ID: `NativeLoader1111111111111111111111111111111`
- Besitzt die anderen vier Loader

2. Loader-v1:

- Programm-ID: `BPFLoader1111111111111111111111111111111111`
- Verwaltungsbefehle sind deaktiviert, aber Programme werden weiterhin
  ausgeführt

3. Loader-v2:

- Programm-ID: `BPFLoader2111111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-loader-v2-interface/latest/solana_loader_v2_interface/enum.LoaderInstruction.html)
- Verwaltungsbefehle sind deaktiviert, aber Programme werden weiterhin
  ausgeführt

4. Loader-v3:

- Programm-ID: `BPFLoaderUpgradeab1e11111111111111111111111`
- [Anweisungen](https://docs.rs/solana-loader-v3-interface/latest/solana_loader_v3_interface/instruction/enum.UpgradeableLoaderInstruction.html)
- Wird schrittweise eingestellt

5. Loader-v4:

- Programm-ID: `LoaderV411111111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-loader-v4-interface/latest/solana_loader_v4_interface/instruction/enum.LoaderV4Instruction.html)
- Wird zum Standard-Loader werden

Diese Loader sind notwendig, um benutzerdefinierte Programme zu erstellen und zu
verwalten:

- Bereitstellung eines neuen Programms oder Puffers
- Schließen eines Programms oder Puffers
- Erneute Bereitstellung / Aktualisierung eines bestehenden Programms
- Übertragung der Autorität über ein Programm
- Finalisierung eines Programms

Loader-v3 und Loader-v4 unterstützen Änderungen an Programmen nach ihrer ersten
Bereitstellung. Die Berechtigung dazu wird durch die Autorität eines Programms
geregelt, da die Kontoinhaberschaft jedes Programms beim Loader liegt.

### Vorkompilierte Programme

#### Ed25519-Programm

Das Programm zur Überprüfung von Ed25519-Signaturen. Es nimmt eine
Ed25519-Signatur, einen öffentlichen Schlüssel und eine Nachricht entgegen.
Mehrere Signaturen können überprüft werden. Wenn eine der Signaturen nicht
verifiziert werden kann, wird ein Fehler zurückgegeben.

- Programm-ID: `Ed25519SigVerify111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-ed25519-program/latest/solana_ed25519_program/index.html)

Das Ed25519-Programm verarbeitet eine Anweisung. Das erste `u8` ist eine Anzahl
der zu überprüfenden Signaturen, gefolgt von einem einzelnen Byte Padding.
Danach wird die folgende Struktur serialisiert, eine für jede zu überprüfende
Signatur.

```
struct Ed25519SignatureOffsets {
    signature_offset: u16,             // Offset zur Ed25519-Signatur von 64 Bytes
    signature_instruction_index: u16,  // Anweisungsindex zum Finden der Signatur
    public_key_offset: u16,            // Offset zum öffentlichen Schlüssel von 32 Bytes
    public_key_instruction_index: u16, // Anweisungsindex zum Finden des öffentlichen Schlüssels
    message_data_offset: u16,          // Offset zum Beginn der Nachrichtendaten
    message_data_size: u16,            // Größe der Nachrichtendaten
    message_instruction_index: u16,    // Index der Anweisungsdaten zum Abrufen der Nachrichtendaten
}
```

Der Pseudocode der Signaturüberprüfung:

```
process_instruction() {
    for i in 0..count {
        // i-te Indexwerte referenziert:
        instructions = &transaction.message().instructions
        instruction_index = ed25519_signature_instruction_index != u16::MAX ? ed25519_signature_instruction_index : current_instruction;
        signature = instructions[instruction_index].data[ed25519_signature_offset..ed25519_signature_offset + 64]
        instruction_index = ed25519_pubkey_instruction_index != u16::MAX ? ed25519_pubkey_instruction_index : current_instruction;
        pubkey = instructions[instruction_index].data[ed25519_pubkey_offset..ed25519_pubkey_offset + 32]
        instruction_index = ed25519_message_instruction_index != u16::MAX ? ed25519_message_instruction_index : current_instruction;
        message = instructions[instruction_index].data[ed25519_message_data_offset..ed25519_message_data_offset + ed25519_message_data_size]
        if pubkey.verify(signature, message) != Success {
            return Error
        }
    }
    return Success
}
```

#### Secp256k1-Programm

Verifiziert secp256k1 Public-Key-Recovery-Operationen (ecrecover).

- Programm-ID: `KeccakSecp256k11111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-secp256k1-program/latest/solana_secp256k1_program/index.html)

Das secp256k1-Programm verarbeitet eine Anweisung, die als erstes Byte eine
Anzahl der folgenden, in den Anweisungsdaten serialisierten Struktur enthält:

```
struct Secp256k1SignatureOffsets {
    secp_signature_offset: u16,            // Offset zur [Signatur,recovery_id] von 64+1 Bytes
    secp_signature_instruction_index: u8,  // Anweisungsindex zum Finden der Signatur
    secp_pubkey_offset: u16,               // Offset zum ethereum_address pubkey von 20 Bytes
    secp_pubkey_instruction_index: u8,     // Anweisungsindex zum Finden des Pubkeys
    secp_message_data_offset: u16,         // Offset zum Beginn der Nachrichtendaten
    secp_message_data_size: u16,           // Größe der Nachrichtendaten
    secp_message_instruction_index: u8,    // Anweisungsindex zum Finden der Nachrichtendaten
}
```

Der Pseudocode der Recovery-Verifizierung:

```
process_instruction() {
  for i in 0..count {
      // i-te Indexwerte referenziert:
      instructions = &transaction.message().instructions
      signature = instructions[secp_signature_instruction_index].data[secp_signature_offset..secp_signature_offset + 64]
      recovery_id = instructions[secp_signature_instruction_index].data[secp_signature_offset + 64]
      ref_eth_pubkey = instructions[secp_pubkey_instruction_index].data[secp_pubkey_offset..secp_pubkey_offset + 20]
      message_hash = keccak256(instructions[secp_message_instruction_index].data[secp_message_data_offset..secp_message_data_offset + secp_message_data_size])
      pubkey = ecrecover(signature, recovery_id, message_hash)
      eth_pubkey = keccak256(pubkey[1..])[12..]
      if eth_pubkey != ref_eth_pubkey {
          return Error
      }
  }
  return Success
}
```

Dies ermöglicht dem Benutzer, beliebige Anweisungsdaten in der Transaktion für
Signatur- und Nachrichtendaten anzugeben. Durch Angabe einer speziellen
Instructions-Sysvar kann man auch Daten aus der Transaktion selbst empfangen.

Die Kosten der Transaktion werden durch die Anzahl der zu verifizierenden
Signaturen multipliziert mit dem Signaturkosten-Verifizierungsmultiplikator
berechnet.

#### Secp256r1-Programm

Das Programm zur Verifizierung von secp256r1-Signaturen. Es nimmt eine
secp256r1-Signatur, einen öffentlichen Schlüssel und eine Nachricht entgegen.
Bis zu 8 Signaturen können verifiziert werden. Wenn eine der Signaturen nicht
verifiziert werden kann, wird ein Fehler zurückgegeben.

- Programm-ID: `Secp256r1SigVerify1111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-secp256k1-recover/latest/solana_secp256k1_recover/index.html)

Das secp256r1-Programm verarbeitet eine Anweisung. Das erste `u8` ist eine
Anzahl der zu prüfenden Signaturen, gefolgt von einem einzelnen Byte Padding.
Danach wird die folgende Struktur serialisiert, eine für jede zu prüfende
Signatur:

```rust
struct Secp256r1SignatureOffsets {
    signature_offset: u16,             // Offset zur kompakten secp256r1-Signatur von 64 Bytes
    signature_instruction_index: u16,  // Anweisungsindex zum Finden der Signatur
    public_key_offset: u16,            // Offset zum komprimierten öffentlichen Schlüssel von 33 Bytes
    public_key_instruction_index: u16, // Anweisungsindex zum Finden des öffentlichen Schlüssels
    message_data_offset: u16,          // Offset zum Beginn der Nachrichtendaten
    message_data_size: u16,            // Größe der Nachrichtendaten
    message_instruction_index: u16,    // Index der Anweisungsdaten zum Abrufen der Nachrichtendaten
}

```

Der Pseudocode der Signaturverifizierung:

```
process_instruction() {
    if data.len() < SIGNATURE_OFFSETS_START {
        return Error
    }

    num_signatures = data[0] as usize
    if num_signatures == 0 || num_signatures > 8 {
        return Error
    }

    expected_data_size = num_signatures * SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START
    if data.len() < expected_data_size {
        return Error
    }

    for i in 0..num_signatures {
        offsets = parse_signature_offsets(data, i)

        signature = get_data_slice(data, instruction_datas, offsets.signature_instruction_index, offsets.signature_offset, SIGNATURE_SERIALIZED_SIZE)

        if s > half_curve_order {
            return Error
        }

        pubkey = get_data_slice(data, instruction_datas, offsets.public_key_instruction_index, offsets.public_key_offset, COMPRESSED_PUBKEY_SERIALIZED_SIZE)

        message = get_data_slice(data, instruction_datas, offsets.message_instruction_index, offsets.message_data_offset, offsets.message_data_size)

        if !verify_signature(signature, pubkey, message) {
            return Error
        }
    }

    return Success
}
```

Hinweis: Niedrige S-Werte werden für alle Signaturen erzwungen, um
versehentliche Signaturveränderbarkeit zu vermeiden.

### Kernprogramme

Die Solana-Cluster-Genesis enthält eine Liste spezieller Programme, die
verschiedene Kernfunktionalitäten für das Netzwerk bereitstellen. Historisch
wurden diese als "native" Programme bezeichnet und wurden früher zusammen mit
dem Validator-Code verteilt.

1. System-Programm

- Programm-ID: `11111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html)
- Erstellt neue Konten, weist Kontendaten zu, ordnet Konten den besitzenden
  Programmen zu, überträgt Lamports von System-Programm-eigenen Konten und zahlt
  Transaktionsgebühren.

2. Vote-Programm

- Programm-ID: `Vote111111111111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-vote-program/latest/solana_vote_program/vote_instruction/enum.VoteInstruction.html)
- Erstellt und verwaltet Konten, die den Abstimmungsstatus und die Belohnungen
  des Validators verfolgen.

3. Stake-Programm

- Programm-ID: `Stake11111111111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-sdk/latest/solana_sdk/stake/instruction/enum.StakeInstruction.html)
- Erstellt und verwaltet Konten, die Einsätze und Belohnungen für Delegationen
  an Validatoren darstellen.

4. Config-Programm

- Programm-ID: `Config1111111111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-config-program/latest/solana_config_program/config_instruction/index.html)
- Fügt Konfigurationsdaten zur Chain hinzu, gefolgt von der Liste der
  öffentlichen Schlüssel, die zu deren Änderung berechtigt sind. Im Gegensatz zu
  den anderen Programmen definiert das Config-Programm keine einzelnen
  Anweisungen. Es hat nur eine implizite Anweisung: "store". Seine
  Anweisungsdaten sind eine Reihe von Schlüsseln, die den Zugriff auf das Konto
  regeln, und die Daten, die darin gespeichert werden sollen.

5. Compute Budget-Programm

- Programm-ID: `ComputeBudget111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-compute-budget-interface/latest/solana_compute_budget_interface/enum.ComputeBudgetInstruction.html)

6. Address Lookup Table-Programm

- Programm-ID: `AddressLookupTab1e1111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-sdk/latest/solana_sdk/address_lookup_table/instruction/enum.ProgramInstruction.html)

7. Zk Token Proof-Programm

- Programm-ID: `ZkTokenProof1111111111111111111111111111111`

8. Zk Elgamal Proof-Programm

- Programm-ID: `ZkE1Gama1Proof11111111111111111111111111111`
