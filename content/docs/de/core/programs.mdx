---
title: Programme auf Solana
description:
  Erfahren Sie mehr über Solana-Programme (Smart Contracts) und wie Sie diese mit
  Rust oder dem Anchor-Framework entwickeln können. Verstehen Sie die Bereitstellung,
  Aktualisierungen und die Überprüfung von Programmen im Solana-Netzwerk.
h1: Programme
---

Auf Solana werden "Smart Contracts" als Programme bezeichnet.
[Programme](/docs/core/accounts#program-account) werden on-chain auf
Konten bereitgestellt, die die kompilierte ausführbare Binärdatei des Programms enthalten.
Benutzer interagieren mit Programmen, indem sie Transaktionen senden, die
[Anweisungen](/docs/core/transactions#instruction) enthalten, die dem Programm sagen,
was es tun soll.

## Wichtige Punkte

- Programme sind Konten, die **ausführbaren Code** enthalten, der in Funktionen
  organisiert ist, die **Anweisungen** genannt werden.
- Während Programme **zustandslos** sind, können sie Anweisungen enthalten, die
  andere Konten erstellen und aktualisieren, um Daten zu speichern.
- Eine **Upgrade-Behörde** kann Programme aktualisieren. Sobald diese Behörde entfernt
  wird, wird das Programm unveränderlich.
- Benutzer können überprüfen, ob die Daten eines on-chain Programmkontos mit dem
  öffentlichen Quellcode übereinstimmen, durch überprüfbare Builds.

## Schreiben von Solana-Programmen

Solana-Programme werden überwiegend in der
[Rust](https://rust-book.cs.brown.edu/title-page.html) Programmiersprache geschrieben,
mit zwei gängigen Ansätzen für die Entwicklung:

- [Anchor](https://www.anchor-lang.com/docs): Ein Framework, das für die Entwicklung
  von Solana-Programmen konzipiert wurde. Es bietet eine schnellere und einfachere
  Möglichkeit, Programme zu schreiben, indem Rust-Makros verwendet werden, um den
  Boilerplate-Code erheblich zu reduzieren. Für Anfänger wird empfohlen, mit dem
  Anchor-Framework zu beginnen.

- [Native Rust](/docs/programs/rust): Dieser Ansatz beinhaltet das Schreiben von
  Solana-Programmen in Rust, ohne auf Frameworks zurückzugreifen. Es bietet mehr
  Flexibilität, geht jedoch mit einer erhöhten Komplexität einher.

## Aktualisieren von Solana-Programmen

Um mehr über die Bereitstellung und Aktualisierung von Programmen zu erfahren, siehe
  die Seite [Programme bereitstellen](/docs/programs/deploying).

On-chain Programme können
[direkt modifiziert](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L704)
werden von einem Konto, das als "Upgrade-Behörde" bezeichnet wird, das typischerweise das
Konto ist, das das Programm ursprünglich bereitgestellt hat. Wenn die
[Upgrade-Behörde](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L894)
widerrufen und auf `None` gesetzt wird, wird das Programm unveränderlich und kann nicht
mehr aktualisiert werden.

## Überprüfbare Programme

Überprüfbare Builds ermöglichen es jedem, zu überprüfen, ob der on-chain Code eines
Programms mit seinem öffentlichen Quellcode übereinstimmt, wodurch es möglich wird,
Abweichungen zwischen Quell- und bereitgestellten Versionen zu erkennen.

Die Solana-Entwicklergemeinschaft hat Werkzeuge eingeführt, um überprüfbare
Builds zu unterstützen, die es sowohl Entwicklern als auch Benutzern ermöglichen,
zu überprüfen, dass on-chain Programme ihren öffentlich geteilten Quellcode genau
widerspiegeln.

- **Suche nach verifizierten Programmen**: Um schnell nach verifizierten Programmen zu
  suchen, können Benutzer eine Programmadresse im [SolanaFM](https://solana.fm/)
  Explorer suchen und zum Tab "Verifizierung" navigieren. Sehen Sie ein Beispiel für ein
  verifiziertes Programm
  [hier](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY).

- **Verifizierungstools**: Das
  [Solana Verifiable Build CLI](https://github.com/Ellipsis-Labs/solana-verifiable-build)
  von Ellipsis Labs ermöglicht es Benutzern, on-chain Programme unabhängig gegen
  veröffentlichten Quellcode zu überprüfen.

- **Unterstützung für überprüfbare Builds in Anchor**: Anchor bietet integrierte
  Unterstützung für überprüfbare Builds. Details finden Sie in der
  [Anchor-Dokumentation](https://www.anchor-lang.com/docs/verifiable-builds).

## Berkeley Packet Filter (BPF)

Solana verwendet [LLVM](https://llvm.org/), um Programme in
[ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) Dateien zu
kompilieren. Diese Dateien enthalten Solanas benutzerdefinierte Version von
[eBPF](https://en.wikipedia.org/wiki/EBPF) Bytecode, der als "Solana Bytecode
Format" (sBPF) bezeichnet wird. Die ELF-Datei enthält die Binärdatei des Programms
und wird on-chain in einem ausführbaren Konto gespeichert, wenn das Programm bereitgestellt
wird.

## Eingebaute Programme

### Loader-Programme

Jedes Programm selbst wird von einem anderen Programm, dem Loader, besessen. Es
gibt derzeit fünf Loader:

1. native loader:

  - Programm-ID: `NativeLoader1111111111111111111111111111111`
  - Besitzt die anderen vier Loader

2. loader-v1:

  - Programm-ID: `BPFLoader1111111111111111111111111111111111`
  - Verwaltungsanweisungen sind deaktiviert, aber Programme werden weiterhin ausgeführt

3. loader-v2:

  - Programm-ID: `BPFLoader2111111111111111111111111111111111`
  - [Anweisungen](https://docs.rs/solana-loader-v2-interface/latest/solana_loader_v2_interface/enum.LoaderInstruction.html)
  - Verwaltungsanweisungen sind deaktiviert, aber Programme werden weiterhin ausgeführt

4. loader-v3:

  - Programm-ID: `BPFLoaderUpgradeab1e11111111111111111111111`
  - [Anweisungen](https://docs.rs/solana-loader-v3-interface/latest/solana_loader_v3_interface/instruction/enum.UpgradeableLoaderInstruction.html)
  - Wird schrittweise eingestellt

5. loader-v4:

  - Programm-ID: `LoaderV411111111111111111111111111111111111`
  - [Anweisungen](https://docs.rs/solana-loader-v4-interface/latest/solana_loader_v4_interface/instruction/enum.LoaderV4Instruction.html)
  - Wird der Standard-Loader

Diese Loader sind notwendig, um benutzerdefinierte Programme zu erstellen und zu
verwalten:

- Ein neues Programm oder einen Puffer bereitstellen
- Ein Programm oder einen Puffer schließen
- Ein bestehendes Programm neu bereitstellen / aktualisieren
- Die Autorität über ein Programm übertragen
- Ein Programm abschließen

Loader-v3 und loader-v4 unterstützen Änderungen an Programmen nach ihrer ursprünglichen
Bereitstellung. Die Erlaubnis dazu wird durch die Autorität eines Programms geregelt,
weil das Kontobesitz jedes Programms beim Loader liegt.

### Vorgefertigte Programme

#### Ed25519-Programm

Das Programm zur Überprüfung von Ed25519-Signaturen. Es nimmt eine Ed25519-Signatur,
einen öffentlichen Schlüssel und eine Nachricht entgegen.
Mehrere Signaturen können überprüft werden. Wenn eine der Signaturen nicht
überprüft werden kann, wird ein Fehler zurückgegeben.

- Programm-ID: `Ed25519SigVerify111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-ed25519-program/latest/solana_ed25519_program/index.html)

Das Ed25519-Programm verarbeitet eine Anweisung. Das erste `u8` ist eine Zählung der
Anzahl der Signaturen, die überprüft werden sollen, gefolgt von einem einzelnen Byte-Padding.
Danach wird die folgende Struktur serialisiert, eine für jede zu überprüfende Signatur.

```
struct Ed25519SignatureOffsets {
    signature_offset: u16,             // Offset zur Ed25519-Signatur von 64 Bytes
    signature_instruction_index: u16,  // Anweisungsindex zur Auffindung der Signatur
    public_key_offset: u16,            // Offset zum öffentlichen Schlüssel von 32 Bytes
    public_key_instruction_index: u16, // Anweisungsindex zur Auffindung des öffentlichen Schlüssels
    message_data_offset: u16,          // Offset zum Beginn der Nachrichtendaten
    message_data_size: u16,            // Größe der Nachrichtendaten
    message_instruction_index: u16,    // Index der Anweisungsdaten zur Abrufung der Nachrichtendaten
}
```

Der Pseudocode der Signaturüberprüfung:

```
process_instruction() {
    for i in 0..count {
        // i'th Indexwerte referenziert:
        instructions = &transaction.message().instructions
        instruction_index = ed25519_signature_instruction_index != u16::MAX ? ed25519_signature_instruction_index : current_instruction;
        signature = instructions[instruction_index].data[ed25519_signature_offset..ed25519_signature_offset + 64]
        instruction_index = ed25519_pubkey_instruction_index != u16::MAX ? ed25519_pubkey_instruction_index : current_instruction;
        pubkey = instructions[instruction_index].data[ed25519_pubkey_offset..ed25519_pubkey_offset + 32]
        instruction_index = ed25519_message_instruction_index != u16::MAX ? ed25519_message_instruction_index : current_instruction;
        message = instructions[instruction_index].data[ed25519_message_data_offset..ed25519_message_data_offset + ed25519_message_data_size]
        if pubkey.verify(signature, message) != Success {
            return Error
        }
    }
    return Success
}
```

#### Secp256k1-Programm

Überprüfen Sie die secp256k1-Operationen zur Wiederherstellung des öffentlichen Schlüssels (ecrecover).

- Programm-ID: `KeccakSecp256k11111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-secp256k1-program/latest/solana_secp256k1_program/index.html)

Das secp256k1-Programm verarbeitet eine Anweisung, die als erstes Byte eine Zählung der
folgenden Struktur enthält, die in den Anweisungsdaten serialisiert ist:

```
struct Secp256k1SignatureOffsets {
    secp_signature_offset: u16,            // Offset zu [signature,recovery_id] von 64+1 Bytes
    secp_signature_instruction_index: u8,  // Anweisungsindex zur Auffindung der Signatur
    secp_pubkey_offset: u16,               // Offset zum Ethereum-Adresse-Publikums-Schlüssel von 20 Bytes
    secp_pubkey_instruction_index: u8,     // Anweisungsindex zur Auffindung des öffentlichen Schlüssels
    secp_message_data_offset: u16,         // Offset zum Beginn der Nachrichtendaten
    secp_message_data_size: u16,           // Größe der Nachrichtendaten
    secp_message_instruction_index: u8,    // Anweisungsindex zur Auffindung der Nachrichtendaten
}
```

Der Pseudocode der Wiederherstellungsüberprüfung:

```
process_instruction() {
  for i in 0..count {
      // i'th Indexwerte referenziert:
      instructions = &transaction.message().instructions
      signature = instructions[secp_signature_instruction_index].data[secp_signature_offset..secp_signature_offset + 64]
      recovery_id = instructions[secp_signature_instruction_index].data[secp_signature_offset + 64]
      ref_eth_pubkey = instructions[secp_pubkey_instruction_index].data[secp_pubkey_offset..secp_pubkey_offset + 20]
      message_hash = keccak256(instructions[secp_message_instruction_index].data[secp_message_data_offset..secp_message_data_offset + secp_message_data_size])
      pubkey = ecrecover(signature, recovery_id, message_hash)
      eth_pubkey = keccak256(pubkey[1..])[12..]
      if eth_pubkey != ref_eth_pubkey {
          return Error
      }
  }
  return Success
}
```

Dies ermöglicht es dem Benutzer, beliebige Anweisungsdaten in der Transaktion für
Signatur- und Nachrichtendaten anzugeben. Durch die Angabe einer speziellen Anweisungs-Sysvar
kann man auch Daten aus der Transaktion selbst empfangen.

Die Kosten der Transaktion zählen die Anzahl der zu überprüfenden Signaturen multipliziert
mit dem Kostenmultiplikator für die Signaturüberprüfung.

#### Secp256r1-Programm

Das Programm zur Überprüfung von secp256r1-Signaturen. Es nimmt eine secp256r1-Signatur,
einen öffentlichen Schlüssel und eine Nachricht entgegen. Bis zu 8 Signaturen können überprüft
werden. Wenn eine der Signaturen nicht überprüft werden kann, wird ein Fehler zurückgegeben.

- Programm-ID: `Secp256r1SigVerify1111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-secp256k1-recover/latest/solana_secp256k1_recover/index.html)

Das secp256r1-Programm verarbeitet eine Anweisung. Das erste `u8` ist eine Zählung der Anzahl der
Signaturen, die überprüft werden sollen, gefolgt von einem einzelnen Byte-Padding. Danach wird die
folgende Struktur serialisiert, eine für jede zu überprüfende Signatur:

```rust
struct Secp256r1SignatureOffsets {
    signature_offset: u16,             // Offset zur kompakten secp256r1-Signatur von 64 Bytes
    signature_instruction_index: u16,  // Anweisungsindex zur Auffindung der Signatur
    public_key_offset: u16,            // Offset zum komprimierten öffentlichen Schlüssel von 33 Bytes
    public_key_instruction_index: u16, // Anweisungsindex zur Auffindung des öffentlichen Schlüssels
    message_data_offset: u16,          // Offset zum Beginn der Nachrichtendaten
    message_data_size: u16,            // Größe der Nachrichtendaten
    message_instruction_index: u16,    // Index der Anweisungsdaten zur Abrufung der Nachrichtendaten
}

```

Der Pseudocode der Signaturüberprüfung:
```
process_instruction() {
    if data.len() < SIGNATURE_OFFSETS_START {
        return Error
    }

    num_signatures = data[0] as usize
    if num_signatures == 0 || num_signatures > 8 {
        return Error
    }

    expected_data_size = num_signatures * SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START
    if data.len() < expected_data_size {
        return Error
    }

    for i in 0..num_signatures {
        offsets = parse_signature_offsets(data, i)

        signature = get_data_slice(data, instruction_datas, offsets.signature_instruction_index, offsets.signature_offset, SIGNATURE_SERIALIZED_SIZE)

        if s > half_curve_order {
            return Error
        }

        pubkey = get_data_slice(data, instruction_datas, offsets.public_key_instruction_index, offsets.public_key_offset, COMPRESSED_PUBKEY_SERIALIZED_SIZE)

        message = get_data_slice(data, instruction_datas, offsets.message_instruction_index, offsets.message_data_offset, offsets.message_data_size)

        if !verify_signature(signature, pubkey, message) {
            return Error
        }
    }

    return Success
}
```
Hinweis: Niedrige S-Werte werden für alle Signaturen durchgesetzt, um versehentliche Signaturmalleabilität zu vermeiden.

### Kernprogramme

Der Genesis des Solana-Clusters umfasst eine Liste spezieller Programme, die
verschiedene Kernfunktionen für das Netzwerk bereitstellen. Historisch wurden diese als
"native" Programme bezeichnet und wurden zusammen mit dem Validator-Code verteilt.

1. Systemprogramm

- Programm-ID: `11111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html)
- Erstellen neuer Konten, Zuweisen von Kontodaten, Zuweisen von Konten an besitzende
Programme, Übertragen von Lamports von Systemprogramm-eigenen Konten und Bezahlen
von Transaktionsgebühren.

2. Abstimmungsprogramm

- Programm-ID: `Vote111111111111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-vote-program/latest/solana_vote_program/vote_instruction/enum.VoteInstruction.html)
- Erstellen und Verwalten von Konten, die den Abstimmungsstatus und die Belohnungen
von Validatoren verfolgen.

3. Stake-Programm

- Programm-ID: `Stake11111111111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-sdk/latest/solana_sdk/stake/instruction/enum.StakeInstruction.html)
- Erstellen und Verwalten von Konten, die Stake und Belohnungen für Delegationen an
Validatoren darstellen.

4. Konfigurationsprogramm

- Programm-ID: `Config1111111111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-config-program/latest/solana_config_program/config_instruction/index.html)
- Hinzufügen von Konfigurationsdaten zur Kette, gefolgt von der Liste der öffentlichen
Schlüssel, die berechtigt sind, diese zu ändern. Im Gegensatz zu den anderen Programmen
definiert das Konfigurationsprogramm keine einzelnen Anweisungen. Es hat nur eine
implizite Anweisung: "speichern". Ihre Anweisungsdaten sind eine Menge von Schlüsseln,
die den Zugriff auf das Konto und die darin zu speichernden Daten steuern.

5. Compute Budget Programm

- Programm-ID: `ComputeBudget111111111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-compute-budget-interface/latest/solana_compute_budget_interface/enum.ComputeBudgetInstruction.html)

6. Adressensuchtabellenprogramm

- Programm-ID: `AddressLookupTab1e1111111111111111111111111`
- [Anweisungen](https://docs.rs/solana-sdk/latest/solana_sdk/address_lookup_table/instruction/enum.ProgramInstruction.html)

7. Zk Token Proof Programm

- Programm-ID: `ZkTokenProof1111111111111111111111111111111`

8. Zk Elgamal Proof Programm

- Programm-ID: `ZkE1Gama1Proof11111111111111111111111111111`
