---
title: هيكل البرنامج
description:
  تعلم كيفية هيكلة برامج سولانا في لغة Rust، بما في ذلك نقاط الدخول، وإدارة
  الحالة، ومعالجة التعليمات، والاختبار.
h1: هيكل برنامج Rust
---

تتمتع برامج سولانا المكتوبة بلغة Rust بمتطلبات هيكلية بسيطة، مما يتيح المرونة في
تنظيم الشفرة. المتطلب الوحيد هو أن البرنامج يجب أن يحتوي على `entrypoint`، الذي
يحدد نقطة بداية تنفيذ البرنامج.

## هيكل البرنامج

على الرغم من عدم وجود قواعد صارمة لهيكل الملفات، فإن برامج سولانا عادة ما تتبع
نمطًا شائعًا:

- `entrypoint.rs`: يحدد نقطة الدخول التي توجه التعليمات الواردة.
- `state.rs`: تحدد حالة البرنامج المحددة (بيانات الحساب).
- `instructions.rs`: تحدد التعليمات التي يمكن للبرنامج تنفيذها.
- `processor.rs`: تحدد معالجات التعليمات (الوظائف) التي تنفذ المنطق التجاري لكل
  تعليمة.
- `error.rs`: تحدد الأخطاء المخصصة التي يمكن للبرنامج إرجاعها.

يمكنك العثور على أمثلة في
[مكتبة برامج سولانا](https://github.com/solana-program/token/tree/main/program/src).

## مثال على البرنامج

لتوضيح كيفية بناء برنامج Rust أصلي مع تعليمات متعددة، سنشرح برنامج عداد بسيط
ينفذ تعليمتين:

1. `InitializeCounter`: ينشئ ويهيئ حسابًا جديدًا بقيمة أولية.
2. `IncrementCounter`: يزيد القيمة المخزنة في حساب موجود.

للتبسيط، سيتم تنفيذ البرنامج في ملف `lib.rs` واحد، على الرغم من أنه في الممارسة
العملية قد ترغب في تقسيم البرامج الأكبر إلى ملفات متعددة.

<Accordions>
<Accordion title="شفرة البرنامج الكاملة">

```rs title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

// Program entrypoint
entrypoint!(process_instruction);

// Function to route instructions to the correct handler
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Unpack instruction data
    let instruction = CounterInstruction::unpack(instruction_data)?;

    // Match instruction type
    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => process_increment_counter(program_id, accounts)?,
    };
    Ok(())
}

// Instructions that our program can execute
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 }, // variant 0
    IncrementCounter,                         // variant 1
}

impl CounterInstruction {
    pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        // Get the instruction variant from the first byte
        let (&variant, rest) = input
            .split_first()
            .ok_or(ProgramError::InvalidInstructionData)?;

        // Match instruction type and parse the remaining bytes based on the variant
        match variant {
            0 => {
                // For InitializeCounter, parse a u64 from the remaining bytes
                let initial_value = u64::from_le_bytes(
                    rest.try_into()
                        .map_err(|_| ProgramError::InvalidInstructionData)?,
                );
                Ok(Self::InitializeCounter { initial_value })
            }
            1 => Ok(Self::IncrementCounter), // No additional data needed
            _ => Err(ProgramError::InvalidInstructionData),
        }
    }
}

// Initialize a new counter account
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // Size in bytes to store a u64

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for the new account
            counter_account.key,  // Account to be created
            required_lamports,    // Amount of lamports to transfer to the new account
            account_space as u64, // Size in bytes to allocate for the data field
            program_id,           // Set program owner to our program
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Create a new CounterAccount struct with the initial value
    let counter_data = CounterAccount {
        count: initial_value,
    };

    // Get a mutable reference to the counter account's data
    let mut account_data = &mut counter_account.data.borrow_mut()[..];

    // Serialize the CounterAccount struct into the account's data
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}

// Update an existing counter's value
fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify account ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Mutable borrow the account data
    let mut data = counter_account.data.borrow_mut();

    // Deserialize the account data into our CounterAccount struct
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    // Increment the counter value
    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    // Serialize the updated counter data back into the account
    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);
    Ok(())
}

// Struct representing our counter account's data
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    count: u64,
}

#[cfg(test)]
mod test {
    use super::*;
    use solana_program_test::*;
    use solana_sdk::{
        instruction::{AccountMeta, Instruction},
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[tokio::test]
    async fn test_counter_program() {
        let program_id = Pubkey::new_unique();
        let (mut banks_client, payer, recent_blockhash) = ProgramTest::new(
            "counter_program",
            program_id,
            processor!(process_instruction),
        )
        .start()
        .await;

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Create initialization instruction
        let mut init_instruction_data = vec![0]; // 0 = initialize instruction
        init_instruction_data.extend_from_slice(&initial_value.to_le_bytes());

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Send transaction with initialize instruction
        let mut transaction =
            Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 42);
            println!(
                "✅ Counter initialized successfully with value: {}",
                counter.count
            );
        }

        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Create increment instruction
        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &[1], // 1 = increment instruction
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Send transaction with increment instruction
        let mut transaction =
            Transaction::new_with_payer(&[increment_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 43);
            println!("✅ Counter incremented successfully to: {}", counter.count);
        }
    }
}
```

```toml title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
borsh = "1.5.1"
solana-program = "1.18.26"

[dev-dependencies]
solana-program-test = "1.18.26"
solana-sdk = "1.18.26"
tokio = "1.41.0"
```

</Accordion>
</Accordions>

<Steps>
<Step>

### إنشاء برنامج جديد

أولاً، قم بإنشاء مشروع Rust جديد باستخدام أمر `cargo init` القياسي مع خيار
`--lib`.

```shell title="Terminal"
cargo init counter_program --lib
```

انتقل إلى دليل المشروع. يجب أن ترى ملفات `src/lib.rs` و `Cargo.toml` الافتراضية

```shell title="Terminal"
cd counter_program
```

بعد ذلك، أضف تبعية `solana-program`. هذه هي الحد الأدنى من التبعيات المطلوبة
لبناء برنامج سولانا.

```shell title="Terminal"
cargo add solana-program@1.18.26
```

بعد ذلك، أضف المقتطف التالي إلى `Cargo.toml`. إذا لم تقم بتضمين هذا الإعداد، فلن
يتم إنشاء دليل `target/deploy` عند بناء البرنامج.

```toml title="Cargo.toml"
[lib]
crate-type = ["cdylib", "lib"]
```

يجب أن يبدو ملف `Cargo.toml` الخاص بك كما يلي:

```toml title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
solana-program = "1.18.26"
```

</Step>
<Step>

### نقطة دخول البرنامج

نقطة دخول برنامج سولانا هي الوظيفة التي يتم استدعاؤها عند تشغيل البرنامج. تحتوي
نقطة الدخول على التعريف الأولي التالي ويتمتع المطورون بحرية إنشاء تنفيذهم الخاص
لوظيفة نقطة الدخول.

للتبسيط، استخدم وحدة الماكرو
[`entrypoint!`](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/entrypoint.rs#L124-L140)
من حزمة `solana_program` لتحديد نقطة الدخول في برنامجك.

```rs
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64;
```

استبدل الكود الافتراضي في `lib.rs` بالكود التالي. هذا المقتطف:

1. يستورد التبعيات المطلوبة من `solana_program`
2. يحدد نقطة دخول البرنامج باستخدام وحدة الماكرو `entrypoint!`
3. ينفذ وظيفة `process_instruction` التي ستوجه التعليمات إلى وظائف المعالجة
   المناسبة

```rs title="lib.rs" {13} /process_instruction/
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Your program logic
    Ok(())
}
```

تتطلب وحدة الماكرو `entrypoint!` وظيفة ذات
[توقيع النوع](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/entrypoint.rs#L28-L29)
التالي كوسيط:

```rs
pub type ProcessInstruction =
    fn(program_id: &Pubkey, accounts: &[AccountInfo], instruction_data: &[u8]) -> ProgramResult;
```

عند استدعاء برنامج سولانا، تقوم نقطة الدخول
[بفك تسلسل](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/entrypoint.rs#L277)
[بيانات الإدخال](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/entrypoint.rs#L129-L131)
(المقدمة كبايتات) إلى ثلاث قيم وتمريرها إلى وظيفة
[`process_instruction`](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/entrypoint.rs#L132):

- `program_id`: المفتاح العام للبرنامج الذي يتم استدعاؤه (البرنامج الحالي)
- `accounts`: `AccountInfo` للحسابات المطلوبة بواسطة التعليمات التي يتم
  استدعاؤها
- `instruction_data`: بيانات إضافية يتم تمريرها إلى البرنامج والتي تحدد
  التعليمات المراد تنفيذها والوسائط المطلوبة لها

ترتبط هذه المعلمات الثلاث مباشرة بالبيانات التي يجب على العملاء توفيرها عند بناء
تعليمات لاستدعاء برنامج.

</Step>
<Step>

### تحديد حالة البرنامج

عند بناء برنامج سولانا، ستبدأ عادةً بتحديد حالة برنامجك - البيانات التي سيتم
تخزينها في الحسابات التي تم إنشاؤها وامتلاكها من قبل برنامجك.

يتم تحديد حالة البرنامج باستخدام هياكل Rust التي تمثل تخطيط بيانات حسابات
برنامجك. يمكنك تحديد هياكل متعددة لتمثيل أنواع مختلفة من الحسابات لبرنامجك.

عند العمل مع الحسابات، تحتاج إلى طريقة لتحويل أنواع بيانات برنامجك من وإلى
البايتات الخام المخزنة في حقل بيانات الحساب:

- التسلسل: تحويل أنواع البيانات الخاصة بك إلى بايتات للتخزين في حقل بيانات
  الحساب
- إلغاء التسلسل: تحويل البايتات المخزنة في الحساب مرة أخرى إلى أنواع البيانات
  الخاصة بك

بينما يمكنك استخدام أي تنسيق تسلسل لتطوير برنامج سولانا، يتم استخدام
[Borsh](https://borsh.io/) بشكل شائع. لاستخدام Borsh في برنامج سولانا الخاص بك:

1. أضف مكتبة `borsh` كتبعية إلى ملف `Cargo.toml` الخاص بك:

```shell title="Terminal"
cargo add borsh
```

2. استورد سمات Borsh واستخدم ماكرو derive لتنفيذ السمات للهياكل الخاصة بك:

```rust
use borsh::{BorshSerialize, BorshDeserialize};

// Define struct representing our counter account's data
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    count: u64,
}
```

أضف هيكل `CounterAccount` إلى `lib.rs` لتحديد حالة البرنامج. سيتم استخدام هذا
الهيكل في كل من تعليمات التهيئة والزيادة.

```rs title="lib.rs" {12} {25-29}
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};
use borsh::{BorshSerialize, BorshDeserialize};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Your program logic
    Ok(())
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    count: u64,
}
```

</Step>
<Step>

### تحديد التعليمات

تشير التعليمات إلى العمليات المختلفة التي يمكن لبرنامج سولانا الخاص بك تنفيذها.
فكر فيها كواجهات برمجة تطبيقات عامة لبرنامجك - فهي تحدد الإجراءات التي يمكن
للمستخدمين اتخاذها عند التفاعل مع برنامجك.

يتم تحديد التعليمات عادةً باستخدام تعداد Rust حيث:

- كل متغير في التعداد يمثل تعليمة مختلفة
- حمولة المتغير تمثل معلمات التعليمة

لاحظ أن متغيرات التعداد في Rust يتم ترقيمها تلقائيًا بدءًا من 0.

فيما يلي مثال على تعداد يحدد تعليمتين:

```rust
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 }, // variant 0
    IncrementCounter,                         // variant 1
}
```

عندما يقوم العميل باستدعاء برنامجك، يجب عليه توفير instruction data (كمخزن مؤقت
من البايتات) حيث:

- البايت الأول يحدد أي متغير من التعليمات سيتم تنفيذه (0، 1، إلخ)
- البايتات المتبقية تحتوي على معلمات التعليمات المسلسلة (إذا كانت مطلوبة)

لتحويل instruction data (البايتات) إلى متغير من التعداد، من الشائع تنفيذ طريقة
مساعدة. هذه الطريقة:

1. تفصل البايت الأول للحصول على متغير التعليمات
2. تطابق المتغير وتحلل أي معلمات إضافية من البايتات المتبقية
3. تعيد متغير التعداد المقابل

على سبيل المثال، طريقة `unpack` للتعداد `CounterInstruction`:

```rust
impl CounterInstruction {
    pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        // Get the instruction variant from the first byte
        let (&variant, rest) = input
            .split_first()
            .ok_or(ProgramError::InvalidInstructionData)?;

        // Match instruction type and parse the remaining bytes based on the variant
        match variant {
            0 => {
                // For InitializeCounter, parse a u64 from the remaining bytes
                let initial_value = u64::from_le_bytes(
                    rest.try_into()
                        .map_err(|_| ProgramError::InvalidInstructionData)?
                );
                Ok(Self::InitializeCounter { initial_value })
            }
            1 => Ok(Self::IncrementCounter), // No additional data needed
            _ => Err(ProgramError::InvalidInstructionData),
        }
    }
}
```

أضف الكود التالي إلى `lib.rs` لتحديد التعليمات لبرنامج العداد.

```rs title="lib.rs" {18-46}
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::AccountInfo, entrypoint, entrypoint::ProgramResult, msg,
    program_error::ProgramError, pubkey::Pubkey,
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Your program logic
    Ok(())
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 }, // variant 0
    IncrementCounter,                         // variant 1
}

impl CounterInstruction {
    pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        // Get the instruction variant from the first byte
        let (&variant, rest) = input
            .split_first()
            .ok_or(ProgramError::InvalidInstructionData)?;

        // Match instruction type and parse the remaining bytes based on the variant
        match variant {
            0 => {
                // For InitializeCounter, parse a u64 from the remaining bytes
                let initial_value = u64::from_le_bytes(
                    rest.try_into()
                        .map_err(|_| ProgramError::InvalidInstructionData)?,
                );
                Ok(Self::InitializeCounter { initial_value })
            }
            1 => Ok(Self::IncrementCounter), // No additional data needed
            _ => Err(ProgramError::InvalidInstructionData),
        }
    }
}
```

</Step>
<Step>

### معالجات التعليمات

معالجات التعليمات تشير إلى الوظائف التي تحتوي على منطق الأعمال لكل تعليمة. من
الشائع تسمية وظائف المعالج كـ `process_<instruction_name>`، ولكن يمكنك اختيار أي
اتفاقية تسمية.

أضف الكود التالي إلى `lib.rs`. يستخدم هذا الكود التعداد `CounterInstruction`
وطريقة `unpack` المحددة في الخطوة السابقة لتوجيه التعليمات الواردة إلى وظائف
المعالج المناسبة:

```rs title="lib.rs" {8-17} {20-32} /process_initialize_counter/1 /process_increment_counter/1
entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Unpack instruction data
    let instruction = CounterInstruction::unpack(instruction_data)?;

    // Match instruction type
    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => process_increment_counter(program_id, accounts)?,
    };
}

fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    // Implementation details...
    Ok(())
}

fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    // Implementation details...
    Ok(())
}
```

بعد ذلك، أضف تنفيذ وظيفة `process_initialize_counter`. معالج التعليمات هذا:

1. ينشئ ويخصص مساحة لحساب جديد لتخزين بيانات العداد
2. تهيئة بيانات الحساب بـ `initial_value` الممررة إلى التعليمة

<Accordions>
<Accordion title="شرح">

تتطلب وظيفة `process_initialize_counter` ثلاثة حسابات:

1. حساب العداد الذي سيتم إنشاؤه وتهيئته
2. حساب الدافع الذي سيمول إنشاء الحساب الجديد
3. System Program الذي نستدعيه لإنشاء الحساب الجديد

لتحديد الحسابات المطلوبة بواسطة التعليمات، نقوم بإنشاء مكرر على شريحة `accounts`
ونستخدم وظيفة `next_account_info` للحصول على كل حساب. عدد الحسابات التي تحددها
هي الحسابات المطلوبة بواسطة التعليمات.

ترتيب الحسابات مهم - عند بناء التعليمات على جانب العميل، يجب توفير الحسابات بنفس
الترتيب كما هو محدد في البرنامج لكي تنفذ التعليمات بنجاح.

في حين أن أسماء المتغيرات للحسابات ليس لها تأثير على وظائف البرنامج، يوصى
باستخدام أسماء وصفية.

```rs title="lib.rs" {6-10}
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    Ok(())
}
```

قبل إنشاء حساب، نحتاج إلى:

1. تحديد المساحة (بالبايت) المخصصة لحقل بيانات الحساب. بما أننا نخزن قيمة u64
   (`count`), نحتاج إلى 8 بايت.

2. حساب الحد الأدنى لرصيد "rent" المطلوب. على سولانا، يجب أن تحافظ الحسابات على
   الحد الأدنى من رصيد lamport (rent) بناءً على كمية البيانات المخزنة في الحساب.

```rs title="lib.rs" {12-17}
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // Size in bytes to store a u64

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    Ok(())
}
```

بمجرد تحديد المساحة وحساب الـ rent، قم بإنشاء الحساب عن طريق استدعاء تعليمات
`create_account` الخاصة بـ System Program.

على سولانا، يمكن إنشاء حسابات جديدة فقط بواسطة System Program. عند إنشاء حساب،
نحدد عدد البايتات المراد تخصيصها ومالك البرنامج للحساب الجديد. يقوم System
Program بما يلي:

1. إنشاء الحساب الجديد
2. تخصيص المساحة المحددة لحقل بيانات الحساب
3. نقل الملكية إلى البرنامج المحدد

هذا النقل للملكية مهم لأن مالك البرنامج للحساب فقط هو من يمكنه تعديل بيانات
الحساب. في هذه الحالة، نقوم بتعيين برنامجنا كمالك، مما سيسمح لنا بتعديل بيانات
الحساب لتخزين قيمة العداد.

لاستدعاء برنامج النظام (System Program) من تعليمات برنامجنا، نقوم بإجراء استدعاء
عبر البرامج (Cross Program Invocation - CPI) عبر دالة `invoke`. يسمح CPI لبرنامج
واحد باستدعاء تعليمات على برامج أخرى - في هذه الحالة، تعليمة `create_account`
الخاصة ببرنامج النظام.

```rs title="lib.rs" {19-33}
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // Size in bytes to store a u64

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for the new account
            counter_account.key,  // Account to be created
            required_lamports,    // Amount of lamports to transfer to the new account
            account_space as u64, // Size in bytes to allocate for the data field
            program_id,           // Set program owner to our program
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    Ok(())
}
```

بمجرد إنشاء الحساب، نقوم بتهيئة بيانات الحساب عن طريق:

1. إنشاء بنية `CounterAccount` جديدة مع `initial_value` المقدمة إلى التعليمات.
2. الحصول على مرجع قابل للتعديل لحقل بيانات الحساب الجديد.
3. تسلسل بنية `CounterAccount` في حقل بيانات الحساب، مما يؤدي فعليًا إلى تخزين
   `initial_value` في الحساب.

```rs title="lib.rs" {35-44} /initial_value/
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // Size in bytes to store a u64

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for the new account
            counter_account.key,  // Account to be created
            required_lamports,    // Amount of lamports to transfer to the new account
            account_space as u64, // Size in bytes to allocate for the data field
            program_id,           // Set program owner to our program
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Create a new CounterAccount struct with the initial value
    let counter_data = CounterAccount {
        count: initial_value,
    };

    // Get a mutable reference to the counter account's data
    let mut account_data = &mut counter_account.data.borrow_mut()[..];

    // Serialize the CounterAccount struct into the account's data
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}
```

</Accordion>
</Accordions>

```rs title="lib.rs"
// Initialize a new counter account
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // Size in bytes to store a u64

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for the new account
            counter_account.key,  // Account to be created
            required_lamports,    // Amount of lamports to transfer to the new account
            account_space as u64, // Size in bytes to allocate for the data field
            program_id,           // Set program owner to our program
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Create a new CounterAccount struct with the initial value
    let counter_data = CounterAccount {
        count: initial_value,
    };

    // Get a mutable reference to the counter account's data
    let mut account_data = &mut counter_account.data.borrow_mut()[..];

    // Serialize the CounterAccount struct into the account's data
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}
```

بعد ذلك، أضف تنفيذ دالة `process_increment_counter`. هذه التعليمة تزيد قيمة حساب
العداد الموجود.

<Accordions>
<Accordion title="شرح">

تمامًا مثل دالة `process_initialize_counter`، نبدأ بإنشاء مكرر على الحسابات. في
هذه الحالة، نتوقع حسابًا واحدًا فقط، وهو الحساب المراد تحديثه.

لاحظ أنه في الممارسة العملية، يجب على المطور تنفيذ فحوصات أمان مختلفة للتحقق من
صحة الحسابات التي تم تمريرها إلى البرنامج. بما أن جميع الحسابات يتم توفيرها من
قبل مستدعي التعليمات، فلا يوجد ضمان بأن الحسابات المقدمة هي التي يتوقعها
البرنامج. فحوصات التحقق من الحساب المفقودة هي مصدر شائع لثغرات البرنامج.

يتضمن المثال أدناه فحصًا للتأكد من أن الحساب الذي نشير إليه باسم
`counter_account` مملوك للبرنامج الذي يتم تنفيذه.

```rs title="lib.rs" {6-9}
// Update an existing counter's value
fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify account ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    Ok(())
}
```

لتحديث بيانات الحساب، نقوم بما يلي:

- استعارة حقل بيانات الحساب الموجود بشكل قابل للتعديل
- فك تسلسل البايتات الخام إلى بنية `CounterAccount` الخاصة بنا
- تحديث قيمة `count`
- إعادة تسلسل البنية المعدلة مرة أخرى إلى حقل بيانات الحساب

```rs title="lib.rs" {11-24}
// Update an existing counter's value
fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify account ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Mutable borrow the account data
    let mut data = counter_account.data.borrow_mut();

    // Deserialize the account data into our CounterAccount struct
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    // Increment the counter value
    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    // Serialize the updated counter data back into the account
    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);
    Ok(())
}
```

</Accordion>
</Accordions>

```rs title="lib.rs"
// Update an existing counter's value
fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify account ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Mutable borrow the account data
    let mut data = counter_account.data.borrow_mut();

    // Deserialize the account data into our CounterAccount struct
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    // Increment the counter value
    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    // Serialize the updated counter data back into the account
    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);
    Ok(())
}
```

</Step>
<Step>

### اختبار التعليمات

لاختبار تعليمات البرنامج، أضف التبعيات التالية إلى `Cargo.toml`.

```shell title="Terminal"
cargo add solana-program-test@1.18.26 --dev
cargo add solana-sdk@1.18.26 --dev
cargo add tokio --dev
```

ثم أضف وحدة الاختبار التالية إلى `lib.rs` وقم بتشغيل `cargo test-sbf` لتنفيذ
الاختبارات. اختيارياً، استخدم العلامة `--nocapture` لرؤية عبارات الطباعة في
المخرجات.

```shell title="Terminal"
cargo test-sbf -- --nocapture
```

<Accordions>
<Accordion title="شرح">

أولاً، قم بإعداد وحدة الاختبار واستيراد التبعيات المطلوبة:

```rs title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use solana_program_test::*;
    use solana_sdk::{
        instruction::{AccountMeta, Instruction},
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[tokio::test]
    async fn test_counter_program() {
        // Test code will go here
    }
}
```

بعد ذلك، قم بإعداد الاختبار باستخدام `ProgramTest`. ثم قم بإنشاء keypair جديد
لاستخدامه كعنوان لحساب العداد الذي سنقوم بتهيئته وتحديد قيمة أولية لتعيينها
للعداد.

```rs title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use solana_program_test::*;
    use solana_sdk::{
        instruction::{AccountMeta, Instruction},
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[tokio::test]
    async fn test_counter_program() {
        let program_id = Pubkey::new_unique();
        let (mut banks_client, payer, recent_blockhash) = ProgramTest::new(
            "counter_program",
            program_id,
            processor!(process_instruction),
        )
        .start()
        .await;

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;
    }
}
```

عند بناء تعليمة، يجب توفير كل حساب كـ
[`AccountMeta`](https://github.com/solana-labs/solana/blob/v2.0/sdk/program/src/instruction.rs#L539-L545)،
والذي يحدد:

- المفتاح العام للحساب (`Pubkey`)
- `is_writable`: ما إذا كانت بيانات الحساب ستتم تعديلها
- `is_signer`: ما إذا كان يجب على الحساب توقيع المعاملة

```rs
AccountMeta::new(account1_pubkey, true),           // writable, signer
AccountMeta::new(account2_pubkey, false),          // writable, not signer
AccountMeta::new_readonly(account3_pubkey, false), // not writable, not signer
AccountMeta::new_readonly(account4_pubkey, true),  // writable, signer
```

لاختبار تعليمة التهيئة:

- إنشاء بيانات التعليمة مع المتغير 0 (`InitializeCounter`) والقيمة الأولية
- بناء التعليمة مع معرف البرنامج وبيانات التعليمة والحسابات المطلوبة
- إرسال معاملة مع تعليمة التهيئة
- التحقق من إنشاء الحساب بالقيمة الأولية الصحيحة

```rs title="lib.rs" {16-53}
    #[tokio::test]
    async fn test_counter_program() {
        let program_id = Pubkey::new_unique();
        let (mut banks_client, payer, recent_blockhash) = ProgramTest::new(
            "counter_program",
            program_id,
            processor!(process_instruction),
        )
        .start()
        .await;

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Create initialization instruction
        let mut init_instruction_data = vec![0]; // 0 = initialize instruction
        init_instruction_data.extend_from_slice(&initial_value.to_le_bytes());

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Send transaction with initialize instruction
        let mut transaction =
            Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 42);
            println!(
                "✅ Counter initialized successfully with value: {}",
                counter.count
            );
        }
    }
```

لاختبار تعليمة الزيادة:

- بناء التعليمة مع معرف البرنامج وبيانات التعليمة والحسابات المطلوبة
- إرسال معاملة مع تعليمة الزيادة
- التحقق من زيادة قيمة الحساب إلى القيمة الصحيحة

لاحظ أن بيانات التعليمة لتعليمة الزيادة هي `[1]`، والتي تتوافق مع المتغير 1
(`IncrementCounter`). بما أنه لا توجد معلمات إضافية لتعليمة الزيادة، فإن
البيانات هي ببساطة متغير التعليمة.

```rs title="lib.rs" {55-82}
    #[tokio::test]
    async fn test_counter_program() {
        let program_id = Pubkey::new_unique();
        let (mut banks_client, payer, recent_blockhash) = ProgramTest::new(
            "counter_program",
            program_id,
            processor!(process_instruction),
        )
        .start()
        .await;

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Create initialization instruction
        let mut init_instruction_data = vec![0]; // 0 = initialize instruction
        init_instruction_data.extend_from_slice(&initial_value.to_le_bytes());

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Send transaction with initialize instruction
        let mut transaction =
            Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 42);
            println!(
                "✅ Counter initialized successfully with value: {}",
                counter.count
            );
        }

        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Create increment instruction
        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &[1], // 1 = increment instruction
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Send transaction with increment instruction
        let mut transaction =
            Transaction::new_with_payer(&[increment_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 43);
            println!("✅ Counter incremented successfully to: {}", counter.count);
        }
    }
```

</Accordion>
</Accordions>

```rs title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use solana_program_test::*;
    use solana_sdk::{
        instruction::{AccountMeta, Instruction},
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[tokio::test]
    async fn test_counter_program() {
        let program_id = Pubkey::new_unique();
        let (mut banks_client, payer, recent_blockhash) = ProgramTest::new(
            "counter_program",
            program_id,
            processor!(process_instruction),
        )
        .start()
        .await;

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Create initialization instruction
        let mut init_instruction_data = vec![0]; // 0 = initialize instruction
        init_instruction_data.extend_from_slice(&initial_value.to_le_bytes());

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Send transaction with initialize instruction
        let mut transaction =
            Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 42);
            println!(
                "✅ Counter initialized successfully with value: {}",
                counter.count
            );
        }

        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Create increment instruction
        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &[1], // 1 = increment instruction
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Send transaction with increment instruction
        let mut transaction =
            Transaction::new_with_payer(&[increment_instruction], Some(&payer.pubkey()));
        transaction.sign(&[&payer, &counter_keypair], recent_blockhash);
        banks_client.process_transaction(transaction).await.unwrap();

        // Check account data
        let account = banks_client
            .get_account(counter_keypair.pubkey())
            .await
            .expect("Failed to get counter account");

        if let Some(account_data) = account {
            let counter: CounterAccount = CounterAccount::try_from_slice(&account_data.data)
                .expect("Failed to deserialize counter data");
            assert_eq!(counter.count, 43);
            println!("✅ Counter incremented successfully to: {}", counter.count);
        }
    }
}
```

مثال للمخرجات:

```shell title="Terminal" {6} {10}
running 1 test
[2024-10-29T20:51:13.783708000Z INFO  solana_program_test] "counter_program" SBF program from /counter_program/target/deploy/counter_program.so, modified 2 seconds, 169 ms, 153 µs and 461 ns ago
[2024-10-29T20:51:13.855204000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM invoke [1]
[2024-10-29T20:51:13.856052000Z DEBUG solana_runtime::message_processor::stable_log] Program 11111111111111111111111111111111 invoke [2]
[2024-10-29T20:51:13.856135000Z DEBUG solana_runtime::message_processor::stable_log] Program 11111111111111111111111111111111 success
[2024-10-29T20:51:13.856242000Z DEBUG solana_runtime::message_processor::stable_log] Program log: Counter initialized with value: 42
[2024-10-29T20:51:13.856285000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM consumed 3791 of 200000 compute units
[2024-10-29T20:51:13.856307000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM success
[2024-10-29T20:51:13.860038000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM invoke [1]
[2024-10-29T20:51:13.860333000Z DEBUG solana_runtime::message_processor::stable_log] Program log: Counter incremented to: 43
[2024-10-29T20:51:13.860355000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM consumed 756 of 200000 compute units
[2024-10-29T20:51:13.860375000Z DEBUG solana_runtime::message_processor::stable_log] Program 1111111QLbz7JHiBTspS962RLKV8GndWFwiEaqKM success
test test::test_counter_program ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.08s
```

</Step>
</Steps>
