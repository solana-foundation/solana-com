---
title: "@solana/client"
description:
  Erstellen Sie schlanke Solana-Frontends mit der headless
  Solana-Client-Runtime.
---

`@solana/client` hält die Runtime-Oberfläche schlank. Ein Store, ein RPC-Stack
und eine Wallet-Registry versorgen die verschiedenen Helfer, sodass dieselbe
Instanz CLIs, Skripte oder vollständige UIs unterstützen kann. Actions, Watcher
und Helfer teilen sich alle Cache, Subscriptions und Wallet-Sessions über diesen
einzelnen Client.

<Callout type="info">
  Wenn Sie eine reine React-Erfahrung erstellen, ist es normalerweise schneller,
  mit [`@solana/react-hooks`](/docs/frontend/react-hooks) zu beginnen. Das
  Hooks-Paket umschließt dieselbe Client-Runtime und stellt fertige Hooks
  bereit, sodass Sie nur dann auf den headless Client zurückgreifen, wenn Sie
  zusätzliche Kontrolle benötigen.
</Callout>

## Installation

```terminal
$ npm install @solana/client
```

Verwenden Sie einen beliebigen Paketmanager; der Client läuft in Browsern,
Workern, React, Svelte oder serverseitigen Runtimes.

## Client einmalig erstellen

Wählen Sie Wallet Standard-Connectors (automatische Erkennung ist der schnellste
Einstieg), erstellen Sie dann den Client. Dieses einzelne Objekt stellt den
Store, Actions, Watcher und Helfer bereit.

```ts
import { autoDiscover, createClient } from "@solana/client";

const client = createClient({
  endpoint: "https://api.devnet.solana.com",
  websocketEndpoint: "wss://api.devnet.solana.com",
  walletConnectors: autoDiscover()
});

await client.actions.connectWallet("wallet-standard:phantom");
const balance = await client.actions.fetchBalance("Fke...address");
console.log(balance.lamports?.toString());
```

Der Client-Store verfolgt Cluster-Konfiguration, Subscriptions, ausstehende
Transaktionen und Wallet-Sessions. Sie können Ihren eigenen Zustand-Store
bereitstellen, wenn Sie Persistenz oder Multi-Tab-Koordination benötigen.

## Wallet-Orchestrierung

Connectors kapseln Wallet Standard-Metadaten sowie Connect/Disconnect-Logik.
Registrieren Sie die integrierten `phantom()`, `solflare()`, `backpack()` oder
`autoDiscover()` Helfer, oder umschließen Sie benutzerdefinierte Provider mit
`createWalletStandardConnector`. Alle Wallet-Actions (connect, disconnect, sign,
send) laufen durch die Client-Registry, sodass alle Consumer synchron bleiben.

## Actions, Watcher und Helfer

- **Actions** umschließen gängige RPC-Lese- und Schreibvorgänge und
  aktualisieren dabei den Store (z. B. `fetchAccount`, `requestAirdrop`,
  `setCluster`).
- **Watcher** multiplexen Websocket-Subscriptions, streamen Updates in den Store
  und geben Ihnen Abort-Handles für das Cleanup.
- **Helfer** stellen höherstufige Abläufe bereit, wie SOL-Transfers, SPL-Token-
  Helfer, Signature-Polling und Transaction-Pools.

```ts
const abortWatcher = client.watchers.watchBalance(
  { address: "Fke...address" },
  (lamports) => {
    console.log("live balance", lamports.toString());
  }
);

// Later when the component unmounts or the flow ends
abortWatcher.abort();
```

## Transaction-Helper-Muster

Der Transaction-Helper verwaltet die Blockhash-Aktualisierung, die Auflösung des
Fee-Payers und das Signieren. Sie können mit der von Ihnen bevorzugten UX
vorbereiten, prüfen und senden.

```ts
const prepared = await client.helpers.transaction.prepare({
  authority: client.store.getState().wallet.session!,
  instructions: [instructionA, instructionB]
});

await client.helpers.transaction.simulate(prepared, {
  commitment: "processed"
});
const signature = await client.helpers.transaction.send(prepared);
console.log("submitted", signature.toString());
```

Verwenden Sie `prepareAndSend` für einen vorgefertigten Ablauf (Simulation plus
Logging) oder rufen Sie `sign` / `toWire` auf, um Signaturen manuell zu sammeln,
bevor Sie das Wire-Format selbst übertragen.

## Gängige Muster für Solana-Entwickler

- **Headless-Zustandsautomaten**: Führen Sie den Client in API-Routen, Skripten
  oder Workern aus, um dieselbe Wallet- und RPC-Orchestrierungslogik
  wiederzuverwenden, die Ihre UI antreibt.
- **Echtzeit-Dashboards**: Kombinieren Sie Watcher (Guthaben, Konten,
  Signaturen) mit Ihrer bevorzugten UI-Bibliothek; der Client übernimmt
  Websocket-Fan-out und Cache-Invalidierung.
- **Benutzerdefinierte Stores**: Injizieren Sie Ihren eigenen Zustand-Store, um
  aus IndexedDB/localStorage zu hydrieren, den Zustand in Server-Sessions zu
  spiegeln oder zwischen Browser-Tabs zu koordinieren.
- **Brücke zu React-Hooks**: Übergeben Sie eine konfigurierte Client-Instanz an
  `@solana/react-hooks`, wenn Sie ergonomische Hooks auf derselben Runtime
  wünschen.
- **Testbarkeit**: Die einzelne Client-Schnittstelle kann in Unit-Tests gemockt
  werden, was es einfach macht, RPC-Antworten oder Wallet-Sessions ohne
  vorhandenes Browser-Wallet zu simulieren.
