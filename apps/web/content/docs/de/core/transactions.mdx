---
title: Transaktionen
description:
  Erfahren Sie mehr über Solana-Transaktionen – die grundlegenden Bausteine für
  die Interaktion mit der Solana-Blockchain. Verstehen Sie Transaktionsstruktur
  und Anweisungszusammensetzung mit praktischen Beispielen.
---

Um mit dem Solana-Netzwerk zu interagieren, müssen Sie eine Transaktion senden.
Sie können sich eine Transaktion wie einen Umschlag vorstellen, der mehrere
Formulare enthält. Jedes Formular ist eine Anweisung, die dem Netzwerk mitteilt,
was zu tun ist. Das Senden der Transaktion ist wie das Versenden des Umschlags,
damit die Formulare verarbeitet werden können.

Das folgende Beispiel zeigt eine vereinfachte Version von zwei Transaktionen.
Wenn die erste Transaktion verarbeitet wird, führt sie eine einzelne Anweisung
aus. Wenn die zweite Transaktion verarbeitet wird, führt sie drei Anweisungen
**in sequentieller Reihenfolge** aus: zuerst Anweisung 1, gefolgt von Anweisung
2, gefolgt von Anweisung 3.

<Callout type="warn">
  Transaktionen sind **atomar**: Wenn eine einzelne Anweisung fehlschlägt, wird
  die gesamte Transaktion fehlschlagen und es werden keine Änderungen
  vorgenommen.
</Callout>

![Ein vereinfachtes Diagramm, das zwei Transaktionen zeigt](/assets/docs/core/transactions/transaction-simple.svg)

Eine
[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
besteht aus den folgenden Informationen:

<WithMentions>

- [`signatures`](mention:signatures): Ein Array von [Signaturen](#signatures)
- [`message`](mention:message): Transaktionsinformationen, einschließlich der
  Liste der zu verarbeitenden Anweisungen

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![Diagramm, das die zwei Teile einer Transaktion zeigt](/assets/docs/core/transactions/tx_format.png)

Transaktionen haben eine Gesamtgrößenbegrenzung von
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
Bytes. Diese Begrenzung umfasst sowohl das [`signatures`](#signatures)-Array als
auch die [`message`](#message)-Struktur.

<Callout>
  Diese Begrenzung stammt von der IPv6 Maximum Transmission Unit (MTU) Größe von
  1280 Bytes, abzüglich 48 Bytes für Netzwerk-Header (40 Bytes IPv6 + 8 Bytes
  Header).
</Callout>

![Diagramm, das das Transaktionsformat und Größenbegrenzungen zeigt](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## Signaturen

Das `signatures`Array der Transaktion enthält `Signature`Strukturen. Jede
[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
ist 64 Bytes groß und wird durch Signieren des `Message` der Transaktion mit dem
privaten Schlüssel des Kontos erstellt. Eine Signatur muss für jedes
[Signer-Konto](#account-addresses) bereitgestellt werden, das in einer der
Anweisungen der Transaktion enthalten ist.

Die erste Signatur gehört zu dem Konto, das die
[Basisgebühr](docs/core/fees#base-fee) der Transaktion bezahlt und ist die
Transaktionssignatur. Die Transaktionssignatur kann verwendet werden, um die
Details der Transaktion im Netzwerk nachzuschlagen.

## Nachricht

Die `message` der Transaktion ist eine
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)
Struktur, die folgende Informationen enthält:

<WithMentions>

- [`header`](mention:message-header): Der [Header](#header) der Nachricht
- [`account_keys`](mention:account-addresses): Ein Array von
  [Kontoadressen](#account-addresses), die von den Anweisungen der Transaktion
  benötigt werden
- [`recent_blockhash`](mention:recent-blockhash): Ein
  [Blockhash](#recent-blockhash), der als Zeitstempel für die Transaktion dient
- [`instructions`](mention:instructions): Ein Array von
  [Anweisungen](#instructions)

<Callout>
  Um Speicherplatz zu sparen, speichert die Transaktion nicht die Berechtigungen
  für jedes Konto einzeln. Stattdessen werden die Kontoberechtigungen mithilfe
  des `header` und `account_keys` bestimmt.
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### Header

<WithMentions>

Der `header` der Nachricht ist eine
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
Struktur. Er enthält folgende Informationen:

- [`num_required_signatures`](mention:num_required_signatures): Die Gesamtzahl
  der von der Transaktion benötigten Signaturen
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts): Die
  Gesamtzahl der schreibgeschützten Konten, die Signaturen erfordern
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts):
  Die Gesamtzahl der schreibgeschützten Konten, die keine Signaturen erfordern

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![Diagramm, das die drei Teile des Nachrichtenheaders zeigt](/assets/docs/core/transactions/message_header.png)

### Kontoadressen

Das
[`account_keys`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
der Nachricht ist ein Array von Kontoadressen, das im
[Kompakt-Array-Format](/docs/references/terminology#compact-array-format)
gesendet wird. Das Präfix des Arrays gibt seine Länge an. Jedes Element im Array
ist ein öffentlicher Schlüssel, der auf ein von seinen Anweisungen verwendetes
Konto verweist. Das `accounts_keys`Array muss vollständig und streng in
folgender Reihenfolge angeordnet sein:

1. Signer + Beschreibbar
2. Signer + Schreibgeschützt
3. Kein Signer + Beschreibbar
4. Kein Signer + Schreibgeschützt

<Callout>
  Die strenge Anordnung ermöglicht es, das `account_keys`Array mit den
  Informationen im [`header`](#header) der Nachricht zu kombinieren, um die
  Berechtigungen für jedes Konto zu bestimmen.
</Callout>

![Diagramm, das die Reihenfolge des Kontenadressenfeldes zeigt](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Aktueller Blockhash

Der `recent_blockhash` der Nachricht ist ein Hash-Wert, der als Zeitstempel für
die Transaktion dient und doppelte Transaktionen verhindert. Ein Blockhash läuft
nach
[150 Blöcken](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)
ab. (Entspricht einer Minute – unter der Annahme, dass jeder Block 400ms
dauert.) Nach Ablauf des Blocks ist die Transaktion abgelaufen und kann nicht
mehr verarbeitet werden.

<Callout>
  Die RPC-Methode [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash)
  ermöglicht es dir, den aktuellen Blockhash und die letzte Blockhöhe zu
  erhalten, bei der der Blockhash noch gültig sein wird.
</Callout>

### Anweisungen

Das
[`instructions`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
der Nachricht ist ein Array aller zu verarbeitenden Anweisungen, gesendet im
[kompakten Array-Format](/docs/references/terminology#compact-array-format). Das
Präfix des Arrays gibt seine Länge an. Jedes Element im Array ist eine
[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
Struktur und enthält folgende Informationen:

<WithMentions>

1. [`program_id_index`](mention:program-id-index): Ein Index, der auf eine
   Adresse im [`account_keys`](#account-addresses) Array zeigt. Dieser Wert gibt
   die Adresse des Programms an, das die Anweisung verarbeitet.
2. [`accounts`](mention:account-indexes): Ein Array von Indizes, die auf
   Adressen im `account_keys` Array zeigen. Jeder Index zeigt auf die Adresse
   eines Kontos, das für diese Anweisung erforderlich ist.
3. [`data`](mention:instruction-data): Ein Byte-Array, das angibt, welche
   Anweisung im Programm aufgerufen werden soll. Es enthält auch alle
   zusätzlichen Daten, die von der Anweisung benötigt werden. (Zum Beispiel
   Funktionsargumente)

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Kompaktes Array von Anweisungen](/assets/docs/core/transactions/compact_array_of_ixs.png)

## Beispiel einer Transaktionsstruktur

Das folgende Beispiel zeigt die Struktur einer Transaktion, die eine einzelne
SOL-Überweisungsanweisung enthält.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
Der folgende Code zeigt die Ausgabe der vorherigen Codeausschnitte.
Das Format unterscheidet sich zwischen den SDKs,
aber beachte, dass jede Anweisung die gleichen erforderlichen Informationen enthält.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

Nachdem eine Transaktion übermittelt wurde, können Sie ihre Details mithilfe der
Transaktionssignatur und der [getTransaction](/docs/rpc/http/gettransaction)
RPC-Methode abrufen. Die Antwort wird eine Struktur ähnlich dem folgenden
Ausschnitt haben.

<Callout>
  Sie können die Transaktion auch über den [Solana
  Explorer](https://explorer.solana.com) finden.
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
