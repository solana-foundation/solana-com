---
title: Transaktionsgebühren
description:
  Erfahren Sie mehr über Solanas Transaktionsgebühren, einschließlich der Basis-
  und Prioritätsgebühren, wie diese angewendet werden und bewährte Methoden zur
  Verwaltung von Compute-Einheiten in Ihren Transaktionen.
---

Jede Solana-Transaktion erfordert eine Transaktionsgebühr, die in SOL bezahlt
wird. Transaktionsgebühren sind in zwei Teile aufgeteilt: die Basisgebühr und
die Priorisierungsgebühr. Die Basisgebühr entschädigt Validatoren für die
Verarbeitung der Transaktion. Die priority fee ist eine optionale Gebühr, um die
Wahrscheinlichkeit zu erhöhen, dass der aktuelle Leader Ihre Transaktion
verarbeitet.

## Basisgebühr

Jede Transaktion kostet 5000 [Lamports](/docs/references/terminology#lamport)
pro enthaltener Signatur. Diese Gebühr wird vom ersten Signer der Transaktion
bezahlt und muss von einem Konto bezahlt werden, das dem System Program gehört.
Die Basisgebühr wird wie folgt aufgeteilt:

- **50% verbrannt:** Die Hälfte wird
  [verbrannt](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (aus dem zirkulierenden SOL-Angebot entnommen).
- **50% verteilt:** Die Hälfte wird
  [an den Validator gezahlt](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62),
  der die Transaktion verarbeitet hat.

## Priority fee

Eine
[priority fee](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
ist eine optionale Gebühr, die verwendet wird, um die Wahrscheinlichkeit zu
erhöhen, dass der aktuelle Leader (Validator) Ihre Transaktion verarbeitet. Der
Validator erhält
[100% der priority fee](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Priorisierungsgebühren können durch Anpassung des
[Compute-Einheiten](/docs/references/terminology#compute-units) (CU)-Preises und
CU-Limits der Transaktion festgelegt werden. (Weitere Details zu
Priorisierungsgebühren finden Sie im
[Leitfaden zur Verwendung von Priority Fees](/developers/guides/advanced/how-to-use-priority-fees)).

Die priority fee wird wie folgt berechnet:

**Priorisierungsgebühr = Compute-Einheiten-Limit × Compute-Einheiten-Preis**

Die priority fee wird verwendet, um die
[Priorität Ihrer Transaktion](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646)
im Verhältnis zu anderen Transaktionen zu bestimmen. Sie wird mit der folgenden
Formel berechnet:

Wenn Sie eine Transaktion mit einer priority fee senden, wird diese Gebühr
zusätzlich zur Basisgebühr erhoben. Die Basisgebühr wird an die Validator-Staker
verteilt, während die priority fee vollständig an den Validator geht, der die
Transaktion verarbeitet.

#### Compute-Einheiten-Limit

Standardmäßig werden
[jeder Anweisung](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197)
[200.000 CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
und jeder Transaktion
[1,4 Millionen CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14)
zugewiesen. Sie können diese Standardwerte ändern, indem Sie eine
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
Anweisung in Ihre Transaktion einfügen.

Um das angemessene CU-Limit für Ihre Transaktion zu berechnen, empfehlen wir die
folgenden Schritte:

1. Schätzen Sie die erforderlichen CU-Einheiten durch
   [Simulation](/developers/guides/advanced/how-to-request-optimal-compute) der
   Transaktion
2. Fügen Sie dieser Schätzung einen Sicherheitspuffer von 10% hinzu

<Callout type="warn">
  Die priority fee wird durch das angeforderte Compute-Unit-Limit der
  Transaktion bestimmt, *nicht* durch die tatsächlich verwendete Anzahl an
  Compute-Units. Wenn Sie ein zu hohes Compute-Unit-Limit festlegen oder den
  Standardwert verwenden, zahlen Sie möglicherweise für ungenutzte
  Compute-Units.
</Callout>

#### Compute-Unit-Preis

Der Compute-Unit-Preis ist ein optionaler Betrag in
[Mikro-Lamports](/docs/references/terminology#micro-lamports), der für jede
angeforderte CU gezahlt wird. Sie können den CU-Preis als Trinkgeld betrachten,
um den Validator zu ermutigen, Ihre Transaktion zu priorisieren. Um den CU-Preis
festzulegen, fügen Sie eine
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
Anweisung in Ihre Transaktion ein.

<Callout>
  Der Standard-CU-Preis ist 0, was bedeutet, dass die Standard-Prioritätsgebühr
  ebenfalls 0 ist.
</Callout>

Für Hilfe bei der Bestimmung des besten CU-Preises für Ihre Transaktion, sehen
Sie sich die Echtzeit- CU-Preisempfehlung in der unten aufgeführten Tabelle an.

| Anbieter                                | Priority Fee API                                                                  |
| --------------------------------------- | --------------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [Dokumentation](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Dokumentation](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Dokumentation](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Beispiel

Die folgenden Beispiele zeigen, wie man das CU-Limit und den CU-Preis für eine
Transaktion mit Solana SDKs festlegt.

| SDK                            | Quellcode-Referenz                                                                                                             |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
