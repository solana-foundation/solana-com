---
title: Programme
description:
  Erfahren Sie mehr über Solana-Programme (Smart Contracts) und wie man sie mit
  Rust oder dem Anchor-Framework entwickelt. Verstehen Sie Deployment, Upgrades
  und Verifizierung von Programmen im Solana-Netzwerk.
h1: Programme
---

Auf Solana wird ein Smart Contract als Programm bezeichnet. Ein Programm ist ein
zustandsloses [Konto](/docs/core/accounts#program-account), das ausführbaren
Code enthält. Dieser Code ist in Funktionen organisiert, die als Anweisungen
bezeichnet werden. Benutzer interagieren mit einem Programm, indem sie eine
[Transaktion](/docs/core/transaction) senden, die eine oder mehrere
[Anweisungen](/docs/core/instructions) enthält. Eine Transaktion kann
Anweisungen von mehreren Programmen enthalten.

Wenn ein Programm bereitgestellt wird, verwendet Solana
[LLVM](https://llvm.org/), um es in ein ausführbares und verknüpfbares Format
([ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)) zu
kompilieren. Die ELF- Datei enthält die Programmbinärdatei im Solana Bytecode
Format (sBPF) und wird on-chain in einem ausführbaren Konto gespeichert.

<Callout>
  sBPF ist Solanas angepasste Version des
  [eBPF](https://en.wikipedia.org/wiki/EBPF) Bytecodes.
</Callout>

## Programme schreiben

Die Mehrheit der Programme wird in
[Rust](https://rust-book.cs.brown.edu/title-page.html) geschrieben, mit zwei
gängigen Entwicklungsansätzen:

- [Anchor](https://www.anchor-lang.com/docs): Anchor ist ein Framework, das für
  schnelle und einfache Solana-Entwicklung konzipiert wurde. Es verwendet
  [Rust-Makros](https://doc.rust-lang.org/book/ch20-05-macros.html), um
  Boilerplate-Code zu reduzieren – ideal für Anfänger.
- [Native Rust](/docs/programs/rust): Programme in Rust schreiben, ohne
  Frameworks zu nutzen. Dieser Ansatz bietet mehr Flexibilität, bringt aber auch
  erhöhte Komplexität mit sich.

## Programme aktualisieren

Um ein bestehendes Programm zu
[modifizieren](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L704),
muss ein Konto als
[Upgrade-Authority](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L894)
festgelegt werden. (Typischerweise dasselbe Konto, das ursprünglich das Programm
[bereitgestellt hat](/docs/programs/deploying).) Wenn die Upgrade-Authority
widerrufen und auf `None` gesetzt wird, kann das Programm nicht mehr
aktualisiert werden.

## Programme verifizieren

Solana unterstützt [verifizierbare Builds](/docs/programs/verified-builds), die
es Benutzern ermöglichen zu überprüfen, ob der On-Chain-Code eines Programms mit
seinem öffentlichen Quellcode übereinstimmt. Das Anchor-Framework bietet
[integrierte Unterstützung](https://www.anchor-lang.com/docs/verifiable-builds)
für die Erstellung eines verifizierbaren Builds.

Um zu überprüfen, ob ein bestehendes Programm verifiziert ist, suchen Sie nach
seiner Programm-ID im
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY).
Alternativ können Sie die Ellipsis Labs
[Solana Verifiable Build CLI](https://github.com/Ellipsis-Labs/solana-verifiable-build)
verwenden, um On-Chain-Programme unabhängig zu verifizieren.

## Integrierte Programme

### Das System Program

Das System Program ist das einzige Konto, das neue Konten erstellen kann.
Standardmäßig gehören alle neuen Konten dem
[System Program](https://github.com/anza-xyz/agave/tree/v2.1.13/programs/system/src),
obwohl viele bei der Erstellung einem neuen Eigentümer zugewiesen werden. Das
System Program erfüllt die folgenden Schlüsselfunktionen:

| Funktion                                                                                                                 | Beschreibung                                                                                                                                                                                                                                                    |
| ------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Erstellung neuer Konten](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L146)   | Nur das System Program kann neue Konten erstellen.                                                                                                                                                                                                              |
| [Speicherplatzzuweisung](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L71)     | Legt die Bytekapazität für das Datenfeld jedes Kontos fest.                                                                                                                                                                                                     |
| [Programmeigentum zuweisen](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L113) | Sobald das System Program ein Konto erstellt hat, kann es den festgelegten Programmeigentümer einem anderen program account zuweisen. So übernehmen benutzerdefinierte Programme die Eigentümerschaft von neuen Konten, die vom System Program erstellt wurden. |
| [SOL übertragen](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L215)            | Überträgt Lamports (SOL) von System-Konten auf andere Konten.                                                                                                                                                                                                   |

Die Adresse des System Program ist `11111111111111111111111111111111`.

### Loader-Programme

Jedes Programm gehört einem anderen – seinem Loader. Loader werden verwendet, um
Programme zu deployen, erneut zu deployen, zu aktualisieren oder zu schließen.
Sie werden auch verwendet, um ein Programm zu finalisieren und die
Programmautorität zu übertragen.

<Callout>
  Loader-Programme werden manchmal als 'BPF Loaders' bezeichnet.
</Callout>

Derzeit gibt es fünf Loader-Programme, wie in der folgenden Tabelle dargestellt.

| Loader | Program ID                                    | Hinweise                                                                                                                                       | Anweisungen Link                                                                                                                               |
| ------ | --------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| native | `NativeLoader1111111111111111111111111111111` | Besitzt die anderen vier Loader                                                                                                                | —                                                                                                                                              |
| v1     | `BPFLoader1111111111111111111111111111111111` | Verwaltungs-Anweisungen sind deaktiviert, aber Programme werden weiterhin ausgeführt                                                           | —                                                                                                                                              |
| v2     | `BPFLoader2111111111111111111111111111111111` | Verwaltungs-Anweisungen sind deaktiviert, aber Programme werden weiterhin ausgeführt                                                           | [Anweisungen](https://docs.rs/solana-loader-v2-interface/latest/solana_loader_v2_interface/enum.LoaderInstruction.html)                        |
| v3     | `BPFLoaderUpgradeab1e11111111111111111111111` | Programme können nach dem Deployment aktualisiert werden. Die ausführbare Programmdatei wird in einem separaten Programmdatenkonto gespeichert | [Anweisungen](https://docs.rs/solana-loader-v3-interface/latest/solana_loader_v3_interface/instruction/enum.UpgradeableLoaderInstruction.html) |
| v4     | `LoaderV411111111111111111111111111111111111` | In Entwicklung (unveröffentlicht)                                                                                                              | [Anweisungen](https://docs.rs/solana-loader-v4-interface/latest/solana_loader_v4_interface/instruction/enum.LoaderV4Instruction.html)          |

Programme, die mit loader-v3 oder loader-v4 bereitgestellt wurden, können nach
dem Deployment modifizierbar sein, je nachdem, was ihre Upgrade-Authority
festlegt.

<Callout>
  Wenn ein neues Programm bereitgestellt wird, wird standardmäßig die neueste
  Loader-Version verwendet.
</Callout>

### Vorkompilierte Programme

Zusätzlich zu den Loader-Programmen bietet Solana die folgenden vorkompilierten
Programme.

#### Verifizierung von ed25519-Signaturen

Das ed25519-Programm wird verwendet, um eine oder mehrere ed25519-Signaturen zu
verifizieren.

| Programm         | Programm-ID                                   | Beschreibung                                                                                   | Anweisungen                                                                                    |
| ---------------- | --------------------------------------------- | ---------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| Ed25519-Programm | `Ed25519SigVerify111111111111111111111111111` | Verifiziert ed25519-Signaturen. Wenn eine Signatur fehlschlägt, wird ein Fehler zurückgegeben. | [Anweisungen](https://docs.rs/solana-ed25519-program/latest/solana_ed25519_program/index.html) |

Das ed25519-Programm verarbeitet eine Anweisung. Das erste instruction data der
Anweisung enthält die Anzahl der zu überprüfenden Signaturen, gefolgt von einem
einzelnen Byte Padding. Danach wird für jede zu überprüfende Signatur die
folgende Struktur serialisiert.

```rs title="Ed25519SignatureOffsets"
struct Ed25519SignatureOffsets {
    signature_offset: u16,             // offset to ed25519 signature of 64 bytes
    signature_instruction_index: u16,  // instruction index to find signature
    public_key_offset: u16,            // offset to public key of 32 bytes
    public_key_instruction_index: u16, // instruction index to find public key
    message_data_offset: u16,          // offset to start of message data
    message_data_size: u16,            // size of message data
    message_instruction_index: u16,    // index of instruction data to get message data
}
```

```txt title="Signature verification pseudocode"
process_instruction() {
    for i in 0..count {
        // i'th index values referenced:
        instructions = &transaction.message().instructions
        instruction_index = ed25519_signature_instruction_index != u16::MAX ? ed25519_signature_instruction_index : current_instruction;
        signature = instructions[instruction_index].data[ed25519_signature_offset..ed25519_signature_offset + 64]
        instruction_index = ed25519_pubkey_instruction_index != u16::MAX ? ed25519_pubkey_instruction_index : current_instruction;
        pubkey = instructions[instruction_index].data[ed25519_pubkey_offset..ed25519_pubkey_offset + 32]
        instruction_index = ed25519_message_instruction_index != u16::MAX ? ed25519_message_instruction_index : current_instruction;
        message = instructions[instruction_index].data[ed25519_message_data_offset..ed25519_message_data_offset + ed25519_message_data_size]
        if pubkey.verify(signature, message) != Success {
            return Error
        }
    }
    return Success
}
```

#### Verifizierung von secp256k1-Wiederherstellung

Das secp256k1-Programm wird verwendet, um
secp256k1-Public-Key-Wiederherstellungsoperationen zu verifizieren.

| Programm           | Programm-ID                                   | Beschreibung                                                                | Anweisungen                                                                                        |
| ------------------ | --------------------------------------------- | --------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| Secp256k1-Programm | `KeccakSecp256k11111111111111111111111111111` | Verifiziert secp256k1-Public-Key-Wiederherstellungsoperationen (ecrecover). | [Anweisungen](https://docs.rs/solana-secp256k1-program/latest/solana_secp256k1_program/index.html) |

Das secp256k1-Programm verarbeitet eine Anweisung. Das erste Byte der Anweisung
enthält die Anzahl der zu überprüfenden öffentlichen Schlüssel. Danach wird die
folgende Struktur einmal für jeden öffentlichen Schlüssel erstellt, dann
serialisiert und zu den instruction data hinzugefügt.

```rs title="Secp256k1SignatureOffsets"
struct Secp256k1SignatureOffsets {
    secp_signature_offset: u16,            // offset to [signature,recovery_id] of 64+1 bytes
    secp_signature_instruction_index: u8,  // instruction index to find signature
    secp_pubkey_offset: u16,               // offset to ethereum_address pubkey of 20 bytes
    secp_pubkey_instruction_index: u8,     // instruction index to find pubkey
    secp_message_data_offset: u16,         // offset to start of message data
    secp_message_data_size: u16,           // size of message data
    secp_message_instruction_index: u8,    // instruction index to find message data
}
```

```txt title="Recovery verification pseudocode"
process_instruction() {
  for i in 0..count {
      // i'th index values referenced:
      instructions = &transaction.message().instructions
      signature = instructions[secp_signature_instruction_index].data[secp_signature_offset..secp_signature_offset + 64]
      recovery_id = instructions[secp_signature_instruction_index].data[secp_signature_offset + 64]
      ref_eth_pubkey = instructions[secp_pubkey_instruction_index].data[secp_pubkey_offset..secp_pubkey_offset + 20]
      message_hash = keccak256(instructions[secp_message_instruction_index].data[secp_message_data_offset..secp_message_data_offset + secp_message_data_size])
      pubkey = ecrecover(signature, recovery_id, message_hash)
      eth_pubkey = keccak256(pubkey[1..])[12..]
      if eth_pubkey != ref_eth_pubkey {
          return Error
      }
  }
  return Success
}
```

Dies ermöglicht dem Benutzer, beliebige instruction data in der Transaktion für
Signatur- und Nachrichtendaten anzugeben. Durch Angabe eines speziellen
instructions sysvar kann man auch Daten aus der Transaktion selbst empfangen.

Die Kosten der Transaktion werden anhand der Anzahl der zu verifizierenden
Signaturen multipliziert mit dem Signaturkosten-Verifizierungsmultiplikator
berechnet.

Das Secp256r1-Programm wird verwendet, um bis zu 8 Secp256r1-Signaturen zu
verifizieren.

| Programm           | Programm-ID                                   | Beschreibung                                                                                                                                     | Anweisungen                                                                                      |
| ------------------ | --------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------ |
| Secp256r1-Programm | `Secp256r1SigVerify1111111111111111111111111` | Verifiziert bis zu 8 Secp256r1-Signaturen. Nimmt eine Signatur, öffentlichen Schlüssel und Nachricht. Gibt Fehler zurück, wenn eine fehlschlägt. | [Anweisungen](https://docs.rs/solana-secp256r1-program/latest/solana_secp256r1_program/all.html) |

Das Secp256r1-Programm verarbeitet eine Anweisung. Das erste `u8` ist eine
Anzahl der zu überprüfenden Signaturen, gefolgt von einem einzelnen Byte
Padding. Danach wird die folgende Struktur für jede Signatur erstellt, dann
serialisiert und zu den instruction data hinzugefügt.

```rs title="Secp256r1SignatureOffsets"
struct Secp256r1SignatureOffsets {
    signature_offset: u16,             // offset to compact secp256r1 signature of 64 bytes
    signature_instruction_index: u16,  // instruction index to find signature
    public_key_offset: u16,            // offset to compressed public key of 33 bytes
    public_key_instruction_index: u16, // instruction index to find public key
    message_data_offset: u16,          // offset to start of message data
    message_data_size: u16,            // size of message data
    message_instruction_index: u16,    // index of instruction data to get message data
}

```

<Callout>
  Niedrige S-Werte werden für alle Signaturen erzwungen, um unbeabsichtigte
  Signaturveränderbarkeit zu vermeiden.
</Callout>

```txt title="Signature verification psuedocode"
process_instruction() {
    if data.len() < SIGNATURE_OFFSETS_START {
        return Error
    }

    num_signatures = data[0] as usize
    if num_signatures == 0 || num_signatures > 8 {
        return Error
    }

    expected_data_size = num_signatures * SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START
    if data.len() < expected_data_size {
        return Error
    }

    for i in 0..num_signatures {
        offsets = parse_signature_offsets(data, i)

        signature = get_data_slice(data, instruction_datas, offsets.signature_instruction_index, offsets.signature_offset, SIGNATURE_SERIALIZED_SIZE)

        if s > half_curve_order {
            return Error
        }

        pubkey = get_data_slice(data, instruction_datas, offsets.public_key_instruction_index, offsets.public_key_offset, COMPRESSED_PUBKEY_SERIALIZED_SIZE)

        message = get_data_slice(data, instruction_datas, offsets.message_instruction_index, offsets.message_data_offset, offsets.message_data_size)

        if !verify_signature(signature, pubkey, message) {
            return Error
        }
    }

    return Success
}
```

### Kernprogramme

Die Programme in der folgenden Liste bieten die Kernfunktionalität des
Netzwerks.

| Programm                 | Programm-ID                                   | Beschreibung                                                                                                                                                                                                                                                                                                                                                                                                    | Anweisungen                                                                                                                                           |
| ------------------------ | --------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **System**               | `11111111111111111111111111111111`            | Erstellt neue Konten, weist Kontendaten zu, weist Konten den besitzenden Programmen zu, überträgt Lamports von System-Programm-eigenen Konten und zahlt Transaktionsgebühren                                                                                                                                                                                                                                    | [SystemInstruction](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html)                              |
| **Vote**                 | `Vote111111111111111111111111111111111111111` | Erstellt und verwaltet Konten, die den Abstimmungsstatus und die Belohnungen der Validatoren verfolgen                                                                                                                                                                                                                                                                                                          | [VoteInstruction](https://docs.rs/solana-vote-program/latest/solana_vote_program/vote_instruction/enum.VoteInstruction.html)                          |
| **Stake**                | `Stake11111111111111111111111111111111111111` | Erstellt und verwaltet Konten, die Einsätze und Belohnungen für Delegationen an Validatoren darstellen                                                                                                                                                                                                                                                                                                          | [StakeInstruction](https://docs.rs/solana-sdk/latest/solana_sdk/stake/instruction/enum.StakeInstruction.html)                                         |
| **Config**               | `Config1111111111111111111111111111111111111` | Fügt Konfigurationsdaten zur Blockchain hinzu, gefolgt von der Liste der öffentlichen Schlüssel, die zu deren Änderung berechtigt sind. Im Gegensatz zu anderen Programmen definiert das Config-Programm keine einzelnen Anweisungen. Es hat nur eine implizite Anweisung: "store". Seine instruction data ist ein Satz von Schlüsseln, die den Zugriff auf das Konto und die darin gespeicherten Daten steuern | [ConfigInstruction](https://docs.rs/solana-config-program/latest/solana_config_program/config_instruction/index.html)                                 |
| **Compute Budget**       | `ComputeBudget111111111111111111111111111111` | Legt Recheneinheitslimits und Preise für Transaktionen fest, sodass Benutzer Rechenressourcen und Priorisierungsgebühren kontrollieren können                                                                                                                                                                                                                                                                   | [ComputeBudgetInstruction](https://docs.rs/solana-compute-budget-interface/latest/solana_compute_budget_interface/enum.ComputeBudgetInstruction.html) |
| **Address Lookup Table** | `AddressLookupTab1e1111111111111111111111111` | Verwaltet Adressnachschlagetabellen, die es Transaktionen ermöglichen, mehr Konten zu referenzieren, als sonst in die Kontenliste der Transaktion passen würden                                                                                                                                                                                                                                                 | [ProgramInstruction](https://docs.rs/solana-sdk/latest/solana_sdk/address_lookup_table/instruction/enum.ProgramInstruction.html)                      |
| **ZK ElGamal Proof**     | `ZkE1Gama1Proof11111111111111111111111111111` | Bietet Zero-Knowledge-Proof-Verifizierung für ElGamal-verschlüsselte Daten                                                                                                                                                                                                                                                                                                                                      | —                                                                                                                                                     |
