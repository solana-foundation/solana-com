---
title: Creare un token account
description:
  Impara come creare un token account con l'estensione Confidential Transfer.
---

<Callout type="warn">
  Il programma ZK ElGamal è temporaneamente disabilitato su mainnet e devnet
  mentre è sottoposto a un audit di sicurezza. Ciò significa che l'estensione
  per i trasferimenti confidenziali non è attualmente disponibile. Sebbene i
  concetti siano ancora validi, gli esempi di codice non funzioneranno.
</Callout>

## Come creare un token account con l'estensione Confidential Transfer

L'estensione Confidential Transfer consente trasferimenti privati di token
aggiungendo stati aggiuntivi al token account. Questa sezione spiega come creare
un token account con questa estensione abilitata.

Il seguente diagramma mostra i passaggi necessari per creare un token account
con l'estensione Confidential Transfer:

```mermaid title="Create Token Account with Confidential Transfer Extension"
sequenceDiagram
    participant Payer as Wallet
    participant ATA as Associated Token Program
    participant Token22 as Token Extensions Program
    participant TokenAccount as Token Account

    Payer->>ATA: create_associated_token_account()
    activate ATA
    ATA->>Token22: Create token account <br> at deterministic address
    deactivate ATA
    activate Token22
    Token22-->>TokenAccount: Initialize Token Account
    deactivate Token22

    Payer->>Token22: reallocate() for ConfidentialTransferAccount extension
    activate Token22
    Token22-->>TokenAccount: Add space for extension data
    deactivate Token22

    Payer->>Payer: Generate ElGamal keypair
    Payer->>Payer: Generate AES key
    Payer->>Payer: Create PubkeyValidityProofData from ElGamal keypair
    Payer->>Payer: Encrypt initial balance (0) with AES key

    Payer->>Token22: configure_account()
    activate Token22
    Token22-->>TokenAccount: Configure for confidential transfers
    deactivate Token22
```

### Stato del Token Account con Confidential Transfer

L'estensione aggiunge lo stato
[ConfidentialTransferAccount](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/extension/confidential_transfer/mod.rs#L75-L122)
al token account:

```rust title="Confidential Token Account State"
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq, Pod, Zeroable)]
pub struct ConfidentialTransferAccount {
    /// `true` if this account has been approved for use. All confidential
    /// transfer operations for the account will fail until approval is
    /// granted.
    pub approved: PodBool,

    /// The public key associated with ElGamal encryption
    pub elgamal_pubkey: PodElGamalPubkey,

    /// The low 16 bits of the pending balance (encrypted by `elgamal_pubkey`)
    pub pending_balance_lo: EncryptedBalance,

    /// The high 48 bits of the pending balance (encrypted by `elgamal_pubkey`)
    pub pending_balance_hi: EncryptedBalance,

    /// The available balance (encrypted by `encryption_pubkey`)
    pub available_balance: EncryptedBalance,

    /// The decryptable available balance
    pub decryptable_available_balance: DecryptableBalance,

    /// If `false`, the extended account rejects any incoming confidential
    /// transfers
    pub allow_confidential_credits: PodBool,

    /// If `false`, the base account rejects any incoming transfers
    pub allow_non_confidential_credits: PodBool,

    /// The total number of `Deposit` and `Transfer` instructions that have
    /// credited `pending_balance`
    pub pending_balance_credit_counter: PodU64,

    /// The maximum number of `Deposit` and `Transfer` instructions that can
    /// credit `pending_balance` before the `ApplyPendingBalance`
    /// instruction is executed
    pub maximum_pending_balance_credit_counter: PodU64,

    /// The `expected_pending_balance_credit_counter` value that was included in
    /// the last `ApplyPendingBalance` instruction
    pub expected_pending_balance_credit_counter: PodU64,

    /// The actual `pending_balance_credit_counter` when the last
    /// `ApplyPendingBalance` instruction was executed
    pub actual_pending_balance_credit_counter: PodU64,
}
```

Il _rs`ConfidentialTransferAccount`_ contiene diversi campi per gestire i
trasferimenti confidenziali:

- **approved**: Lo stato di approvazione dell'account per i trasferimenti
  confidenziali. Se la configurazione `auto_approve_new_accounts` del mint
  account è impostata come `true`, tutti i token account sono automaticamente
  approvati per i trasferimenti confidenziali.

- **elgamal_pubkey**: La chiave pubblica ElGamal utilizzata per criptare i saldi
  e gli importi dei trasferimenti.

- **pending_balance_lo**: I 16 bit inferiori criptati del saldo in attesa. Il
  saldo è diviso in parti alte e basse per una decrittazione efficiente.

- **pending_balance_hi**: I 48 bit superiori criptati del saldo in attesa. Il
  saldo è diviso in parti alte e basse per una decrittazione efficiente.

- **available_balance**: Il saldo criptato disponibile per i trasferimenti.

- **decryptable_available_balance**: Il saldo disponibile criptato con una
  chiave Advanced Encryption Standard (AES) per una decrittazione efficiente da
  parte del proprietario dell'account.

- **allow_confidential_credits**: Se true, consente trasferimenti confidenziali
  in entrata.

- **allow_non_confidential_credits**: Se true, consente trasferimenti non
  confidenziali in entrata.

- **pending_balance_credit_counter**: Conta i crediti di saldo in sospeso in
  entrata da istruzioni di deposito e trasferimento.

- **maximum_pending_balance_credit_counter**: Il limite di conteggio dei crediti
  in sospeso prima di richiedere un'istruzione _rs`ApplyPendingBalance`_ per
  convertire il saldo in sospeso in saldo disponibile.

- **expected_pending_balance_credit_counter**: Il valore
  `pending_balance_credit_counter` fornito dal client attraverso i dati
  dell'istruzione l'ultima volta che l'istruzione _rs`ApplyPendingBalance`_ è
  stata elaborata.

- **actual_pending_balance_credit_counter**: Il valore
  `pending_balance_credit_counter` sul token account al momento in cui l'ultima
  istruzione _rs`ApplyPendingBalance`_ è stata elaborata.

<Callout type="info">
  **Saldo in sospeso vs saldo disponibile**

I saldi confidenziali sono separati in saldi in sospeso e disponibili per
prevenire attacchi DoS. Senza questa separazione, un attaccante potrebbe inviare
ripetutamente token a un token account, bloccando la capacità del proprietario
del token account di trasferire token. Il proprietario del token account non
sarebbe in grado di trasferire token perché il saldo criptato cambierebbe tra il
momento in cui la transazione viene inviata e quando viene elaborata, risultando
in una transazione fallita.

Tutti i depositi e gli importi di trasferimento vengono inizialmente aggiunti al
saldo in sospeso. I proprietari di token account devono utilizzare l'istruzione
_rs`ApplyPendingBalance`_ per convertire il saldo in sospeso in saldo
disponibile. I trasferimenti in entrata o i depositi non influenzano il saldo
disponibile di un token account.

</Callout>

<Callout type="info">
  **Divisione alta/bassa del saldo in sospeso**

Il saldo confidenziale in sospeso è diviso in `pending_balance_lo` e
`pending_balance_hi` perché la decrittografia ElGamal richiede più calcoli per
numeri più grandi. Puoi trovare l'implementazione dell'aritmetica del testo
cifrato
[qui](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/confidential-transfer/ciphertext-arithmetic/src/lib.rs#L54),
che viene utilizzata nell'istruzione _rs`ApplyPendingBalance`_
[qui](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/extension/confidential_transfer/processor.rs#L1180-L1184).

</Callout>

<Callout type="info">
  **Contatori di credito del saldo in sospeso**

Quando si chiama l'istruzione _rs`ApplyPendingBalance`_ per convertire il saldo
in sospeso in saldo disponibile:

1. Il client cerca i saldi correnti in sospeso e disponibili, cripta la somma, e
   fornisce un `decryptable_available_balance` criptato utilizzando la chiave
   AES del proprietario del token account.

2. I contatori di credito in sospeso previsti e effettivi tengono traccia delle
   modifiche al valore del contatore tra quando l'istruzione
   _rs`ApplyPendingBalance`_ viene creata e elaborata:
   - `expected_pending_balance_credit_counter`: Il valore
     `pending_balance_credit_counter` quando il client crea l'istruzione
     _rs`ApplyPendingBalance`_
   - `actual_pending_balance_credit_counter`: Il valore
     `pending_balance_credit_counter` sul token account nel momento in cui
     l'istruzione _rs`ApplyPendingBalance`_ viene elaborata

Contatori previsti/effettivi corrispondenti indicano che il
`decryptable_available_balance` corrisponde al `available_balance`.

Quando si recupera lo stato di un token account per leggere il
`decryptable_available_balance`, valori diversi dei contatori previsti/effettivi
richiedono che il client cerchi le recenti istruzioni di deposito/trasferimento
corrispondenti alla differenza del contatore per calcolare il saldo corretto.

**Processo di riconciliazione del saldo**

Quando i contatori del saldo in sospeso previsto e effettivo differiscono, segui
questi passaggi per riconciliare il `decryptable_available_balance`:

1. Inizia con il `decryptable_available_balance` dal token account
2. Recupera le transazioni più recenti incluse le istruzioni di deposito e
   trasferimento fino alla differenza del contatore (effettivo - previsto):
   - Aggiungi gli importi pubblici dalle istruzioni di deposito
   - Decifra e aggiungi gli importi cifrati di destinazione dalle istruzioni di
     trasferimento

</Callout>

### Istruzioni richieste

La creazione di un token account con l'estensione Confidential Transfer richiede
tre istruzioni:

1. **Crea il token account**: Invoca l'istruzione
   _rs`AssociatedTokenAccountInstruction:Create`_ dell'Associated Token Program
   per creare il token account.

2. **Rialloca lo spazio dell'account**: Invoca l'istruzione
   _rs`TokenInstruction::Reallocate`_ del Token Extensions Program per
   aggiungere spazio per lo stato _rs`ConfidentialTransferAccount`_.

3. **Configura i trasferimenti confidenziali**: Invoca l'istruzione
   [ConfidentialTransferInstruction::ConfigureAccount](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/extension/confidential_transfer/processor.rs#L201)
   del Token Extensions Program per inizializzare lo stato
   _rs`ConfidentialTransferAccount`_.

<Callout type="info">

**Solo il proprietario del token account può configurare un token account per
trasferimenti confidenziali**.

L'istruzione _rs`ConfigureAccount`_ richiede la generazione lato client di
chiavi di crittografia e dati di prova che possono essere generati solo dal
proprietario del token account.

Il _rs`PubkeyValidityProofData`_ crea una prova che verifica la validità di una
chiave ElGamal. Per i dettagli di implementazione, vedi:

- [PubkeyValidityProofData](https://github.com/anza-xyz/agave/blob/b39a9764005ac8596b7e14e61d381305ce57ecaa/zk-sdk/src/zk_elgamal_proof_program/proof_data/pubkey_validity.rs#L58)
- [PubkeyValidityProof](https://github.com/anza-xyz/agave/blob/b39a9764005ac8596b7e14e61d381305ce57ecaa/zk-sdk/src/sigma_proofs/pubkey_validity.rs#L65)

</Callout>

### Codice di esempio

Il seguente codice dimostra come creare un Associated Token Account con
l'estensione Confidential Transfer,

Per eseguire l'esempio, avvia un validator locale con il Token Extensions
Program clonato dalla mainnet usando il seguente comando. Devi avere la CLI di
Solana installata per avviare il validator locale.

```terminal
$ solana-test-validator --clone-upgradeable-program TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb --url https://api.mainnet.solana.com -r
```

<Callout type="info">
  Al momento della stesura, i Confidential Transfers non sono abilitati sul
  validator locale predefinito. Devi clonare il Token Extensions Program dalla
  mainnet per eseguire il codice di esempio.
</Callout>

<CodeTabs>

```rust !! title="main.rs"
use anyhow::{Context, Result};
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,
};
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    spl_token_2022::{
        extension::{
            confidential_transfer::instruction::{configure_account, PubkeyValidityProofData},
            ExtensionType,
        },
        id as token_2022_program_id,
        instruction::reallocate,
        solana_zk_sdk::encryption::{auth_encryption::*, elgamal::*},
    },
    token::{ExtensionInitializationParams, Token},
};
use spl_token_confidential_transfer_proof_extraction::instruction::{ProofData, ProofLocation};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local test validator
    let rpc_client = Arc::new(RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    ));

    // Load the default Solana CLI keypair to use as the fee payer
    // This will be the wallet paying for the transaction fees
    // Use Arc to prevent multiple clones of the keypair
    let payer = Arc::new(load_keypair()?);
    println!("Using payer: {}", payer.pubkey());

    // Generate a new keypair to use as the address of the token mint
    let mint = Keypair::new();
    println!("Mint keypair generated: {}", mint.pubkey());

    // Set up program client for Token client
    let program_client = ProgramRpcClient::new(rpc_client.clone(), ProgramRpcClientSendTransaction);

    // Number of decimals for the mint
    let decimals = 9;

    // Create a token client for the Token-2022 program
    // This provides high-level methods for token operations
    let token = Token::new(
        Arc::new(program_client),
        &token_2022_program_id(), // Use the Token-2022 program (newer version with extensions)
        &mint.pubkey(),           // Address of the new token mint
        Some(decimals),           // Number of decimal places
        payer.clone(),            // Fee payer for transactions (cloning Arc, not keypair)
    );

    // Create extension initialization parameters for the mint
    // The ConfidentialTransferMint extension enables confidential (private) transfers of tokens
    let extension_initialization_params =
        vec![ExtensionInitializationParams::ConfidentialTransferMint {
            authority: Some(payer.pubkey()), // Authority that can modify confidential transfer settings
            auto_approve_new_accounts: true, // Automatically approve new confidential accounts
            auditor_elgamal_pubkey: None,    // Optional auditor ElGamal public key
        }];

    // Create and initialize the mint with the ConfidentialTransferMint extension
    // This sends a transaction to create the new token mint
    let transaction_signature = token
        .create_mint(
            &payer.pubkey(),                 // Mint authority - can mint new tokens
            Some(&payer.pubkey()),           // Freeze authority - can freeze token accounts
            extension_initialization_params, // Add the ConfidentialTransferMint extension
            &[&mint],                        // Mint keypair needed as signer
        )
        .await?;

    println!("Mint Address: {}", mint.pubkey());
    println!(
        "Mint Creation Transaction Signature: {}",
        transaction_signature
    );

    // ===== Create and configure token account for confidential transfers =====
    println!("\nCreate and configure token account for confidential transfers");

    // Get the associated token account address for the owner
    let token_account_pubkey = get_associated_token_address_with_program_id(
        &payer.pubkey(),          // Token account owner
        &mint.pubkey(),           // Mint
        &token_2022_program_id(), // Token program ID
    );
    println!("Token Account Address: {}", token_account_pubkey);

    // Step 1: Create the associated token account
    let create_associated_token_account_instruction = create_associated_token_account(
        &payer.pubkey(),          // Funding account
        &payer.pubkey(),          // Token account owner
        &mint.pubkey(),           // Mint
        &token_2022_program_id(), // Token program ID
    );

    // Step 2: Reallocate the token account to include space for the ConfidentialTransferAccount extension
    let reallocate_instruction = reallocate(
        &token_2022_program_id(),                      // Token program ID
        &token_account_pubkey,                         // Token account
        &payer.pubkey(),                               // Payer
        &payer.pubkey(),                               // Token account owner
        &[&payer.pubkey()],                            // Signers
        &[ExtensionType::ConfidentialTransferAccount], // Extension to reallocate space for
    )?;

    // Step 3: Generate the ElGamal keypair and AES key for token account
    let elgamal_keypair = ElGamalKeypair::new_from_signer(&payer, &token_account_pubkey.to_bytes())
        .expect("Failed to create ElGamal keypair");
    let aes_key = AeKey::new_from_signer(&payer, &token_account_pubkey.to_bytes())
        .expect("Failed to create AES key");

    // The maximum number of Deposit and Transfer instructions that can
    // credit pending_balance before the ApplyPendingBalance instruction is executed
    let maximum_pending_balance_credit_counter = 65536;

    // Initial token balance is 0
    let decryptable_balance = aes_key.encrypt(0);

    // Generate the proof data client-side
    let proof_data = PubkeyValidityProofData::new(&elgamal_keypair)
        .map_err(|_| anyhow::anyhow!("Failed to generate proof data"))?;

    // Indicate that proof is included in the same transaction
    let proof_location =
        ProofLocation::InstructionOffset(1.try_into()?, ProofData::InstructionData(&proof_data));

    // Step 4: Create instructions to configure the account for confidential transfers
    let configure_account_instructions = configure_account(
        &token_2022_program_id(),               // Program ID
        &token_account_pubkey,                  // Token account
        &mint.pubkey(),                         // Mint
        &decryptable_balance.into(),            // Initial balance
        maximum_pending_balance_credit_counter, // Maximum pending balance credit counter
        &payer.pubkey(),                        // Token Account Owner
        &[],                                    // Additional signers
        proof_location,                         // Proof location
    )?;

    // Combine all instructions
    let mut instructions = vec![
        create_associated_token_account_instruction,
        reallocate_instruction,
    ];
    instructions.extend(configure_account_instructions);

    // Create and send the transaction
    let recent_blockhash = rpc_client.get_latest_blockhash().await?;
    let transaction = Transaction::new_signed_with_payer(
        &instructions,
        Some(&payer.pubkey()),
        &[&payer],
        recent_blockhash,
    );

    let transaction_signature = rpc_client
        .send_and_confirm_transaction(&transaction)
        .await?;
    println!(
        "Create Token Account Transaction Signature: {}",
        transaction_signature
    );

    Ok(())
}

// Load the keypair from the default Solana CLI keypair path (~/.config/solana/id.json)
// This enables using the same wallet as the Solana CLI tools
fn load_keypair() -> Result<Keypair> {
    // Get the default keypair path
    let keypair_path = dirs::home_dir()
        .context("Could not find home directory")?
        .join(".config/solana/id.json");

    // Read the keypair file directly into bytes using serde_json
    // The keypair file is a JSON array of bytes
    let file = std::fs::File::open(&keypair_path)?;
    let keypair_bytes: Vec<u8> = serde_json::from_reader(file)?;

    // Create keypair from the loaded bytes
    // This converts the byte array into a keypair
    let keypair = Keypair::from_bytes(&keypair_bytes)?;

    Ok(keypair)
}
```

```toml !! title="Cargo.toml"
[package]
name = "confidential-transfer"
version = "0.1.0"
edition = "2021"

[dependencies]
solana-client = "2.2.2"
solana-sdk = "2.2.2"
spl-associated-token-account = "6.0.0"
spl-token-client = "0.14.0"
spl-token-confidential-transfer-proof-extraction = "0.2.1"
spl-token-confidential-transfer-proof-generation = "0.3.0"

anyhow = "1.0.95"
dirs = "6.0.0"
serde_json = "1.0.135"
tokio = { version = "1.44.2", features = ["full"] }
```

</CodeTabs>
