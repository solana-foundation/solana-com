---
title: Аккаунты
description:
  Узнайте о модели аккаунтов Solana, включая то, как аккаунты хранят данные и
  программы, механику rent, владение аккаунтами и связь между программами и
  аккаунтами данных. Поймите основные концепции системы хранения данных в
  формате ключ-значение на Solana.
---

Все данные в сети Solana хранятся в аккаунтах. Вы можете представить сеть Solana
как публичную базу данных с одной таблицей аккаунтов. Отношение между аккаунтом
и его адресом похоже на пару ключ-значение, где ключ — это адрес, а значение —
аккаунт.

Каждый аккаунт имеет одинаковую базовую [структуру](#account-structure) и может
быть найден с помощью его [адреса](#account-address).

![Диаграмма 3 аккаунтов и их адресов. Включает определение структуры аккаунта.](/assets/docs/core/accounts/accounts.png)

## Адрес аккаунта

Адрес аккаунта — это уникальный 32-байтовый идентификатор, используемый для
поиска аккаунта в блокчейне Solana. Адреса аккаунтов часто отображаются в виде
строк, закодированных в base58. Большинство аккаунтов используют
[Ed25519](https://ed25519.cr.yp.to/) [публичный ключ](#public-key) в качестве
адреса, но это не обязательно, так как Solana также поддерживает
[программные производные адреса](#program-derived-address).

![Аккаунт с адресом публичного ключа, закодированным в base58](/assets/docs/core/accounts/account-address.svg)

### Публичный ключ

Пример ниже демонстрирует, как использовать Solana SDK для создания keypair.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner } from "@solana/kit";

// Kit does not enable extractable private keys
const keypairSigner = await generateKeyPairSigner();
console.log(keypairSigner);
```

```ts !! title="Legacy"
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);
console.log(`Secret Key: ${keypair.secretKey}`);
```

```rs !! title="Rust"
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() {
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());
    println!("Secret Key: {:?}", keypair.to_bytes());
}
```

</CodeTabs>

### Программный производный адрес

[Программный производный адрес](/docs/core/pda) (PDA) — это адрес, который
детерминированно создается с использованием ID программы и одного или нескольких
опциональных входных данных (seed). Пример ниже демонстрирует, как использовать
Solana SDK для создания программного производного адреса.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey; // macro
use solana_sdk::pubkey::Pubkey;

#[tokio::main]
async fn main() {
    let program_address = pubkey!("11111111111111111111111111111111");
    let seeds = [b"helloWorld".as_ref()];
    let (pda, bump) = Pubkey::find_program_address(&seeds, &program_address);
    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
}
```

</CodeTabs>

## Структура аккаунта

Каждый
[`Account`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L48-L60)
имеет максимальный размер
[10MiB](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/system_instruction.rs#L85)
и содержит следующую информацию:

<WithMentions>

- [`lamports`](mention:lamports): Количество [лампортов](#lamports) в аккаунте
- [`data`](mention:data): [Данные](#data) аккаунта
- [`owner`](mention:owner): ID программы, которая [владеет](#owner) аккаунтом
- [`executable`](mention:executable): Указывает, содержит ли аккаунт
  [исполняемый](#executable) бинарный файл
- [`rent_epoch`](mention:rent_epoch): Устаревшее поле
  [эпохи аренды](#rent-epoch)

```rust title="Account"
pub struct Account {
    /// lamports in the account
    // !mention lamports
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    // !mention data
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    // !mention owner
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    // !mention executable
    pub executable: bool,
    /// the epoch at which this account will next owe rent
    // !mention rent_epoch
    pub rent_epoch: Epoch,
}
```

</WithMentions>

<ScrollyCoding>

## !!steps Lamports

Баланс аккаунта в [lamports](/docs/references/terminology#lamport).

Каждый аккаунт должен иметь минимальный баланс в lamports, называемый
[rent](/docs/references/terminology#rent), который позволяет хранить его данные
в блокчейне. Rent пропорционален размеру аккаунта.

<Callout type="info">
  Хотя этот баланс называется арендой, он работает скорее как депозит, так как
  весь баланс может быть возвращен, когда аккаунт закрывается. (Название
  "аренда" происходит от устаревшего поля [rent epoch](#rent-epoch).)
</Callout>

(См. формулу
[минимального баланса](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97)
и применимые
[константы](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L47-L70).)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    // !focus
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    // !focus
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Данные

Это поле обычно называется "данные аккаунта". `data` в этом поле считается
произвольным, так как оно может содержать любую последовательность байтов.
Каждая программа определяет структуру данных, хранящихся в этом поле.

- Программные аккаунты: Это поле содержит либо исполняемый код программы, либо
  адрес [аккаунта данных программы](#program-data-accounts), который хранит
  исполняемый код программы.
- Аккаунты данных: Это поле обычно хранит данные состояния, предназначенные для
  чтения.

Чтение данных из аккаунта Solana включает два шага:

1. Получение аккаунта с использованием его [адреса](#account-address)
2. Десериализация поля `data` аккаунта из сырых байтов в соответствующую
   структуру данных, определенную программой, которой принадлежит аккаунт.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    // !focus
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    // !focus
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    // !focus
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    // !focus
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Владелец

Это поле содержит ID программы, которой принадлежит аккаунт.

Каждый аккаунт Solana имеет [программу](/docs/core/programs), назначенную его
владельцем. Только программа-владелец может изменять `data` аккаунта или
вычитать lamports, как указано в инструкциях программы.

(В случае программного аккаунта владельцем является его
[загрузочная программа](https://solana.com/docs/core/programs#loader-programs).)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    // !focus
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    // !focus
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Исполняемый

Это поле указывает, является ли аккаунт
[программным аккаунтом](#program-accounts) или
[аккаунтом данных](#data-accounts)

- Если `true`: Аккаунт является программным аккаунтом
- Если `false`: Аккаунт является аккаунтом данных

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    // !focus
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    // !focus
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Эпоха аренды

**Поле `rent_epoch` устарело.**

Ранее это поле отслеживало, когда аккаунту нужно было платить аренду. Однако
этот механизм сбора аренды был впоследствии упразднён.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    // !focus
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    // !focus
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

</ScrollyCoding>

## Типы аккаунтов

Существует две основные категории аккаунтов:

- [Программные аккаунты](#program-accounts): Аккаунты, содержащие исполняемый
  код
- [Аккаунты данных](#data-accounts): Аккаунты, не содержащие исполняемый код

Это разделение означает, что исполняемый код программы и её состояние хранятся в
отдельных аккаунтах. (Аналогично операционным системам, которые обычно имеют
отдельные файлы для программ и их данных.)

### Программные аккаунты

Каждая программа принадлежит
[загрузочной программе](/docs/core/programs#loader-programs), которая
используется для развёртывания и управления аккаунтом. Когда новая
[программа](/docs/core/programs) развёртывается, создаётся аккаунт для хранения
её [исполняемого](#executable) кода. Этот аккаунт называется программным
аккаунтом. (Для упрощения можно считать программный аккаунт самой программой.)

На диаграмме ниже показано, как загрузочная программа используется для
развёртывания программного аккаунта. Поле `data` программного аккаунта содержит
исполняемый код программы.

![Диаграмма программного аккаунта, его 4 компонентов и загрузочной программы.](/assets/docs/core/accounts/program-account-simple.svg)

#### Аккаунты данных программы

Программы, развёрнутые с использованием loader-v3, не содержат программный код в
своём поле `data`. Вместо этого их поле `data` указывает на отдельный **аккаунт
данных программы**, который содержит программный код. (См. диаграмму ниже.)

![Программный аккаунт с данными. Данные указывают на отдельный аккаунт данных программы](/assets/docs/core/accounts/program-account-expanded.svg)

<Callout>
  Во время развертывания или обновления программы буферные аккаунты используются
  для временного размещения загрузки.
</Callout>

Пример ниже извлекает аккаунт Token Program. Обратите внимание, что поле
`executable` установлено в `true`, что указывает на то, что аккаунт является
программой.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const programId = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address;

const accountInfo = await rpc
  .getAccountInfo(programId, { encoding: "base64" })
  .send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Connection, PublicKey } from "@solana/web3.js";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const programId = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

const accountInfo = await connection.getAccountInfo(programId);
// !collapse(1:17) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::pubkey;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let program_id = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let account_info = connection.get_account(&program_id).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

### Аккаунты данных

Аккаунты данных не содержат исполняемого кода. Вместо этого они хранят
информацию.

#### Аккаунт состояния программы

Программы используют аккаунты данных для поддержания своего состояния. Для этого
они должны сначала создать новый аккаунт данных. Процесс создания аккаунта
состояния программы часто абстрагирован, но полезно понимать основной процесс.

Чтобы управлять своим состоянием, новая программа должна:

1. Вызвать [System Program](/docs/core/programs#the-system-program) для создания
   аккаунта. (System Program затем передает владение новой программе.)
2. Инициализировать данные аккаунта, как это определено в его
   [инструкциях](/docs/core/instructions).

![Диаграмма аккаунта данных, принадлежащего программному аккаунту](/assets/docs/core/accounts/data-account.svg)

Пример ниже создает и извлекает аккаунт Token Mint, принадлежащий программе
Token 2022.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  fetchMint
} from "@solana-program/token-2022";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer
const feePayer = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Instruction to create new account for mint (token 2022 program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token 2022 program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address
});

const instructions = [createAccountInstruction, initializeMintInstruction];

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }), // Create transaction message
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx), // Set fee payer
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set transaction blockhash
  (tx) => appendTransactionMessageInstructions(instructions, tx) // Append instructions
);

// Sign transaction message with required signers (fee payer and mint keypair)
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Mint Address:", mint.address);
console.log("Transaction Signature:", transactionSignature);

const accountInfo = await rpc.getAccountInfo(mint.address).send();
console.log(accountInfo);

const mintAccount = await fetchMint(rpc, mint.address);
console.log(mintAccount);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  TOKEN_2022_PROGRAM_ID,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const recentBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: recentBlockhash.blockhash,
  lastValidBlockHeight: recentBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Generate keypair to use as address of mint
const mint = Keypair.generate();

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: await getMinimumBalanceForRentExemptMint(connection),
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);

const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint] // Signers
);

console.log("Mint Address: ", mint.publicKey.toBase58());
console.log("Transaction Signature: ", transactionSignature);

const accountInfo = await connection.getAccountInfo(mint.publicKey);

// !collapse(1:16) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);

const mintAccount = await getMint(
  connection,
  mint.publicKey,
  "confirmed",
  TOKEN_2022_PROGRAM_ID
);
console.log(mintAccount);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    program_pack::Pack,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_token_2022_interface::{
    id as token_2022_program_id, instruction::initialize_mint, state::Mint,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let recent_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    let space = Mint::LEN;
    let rent = client.get_minimum_balance_for_rent_exemption(space).await?;

    // Create account instruction
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),      // fee payer
        &mint.pubkey(),           // mint address
        rent,                     // rent
        space as u64,             // space
        &token_2022_program_id(), // program id
    );

    // Initialize mint instruction
    let initialize_mint_instruction = initialize_mint(
        &token_2022_program_id(),
        &mint.pubkey(),            // mint address
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        9,                         // decimals
    )?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        recent_blockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    let account_info = client.get_account(&mint.pubkey()).await?;
    println!("{:#?}", account_info);

    let mint_account = Mint::unpack(&account_info.data)?;
    println!("{:#?}", mint_account);

    Ok(())
}
```

</CodeTabs>

#### Системные аккаунты

Не все аккаунты получают нового владельца после создания System Program.
Аккаунты, принадлежащие System Program, называются системными аккаунтами. Все
аккаунты кошельков являются системными аккаунтами, что позволяет им оплачивать
[комиссии за транзакции](docs/core/fees).

![Кошелек, принадлежащий System Program, содержащий 1,000,000 лампортов](/assets/docs/core/accounts/system-account.svg)

Когда SOL отправляется на новый адрес впервые, на этом адресе создается аккаунт,
принадлежащий System Program.

В приведённом ниже примере создаётся новая пара ключей (keypair) и пополняется
SOL. После выполнения кода вы можете увидеть адрес аккаунта `owner`, который
является `11111111111111111111111111111111`
([Системная программа](/docs/core/programs#the-system-program)).

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  generateKeyPairSigner,
  lamports
} from "@solana/kit";

// Create a connection to Solana cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate a new keypair
const keypair = await generateKeyPairSigner();
console.log(`Public Key: ${keypair.address}`);

// Funding an address with SOL automatically creates an account
const signature = await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: keypair.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

const accountInfo = await rpc.getAccountInfo(keypair.address).send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";

// Generate a new keypair
const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);

// Create a connection to the Solana cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Funding an address with SOL automatically creates an account
const signature = await connection.requestAirdrop(
  keypair.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const accountInfo = await connection.getAccountInfo(keypair.publicKey);
console.log(JSON.stringify(accountInfo, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signer::{keypair::Keypair, Signer},
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate a new keypair
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());

    // Create a connection to Solana cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Funding an address with SOL automatically creates an account
    let signature = connection
        .request_airdrop(&keypair.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = connection.confirm_transaction(&signature).await?;
        if confirmed {
            break;
        }
    }

    let account_info = connection.get_account(&keypair.pubkey()).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

#### Аккаунты Sysvar

Аккаунты Sysvar существуют по заранее определённым адресам и предоставляют
доступ к данным состояния кластера. Они динамически обновляются с данными о
сетевом кластере. Полный список можно найти в
[Аккаунты Sysvar](https://docs.anza.xyz/runtime/sysvars).

Пример ниже извлекает и десериализует данные из аккаунта Sysvar Clock.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { createSolanaRpc } from "@solana/kit";
import { fetchSysvarClock, SYSVAR_CLOCK_ADDRESS } from "@solana/sysvars";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const accountInfo = await rpc
  .getAccountInfo(SYSVAR_CLOCK_ADDRESS, { encoding: "base64" })
  .send();
console.log(accountInfo);

// Automatically fetch and deserialize the account data
const clock = await fetchSysvarClock(rpc);
console.log(clock);
```

```ts !! title="Legacy"
import { Connection, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getSysvarClockCodec } from "@solana/sysvars";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const accountInfo = await connection.getAccountInfo(SYSVAR_CLOCK_PUBKEY);

// Deserialize the account data
const decodedClock = getSysvarClockCodec().decode(
  new Uint8Array(accountInfo?.data ?? [])
);
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
console.log(decodedClock);
```

```rs !! title="Rust"
use anyhow::Result;
use bincode::deserialize;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::sysvar::{self, clock::Clock};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let account = connection.get_account(&sysvar::clock::ID).await?;
    // Deserialize the account data
    let clock: Clock = deserialize(&account.data)?;

    println!("{:#?}", account);
    println!("{:#?}", clock);

    Ok(())
}
```

</CodeTabs>
