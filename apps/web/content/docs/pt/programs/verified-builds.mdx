---
title: Verificando programas
description:
  Builds verificados são uma forma de vincular seu programa ao seu código-fonte
  e permitir que todos verifiquem independentemente que o programa foi realmente
  construído a partir desse código-fonte fornecido.
---

Este guia serve como referência para desenvolvedores que desejam implementar
builds verificados para seus programas na Solana. Vamos abordar o que são builds
verificados, como usá-los, considerações especiais e melhores práticas para
garantir a autenticidade do seu programa na blockchain.

# O que são builds verificados?

Builds verificados garantem que o programa executável que você implanta na rede
Solana corresponde ao código-fonte em seu repositório. Com isso, desenvolvedores
e usuários podem ter confiança de que o programa em execução na blockchain
corresponde exatamente à base de código pública, promovendo transparência e
segurança.

O processo de verificação envolve comparar o hash do programa na blockchain com
o hash do programa compilado localmente a partir do código-fonte. Isso garante
que não haja discrepâncias entre as duas versões.

> Embora um build verificado não deva ser considerado mais seguro que um build
> não verificado, o build permite que os desenvolvedores verifiquem por conta
> própria se o código-fonte corresponde ao que está implantado na blockchain.
> Usando o código-fonte, um desenvolvedor pode então validar o que o código
> executa ao enviar uma transação.

O pipeline de builds verificados foi concebido e é mantido pela
[Ellipsis Labs](https://ellipsislabs.xyz/) e [OtterSec](https://osec.io/). Para
mais detalhes, siga o guia no
[repositório original de builds verificados](https://github.com/Ellipsis-Labs/solana-verifiable-build)
e o processo de verificação de build diretamente na suíte de ferramentas
[Anza](https://www.anza.xyz/), quando suportado.

# Como funciona?

O processo de verificação é feito comparando o hash do programa na blockchain
com o hash do programa construído localmente a partir do código-fonte. Você
constrói seu programa em um ambiente controlado usando a CLI Solana Verify e
Docker. Isso garante que o processo de construção seja determinístico e
consistente em diferentes sistemas. Depois de ter o executável, você pode
implantá-lo na rede Solana. Durante o processo de construção, uma
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)
do [programa verify](https://github.com/otter-sec/otter-verify) será criada.
Esta PDA contém todos os dados necessários para verificar o programa. A PDA
contém o endereço do programa, URL do git, hash do commit e os argumentos usados
para construir o programa.

Usando os dados na PDA, todos podem executar o comando do programa verify
localmente e verificar se o programa foi construído a partir do código-fonte
fornecido. Então todos podem verificar por si mesmos de forma completamente
confiável ou podem executar sua própria
[API de verificação](https://github.com/otter-sec/solana-verified-programs-api)
mantida pela [OtterSec](https://github.com/otter-sec) para fornecer um ponto de
acesso fácil para os usuários verificarem a verificação. Você já pode ver essas
[chamadas de API](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
sendo usadas no
[Solana Explorer](https://explorer.solana.com/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/verified-build)
e
[SolanaFM](https://solana.fm/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/transactions?cluster=mainnet-alpha),
entre outros lugares.

# Por que devo usar builds verificadas?

O uso de builds verificadas proporciona os seguintes benefícios:

- Segurança: Garante que o programa em execução na blockchain corresponde ao
  código-fonte, evitando alterações maliciosas.

- Transparência: Permite que outros usuários e desenvolvedores validem que o
  programa na blockchain é confiável, comparando-o com a base de código pública.

- Confiança: Aumenta a confiança do usuário, pois as builds verificadas
  demonstram que o comportamento do seu programa na blockchain está alinhado com
  seu código público. Ao construir programas verificáveis, você minimiza os
  riscos associados à execução de código não autorizado ou malicioso. Também
  garante que você siga as melhores práticas e ofereça aos pesquisadores de
  segurança uma maneira fácil de entrar em contato com você. Além disso,
  carteiras e outras ferramentas podem permitir transações do seu programa mais
  facilmente desde que esteja verificado.

- Descoberta: quando você fornece uma compilação verificada do seu programa,
  todos podem encontrar seu código-fonte, documentação, SDK do programa ou IDL e
  também podem facilmente entrar em contato com você via GitHub caso haja algum
  problema.

# Como criar compilações verificadas?

Para criar compilações verificadas, você precisará seguir estas etapas:

Resumo:

- Faça commit do seu código em um repositório público
- Construa uma compilação verificada no Docker
- Implante a compilação verificada
- Verifique o programa implantado na API pública

Se você verificar seu programa que não foi compilado em um contêiner Docker,
provavelmente falhará porque as compilações de programas Solana não são
determinísticas em diferentes sistemas.

<Steps>
<Step>

### Instale o Docker e o Cargo

Instale as ferramentas necessárias, garantindo que você tenha o Docker e o Cargo
instalados. O Docker fornece um ambiente de compilação controlado para garantir
consistência, e o Cargo é usado para gerenciar pacotes Rust.

- Docker: Siga os passos no
  [site do Docker](https://docs.docker.com/engine/install/) para instalar o
  Docker para sua plataforma. Depois de instalado, certifique-se de que o
  serviço Docker esteja em execução seguindo este guia adiante.
- Cargo: Se você ainda não tem o Cargo instalado, pode instalá-lo executando o
  seguinte comando:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

</Step>
<Step>

### Instale a CLI Solana Verify

A CLI Solana Verify é a principal ferramenta usada para verificar compilações. A
CLI Solana Verify atualmente é mantida pela
[Ellipsis Labs](https://ellipsislabs.xyz/) e pode ser instalada usando o Cargo.

Você pode instalá-la executando:

```bash
cargo install solana-verify
```

Se você precisar de uma versão específica da CLI, pode fixar a versão com:

```bash
cargo install solana-verify --version $VERSION
```

Se desejar, você pode instalar uma versão diretamente de um commit específico:

```bash
cargo install solana-verify --git https://github.com/Ellipsis-Labs/solana-verifiable-build --rev 13a1db2
```

</Step>
<Step>

### Preparar projeto

Para verificar contra um repositório, ele precisa ter um arquivo `Cargo.lock` no
diretório raiz do seu repositório. Se você tiver apenas um programa em seu
repositório e um arquivo `cargo.lock` na raiz, pode ir diretamente para o
próximo passo e compilar seu programa.

Se o seu programa estiver em uma subpasta e você tiver um workspace Rust, você
precisa criar um arquivo `Cargo.toml` do workspace no diretório raiz do seu
repositório.

Você pode usar este exemplo de `Cargo.toml` como modelo:

```toml title="Cargo.toml"
[workspace]
members = ["program/programs/*"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1

[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
```

Certifique-se de que seu programa esteja no array `workspace/members` e que o
arquivo `Cargo.toml` do seu programa tenha o nome `lib` correto configurado.

> O importante é o `lib name`, não o nome do pacote!

Algo como isto:

```toml title="waffle/Cargo.toml"
[package]
name = "waffle"
version = "0.1.0"
edition = "2021"

[lib]
name = "waffle"
crate-type = ["cdylib", "lib"]

[dependencies]
solana-program = "2.1.0"
```

Neste [repositório](https://github.com/solana-developers/verified-program) você
pode ver um exemplo de um workspace com um programa em uma subpasta. Observe
também que quando o programa está em uma subpasta, você precisará adicionar esta
pasta como `--mount-path` ao comando `verify-from-repo` posteriormente.

Neste [repositório](https://github.com/solana-developers/solana-game-preset)
você pode encontrar um exemplo de Anchor. Neste
[repositório](https://github.com/solana-developers/verified-program-root) você
pode encontrar um exemplo de Rust nativo.

Com este arquivo `Cargo.toml` no lugar, você pode então executar
`cargo generate-lockfile` para criar um arquivo de bloqueio e continuar com a
compilação do seu programa.

</Step>
<Step>

### Compilando programas verificáveis

Para compilar de forma verificável seu programa Solana, navegue até o diretório
que contém o arquivo `Cargo.toml` do seu workspace e execute:

```bash
solana-verify build
```

Isso copiará seu ambiente para um contêiner Docker e o compilará de maneira
determinística.

> Certifique-se de que você realmente implante a compilação verificada e não a
> sobrescreva acidentalmente com `anchor build` ou `cargo build-sbf`, pois estes
> provavelmente não resultarão no mesmo hash e, portanto, sua verificação
> falhará.

Para projetos com vários programas, você pode compilar um programa específico
usando o nome da biblioteca (não o nome do pacote):

```bash
solana-verify build --library-name $PROGRAM_LIB_NAME
```

Este processo garante compilações determinísticas e pode levar algum tempo,
especialmente em certos sistemas (por exemplo, MacBook M1) porque está sendo
executado dentro de um contêiner docker. Para compilações mais rápidas, é
recomendado usar uma máquina Linux com arquitetura x86.

Depois que a compilação for concluída, você pode recuperar o hash do executável
usando o seguinte comando:

```bash
solana-verify get-executable-hash target/deploy/$PROGRAM_LIB_NAME.so
```

</Step>
<Step>

### Implantando programas verificáveis

Depois de compilar seu programa e recuperar seu hash, você pode implantá-lo na
rede Solana. É recomendado usar uma solução de assinatura múltipla ou governança
como o [Squads Protocol](https://squads.so/protocol) para implantações seguras,
mas você também pode implantar diretamente com:

```bash
solana program deploy -u $NETWORK_URL target/deploy/$PROGRAM_LIB_NAME.so --program-id $PROGRAM_ID --with-compute-unit-price 50000 --max-sign-attempts 100 --use-rpc
```

Uma taxa de baixa prioridade adequada atualmente pode ser solicitada ao seu
provedor rpc, por exemplo
[Quicknode](https://www.quicknode.com/gas-tracker/solana).

Para verificar se o programa implantado corresponde ao executável compilado,
execute:

```bash
solana-verify get-program-hash -u $NETWORK_URL $PROGRAM_ID
```

> Você pode ter diferentes versões implantadas em diferentes
> [clusters Solana](/docs/references/clusters) (ou seja, devnet, testnet,
> mainnet). Certifique-se de usar a URL de rede correta para o cluster Solana
> desejado contra o qual você quer verificar um programa. A verificação remota
> só funcionará na mainnet.

</Step>
<Step>

### Verificando contra repositórios

Para verificar um programa contra seu repositório público, use:

```bash
solana-verify verify-from-repo -u $NETWORK_URL --program-id $PROGRAM_ID https://github.com/$REPO_PATH --commit-hash $COMMIT_HASH --library-name $PROGRAM_LIB_NAME --mount-path $MOUNT_PATH
```

> Enquanto você executa a compilação verificada no diretório do seu programa, ao
> executar `verify-from-repo` você precisa adicionar a flag `--mount-path`. Este
> será o caminho para a pasta contendo o `Cargo.toml` que contém o nome da
> biblioteca do seu programa.

Este comando compara o hash do programa na blockchain com o hash executável
construído a partir do código-fonte no hash de commit especificado.

No final, o comando perguntará se você deseja carregar seus dados de verificação
na blockchain. Se fizer isso, o Solana Explorer mostrará imediatamente os dados
de verificação do seu programa. Até que seja verificado por uma compilação
remota, ele será exibido como não verificado. Aprenda como verificar seu
programa em uma API pública no próximo passo.

Se você quiser fixar a verificação a uma determinada versão, pode adicionar a
flag `--commit-hash` ao comando.

</Step>
<Step>

### Verificar com API pública

Finalmente, você também pode verificar diretamente o programa com qualquer
pessoa que esteja executando a API de verificação:

```bash
solana-verify verify-from-repo --remote -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

> Recomenda-se usar uma URL RPC paga, pois caso contrário, você pode atingir
> limites de taxa dos RPCs gratuitos. Então, em vez de `-um`, você deve usar
> `--url yourRpcUrl` para uma verificação mais confiável.

A flag `--remote` envia uma solicitação de compilação para a API da OtterSec,
que aciona uma compilação remota do seu programa. Quando a compilação é
concluída, o sistema verifica se o hash na blockchain do seu programa
corresponde ao hash do artefato de compilação gerado a partir do seu
repositório.

O padrão é a
[API da OtterSec](https://github.com/otter-sec/solana-verified-programs-api).

Certifique-se de escolher sim quando for perguntado se deseja carregar os dados
de verificação na blockchain. Isso é usado pela API para verificar que você
carregou os dados de verificação.

Você também pode acionar um trabalho remoto manualmente usando:

```bash
solana-verify remote submit-job --program-id <program-id> --uploader <address>
```

Onde o uploader é o endereço que tem autoridade para escrever no PDA. Isso deve
ser a autoridade do programa na maioria dos casos. Se o seu programa é
controlado por um multisig, continue na parte
[verificação multisig](#how-to-verify-your-program-when-its-controlled-by-a-multisig-like-squads)
deste guia abaixo.

Isso enviará um trabalho para a API OtterSec e você poderá verificar o status do
trabalho com:

```bash
solana-verify remote get-job-status --job-id <job-id>
```

Depois que a verificação for concluída com sucesso, o que pode demorar um pouco,
você poderá ver seu programa como verificado na
[API OtterSec para programas individuais](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
e no
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY/verified-build),
[SolanaFM](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY?cluster=mainnet-alpha),
[SolScan](https://solscan.io/account/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY#programVerification)
e eventualmente também no site mantido pela comunidade
[SolanaVerify.org](https://www.solanaverify.org/) mantido por
[0xDeep](https://x.com/0xDeep) e na
[API de programas verificados OtterSec](https://verify.osec.io/verified-programs)
e finalmente no
[Painel Dune de Programas Verificados](https://dune.com/jonashahn/verified-programs/dedf21e1-9b71-42c8-89f9-02ed94628657)
contribuindo para um ecossistema Solana mais saudável.

</Step>
</Steps>

## Como verificar seu programa quando ele é controlado por um Multisig como Squads

Para que a verificação remota funcione, você precisa escrever os dados de
verificação em um PDA assinado pela autoridade do programa. Se seu programa é
controlado por um multisig, você pode exportar esta transação de escrita PDA e
enviá-la através do [Squads Protocol](https://squads.so/protocol) ou outra
solução multisig de sua escolha.

<Steps>
<Step>

### 1. Construir o programa verificável

Primeiro construa o programa:

```bash
solana-verify build
```

Isso construirá uma build verificável usando um contêiner docker com a versão
solana especificada no arquivo `Cargo.lock`.

</Step>
<Step>

### 2. Implantar o programa

```bash
solana config set --url "PayedMainnetRPCAddress" // the public endpoint will be rate limited too much
solana program deploy target/deploy/verify_squads.so
```

Para o restante deste guia multisig, usaremos um ID de programa de exemplo
`6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`.

</Step>
<Step>

### 3. Commit e verificação contra o repositório

Uma vez feito isso, commitamos o projeto para o github. Aqui está um exemplo:
https://github.com/solana-developers/verify-squads

Opcional: Veja se você pode verificar localmente primeiro (este comando usa o ID
do programa de exemplo `6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`):

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
```

Apenas para garantir que seus parâmetros estão corretos.

</Step>
<Step>

### 4. Transferir a autoridade do programa para o multisig

Se você ainda não transferiu a autoridade do seu programa para o multisig e
copiou a autoridade do multisig. Você precisará dela na próxima etapa.

</Step>
<Step>

### 5. Exportar transação PDA

Quando você tem a autoridade do programa localmente, você é solicitado a fazer
upload dos dados de build para a blockchain ao usar o comando
`solana-verify verify-from-repo`.

Como você não pode fazer isso quando está usando um multisig, você precisa
exportar a transação PDA manualmente e depois acionar a transação através do
Squads.

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader <your program authority> --encoding base58 --compute-unit-price 0
```

Isso retornará uma transação em base58. Se você quiser uma transação codificada
em base64 para uso em um inspetor de transações, você pode usar
`--encoding base64`.

```bash
P6vBfcPaaXb8fZoT3NBAYEcdtEj7tubA1k2gBxmFKZ3UWF5YyrmDMFTvLKALCJoUuRsPAjMckudYruCu3eeWQtuDrFbEMLxLFutnKXac974fnkMivcwUdY66VLjbxQT6ATmcy7F4hBtz1G4P1h6iBJLhb8WtrtgY3i4qq45MUEb7RjuMEfUFXKrNgPdGxkz5xvMHq3dxKRcpmEK5k2DkeW6SUQYBVe19Ga3B9GyhTX8k3CMt9JCEah13WyRnQd8GjoK6sTEvGJym6xDNvmd8yiJYSNcaYwEJsjHEUf4Yh6kAC7ki2KRvVAr3NVe1gjqK9McrwSQjtUatvydTG8Zovcr7PPUEMf3yPMgKXjZLB2QpkH63yTTYdNAnWFuv9E6b6nYRqye5XcNi436yKw5U14fXh65yK34bgYLi9328UT1huJELsJU9BRGnGUmb6GWp6c2WL5BhnzgNTSnt9TXFfEgUMzhvKzpVBxLP44hwqqBdyUhHFysCF37531PnmiESq8x1xou23xJ6FcQbc199754MkqQd7tX9CUznGzAEqHGkzn3VBoJnojsKtgYmiTYbdRsT1CU18MbYEE7WvGAvXyxxbpNzbAcc94HrnM6cqRGmwhEBroPfFghTdmzg9D
```

</Step>
<Step>

### 6. Enviar transação através do Squads

Vá para o construtor de transações do Squads e importe a transação codificada em
base58. Certifique-se de que na simulação a transação tenha apenas uma chamada
para o programa de verificação osec e o programa de orçamento do computador e
nada mais!

</Step>
<Step>

### 7. Enviar trabalho de verificação remota

Uma vez que a transação para o Squads foi bem-sucedida, você pode enviar o
trabalho remoto:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
--uploader <your program authority>
```

É isso! Você verificou seu programa contra um repositório público e enviou um
trabalho remoto para a API da OtterSec. Agora você deve poder ver isso refletido
no explorador da Solana e em outros lugares.

</Step>
<Step>

### 8. Atualizando o programa (Opcional)

Quando você atualiza seu programa, precisa exportar uma nova transação PDA e
enviá-la novamente através do Squads.

Fazendo uma atualização no programa:

```bash
solana-verify build
solana program write-buffer target/deploy/verify_squads.so --with-compute-unit-price 50000 --max-sign-attempts 50
```

Em seguida, transfira essa autoridade do buffer para o multisig ou crie
diretamente o buffer com a autoridade do multisig.

```bash
solana program set-buffer-authority Fu3k79g53ZozAj47uq1tXrFy4QbQYh7y745DDsxjtyLR --new-buffer-authority 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

</Step>
<Step>

### 9. Exportar e enviar nova transação PDA

Não se esqueça de fazer commit das suas alterações no github. Exporte a
transação de atualização PDA novamente:

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

Envie a transação através do Squads novamente.

Você pode ver um exemplo de transação
[aqui](https://solana.fm/tx/4zJ1vK2KToAwxuEYzTMLqPkcebjoi9rdeeyxtEEx9L5Q4vWDA8h6Rr4kPRuRxcV7ZLKMr6qx1LTWb6x3ZpUJaFUW?cluster=mainnet-alpha).

Em seguida, envie para outra compilação remota:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

Deve resultar em algo como isto:

```shell
Verification request sent with request id: b63339d2-163e-49ac-b55d-3454c1c2b5b3
Verification in progress... ⏳ [00:18:02] ✅ Process completed. (Done in 18
minutes) Program 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD has been verified.
✅ The provided GitHub build matches the on-chain hash. On Chain Hash:
96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Executable
Hash: 96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Repo URL:
https://github.com/Woody4618/verify-squads/tree/0fb0a2e30c15c51732c0ad5e837975a6f7bbc7ed
Check the verification status at:
https://verify.osec.io/status/6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD Job
url: https://verify.osec.io/job/b63339d2-163e-49ac-b55d-3454c1c2b5b3
```

Parabéns, você verificou seu programa após uma atualização multisig!

</Step>
</Steps>

## Verificar a partir da imagem docker

Você também pode verificar seu programa usando uma imagem docker executando o
seguinte comando:

```bash
solana-verify verify-from-image -e
examples/hello_world/target/deploy/hello_world.so -i
ellipsislabs/hello_world_verifiable_build:latest -p
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn
```

Este comando carrega a imagem armazenada em
`ellipsislabs/hello_world_verifiable_build:latest`, e verifica se o hash do
caminho executável no contêiner é o mesmo que o hash do programa on-chain
fornecido ao comando. Como a compilação já foi carregada para uma imagem, não há
necessidade de uma reconstrução completa do executável, o que pode levar muito
tempo.

O Dockerfile que cria a imagem
`ellipsislabs/hello_world_verifiable_build:latest` pode ser encontrado no
repositório da Ellipsis Labs
[/examples/hello_world](https://github.com/Ellipsis-Labs/solana-verifiable-build/tree/master/examples/hello_world).

Abaixo está a saída esperada:

```bash
Verifying image: "ellipsislabs/hello_world_verifiable_build:latest", on network
"https://api.mainnet-beta.solana.com" against program ID
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn Executable path in container:
"examples/hello_world/target/deploy/hello_world.so"

Executable hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Program hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Executable
matches on-chain program data ✅
```

## Exemplo de build verificada

Aqui está um exemplo de verificação de um programa de exemplo com o ID
`FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv` usando o código-fonte deste
[repositório](https://github.com/solana-developers/verified-program):

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

Por padrão, o comando `verify-from-repo` utiliza o último commit no branch
principal. Você também pode definir um commit específico caso queira continuar
trabalhando no repositório usando o parâmetro `commit-hash`:
`--commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e`

Finalmente, você também pode verificar o programa diretamente na API da
OtterSec:

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --remote --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

O comando `--remote` envia uma solicitação de build para a API da OtterSec, que
inicia uma build remota do seu programa. Quando a build é concluída, o sistema
verifica se o hash do seu programa na blockchain corresponde ao hash do artefato
de build gerado a partir do seu repositório.

## Programas populares que já estão verificados

### Phoenix

```shell
solana-verify verify-from-repo -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

Resultado final:

```shell
Executable Program Hash from repo: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
On-chain Program Hash: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
Program hash matches ✅
```

### Squads V3

```shell
solana-verify verify-from-repo https://github.com/Squads-Protocol/squads-mpl --commit-hash c95b7673d616c377a349ca424261872dfcf8b19d --program-id SMPLecH534NA9acpos4G6x7uf3LWbCAwZQE9e8ZekMu -um --library-name squads_mpl --bpf
```

> Observe que precisamos especificar o `library-name` porque o repositório do
> Squads inclui vários programas. Usamos a flag `--bpf` porque `squads_mpl` foi
> verificado anteriormente com o Anchor.

Resultado final:

```shell
Executable Program Hash from repo: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
On-chain Program Hash: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
Program hash matches ✅
```

### Drift V2

```shell
solana-verify verify-from-repo -um --program-id dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH https://github.com/drift-labs/protocol-v2 --commit-hash 110d3ff4f8ba07c178d69f9bfc7b30194fac56d6 --library-name drift
```

Resultado final:

```shell
Executable Program Hash from repo: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
On-chain Program Hash: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
Program hash matches ✅
```

### Marginfi V2

```shell
solana-verify verify-from-repo -um --program-id MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA https://github.com/mrgnlabs/marginfi-v2 --commit-hash d33e649e415c354cc2a1e3c49131725552d69ba0 --library-name marginfi -- --features mainnet-beta
```

Resultado final:

```shell
Executable Program Hash from repo: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
On-chain Program Hash: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
Program hash matches ✅
```

# Conclusão

Usar [builds verificadas na Solana](/developers/guides/advanced/verified-builds)
garante a integridade e confiabilidade dos seus programas na rede e permite que
desenvolvedores encontrem seus SDKs diretamente no Solana Explorer. Ao
aproveitar ferramentas como o Solana Verify CLI e Docker, você pode manter
builds verificáveis e seguras que estejam alinhadas com seu código-fonte. Sempre
tome as precauções necessárias para usar ambientes consistentes e considere
soluções de governança para atualizações e implantações seguras.

## Segurança + Aviso legal

Embora as builds verificadas sejam uma ferramenta poderosa para garantir a
integridade dos seus programas Solana, elas não são completamente independentes
de confiança na configuração padrão. As imagens docker são construídas e
hospedadas pela Solana Foundation.

Esteja ciente de que você está construindo seu projeto em uma imagem docker
baixada e que toda a sua configuração é copiada para essa imagem docker para
compilação, incluindo informações potencialmente sensíveis.

Se você quiser ter uma configuração completamente independente de confiança,
pode construir as imagens docker você mesmo e hospedá-las em sua própria
infraestrutura. Dessa forma, você pode ter certeza de que as imagens docker não
foram adulteradas. Você pode encontrar os scripts para criar suas próprias
imagens docker no
[repositório de builds verificadas](https://github.com/Ellipsis-Labs/solana-verifiable-build)
e pode fazer um fork e executar as ações do github você mesmo ou validar que
elas estão corretas.

Além disso, para a verificação remota, você está confiando na API da OtterSec e
no
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
até certo ponto.

A API ou o Solana Explorer podem potencialmente exibir informações incorretas se
forem comprometidos.

Se você quiser ter uma configuração completamente independente de confiança,
pode executar a
[API de Verificação](https://github.com/otter-sec/solana-verified-programs-api)
você mesmo ou executar a verificação do programa localmente usando o comando
`verify-from-repo` utilizando os dados de verificação on-chain que são salvos em
um
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)
que é derivado da autoridade de implantação dos programas e do
[programa de verificação](https://explorer.solana.com/address/verifycLy8mB96wd9wqq3WDXQwM4oU6r42Th37Db9fC).

O programa de verificação é implantado pela [equipe OtterSec](https://osec.io/)
e ainda não está congelado, portanto pode ser atualizado a qualquer momento.

A Fundação Solana, OtterSec e a equipe Ellipsis Labs não são responsáveis por
quaisquer perdas ou danos que possam ocorrer ao usar o pipeline de builds
verificados.

# Security.txt para programas Solana

Além de builds verificados, você também pode adicionar um arquivo `security.txt`
ao seu programa. No futuro, uma vez implementado, o `security.txt` conterá a
chave pública do verificador para fácil acesso aos dados de verificação
armazenados no PDA de verificação. O PDA contendo todas as informações
necessárias para construir e verificar um programa é derivado do endereço do
programa e da pubkey do verificador. Por padrão, esta é a mesma pubkey que
construiu e implantou o programa. Mas também pode ser outra pubkey que pode ser
especificada no `security.txt`.

O recurso `security.txt` permite que os desenvolvedores incorporem informações
de contato e segurança diretamente em seus contratos inteligentes Solana.
Inspirado por [securitytxt.org](https://securitytxt.org), esta abordagem fornece
uma forma padronizada para pesquisadores de segurança entrarem em contato com os
mantenedores do projeto, mesmo que eles conheçam apenas o endereço do contrato.

## Por que usar security.txt?

Para muitos projetos, especialmente os menores ou privados, identificar os
desenvolvedores apenas pelo endereço do contrato pode ser difícil e demorado.
Incorporar um arquivo `security.txt` dentro do programa garante que os
pesquisadores de segurança possam facilmente contatar as pessoas corretas,
potencialmente prevenindo exploits e garantindo relatórios de bugs em tempo
hábil.

## Como implementar security.txt

Para adicionar um `security.txt` ao seu programa Solana, inclua os seguintes
passos:

Adicione a dependência `solana-security-txt` ao seu `Cargo.toml`:

```toml title="Cargo.toml"
[dependencies]
solana-security-txt = "1.1.1"
```

Use a macro `security_txt!` no seu contrato para definir suas informações de
segurança. Você pode incluir detalhes de contato, URLs do projeto e até mesmo
uma política de segurança. Aqui está um exemplo:

```rust
#[cfg(not(feature = "no-entrypoint"))]
use {default_env::default_env, solana_security_txt::security_txt};

#[cfg(not(feature = "no-entrypoint"))]
security_txt! {
    name: "MyProject",
    project_url: "https://myproject.com",
    contacts: "email:security@myproject.com,discord:security#1234",
    policy: "https://myproject.com/security-policy",

    // Optional Fields
    preferred_languages: "en,de",
    source_code: "https://github.com/solana-developers/solana-game-preset",
    source_revision: "5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    source_release: "",
    encryption: "",
    auditors: "Verifier pubkey: 5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    acknowledgements: "Thank you to our bug bounty hunters!"
}
```

Uma vez que as informações do `security.txt` estejam incorporadas em seu
programa, elas podem ser facilmente consultadas através de ferramentas como o
Solana Explorer, garantindo que seus contatos e detalhes de segurança estejam
disponíveis para qualquer pessoa que queira reportar possíveis problemas.

## Melhores práticas

- Use links: para informações que provavelmente mudarão (por exemplo, detalhes
  de contato), é recomendado vincular a uma página da web em vez de codificá-las
  diretamente no contrato. Isso evita a necessidade de atualizações frequentes
  do programa.

- Verificação: antes de implantar, verifique o formato e o conteúdo usando a
  ferramenta `query-security-txt`, que pode validar tanto programas na
  blockchain quanto binários locais:

```bash
query-security-txt target/bpfel-unknown-unknown/release/my_contract.so
```

Ao incorporar informações de contato de segurança diretamente no seu contrato,
você torna mais fácil para os pesquisadores entrarem em contato com você,
promovendo melhor segurança e comunicação dentro do ecossistema Solana.

Este é
[um exemplo de como o security.txt aparece no Solana Explorer](https://explorer.solana.com/address/HPxKXnBN4vJ8RjpdqDCU7gvNQHeeyGnSviYTJ4fBrDt4/security?cluster=devnet)

O projeto `security.txt` é mantido pela
[Neodyme Labs](https://github.com/neodyme-labs)
