---
title: Tarifas de transacción
description:
  Aprende sobre las tarifas de transacción de Solana, incluyendo las tarifas
  base y prioritarias, cómo se aplica cada una, y las mejores prácticas para
  gestionar unidades de cómputo en tus transacciones.
---

Cada transacción de Solana requiere una tarifa de transacción, pagada en SOL.
Las tarifas de transacción se dividen en dos partes: la tarifa base y la tarifa
de priorización. La tarifa base compensa a los validadores por procesar la
transacción. La tarifa de priorización es una tarifa opcional para aumentar la
probabilidad de que el líder actual procese tu transacción.

## Tarifa base

Cada transacción cuesta 5000 [lamports](/docs/references/terminology#lamport)
por firma incluida. Esta tarifa es pagada por el primer firmante de la
transacción y debe ser pagada por una cuenta propiedad del System Program. La
tarifa base se divide de la siguiente manera:

- **50% quemado:** La mitad es
  [quemada](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (retirada de la oferta circulante de SOL).
- **50% distribuido:** La mitad es
  [pagada al validator](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
  que procesó la transacción.

## Tarifa de priorización

Una
[tarifa de priorización](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
es una tarifa opcional utilizada para aumentar la probabilidad de que el líder
actual (validator) procese tu transacción. El validator recibe el
[100% de la tarifa de prioridad](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Las tarifas de priorización pueden establecerse ajustando el precio de unidad de
cómputo (CU) y el límite de CU de la transacción. (Consulta la
[Guía de cómo usar tarifas de prioridad](/developers/guides/advanced/how-to-use-priority-fees)
para más detalles sobre las tarifas de priorización.)

La tarifa de priorización se calcula de la siguiente manera:

**Tarifa de priorización = Límite de unidades de cómputo × Precio de unidad de
cómputo**

La tarifa de priorización se utiliza para determinar la
[prioridad de tu transacción](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646),
en relación con otras transacciones. Se calcula utilizando la siguiente fórmula:

**Prioridad de la transacción = Tarifa de priorización / Tamaño de la
transacción**

#### Límite de unidades de cómputo

Por
[defecto](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
a cada instrucción se le asignan
[200,000 CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
y a cada transacción se le asignan
[1.4 millones de CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14).
Puedes cambiar estos valores predeterminados incluyendo una instrucción
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
en tu transacción.

Para calcular el límite de CU apropiado para tu transacción, recomendamos los
siguientes pasos:

1. Estima las unidades CU requeridas
   [simulando](/developers/guides/advanced/how-to-request-optimal-compute) la
   transacción
2. Añade un margen de seguridad del 10% a esta estimación

<Callout type="warn">
  La tarifa de prioridad está determinada por el límite de unidades de cómputo
  solicitado en la transacción, *no* por el número real de unidades de cómputo
  utilizadas. Si estableces un límite de unidades de cómputo demasiado alto o
  usas la cantidad predeterminada, podrías pagar por unidades de cómputo no
  utilizadas.
</Callout>

#### Precio de unidad de cómputo

El precio de unidad de cómputo es una cantidad opcional de
[micro-lamports](/docs/references/terminology#micro-lamports) pagada por cada CU
solicitada. Puedes pensar en el precio de CU como una propina para animar al
validator a priorizar tu transacción. Para establecer el precio de CU, incluye
una instrucción
[ComputeBudgetInstruction::set_compute_unit_price](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
en tu transacción.

<Callout>
  El precio de CU predeterminado es 0, lo que significa que la tarifa de
  priorización predeterminada también es 0.
</Callout>

Para ayudarte a determinar el mejor precio de CU para tu transacción, consulta
la recomendación de precio de CU en tiempo real proporcionada en la tabla a
continuación.

| Proveedor                               | API de tarifa de prioridad                                                        |
| --------------------------------------- | --------------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [Documentación](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Documentación](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Documentación](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Ejemplo

Los ejemplos a continuación muestran cómo establecer el límite de CU y el precio
de CU en una transacción usando los SDK de Solana.

| SDK                          | Referencia del código fuente                                                                                                 |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| @solana/web3.js (Typescript) | [ComputeBudgetProgram](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| solana-sdk (Rust)            | [ComputeBudgetInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    compute_budget::ComputeBudgetInstruction,
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    system_instruction,
    transaction::Transaction,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction =
        system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
