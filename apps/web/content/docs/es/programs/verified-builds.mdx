---
title: Verificación de programas
description:
  Las compilaciones verificadas son una forma de vincular tu programa con su
  código fuente y permitir que todos verifiquen independientemente que el
  programa fue efectivamente construido a partir del código fuente
  proporcionado.
---

Esta guía está destinada a ser una referencia para desarrolladores que desean
implementar compilaciones verificadas para sus programas en Solana. Cubriremos
qué son las compilaciones verificadas, cómo usarlas, consideraciones especiales
y mejores prácticas para garantizar la autenticidad de tu programa en la cadena.

# ¿Qué son las compilaciones verificadas?

Las compilaciones verificadas aseguran que el programa ejecutable que despliegas
en la red de Solana coincide con el código fuente en tu repositorio. Al hacer
esto, los desarrolladores y usuarios pueden tener la confianza de que el
programa ejecutándose en la cadena corresponde exactamente al código base
público, promoviendo la transparencia y seguridad.

El proceso de verificación implica comparar el hash del programa en la cadena
con el hash del programa compilado localmente a partir del código fuente. Esto
asegura que no haya discrepancias entre las dos versiones.

> Aunque una compilación verificada no debe considerarse más segura que una no
> verificada, la compilación permite a los desarrolladores verificar por sí
> mismos que el código fuente coincide con lo que está desplegado en la cadena.
> Usando el código fuente, un desarrollador puede entonces validar qué ejecuta
> el código al enviar una transacción.

El proceso de compilaciones verificadas fue concebido y es mantenido por
[Ellipsis Labs](https://ellipsislabs.xyz/) y [OtterSec](https://osec.io/). Para
más detalles, sigue la guía en el
[repositorio original de compilaciones verificadas](https://github.com/Ellipsis-Labs/solana-verifiable-build)
así como el proceso de verificación de compilación directamente en el conjunto
de herramientas [Anza](https://www.anza.xyz/), una vez que sea compatible.

# ¿Cómo funciona?

El proceso de verificación se realiza comparando el hash del programa en la
cadena con el hash del programa compilado localmente a partir del código fuente.
Compilas tu programa en un entorno controlado utilizando Solana Verify CLI y
Docker. Esto asegura que el proceso de compilación sea determinista y
consistente en diferentes sistemas. Una vez que tienes el ejecutable, puedes
desplegarlo en la red Solana. Durante el proceso de compilación se crea una
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)
del [programa de verificación](https://github.com/otter-sec/otter-verify). Esta
PDA contiene todos los datos necesarios para verificar el programa. La PDA
contiene la dirección del programa, la URL de git, el hash del commit y los
argumentos utilizados para compilar el programa.

Utilizando los datos en la PDA, cualquiera puede ejecutar el comando del
programa de verificación localmente y comprobar si el programa fue compilado a
partir del código fuente proporcionado. Entonces todos pueden verificar por sí
mismos de manera completamente confiable o pueden ejecutar su propia
[API de verificación](https://github.com/otter-sec/solana-verified-programs-api)
mantenida por [OtterSec](https://github.com/otter-sec) para proporcionar un
punto de acceso fácil para que los usuarios comprueben la verificación. Ya
puedes ver estas
[llamadas a la API](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
siendo utilizadas en el
[Explorador de Solana](https://explorer.solana.com/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/verified-build)
y
[SolanaFM](https://solana.fm/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/transactions?cluster=mainnet-alpha),
entre otros lugares.

# ¿Por qué debería usar compilaciones verificadas?

El uso de compilaciones verificadas proporciona los siguientes beneficios:

- Seguridad: Garantiza que el programa que se ejecuta en la cadena coincide con
  el código fuente, evitando alteraciones maliciosas.

- Transparencia: Permite a otros usuarios y desarrolladores validar que el
  programa en la cadena es confiable comparándolo con el código base público.

- Confianza: Aumenta la confianza del usuario, ya que las compilaciones
  verificadas demuestran que el comportamiento de tu programa en la cadena está
  alineado con tu código público. Al construir programas verificables, minimizas
  los riesgos asociados con la ejecución de código no autorizado o malicioso.
  También asegura que cumples con las mejores prácticas y proporcionas a los
  investigadores de seguridad una forma fácil de contactarte. Además, las
  carteras y otras herramientas pueden permitir transacciones desde tu programa
  más fácilmente siempre que esté verificado.

- Descubribilidad: Cuando proporcionas una compilación verificada de tu
  programa, todos pueden encontrar tu código fuente, documentación, SDK del
  programa o IDL y también pueden contactarte fácilmente a través de GitHub en
  caso de que haya algún problema.

# ¿Cómo creo compilaciones verificadas?

Para crear compilaciones verificadas, deberás seguir estos pasos:

Resumen:

- Confirma tu código en un repositorio público
- Construye una compilación verificada en Docker
- Despliega la compilación verificada
- Verifica el programa desplegado contra la API pública

Si verificas tu programa que no está construido en un contenedor Docker, muy
probablemente fallará porque las compilaciones de programas de Solana no son
deterministas en diferentes sistemas.

<Steps>
<Step>

### Instalar Docker y Cargo

Instala las herramientas necesarias asegurándote de tener Docker y Cargo
instalados. Docker proporciona un entorno de compilación controlado para
garantizar la consistencia, y Cargo se utiliza para gestionar paquetes de Rust.

- Docker: Sigue los pasos en el
  [sitio web de Docker](https://docs.docker.com/engine/install/) para instalar
  Docker para tu plataforma. Una vez instalado, asegúrate de que el servicio
  Docker esté funcionando siguiendo esta guía más adelante.
- Cargo: Si aún no tienes Cargo instalado, puedes instalarlo ejecutando el
  siguiente comando:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

</Step>
<Step>

### Instalar Solana Verify CLI

Solana Verify CLI es la herramienta principal utilizada para verificar
compilaciones. Solana Verify CLI es actualmente mantenida por
[Ellipsis Labs](https://ellipsislabs.xyz/) y puede instalarse usando Cargo.

Puedes instalarlo ejecutando:

```bash
cargo install solana-verify
```

Si necesitas una versión específica de la CLI, puedes fijar la versión con:

```bash
cargo install solana-verify --version $VERSION
```

Si lo deseas, puedes instalar una versión directamente desde un commit
específico:

```bash
cargo install solana-verify --git https://github.com/Ellipsis-Labs/solana-verifiable-build --rev 13a1db2
```

</Step>
<Step>

### Preparar el proyecto

Para verificar contra un repositorio, este debe tener un archivo `Cargo.lock` en
el directorio raíz de tu repositorio. Si solo tienes un programa en tu
repositorio y un archivo `cargo.lock` en tu raíz, puedes ir directamente al
siguiente paso y compilar tu programa.

Si tu programa está en una subcarpeta y tienes un espacio de trabajo de Rust,
necesitas crear un archivo `Cargo.toml` del espacio de trabajo en el directorio
raíz de tu repositorio.

Puedes usar este ejemplo de `Cargo.toml` como plantilla:

```toml title="Cargo.toml"
[workspace]
members = ["program/programs/*"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1

[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
```

Asegúrate de que tu programa esté en el array `workspace/members` y que el
`Cargo.toml` de tu programa tenga el nombre `lib` correcto configurado.

> Lo importante es el `lib name`, ¡no el nombre del paquete!

Algo como esto:

```toml title="waffle/Cargo.toml"
[package]
name = "waffle"
version = "0.1.0"
edition = "2021"

[lib]
name = "waffle"
crate-type = ["cdylib", "lib"]

[dependencies]
solana-program = "2.1.0"
```

En este [repositorio](https://github.com/solana-developers/verified-program)
puedes ver un ejemplo de un espacio de trabajo con un programa en una
subcarpeta. Ten en cuenta también que cuando el programa está en una subcarpeta,
más adelante necesitarás añadir esta carpeta como `--mount-path` al comando
`verify-from-repo`.

En este [repositorio](https://github.com/solana-developers/solana-game-preset)
puedes encontrar un ejemplo de Anchor. En este
[repositorio](https://github.com/solana-developers/verified-program-root) puedes
encontrar un ejemplo de Rust nativo.

Con este archivo `Cargo.toml` en su lugar, puedes ejecutar
`cargo generate-lockfile` para crear un archivo de bloqueo y continuar con la
compilación de tu programa.

</Step>
<Step>

### Compilación de programas verificables

Para compilar de manera verificable tu programa de Solana, navega al directorio
que contiene el archivo `Cargo.toml` de tu espacio de trabajo y ejecuta:

```bash
solana-verify build
```

Esto copiará tu entorno en un contenedor Docker y lo compilará de manera
determinista.

> Asegúrate de implementar realmente la compilación verificada y no la
> sobrescribas accidentalmente con `anchor build` o `cargo build-sbf`, ya que
> estos probablemente no resultarán en el mismo hash y, por lo tanto, tu
> verificación fallará.

Para proyectos con múltiples programas, puedes compilar un programa específico
utilizando el nombre de la biblioteca (no el nombre del paquete):

```bash
solana-verify build --library-name $PROGRAM_LIB_NAME
```

Este proceso garantiza compilaciones deterministas y puede llevar algún tiempo,
especialmente en ciertos sistemas (por ejemplo, MacBook M1) porque se ejecuta
dentro de un contenedor docker. Para compilaciones más rápidas, se recomienda
usar una máquina Linux con arquitectura x86.

Una vez que la compilación se completa, puedes obtener el hash del ejecutable
usando el siguiente comando:

```bash
solana-verify get-executable-hash target/deploy/$PROGRAM_LIB_NAME.so
```

</Step>
<Step>

### Desplegando programas verificables

Una vez que hayas compilado tu programa y obtenido su hash, puedes desplegarlo
en la red de Solana. Se recomienda usar una solución de firma múltiple o
gobernanza como [Squads Protocol](https://squads.so/protocol) para despliegues
seguros, pero también puedes desplegar directamente con:

```bash
solana program deploy -u $NETWORK_URL target/deploy/$PROGRAM_LIB_NAME.so --program-id $PROGRAM_ID --with-compute-unit-price 50000 --max-sign-attempts 100 --use-rpc
```

Puedes solicitar una tarifa de baja prioridad adecuada a tu proveedor de rpc,
por ejemplo [Quicknode](https://www.quicknode.com/gas-tracker/solana).

Para verificar que el programa desplegado coincide con el ejecutable compilado,
ejecuta:

```bash
solana-verify get-program-hash -u $NETWORK_URL $PROGRAM_ID
```

> Puedes tener diferentes versiones desplegadas en diferentes
> [clusters de Solana](/docs/references/clusters) (es decir, devnet, testnet,
> mainnet). Asegúrate de usar la URL de red correcta para el cluster de Solana
> deseado contra el que quieres verificar un programa. La verificación remota
> solo funcionará en mainnet.

</Step>
<Step>

### Verificando contra repositorios

Para verificar un programa contra su repositorio público, usa:

```bash
solana-verify verify-from-repo -u $NETWORK_URL --program-id $PROGRAM_ID https://github.com/$REPO_PATH --commit-hash $COMMIT_HASH --library-name $PROGRAM_LIB_NAME --mount-path $MOUNT_PATH
```

> Mientras ejecutas la compilación verificada en el directorio de tu programa,
> cuando ejecutas `verify-from-repo` necesitas añadir la bandera `--mount-path`.
> Esta será la ruta a la carpeta que contiene el `Cargo.toml` que contiene el
> nombre de la biblioteca de tu programa.

Este comando compara el hash del programa en cadena con el hash ejecutable
construido a partir del código fuente en el hash de commit especificado.

Al final, el comando te preguntará si deseas cargar tus datos de verificación en
la cadena. Si lo haces, el Explorador de Solana mostrará inmediatamente los
datos de verificación de tu programa. Hasta que sea verificado por una
compilación remota, se mostrará como no verificado. Aprende cómo puedes
verificar tu programa contra una API pública en el siguiente paso.

Si deseas bloquear la verificación a una versión específica, puedes añadir la
bandera `--commit-hash` al comando.

</Step>
<Step>

### Verificar contra API pública

Finalmente, también puedes verificar directamente el programa contra cualquiera
que esté ejecutando la API de verificación:

```bash
solana-verify verify-from-repo --remote -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

> Se recomienda usar una URL de RPC de pago porque de lo contrario podrías
> encontrarte con límites de tasa de las RPC gratuitas. Así que en lugar de
> `-um` deberías usar `--url yourRpcUrl` para una verificación más confiable.

La bandera `--remote` envía una solicitud de compilación a la API de OtterSec,
que desencadena una compilación remota de tu programa. Una vez que la
compilación está completa, el sistema verifica que el hash en cadena de tu
programa coincida con el hash del artefacto de compilación generado desde tu
repositorio.

El valor predeterminado es la
[API de OtterSec](https://github.com/otter-sec/solana-verified-programs-api).

Asegúrate de elegir sí cuando se te pregunte si deseas cargar los datos de
verificación en la cadena. Esto es utilizado por la API para verificar que has
cargado los datos de verificación.

También puedes activar un trabajo remoto manualmente usando:

```bash
solana-verify remote submit-job --program-id <program-id> --uploader <address>
```

Donde el cargador es la dirección que tiene la autoridad para escribir en el
PDA. Eso debería ser la autoridad del programa en la mayoría de los casos. Si tu
programa está controlado por una multifirma, continúa en la parte
[verificación de multifirma](#how-to-verify-your-program-when-its-controlled-by-a-multisig-like-squads)
de esta guía a continuación.

Esto enviará un trabajo a la API de OtterSec y luego podrás verificar el estado
del trabajo con:

```bash
solana-verify remote get-job-status --job-id <job-id>
```

Una vez que la verificación se haya completado con éxito, lo que puede llevar un
tiempo, podrás ver tu programa como verificado en la
[API de OtterSec para programas individuales](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
y en el
[Explorador de Solana](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY/verified-build),
[SolanaFM](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY?cluster=mainnet-alpha),
[SolScan](https://solscan.io/account/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY#programVerification)
y eventualmente también en el sitio web administrado por la comunidad
[SolanaVerify.org](https://www.solanaverify.org/) mantenido por
[0xDeep](https://x.com/0xDeep) y la
[API de programas verificados de OtterSec](https://verify.osec.io/verified-programs)
y finalmente en el
[Panel de Dune de Programas Verificados](https://dune.com/jonashahn/verified-programs/dedf21e1-9b71-42c8-89f9-02ed94628657)
contribuyendo a un ecosistema Solana más saludable.

</Step>
</Steps>

## Cómo verificar tu programa cuando está controlado por una multifirma como Squads

Para que la verificación remota funcione, necesitas escribir los datos de
verificación en un PDA firmado por la autoridad del programa. Si tu programa
está controlado por una multifirma, puedes exportar esta transacción de
escritura PDA y enviarla a través de
[Squads Protocol](https://squads.so/protocol) u otra solución de multifirma de
tu elección.

<Steps>
<Step>

### 1. Construir el programa verificable

Primero construye el programa:

```bash
solana-verify build
```

Esto construirá una compilación verificable usando un contenedor docker con la
versión de solana especificada en el archivo `Cargo.lock`.

</Step>
<Step>

### 2. Desplegar el programa

```bash
solana config set --url "PayedMainnetRPCAddress" // the public endpoint will be rate limited too much
solana program deploy target/deploy/verify_squads.so
```

Para el resto de esta guía de multifirma, usaremos un ID de programa de ejemplo
`6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`.

</Step>
<Step>

### 3. Confirmar y verificar contra el repositorio

Una vez hecho esto, confirmamos el proyecto en GitHub. Aquí hay un ejemplo:
https://github.com/solana-developers/verify-squads

Opcional: Comprueba si puedes verificar localmente primero (este comando usa un
ID de programa de ejemplo `6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`):

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
```

Solo para asegurarte de que tus parámetros son correctos.

</Step>
<Step>

### 4. Transferir la autoridad del programa a la multifirma

Si aún no has transferido la autoridad de tu programa a la multifirma y copiado
la autoridad de la multifirma. La necesitarás en el siguiente paso.

</Step>
<Step>

### 5. Exportar la transacción PDA

Cuando tienes la autoridad del programa localmente, se te solicita cargar los
datos de compilación en la cadena al usar el comando
`solana-verify verify-from-repo`.

Como no puedes hacer eso cuando estás usando una multifirma, necesitas exportar
la transacción PDA manualmente y luego activar la transacción a través de
Squads.

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader <your program authority> --encoding base58 --compute-unit-price 0
```

Esto te devolverá una transacción en base58. Si quieres una transacción
codificada en base64 para usar en un inspector de transacciones, puedes usar
`--encoding base64`.

```bash
P6vBfcPaaXb8fZoT3NBAYEcdtEj7tubA1k2gBxmFKZ3UWF5YyrmDMFTvLKALCJoUuRsPAjMckudYruCu3eeWQtuDrFbEMLxLFutnKXac974fnkMivcwUdY66VLjbxQT6ATmcy7F4hBtz1G4P1h6iBJLhb8WtrtgY3i4qq45MUEb7RjuMEfUFXKrNgPdGxkz5xvMHq3dxKRcpmEK5k2DkeW6SUQYBVe19Ga3B9GyhTX8k3CMt9JCEah13WyRnQd8GjoK6sTEvGJym6xDNvmd8yiJYSNcaYwEJsjHEUf4Yh6kAC7ki2KRvVAr3NVe1gjqK9McrwSQjtUatvydTG8Zovcr7PPUEMf3yPMgKXjZLB2QpkH63yTTYdNAnWFuv9E6b6nYRqye5XcNi436yKw5U14fXh65yK34bgYLi9328UT1huJELsJU9BRGnGUmb6GWp6c2WL5BhnzgNTSnt9TXFfEgUMzhvKzpVBxLP44hwqqBdyUhHFysCF37531PnmiESq8x1xou23xJ6FcQbc199754MkqQd7tX9CUznGzAEqHGkzn3VBoJnojsKtgYmiTYbdRsT1CU18MbYEE7WvGAvXyxxbpNzbAcc94HrnM6cqRGmwhEBroPfFghTdmzg9D
```

</Step>
<Step>

### 6. Enviar transacción a través de Squads

Ve al constructor de transacciones de Squads e importa la transacción codificada
en base58. ¡Asegúrate de que en la simulación la transacción solo tenga una
llamada al programa de verificación osec y al programa de presupuesto de
computación y nada más!

</Step>
<Step>

### 7. Enviar trabajo de verificación remota

Una vez que la transacción a Squads fue exitosa, puedes enviar el trabajo
remoto:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
--uploader <your program authority>
```

¡Eso es todo! Has verificado tu programa contra un repositorio público y enviado
un trabajo remoto a la API de OtterSec. Ahora deberías poder verlo reflejado en
el explorador de Solana y otros lugares.

</Step>
<Step>

### 8. Actualización del programa (Opcional)

Cuando actualizas tu programa, necesitas exportar una nueva transacción PDA y
enviarla a través de Squads nuevamente.

Cómo realizar una actualización al programa:

```bash
solana-verify build
solana program write-buffer target/deploy/verify_squads.so --with-compute-unit-price 50000 --max-sign-attempts 50
```

Luego transfiere esa autoridad del buffer al multisig o crea directamente el
buffer con la autoridad del multisig.

```bash
solana program set-buffer-authority Fu3k79g53ZozAj47uq1tXrFy4QbQYh7y745DDsxjtyLR --new-buffer-authority 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

</Step>
<Step>

### 9. Exportar y enviar nueva transacción PDA

No olvides confirmar tus cambios en GitHub. Exporta la transacción de
actualización PDA nuevamente:

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

Envía la transacción a través de Squads nuevamente.

Puedes ver un ejemplo de transacción
[aquí](https://solana.fm/tx/4zJ1vK2KToAwxuEYzTMLqPkcebjoi9rdeeyxtEEx9L5Q4vWDA8h6Rr4kPRuRxcV7ZLKMr6qx1LTWb6x3ZpUJaFUW?cluster=mainnet-alpha).

Luego envía para otra compilación remota:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

Debería resultar en algo como esto:

```shell
Verification request sent with request id: b63339d2-163e-49ac-b55d-3454c1c2b5b3
Verification in progress... ⏳ [00:18:02] ✅ Process completed. (Done in 18
minutes) Program 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD has been verified.
✅ The provided GitHub build matches the on-chain hash. On Chain Hash:
96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Executable
Hash: 96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Repo URL:
https://github.com/Woody4618/verify-squads/tree/0fb0a2e30c15c51732c0ad5e837975a6f7bbc7ed
Check the verification status at:
https://verify.osec.io/status/6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD Job
url: https://verify.osec.io/job/b63339d2-163e-49ac-b55d-3454c1c2b5b3
```

¡Felicidades, has verificado tu programa después de una actualización multisig!

</Step>
</Steps>

## Verificar desde imagen docker

También puedes verificar tu programa contra una imagen docker ejecutando el
siguiente comando:

```bash
solana-verify verify-from-image -e
examples/hello_world/target/deploy/hello_world.so -i
ellipsislabs/hello_world_verifiable_build:latest -p
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn
```

Este comando carga la imagen almacenada en
`ellipsislabs/hello_world_verifiable_build:latest`, y verifica que el hash del
ejecutable en el contenedor sea el mismo que el hash del programa en cadena
proporcionado al comando. Como la compilación ya fue subida a una imagen, no es
necesario recompilar completamente el ejecutable, lo que puede llevar mucho
tiempo.

El Dockerfile que crea la imagen
`ellipsislabs/hello_world_verifiable_build:latest` se puede encontrar en el
repositorio de Ellipsis Labs
[/examples/hello_world](https://github.com/Ellipsis-Labs/solana-verifiable-build/tree/master/examples/hello_world).

A continuación se muestra la salida esperada:

```bash
Verifying image: "ellipsislabs/hello_world_verifiable_build:latest", on network
"https://api.mainnet-beta.solana.com" against program ID
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn Executable path in container:
"examples/hello_world/target/deploy/hello_world.so"

Executable hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Program hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Executable
matches on-chain program data ✅
```

## Ejemplo de compilación verificada

Aquí hay un ejemplo de verificación de un programa de ejemplo con el ID
`FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv` utilizando el código fuente de
este [repositorio](https://github.com/solana-developers/verified-program):

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

Por defecto, el comando `verify-from-repo` toma el último commit en la rama
principal. También puedes definir un commit específico en caso de que quieras
continuar trabajando en el repositorio usando el parámetro `commit-hash`:
`--commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e`

Finalmente, también puedes verificar directamente el programa contra la API de
OtterSec:

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --remote --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

El comando `--remote` envía una solicitud de compilación a la API de OtterSec,
que desencadena una compilación remota de tu programa. Una vez que la
compilación está completa, el sistema verifica que el hash en cadena de tu
programa coincida con el hash del artefacto de compilación generado desde tu
repositorio.

## Programas populares que ya están verificados

### Phoenix

```shell
solana-verify verify-from-repo -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

Resultado final:

```shell
Executable Program Hash from repo: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
On-chain Program Hash: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
Program hash matches ✅
```

### Squads V3

```shell
solana-verify verify-from-repo https://github.com/Squads-Protocol/squads-mpl --commit-hash c95b7673d616c377a349ca424261872dfcf8b19d --program-id SMPLecH534NA9acpos4G6x7uf3LWbCAwZQE9e8ZekMu -um --library-name squads_mpl --bpf
```

> Observa que necesitamos especificar el `library-name` porque el repositorio de
> Squads incluye múltiples programas. Usamos la bandera `--bpf` porque
> `squads_mpl` fue verificado previamente con Anchor.

Resultado final:

```shell
Executable Program Hash from repo: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
On-chain Program Hash: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
Program hash matches ✅
```

### Drift V2

```shell
solana-verify verify-from-repo -um --program-id dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH https://github.com/drift-labs/protocol-v2 --commit-hash 110d3ff4f8ba07c178d69f9bfc7b30194fac56d6 --library-name drift
```

Resultado final:

```shell
Executable Program Hash from repo: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
On-chain Program Hash: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
Program hash matches ✅
```

### Marginfi V2

```shell
solana-verify verify-from-repo -um --program-id MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA https://github.com/mrgnlabs/marginfi-v2 --commit-hash d33e649e415c354cc2a1e3c49131725552d69ba0 --library-name marginfi -- --features mainnet-beta
```

Resultado final:

```shell
Executable Program Hash from repo: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
On-chain Program Hash: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
Program hash matches ✅
```

# Conclusión

El uso de
[compilaciones verificadas en Solana](/developers/guides/advanced/verified-builds)
asegura la integridad y confiabilidad de tus programas en la red y permite a los
desarrolladores encontrar tus SDKs directamente desde Solana Explorer. Al
aprovechar herramientas como Solana Verify CLI y Docker, puedes mantener
compilaciones verificables y seguras que se alineen con tu código fuente.
Siempre toma las precauciones necesarias para usar entornos consistentes, y
considera soluciones de gobernanza para actualizaciones y despliegues seguros.

## Seguridad + Descargo de responsabilidad

Aunque las compilaciones verificadas son una herramienta poderosa para asegurar
la integridad de tus programas en Solana, no son completamente sin confianza en
la configuración predeterminada. Las imágenes de docker son construidas y
alojadas por la Fundación Solana.

Ten en cuenta que estás construyendo tu proyecto en una imagen docker descargada
y que toda tu configuración se copia en esa imagen docker para la compilación,
incluyendo información potencialmente sensible.

Si deseas tener una configuración completamente sin confianza, puedes construir
las imágenes docker tú mismo y alojarlas en tu propia infraestructura. De esta
manera puedes asegurarte de que las imágenes docker no han sido manipuladas.
Puedes encontrar los scripts para crear tus propias imágenes docker en el
[repositorio de compilaciones verificadas](https://github.com/Ellipsis-Labs/solana-verifiable-build)
y puedes hacer un fork y ejecutar las acciones de github tú mismo o validar que
son correctas.

Además, para la verificación remota estás confiando en la API de OtterSec y el
[Explorador de Solana](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
hasta cierto punto.

La API o el Explorador de Solana podrían mostrar información incorrecta si son
comprometidos.

Si deseas tener una configuración completamente sin confianza, puedes ejecutar
la [API de Verify](https://github.com/otter-sec/solana-verified-programs-api) tú
mismo o ejecutar la verificación del programa localmente usando el comando
`verify-from-repo` utilizando los datos de verificación en cadena que se guardan
en un
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)
que se deriva de la autoridad de despliegue de los programas y el
[programa de verificación](https://explorer.solana.com/address/verifycLy8mB96wd9wqq3WDXQwM4oU6r42Th37Db9fC).

El programa de verificación es implementado por el
[equipo OtterSec](https://osec.io/) y aún no está congelado, por lo que puede
actualizarse en cualquier momento.

La Fundación Solana, OtterSec y el equipo de Ellipsis Labs no son responsables
de ninguna pérdida o daño que pueda ocurrir al utilizar el proceso de
compilaciones verificadas.

# Security.txt para programas de Solana

Además de las compilaciones verificadas, también puedes añadir un archivo
`security.txt` a tu programa. En el futuro, una vez implementado, el
`security.txt` contendrá la clave pública del verificador para facilitar el
acceso a los datos de verificación almacenados en el PDA de verificación. El PDA
que contiene toda la información necesaria para compilar y verificar un programa
se deriva de la dirección del programa y la pubkey del verificador. Por defecto,
esta es la misma pubkey que compiló e implementó el programa. Pero también puede
ser otra pubkey que se puede especificar en el `security.txt`.

La función `security.txt` permite a los desarrolladores integrar información de
contacto y seguridad directamente en sus contratos inteligentes de Solana.
Inspirado en [securitytxt.org](https://securitytxt.org), este enfoque
proporciona una forma estandarizada para que los investigadores de seguridad se
pongan en contacto con los mantenedores del proyecto, incluso si solo conocen la
dirección del contrato.

## ¿Por qué usar security.txt?

Para muchos proyectos, especialmente los más pequeños o privados, identificar a
los desarrolladores solo con la dirección del contrato puede ser difícil y
llevar mucho tiempo. Incorporar un archivo `security.txt` dentro del programa
garantiza que los investigadores de seguridad puedan contactar fácilmente a las
personas correctas, potencialmente previniendo explotaciones y asegurando
informes de errores oportunos.

## Cómo implementar security.txt

Para añadir un `security.txt` a tu programa de Solana, incluye los siguientes
pasos:

Añade la dependencia `solana-security-txt` a tu `Cargo.toml`:

```toml title="Cargo.toml"
[dependencies]
solana-security-txt = "1.1.1"
```

Utiliza la macro `security_txt!` en tu contrato para definir tu información de
seguridad. Puedes incluir detalles de contacto, URLs del proyecto e incluso una
política de seguridad. Aquí tienes un ejemplo:

```rust
#[cfg(not(feature = "no-entrypoint"))]
use {default_env::default_env, solana_security_txt::security_txt};

#[cfg(not(feature = "no-entrypoint"))]
security_txt! {
    name: "MyProject",
    project_url: "https://myproject.com",
    contacts: "email:security@myproject.com,discord:security#1234",
    policy: "https://myproject.com/security-policy",

    // Optional Fields
    preferred_languages: "en,de",
    source_code: "https://github.com/solana-developers/solana-game-preset",
    source_revision: "5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    source_release: "",
    encryption: "",
    auditors: "Verifier pubkey: 5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    acknowledgements: "Thank you to our bug bounty hunters!"
}
```

Una vez que la información de `security.txt` está integrada en tu programa,
puede ser consultada fácilmente a través de herramientas como Solana Explorer,
asegurando que tus datos de contacto y seguridad estén disponibles para
cualquiera que quiera reportar posibles problemas.

## Mejores prácticas

- Usa enlaces: Para información que probablemente cambie (por ejemplo, detalles
  de contacto), se recomienda enlazar a una página web en lugar de codificarla
  directamente en el contrato. Esto evita la necesidad de actualizaciones
  frecuentes del programa.

- Verificación: Antes de implementar, verifica el formato y contenido usando la
  herramienta `query-security-txt`, que puede validar tanto programas en cadena
  como binarios locales:

```bash
query-security-txt target/bpfel-unknown-unknown/release/my_contract.so
```

Al integrar la información de contacto de seguridad directamente en tu contrato,
facilitas que los investigadores se pongan en contacto contigo, fomentando una
mejor seguridad y comunicación dentro del ecosistema de Solana.

Este es
[un ejemplo de cómo se ve security.txt en Solana Explorer](https://explorer.solana.com/address/HPxKXnBN4vJ8RjpdqDCU7gvNQHeeyGnSviYTJ4fBrDt4/security?cluster=devnet)

El proyecto `security.txt` es mantenido por
[Neodyme Labs](https://github.com/neodyme-labs)
