---
title: Adres pochodny programu
description:
  Dowiedz się więcej o adresach pochodnych programu (PDA) w Solanie —
  deterministycznych adresach kont, które umożliwiają bezpieczne podpisywanie
  przez programy. Zrozum, jak działa pochodzenie PDA, kanoniczne przesunięcia i
  jak tworzyć konta PDA.
---

Adres [konta](/docs/core/accounts#account-address) w Solanie wskazuje
lokalizację konta na blockchainie. Wiele adresów kont to klucze publiczne pary
kluczy (keypair), w takim przypadku odpowiadający im klucz prywatny jest używany
do podpisywania transakcji związanych z kontem.

Przydatną alternatywą dla adresu klucza publicznego jest adres pochodny programu
(PDA). PDA oferują łatwą metodę przechowywania, mapowania i pobierania stanu
programu. PDA to adres tworzony deterministycznie przy użyciu identyfikatora
programu (program ID) oraz kombinacji opcjonalnych, zdefiniowanych wcześniej
danych wejściowych. PDA wyglądają podobnie do adresów kluczy publicznych, ale
nie mają odpowiadającego im klucza prywatnego.

Środowisko wykonawcze Solany umożliwia programom podpisywanie PDA bez potrzeby
posiadania klucza prywatnego. Korzystanie z PDA eliminuje konieczność śledzenia
adresu konta. Zamiast tego można przypomnieć sobie konkretne dane wejściowe
użyte do pochodzenia PDA. (Aby dowiedzieć się, jak programy używają PDA do
podpisywania, zobacz sekcję [Wywołania międzyprogramowe](/docs/core/cpi).)

## Tło

Pary kluczy Solany
([keypairs](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/keypair/src/lib.rs#L26))
są punktami na [krzywej Ed25519](https://ed25519.cr.yp.to/) (kryptografia
krzywych eliptycznych). Składają się z klucza publicznego i klucza prywatnego.
Klucz publiczny staje się adresem konta, a klucz prywatny jest używany do
generowania ważnych [podpisów](/docs/core/transactions#signatures) dla konta.

![Dwa konta z adresami na krzywej](/assets/docs/core/pda/address-on-curve.svg)

PDA jest celowo pochodny, aby znajdować się poza krzywą Ed25519. Oznacza to, że
nie ma ważnego odpowiadającego mu klucza prywatnego i nie może wykonywać
operacji kryptograficznych (takich jak dostarczanie podpisu). Jednak Solana
umożliwia programom podpisywanie PDA bez potrzeby posiadania klucza prywatnego.

![Adres poza krzywą](/assets/docs/core/pda/address-off-curve.svg)

Możesz myśleć o PDA jako o sposobie tworzenia struktur podobnych do hashmap na
łańcuchu za pomocą zdefiniowanego zestawu wejść. (Na przykład ciągi znaków,
liczby i inne adresy kont.)

![Adres pochodny programu](/assets/docs/core/pda/pda.svg)

## Wyprowadzenie PDA

Przed utworzeniem konta z PDA musisz najpierw wyprowadzić adres. Wyprowadzenie
PDA _nie_ tworzy automatycznie konta w łańcuchu pod tym adresem — konto musi
zostać wyraźnie utworzone za pomocą programu użytego do wyprowadzenia PDA.
Możesz myśleć o PDA jak o adresie na mapie: sam fakt, że adres istnieje, nie
oznacza, że coś tam zostało zbudowane.

SDK Solana obsługują tworzenie PDA za pomocą funkcji pokazanych w tabeli
poniżej. Każda funkcja przyjmuje następujące dane wejściowe:

- **ID programu**: Adres programu używanego do wyprowadzenia PDA. Ten program
  może podpisywać się w imieniu PDA.
- **Opcjonalne seedy**: Zdefiniowane wcześniej dane wejściowe, takie jak ciągi
  znaków, liczby lub inne adresy kont.

| SDK                            | Funkcja                                                                                                                          |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `@solana/kit` (Typescript)     | [`getProgramDerivedAddress`](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L157) |
| `@solana/web3.js` (Typescript) | [`findProgramAddressSync`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/publickey.ts#L212)               |
| `solana_sdk` (Rust)            | [`find_program_address`](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/pubkey/src/lib.rs#L617)                        |

Funkcja używa ID programu i opcjonalnych seedów, a następnie iteruje przez
wartości bump, aby spróbować utworzyć prawidłowy adres programu. Iteracja
wartości bump zaczyna się od 255 i zmniejsza o 1, aż zostanie znaleziony
prawidłowy PDA. Po znalezieniu prawidłowego PDA funkcja zwraca PDA i bump seed.

<Callout>
  Bump seed to dodatkowy bajt dołączany do opcjonalnych seedów, aby zapewnić
  wygenerowanie prawidłowego adresu poza krzywą.
</Callout>

![Wyprowadzenie PDA](/assets/docs/core/pda/pda-derivation.svg)

### Kanoniczny bump

Bump seed to dodatkowy bajt dołączany do opcjonalnych seedów. Funkcja
wyprowadzania iteruje przez wartości bump, zaczynając od 255 i zmniejszając o 1,
aż znajdzie wartość, która generuje prawidłowy adres poza krzywą. Pierwsza
wartość, która generuje prawidłowy adres poza krzywą, nazywana jest "kanonicznym
bumpem".

Poniższe przykłady pokazują wyprowadzenie PDA przy użyciu wszystkich możliwych
bump seedów (od 255 do 0):

<Callout type="info">
  Przykład z Kit nie został uwzględniony, ponieważ funkcja
  [createProgramDerivedAddress](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L101)
  nie jest eksportowana.
</Callout>

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const optionalSeed = "helloWorld";

// Loop through all bump seeds (255 down to 0)
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(optionalSeed), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed = b"helloWorld";

    // Loop through all bump seeds (255 down to 0)
    for bump in (0..=255).rev() {
        match Pubkey::create_program_address(&[optional_seed.as_ref(), &[bump]], &program_id) {
            Ok(pda) => println!("bump {}: {}", bump, pda),
            Err(err) => println!("bump {}: {}", bump, err),
        }
    }

    Ok(())
}
```

</CodeTabs>

<CodeTabs>

```sh !! title="Expected TS Output"
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// remaining bump outputs
```

```sh !! title="Expected Rust Output"
bump 255: Provided seeds do not result in a valid address
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Provided seeds do not result in a valid address
...
// remaining bump outputs
```

</CodeTabs>

W tym przykładzie pierwszy bump seed powoduje błąd. Pierwszy bump seed, który
wyprowadza prawidłowy PDA, to 254. Bump seedy od 253 do 251 również wyprowadzają
unikalne, prawidłowe PDA.

Oznacza to, że przy tych samych opcjonalnych seedach i `programId`, bump seed o
innej wartości może nadal wyprowadzić prawidłowy PDA.

<Callout type="warn">
  Zawsze uwzględniaj kontrole bezpieczeństwa, aby upewnić się, że PDA przekazany
  do programu jest wyprowadzony z kanonicznego bumpa. Brak takich kontroli może
  wprowadzić luki bezpieczeństwa, które pozwolą na użycie nieoczekiwanych kont w
  instrukcjach programu. Najlepszą praktyką jest używanie wyłącznie kanonicznego
  bumpa podczas wyprowadzania PDA.
</Callout>

### Przykłady

Poniższe przykłady wyprowadzają PDA przy użyciu SDK Solana. Kliknij **&#9655;
Uruchom**, aby wykonać kod.

#### Wyprowadzenie PDA z seedem w postaci ciągu znaków

Poniższy przykład wyprowadza PDA przy użyciu identyfikatora programu i
opcjonalnego seeda w postaci ciągu znaków.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus
const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus
const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let seeds: &[&[u8]] = &[b"helloWorld"];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Wyprowadzenie PDA z "seed" w postaci adresu

Poniższy przykład wyprowadza PDA przy użyciu ID programu i opcjonalnego "seed" w
postaci adresu.

<CodeTabs storage="pda-examples"flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:4)
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

// !focus(1:3)
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Wyprowadzenie PDA z wieloma "seeds"

Poniższy przykład wyprowadza PDA przy użyciu ID programu i wielu opcjonalnych
"seeds".

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:5)
const optionalSeedString = "helloWorld";
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedString, optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus(1:4)
const optionalSeedString = "helloWorld";
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [Buffer.from(optionalSeedString), optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus(1:2)
    let optional_seed_bytes = b"helloWorld";
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

## Utworzenie konta PDA

<WithMentions>

Poniższy przykład wykorzystuje
[framework Anchor](https://www.anchor-lang.com/docs) do utworzenia nowego konta
z adresem wyprowadzonym przez program. Program zawiera pojedynczą instrukcję
[`initialize`](mention:initialize) do utworzenia nowego konta, które będzie
przechowywać [adres użytkownika](mention:user-address) oraz
[bump seed](mention:bump) użyte do wyprowadzenia PDA.

```rs title="Program"
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    // !mention initialize
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        // !mark
        // !mention user-address
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bumpd
        // !mark
        // !mention bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    // !mention user-address
    pub user: Signer<'info>,

    #[account(
        init,
        // define the seeds to derive the PDA
        // !mark
        // !mention user-address
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        // !mark
        // !mention bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(InitSpace)]
pub struct DataAccount {
    // !mark
    // !mention user-address
    pub user: Pubkey,
    // !mark
    // !mention bump
    pub bump: u8,
}
```

</WithMentions>

<WithMentions>

Ograniczenie [`init`](mention:init) instruuje Anchor, aby
[wywołał System Program](/docs/core/programs#the-system-program) w celu
utworzenia nowego konta, używając PDA jako adresu. "Seeds" użyte do utworzenia
PDA to:

- Adres konta użytkownika podany w instrukcji
- Stały ciąg znaków: "data"
- Kanoniczny [bump seed](mention:bump)

W tym przykładzie ograniczenie "bump" nie jest przypisane do wartości, więc
Anchor użyje `find_program_address` do wyprowadzenia PDA i znalezienia "bump".

```rust title="pda_account"
#[account(
    // !mention init
    init,
    // !mention seeds
    seeds = [b"data", user.key().as_ref()],
    // !mention bump
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

</WithMentions>

<WithMentions>

Plik testowy poniżej zawiera transakcję, która wywołuje instrukcję
[`initialize`](mention:initialize) w celu utworzenia nowego konta z adresem
wyprowadzonym z programu. Plik zawiera kod do [wyprowadzenia PDA](mention:pda).

Przykład pokazuje również, jak [pobrać](mention:fetch) nowe konto, które
zostanie utworzone.

```ts title="Test"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PdaAccount } from "../target/types/pda_account";
import { PublicKey } from "@solana/web3.js";

describe("pda-account", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.PdaAccount as Program<PdaAccount>;
  const user = provider.wallet as anchor.Wallet;

  // !mention(1:5) pda
  // Derive the PDA address using the seeds specified on the program
  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("data"), user.publicKey.toBuffer()],
    program.programId
  );

  it("Is initialized!", async () => {
    const transactionSignature = await program.methods
      // !mention initialize
      .initialize()
      .accounts({
        user: user.publicKey
      })
      .rpc();

    console.log("Transaction Signature:", transactionSignature);
  });

  it("Fetch Account", async () => {
    // !mention fetch
    const pdaAccount = await program.account.dataAccount.fetch(PDA);
    console.log(JSON.stringify(pdaAccount, null, 2));
  });
});
```

</WithMentions>

<Callout type="warn">
  Jeśli ponownie wywołasz instrukcję `initialize` z tym samym seedem adresu
  `user`, transakcja zakończy się niepowodzeniem. Dzieje się tak, ponieważ konto
  już istnieje pod wyprowadzonym adresem.
</Callout>
