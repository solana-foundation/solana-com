---
title: Transakcje
description:
  Dowiedz się więcej o transakcjach Solana — podstawowych elementach interakcji
  z blockchainem Solana. Zrozum strukturę transakcji i skład instrukcji dzięki
  praktycznym przykładom.
---

Aby wchodzić w interakcje z siecią Solana, musisz wysłać transakcję. Możesz
myśleć o transakcji jak o kopercie, która zawiera kilka formularzy. Każdy
formularz to instrukcja, która mówi sieci, co ma zrobić. Wysłanie transakcji
jest jak wysłanie koperty, aby formularze mogły zostać przetworzone.

Poniższy przykład pokazuje uproszczoną wersję dwóch transakcji. Gdy pierwsza
transakcja zostanie przetworzona, wykona pojedynczą instrukcję. Gdy druga
transakcja zostanie przetworzona, wykona trzy instrukcje **w kolejności
sekwencyjnej**: najpierw instrukcję 1, następnie instrukcję 2, a na końcu
instrukcję 3.

<Callout type="warn">
  Transakcje są **atomowe**: jeśli pojedyncza instrukcja się nie powiedzie, cała
  transakcja zakończy się niepowodzeniem i żadne zmiany nie zostaną wprowadzone.
</Callout>

![Uproszczony diagram przedstawiający dwie transakcje](/assets/docs/core/transactions/transaction-simple.svg)

A
[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
składa się z następujących informacji:

<WithMentions>

- [`signatures`](mention:signatures): Tablica [podpisów](#signatures)
- [`message`](mention:message): Informacje o transakcji, w tym lista instrukcji
  do przetworzenia

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![Diagram przedstawiający dwie części transakcji](/assets/docs/core/transactions/tx_format.png)

Transakcje mają całkowity limit rozmiaru wynoszący
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
bajtów. Limit ten obejmuje zarówno tablicę [`signatures`](#signatures), jak i
strukturę [`message`](#message).

<Callout>
  Ten limit wynika z maksymalnej jednostki transmisji (MTU) IPv6 wynoszącej 1280
  bajtów, pomniejszonej o 48 bajtów na nagłówki sieciowe (40 bajtów IPv6 + 8
  bajtów nagłówka).
</Callout>

![Diagram przedstawiający format transakcji i limity rozmiaru](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## Podpisy

Tablica `signatures` transakcji zawiera struktury `Signature`. Każda
[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
ma 64 bajty i jest tworzona przez podpisanie `Message` transakcji za pomocą
prywatnego klucza konta. Podpis musi być dostarczony dla każdego
[konta podpisującego](#account-addresses) uwzględnionego w dowolnej z instrukcji
transakcji.

Pierwszy podpis należy do konta, które opłaci
[opłatę bazową](docs/core/fees#base-fee) transakcji i jest podpisem transakcji.
Podpis transakcji może być użyty do wyszukiwania szczegółów transakcji w sieci.

## Wiadomość

`message` transakcji to
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)
struktura zawierająca następujące informacje:

<WithMentions>

- [`header`](mention:message-header): Nagłówek wiadomości [header](#header)
- [`account_keys`](mention:account-addresses): Tablica
  [adresów kont](#account-addresses) wymaganych przez instrukcje transakcji
- [`recent_blockhash`](mention:recent-blockhash):
  [blockhash](#recent-blockhash), który działa jako znacznik czasu dla
  transakcji
- [`instructions`](mention:instructions): Tablica [instrukcji](#instructions)

<Callout>
  Aby zaoszczędzić miejsce, transakcja nie przechowuje uprawnień dla każdego
  konta indywidualnie. Zamiast tego uprawnienia kont są określane za pomocą
  `header` i `account_keys`.
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### Nagłówek

<WithMentions>

`header` wiadomości to
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
struktura zawierająca następujące informacje:

- [`num_required_signatures`](mention:num_required_signatures): Całkowita liczba
  podpisów wymaganych przez transakcję
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts):
  Całkowita liczba kont tylko do odczytu, które wymagają podpisów
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts):
  Całkowita liczba kont tylko do odczytu, które nie wymagają podpisów

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![Diagram przedstawiający trzy części nagłówka wiadomości](/assets/docs/core/transactions/message_header.png)

### Adresy kont

`account_keys` wiadomości to
[tablica adresów kont](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138),
przesyłana w
[kompaktowym formacie tablicy](/docs/references/terminology#compact-array-format).
Prefiks tablicy wskazuje jej długość. Każdy element w tablicy to klucz
publiczny, wskazujący na konto używane przez jego instrukcje. Tablica
`accounts_keys` musi być kompletna i ściśle uporządkowana w następujący sposób:

1. Podpisujący + Zapis
2. Podpisujący + Tylko do odczytu
3. Nie podpisujący + Zapis
4. Nie podpisujący + Tylko do odczytu

<Callout>
  Ścisłe uporządkowanie pozwala na połączenie tablicy `account_keys` z
  informacjami w [`header`](#header) wiadomości w celu określenia uprawnień dla
  każdego konta.
</Callout>

![Diagram przedstawiający kolejność tablicy adresów kont](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Ostatni blockhash

`recent_blockhash` wiadomości to wartość hash, która działa jako znacznik czasu
transakcji i zapobiega duplikatom transakcji. Blockhash wygasa po
[150 blokach](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134).
(Odpowiada to jednej minucie — zakładając, że każdy blok trwa 400 ms). Po
wygaśnięciu bloku transakcja wygasa i nie może zostać przetworzona.

<Callout>
  Metoda RPC [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) pozwala
  uzyskać aktualny blockhash oraz ostatnią wysokość bloku, przy której blockhash
  będzie ważny.
</Callout>

### Instrukcje

`instructions` wiadomości to tablica wszystkich instrukcji do przetworzenia,
wysyłana w
[kompaktowym formacie tablicy](/docs/references/terminology#compact-array-format).
Prefiks tablicy wskazuje jej długość. Każdy element tablicy to struktura
[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
i zawiera następujące informacje:

<WithMentions>

1. [`program_id_index`](mention:program-id-index): Indeks wskazujący adres w
   tablicy [`account_keys`](#account-addresses). Wartość ta wskazuje adres
   programu, który przetwarza instrukcję.
2. [`accounts`](mention:account-indexes): Tablica indeksów wskazujących adresy w
   tablicy `account_keys`. Każdy indeks wskazuje adres konta wymaganego dla tej
   instrukcji.
3. [`data`](mention:instruction-data): Tablica bajtów określająca, którą
   instrukcję wywołać w programie. Zawiera również wszelkie dodatkowe dane
   wymagane przez instrukcję (na przykład argumenty funkcji).

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Kompaktowa tablica instrukcji](/assets/docs/core/transactions/compact_array_of_ixs.png)

## Przykładowa struktura transakcji

Poniższy przykład pokazuje strukturę transakcji zawierającej pojedynczą
instrukcję transferu SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
Kod poniżej pokazuje wynik z poprzednich fragmentów kodu.
Format różni się między SDK,
ale zauważ, że każda instrukcja zawiera te same wymagane informacje.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

Po przesłaniu transakcji możesz pobrać jej szczegóły, używając sygnatury
transakcji oraz metody RPC [getTransaction](/docs/rpc/http/gettransaction).
Odpowiedź będzie miała strukturę podobną do poniższego fragmentu.

<Callout>
  Możesz również znaleźć transakcję, korzystając z [Solana
  Explorer](https://explorer.solana.com).
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
