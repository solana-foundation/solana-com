---
title: Weryfikacja programów
description:
  Zweryfikowane kompilacje to sposób na powiązanie programu z jego kodem
  źródłowym, umożliwiający każdemu niezależne zweryfikowanie, że program został
  faktycznie zbudowany z dostarczonego kodu źródłowego.
---

Ten przewodnik jest przeznaczony jako odniesienie dla deweloperów, którzy chcą
wdrożyć zweryfikowane kompilacje dla swoich programów na platformie Solana.
Omówimy, czym są zweryfikowane kompilacje, jak z nich korzystać, specjalne uwagi
oraz najlepsze praktyki, aby zapewnić autentyczność Twojego programu w łańcuchu
bloków.

# Czym są zweryfikowane kompilacje?

Zweryfikowane kompilacje zapewniają, że wykonywalny program, który wdrażasz w
sieci Solana, odpowiada kodowi źródłowemu w Twoim repozytorium. Dzięki temu
deweloperzy i użytkownicy mogą mieć pewność, że program działający w łańcuchu
bloków dokładnie odpowiada publicznej bazie kodu, co promuje przejrzystość i
bezpieczeństwo.

Proces weryfikacji polega na porównaniu skrótu programu w łańcuchu bloków ze
skrótem programu lokalnie zbudowanego z kodu źródłowego. To zapewnia brak
rozbieżności między obiema wersjami.

> Chociaż zweryfikowana kompilacja nie powinna być uważana za bardziej
> bezpieczną niż niezweryfikowana, umożliwia ona deweloperom samodzielne
> zweryfikowanie, że kod źródłowy odpowiada temu, co zostało wdrożone w łańcuchu
> bloków. Korzystając z kodu źródłowego, deweloper może następnie zweryfikować,
> co kod wykonuje podczas wysyłania transakcji.

Pipeline zweryfikowanych kompilacji został opracowany i jest utrzymywany przez
[Ellipsis Labs](https://ellipsislabs.xyz/) oraz [OtterSec](https://osec.io/).
Aby uzyskać więcej szczegółów, zapoznaj się z przewodnikiem w
[oryginalnym repozytorium zweryfikowanych kompilacji](https://github.com/Ellipsis-Labs/solana-verifiable-build)
oraz procesem weryfikacji kompilacji bezpośrednio w zestawie narzędzi
[Anza](https://www.anza.xyz/), gdy tylko będzie tam obsługiwany.

# Jak to działa?

Proces weryfikacji polega na porównaniu skrótu programu znajdującego się w
łańcuchu bloków z hashem programu zbudowanego lokalnie z kodu źródłowego.
Budujesz swój program w kontrolowanym środowisku, używając Solana Verify CLI i
Dockera. Zapewnia to, że proces budowy jest deterministyczny i spójny na różnych
systemach. Po uzyskaniu pliku wykonywalnego możesz wdrożyć go w sieci Solana.
Podczas procesu budowy zostanie utworzony
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)
programu [verify](https://github.com/otter-sec/otter-verify). Ten PDA zawiera
wszystkie dane niezbędne do weryfikacji programu. PDA zawiera adres programu,
URL repozytorium git, hash commita oraz argumenty użyte do budowy programu.

Korzystając z danych zawartych w PDA, każdy może lokalnie uruchomić polecenie
verify program i sprawdzić, czy program został zbudowany z dostarczonego kodu
źródłowego. Następnie każdy może zweryfikować to samodzielnie, całkowicie bez
zaufania, lub uruchomić własne
[verify API](https://github.com/otter-sec/solana-verified-programs-api)
zarządzane przez [OtterSec](https://github.com/otter-sec), aby zapewnić
użytkownikom łatwy punkt dostępu do sprawdzania weryfikacji. Możesz już zobaczyć
te
[wywołania API](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
używane w
[Solana Explorer](https://explorer.solana.com/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/verified-build)
i
[SolanaFM](https://solana.fm/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/transactions?cluster=mainnet-alpha),
między innymi.

# Dlaczego warto korzystać ze zweryfikowanych buildów?

Korzystanie ze zweryfikowanych buildów zapewnia następujące korzyści:

- Bezpieczeństwo: Gwarancja, że program działający w łańcuchu bloków odpowiada
  kodowi źródłowemu, co zapobiega złośliwym zmianom.

- Przejrzystość: Umożliwia innym użytkownikom i deweloperom weryfikację, że
  program w łańcuchu bloków jest godny zaufania, porównując go z publiczną bazą
  kodu.

- Zaufanie: Zwiększa zaufanie użytkowników, ponieważ zweryfikowane buildy
  pokazują, że zachowanie programu w łańcuchu bloków jest zgodne z publicznym
  kodem. Tworząc programy możliwe do weryfikacji, minimalizujesz ryzyko związane
  z uruchamianiem nieautoryzowanego lub złośliwego kodu. Zapewnia to również
  zgodność z najlepszymi praktykami i ułatwia badaczom bezpieczeństwa kontakt z
  Tobą. Ponadto portfele i inne narzędzia mogą łatwiej akceptować transakcje z
  Twojego programu, o ile jest on zweryfikowany.

- Odkrywalność: Gdy udostępniasz zweryfikowaną wersję swojego programu, każdy
  może znaleźć Twój kod źródłowy, dokumentację, SDK programu lub IDL, a także
  łatwo skontaktować się z Tobą przez GitHub w przypadku problemów.

# Jak tworzyć zweryfikowane wersje?

Aby stworzyć zweryfikowane wersje, musisz wykonać następujące kroki:

Podsumowanie:

- Zatwierdź swój kod w publicznym repozytorium
- Zbuduj zweryfikowaną wersję w Dockerze
- Wdróż zweryfikowaną wersję
- Zweryfikuj wdrożony program względem publicznego API

Jeśli zweryfikujesz swój program, który nie został zbudowany w kontenerze
Dockera, najprawdopodobniej weryfikacja się nie powiedzie, ponieważ kompilacje
programów Solana nie są deterministyczne na różnych systemach.

<Steps>
<Step>

### Zainstaluj Docker i Cargo

Zainstaluj niezbędne narzędzia, upewnij się, że masz zainstalowane Docker i
Cargo. Docker zapewnia kontrolowane środowisko kompilacji, aby zagwarantować
spójność, a Cargo służy do zarządzania pakietami Rust.

- Docker: Wykonaj kroki opisane na
  [stronie Dockera](https://docs.docker.com/engine/install/), aby zainstalować
  Dockera dla swojej platformy. Po instalacji upewnij się, że usługa Dockera
  działa, postępując zgodnie z dalszymi wskazówkami w tym przewodniku.
- Cargo: Jeśli nie masz jeszcze zainstalowanego Cargo, możesz je zainstalować,
  uruchamiając następujące polecenie:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

</Step>
<Step>

### Zainstaluj Solana Verify CLI

Solana Verify CLI to główne narzędzie używane do weryfikacji kompilacji. Solana
Verify CLI jest obecnie utrzymywane przez
[Ellipsis Labs](https://ellipsislabs.xyz/) i można je zainstalować za pomocą
Cargo.

Możesz je zainstalować, uruchamiając:

```bash
cargo install solana-verify
```

Jeśli potrzebujesz konkretnej wersji CLI, możesz przypiąć wersję za pomocą:

```bash
cargo install solana-verify --version $VERSION
```

Jeśli chcesz, możesz zainstalować wersję bezpośrednio z konkretnego commita:

```bash
cargo install solana-verify --git https://github.com/Ellipsis-Labs/solana-verifiable-build --rev 13a1db2
```

</Step>
<Step>

### Przygotowanie projektu

Aby zweryfikować repozytorium, musi ono zawierać plik `Cargo.lock` w katalogu
głównym repozytorium. Jeśli w repozytorium znajduje się tylko jeden program i
plik `cargo.lock` w katalogu głównym, możesz przejść bezpośrednio do następnego
kroku i zbudować swój program.

Jeśli Twój program znajduje się w podkatalogu i używasz przestrzeni roboczej
Rust, musisz utworzyć plik przestrzeni roboczej `Cargo.toml` w katalogu głównym
repozytorium.

Możesz użyć tego przykładu `Cargo.toml` jako szablonu:

```toml title="Cargo.toml"
[workspace]
members = ["program/programs/*"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1

[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
```

Upewnij się, że Twój program znajduje się w tablicy `workspace/members` i że
plik `Cargo.toml` Twojego programu ma poprawnie skonfigurowaną nazwę `lib`.

> Ważny jest `lib name`, a nie nazwa pakietu!

Coś takiego:

```toml title="waffle/Cargo.toml"
[package]
name = "waffle"
version = "0.1.0"
edition = "2021"

[lib]
name = "waffle"
crate-type = ["cdylib", "lib"]

[dependencies]
solana-program = "2.1.0"
```

W tym [repozytorium](https://github.com/solana-developers/verified-program)
możesz zobaczyć przykład przestrzeni roboczej z programem w podkatalogu. Zwróć
również uwagę, że gdy program znajduje się w podkatalogu, później musisz dodać
ten folder jako `--mount-path` do polecenia `verify-from-repo`.

W tym [repozytorium](https://github.com/solana-developers/solana-game-preset)
znajdziesz przykład z Anchor. W tym
[repozytorium](https://github.com/solana-developers/verified-program-root)
znajdziesz przykład natywnego Rust.

Z plikiem `Cargo.toml` na miejscu możesz uruchomić `cargo generate-lockfile`,
aby utworzyć plik blokady i kontynuować budowanie swojego programu.

</Step>
<Step>

### Budowanie weryfikowalnych programów

Aby weryfikowalnie zbudować swój program Solana, przejdź do katalogu
zawierającego plik `Cargo.toml` przestrzeni roboczej i uruchom:

```bash
solana-verify build
```

To skopiuje Twoje środowisko do kontenera Docker i zbuduje je w sposób
deterministyczny.

> Upewnij się, że faktycznie wdrażasz zweryfikowaną wersję i nie nadpisujesz jej
> przypadkowo za pomocą `anchor build` lub `cargo build-sbf`, ponieważ
> najprawdopodobniej nie wygenerują one tego samego skrótu, co spowoduje
> niepowodzenie weryfikacji.

W przypadku projektów z wieloma programami możesz zbudować konkretny program,
używając nazwy biblioteki (a nie nazwy pakietu):

```bash
solana-verify build --library-name $PROGRAM_LIB_NAME
```

Ten proces zapewnia deterministyczne kompilacje i może zająć trochę czasu,
szczególnie na niektórych systemach (np. M1 MacBook), ponieważ działa w
kontenerze docker. Dla szybszych kompilacji zaleca się użycie maszyny z systemem
Linux działającej na architekturze x86.

Po zakończeniu kompilacji możesz uzyskać hash pliku wykonywalnego za pomocą
następującego polecenia:

```bash
solana-verify get-executable-hash target/deploy/$PROGRAM_LIB_NAME.so
```

</Step>
<Step>

### Wdrażanie weryfikowalnych programów

Po zbudowaniu programu i uzyskaniu jego hasha możesz wdrożyć go w sieci Solana.
Zaleca się użycie rozwiązania wielopodpisowego lub zarządzania, takiego jak
[Squads Protocol](https://squads.so/protocol) dla bezpiecznych wdrożeń, ale
możesz również wdrożyć bezpośrednio za pomocą:

```bash
solana program deploy -u $NETWORK_URL target/deploy/$PROGRAM_LIB_NAME.so --program-id $PROGRAM_ID --with-compute-unit-price 50000 --max-sign-attempts 100 --use-rpc
```

Obecnie odpowiednia niska opłata priorytetowa, którą możesz zażądać od swojego
dostawcy rpc, na przykład
[Quicknode](https://www.quicknode.com/gas-tracker/solana).

Aby zweryfikować, czy wdrożony program odpowiada zbudowanemu plikowi
wykonywalnemu, uruchom:

```bash
solana-verify get-program-hash -u $NETWORK_URL $PROGRAM_ID
```

> Możesz mieć różne wersje wdrożone na różnych
> [klastrach Solana](/docs/references/clusters) (tj. devnet, testnet, mainnet).
> Upewnij się, że używasz poprawnego adresu URL sieci dla wybranego klastra
> Solana, który chcesz zweryfikować. Zdalna weryfikacja będzie działać tylko na
> mainnet.

</Step>
<Step>

### Weryfikacja względem repozytoriów

Aby zweryfikować program względem jego publicznego repozytorium, użyj:

```bash
solana-verify verify-from-repo -u $NETWORK_URL --program-id $PROGRAM_ID https://github.com/$REPO_PATH --commit-hash $COMMIT_HASH --library-name $PROGRAM_LIB_NAME --mount-path $MOUNT_PATH
```

> Podczas uruchamiania zweryfikowanej kompilacji w katalogu programu, przy
> uruchamianiu `verify-from-repo` musisz dodać flagę `--mount-path`. Będzie to
> ścieżka do folderu zawierającego `Cargo.toml`, który zawiera nazwę biblioteki
> twojego programu.

To polecenie porównuje hash programu znajdującego się w łańcuchu bloków z hashem
wykonywalnym zbudowanym na podstawie źródła w określonym commicie.

Na końcu polecenie zapyta, czy chcesz przesłać dane weryfikacyjne na łańcuch
bloków. Jeśli to zrobisz, Solana Explorer natychmiast wyświetli dane
weryfikacyjne twojego programu. Dopóki nie zostanie zweryfikowany przez zdalne
kompilowanie, będzie wyświetlany jako niezweryfikowany. Dowiedz się, jak możesz
zweryfikować swój program za pomocą publicznego API w następnym kroku.

Jeśli chcesz zablokować weryfikację do określonego wydania, możesz dodać flagę
`--commit-hash` do polecenia.

</Step>
<Step>

### Weryfikacja za pomocą publicznego API

Na koniec możesz również bezpośrednio zweryfikować program za pomocą dowolnej
osoby, która uruchamia API weryfikacyjne::

```bash
solana-verify verify-from-repo --remote -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

> Zaleca się korzystanie z płatnego adresu URL RPC, ponieważ w przeciwnym razie
> możesz napotkać limity szybkości darmowych RPC. Zamiast `-um` powinieneś użyć
> `--url yourRpcUrl` dla bardziej niezawodnej weryfikacji.

Flaga `--remote` wysyła żądanie kompilacji do API OtterSec, co uruchamia zdalne
kompilowanie twojego programu. Po zakończeniu kompilacji system weryfikuje, czy
hash programu w łańcuchu bloków pasuje do hasha wygenerowanego artefaktu
kompilacji z twojego repozytorium.

Domyślnie jest to
[API OtterSec](https://github.com/otter-sec/solana-verified-programs-api).

Upewnij się, że wybierasz „tak”, gdy zostaniesz zapytany o przesłanie danych
weryfikacyjnych na łańcuch bloków. API używa tego do weryfikacji, że przesłałeś
dane weryfikacyjne.

Możesz również ręcznie uruchomić zdalne zadanie, używając:

```bash
solana-verify remote submit-job --program-id <program-id> --uploader <address>
```

Uploader to adres, który ma uprawnienia do zapisu w PDA. W większości przypadków
powinien to być autorytet programu. Jeśli Twój program jest kontrolowany przez
multisig, przejdź do sekcji
[weryfikacja multisig](#how-to-verify-your-program-when-its-controlled-by-a-multisig-like-squads)
w tej instrukcji poniżej.

To wyśle zadanie do API OtterSec, a następnie możesz sprawdzić status zadania za
pomocą:

```bash
solana-verify remote get-job-status --job-id <job-id>
```

Po pomyślnym zakończeniu weryfikacji, co może chwilę potrwać, będziesz mógł
zobaczyć swój program jako zweryfikowany w
[API OtterSec dla pojedynczych programów](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
oraz w
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY/verified-build),
[SolanaFM](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY?cluster=mainnet-alpha),
[SolScan](https://solscan.io/account/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY#programVerification)
i ostatecznie także na stronie społecznościowej
[SolanaVerify.org](https://www.solanaverify.org/) utrzymywanej przez
[0xDeep](https://x.com/0xDeep) oraz w API zweryfikowanych programów OtterSec
[OtterSec verified programs API](https://verify.osec.io/verified-programs) oraz
w
[Verified Programs Dune Dashboard](https://dune.com/jonashahn/verified-programs/dedf21e1-9b71-42c8-89f9-02ed94628657),
przyczyniając się do zdrowszego ekosystemu Solana.

</Step>
</Steps>

## Jak zweryfikować program kontrolowany przez Multisig, taki jak Squads

Aby zdalna weryfikacja działała, musisz zapisać dane weryfikacyjne w PDA
podpisanym przez autorytet programu. Jeśli Twój program jest kontrolowany przez
multisig, możesz wyeksportować tę transakcję zapisu PDA i przesłać ją za pomocą
[Squads Protocol](https://squads.so/protocol) lub innego rozwiązania multisig
według własnego wyboru.

<Steps>
<Step>

### 1. Zbuduj weryfikowalny program

Najpierw zbuduj program:

```bash
solana-verify build
```

To zbuduje weryfikowalną wersję przy użyciu kontenera docker z wersją Solana
określoną w pliku `Cargo.lock`.

</Step>
<Step>

### 2. Wdróż program

```bash
solana config set --url "PayedMainnetRPCAddress" // the public endpoint will be rate limited too much
solana program deploy target/deploy/verify_squads.so
```

Na potrzeby reszty tego przewodnika dotyczącego multisig użyjemy przykładowego
ID programu `6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`.

</Step>
<Step>

### 3. Zatwierdź i zweryfikuj w repozytorium

Gdy to zostanie wykonane, zatwierdzamy projekt do GitHuba. Oto przykład:
https://github.com/solana-developers/verify-squads

Opcjonalnie: Sprawdź, czy możesz najpierw zweryfikować lokalnie (to polecenie
używa przykładowego ID programu `6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`):

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
```

Tylko po to, aby upewnić się, że Twoje parametry są poprawne.

</Step>
<Step>

### 4. Przenieś uprawnienia programu do multisig

Jeśli jeszcze tego nie zrobiłeś, przenieś uprawnienia swojego programu do
multisig i skopiuj autorytet multisig. Będzie Ci potrzebny w następnym kroku.

</Step>
<Step>

### 5. Eksportuj transakcję PDA

Gdy masz lokalnie autorytet programu, zostaniesz poproszony o przesłanie danych
kompilacji on-chain, używając polecenia `solana-verify verify-from-repo`.

Ponieważ nie możesz tego zrobić, używając multisig, musisz ręcznie wyeksportować
transakcję PDA, a następnie uruchomić transakcję za pomocą Squads.

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader <your program authority> --encoding base58 --compute-unit-price 0
```

To zwróci transakcję w formacie base58. Jeśli potrzebujesz transakcji
zakodowanej w base64 do użycia w inspektorze transakcji, możesz użyć
`--encoding base64`.

```bash
P6vBfcPaaXb8fZoT3NBAYEcdtEj7tubA1k2gBxmFKZ3UWF5YyrmDMFTvLKALCJoUuRsPAjMckudYruCu3eeWQtuDrFbEMLxLFutnKXac974fnkMivcwUdY66VLjbxQT6ATmcy7F4hBtz1G4P1h6iBJLhb8WtrtgY3i4qq45MUEb7RjuMEfUFXKrNgPdGxkz5xvMHq3dxKRcpmEK5k2DkeW6SUQYBVe19Ga3B9GyhTX8k3CMt9JCEah13WyRnQd8GjoK6sTEvGJym6xDNvmd8yiJYSNcaYwEJsjHEUf4Yh6kAC7ki2KRvVAr3NVe1gjqK9McrwSQjtUatvydTG8Zovcr7PPUEMf3yPMgKXjZLB2QpkH63yTTYdNAnWFuv9E6b6nYRqye5XcNi436yKw5U14fXh65yK34bgYLi9328UT1huJELsJU9BRGnGUmb6GWp6c2WL5BhnzgNTSnt9TXFfEgUMzhvKzpVBxLP44hwqqBdyUhHFysCF37531PnmiESq8x1xou23xJ6FcQbc199754MkqQd7tX9CUznGzAEqHGkzn3VBoJnojsKtgYmiTYbdRsT1CU18MbYEE7WvGAvXyxxbpNzbAcc94HrnM6cqRGmwhEBroPfFghTdmzg9D
```

</Step>
<Step>

### 6. Prześlij transakcję za pomocą Squads

Przejdź do kreatora transakcji Squads i zaimportuj transakcję zakodowaną w
base58. Upewnij się, że w symulacji transakcja zawiera tylko wywołanie programu
weryfikacyjnego osec i programu budżetu komputerowego, i nic więcej!

</Step>
<Step>

### 7. Prześlij zdalne zadanie weryfikacyjne

Gdy transakcja do Squads zakończy się sukcesem, możesz przesłać zdalne zadanie:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
--uploader <your program authority>
```

To wszystko! Zweryfikowałeś swój program w publicznym repozytorium i przesłałeś
zdalne zadanie do API OtterSec. Powinno to być widoczne w solana explorer i
innych miejscach.

</Step>
<Step>

### 8. Aktualizacja programu (opcjonalne)

Podczas aktualizacji programu musisz wyeksportować nową transakcję PDA i
ponownie przesłać ją za pośrednictwem Squads.

Wykonywanie aktualizacji programu:

```bash
solana-verify build
solana program write-buffer target/deploy/verify_squads.so --with-compute-unit-price 50000 --max-sign-attempts 50
```

Następnie przekaż autorytet bufora do multisig lub bezpośrednio utwórz bufor z
autorytetem multisig.

```bash
solana program set-buffer-authority Fu3k79g53ZozAj47uq1tXrFy4QbQYh7y745DDsxjtyLR --new-buffer-authority 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

</Step>
<Step>

### 9. Eksport i przesłanie nowej transakcji PDA

Nie zapomnij zatwierdzić swoich zmian w github. Ponownie wyeksportuj transakcję
aktualizacji PDA:

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

Ponownie prześlij transakcję za pośrednictwem Squads.

Przykładową transakcję możesz zobaczyć
[tutaj](https://solana.fm/tx/4zJ1vK2KToAwxuEYzTMLqPkcebjoi9rdeeyxtEEx9L5Q4vWDA8h6Rr4kPRuRxcV7ZLKMr6qx1LTWb6x3ZpUJaFUW?cluster=mainnet-alpha).

Następnie prześlij do kolejnej zdalnej kompilacji:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

Powinno to skutkować czymś takim:

```shell
Verification request sent with request id: b63339d2-163e-49ac-b55d-3454c1c2b5b3
Verification in progress... ⏳ [00:18:02] ✅ Process completed. (Done in 18
minutes) Program 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD has been verified.
✅ The provided GitHub build matches the on-chain hash. On Chain Hash:
96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Executable
Hash: 96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Repo URL:
https://github.com/Woody4618/verify-squads/tree/0fb0a2e30c15c51732c0ad5e837975a6f7bbc7ed
Check the verification status at:
https://verify.osec.io/status/6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD Job
url: https://verify.osec.io/job/b63339d2-163e-49ac-b55d-3454c1c2b5b3
```

Gratulacje, zweryfikowałeś swój program po aktualizacji multisig!

</Step>
</Steps>

## Weryfikacja z obrazu docker

Możesz również zweryfikować swój program względem obrazu docker, uruchamiając
następujące polecenie:

```bash
solana-verify verify-from-image -e
examples/hello_world/target/deploy/hello_world.so -i
ellipsislabs/hello_world_verifiable_build:latest -p
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn
```

To polecenie ładuje obraz zapisany pod adresem
`ellipsislabs/hello_world_verifiable_build:latest` i weryfikuje, czy hash
ścieżki wykonywalnej w kontenerze jest taki sam jak hash programu on-chain
przekazanego do polecenia. Ponieważ kompilacja została już przesłana do obrazu,
nie ma potrzeby pełnej rekompilacji pliku wykonywalnego, co może zająć dużo
czasu.

Plik Dockerfile, który tworzy obraz
`ellipsislabs/hello_world_verifiable_build:latest` można znaleźć w repozytorium
ellipsis labs
[/examples/hello_world](https://github.com/Ellipsis-Labs/solana-verifiable-build/tree/master/examples/hello_world).

Poniżej znajduje się oczekiwany wynik:

```bash
Verifying image: "ellipsislabs/hello_world_verifiable_build:latest", on network
"https://api.mainnet-beta.solana.com" against program ID
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn Executable path in container:
"examples/hello_world/target/deploy/hello_world.so"

Executable hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Program hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Executable
matches on-chain program data ✅
```

## Przykładowa zweryfikowana kompilacja

Oto przykład weryfikacji przykładowego programu z ID
`FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv` przy użyciu kodu źródłowego z
tego [repozytorium](https://github.com/solana-developers/verified-program):

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

Domyślnie polecenie `verify-from-repo` wykorzystuje ostatni commit na głównej
gałęzi. Możesz również określić konkretny commit, jeśli chcesz kontynuować pracę
nad repozytorium, używając parametru `commit-hash`:
`--commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e`

Na koniec możesz również bezpośrednio zweryfikować program za pomocą API
OtterSec:

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --remote --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

Polecenie `--remote` wysyła żądanie kompilacji do API OtterSec, które uruchamia
zdalną kompilację twojego programu. Po zakończeniu kompilacji system weryfikuje,
czy hash programu w łańcuchu bloków odpowiada hashowi wygenerowanego artefaktu
kompilacji z twojego repozytorium.

## Popularne programy, które już zostały zweryfikowane

### Phoenix

```shell
solana-verify verify-from-repo -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

Końcowy wynik:

```shell
Executable Program Hash from repo: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
On-chain Program Hash: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
Program hash matches ✅
```

### Squads V3

```shell
solana-verify verify-from-repo https://github.com/Squads-Protocol/squads-mpl --commit-hash c95b7673d616c377a349ca424261872dfcf8b19d --program-id SMPLecH534NA9acpos4G6x7uf3LWbCAwZQE9e8ZekMu -um --library-name squads_mpl --bpf
```

> Zauważ, że musieliśmy określić `library-name`, ponieważ repozytorium Squads
> zawiera wiele programów. Używamy flagi `--bpf`, ponieważ `squads_mpl` został
> wcześniej zweryfikowany za pomocą Anchor.

Końcowy wynik:

```shell
Executable Program Hash from repo: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
On-chain Program Hash: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
Program hash matches ✅
```

### Drift V2

```shell
solana-verify verify-from-repo -um --program-id dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH https://github.com/drift-labs/protocol-v2 --commit-hash 110d3ff4f8ba07c178d69f9bfc7b30194fac56d6 --library-name drift
```

Końcowy wynik:

```shell
Executable Program Hash from repo: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
On-chain Program Hash: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
Program hash matches ✅
```

### Marginfi V2

```shell
solana-verify verify-from-repo -um --program-id MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA https://github.com/mrgnlabs/marginfi-v2 --commit-hash d33e649e415c354cc2a1e3c49131725552d69ba0 --library-name marginfi -- --features mainnet-beta
```

Końcowy wynik:

```shell
Executable Program Hash from repo: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
On-chain Program Hash: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
Program hash matches ✅
```

# Podsumowanie

Korzystanie z
[zweryfikowanych kompilacji na Solanie](/developers/guides/advanced/verified-builds)
zapewnia integralność i wiarygodność Twoich programów w sieci oraz pozwala
deweloperom znaleźć Twoje SDK bezpośrednio w Solana Explorer. Wykorzystując
narzędzia takie jak Solana Verify CLI i Docker, możesz utrzymać weryfikowalne i
bezpieczne kompilacje zgodne z Twoim kodem źródłowym. Zawsze podejmuj niezbędne
środki ostrożności, aby używać spójnych środowisk i rozważ rozwiązania
zarządzania dla bezpiecznych aktualizacji i wdrożeń.

## Bezpieczeństwo + Zastrzeżenie

Chociaż zweryfikowane kompilacje są potężnym narzędziem zapewniającym
integralność Twoich programów na Solanie, w domyślnej konfiguracji nie są one
całkowicie pozbawione zaufania. Obrazy Dockera są tworzone i hostowane przez
Solana Foundation.

Pamiętaj, że budujesz swój projekt w pobranym obrazie Dockera i że cała Twoja
konfiguracja jest kopiowana do tego obrazu Dockera w celu kompilacji, w tym
potencjalnie wrażliwe informacje.

Jeśli chcesz mieć całkowicie pozbawioną zaufania konfigurację, możesz
samodzielnie zbudować obrazy Dockera i hostować je na własnej infrastrukturze. W
ten sposób możesz mieć pewność, że obrazy Dockera nie zostały naruszone. Skrypty
do tworzenia własnych obrazów Dockera znajdziesz w
[repozytorium zweryfikowanych kompilacji](https://github.com/Ellipsis-Labs/solana-verifiable-build),
możesz je zforkować i uruchomić github actions samodzielnie lub zweryfikować, że
są poprawne.

Ponadto, w przypadku zdalnej weryfikacji, ufasz API OtterSec oraz
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
do pewnego stopnia.

API lub Solana Explorer mogą potencjalnie wyświetlać nieprawidłowe informacje,
jeśli zostaną naruszone.

Jeśli chcesz mieć całkowicie pozbawioną zaufania konfigurację, możesz uruchomić
[Verify API](https://github.com/otter-sec/solana-verified-programs-api)
samodzielnie lub przeprowadzić weryfikację programu lokalnie, używając polecenia
`verify-from-repo` korzystając z danych weryfikacyjnych zapisanych w
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account),
który jest pochodną autorytetu wdrożenia programów oraz
[programu weryfikacyjnego](https://explorer.solana.com/address/verifycLy8mB96wd9wqq3WDXQwM4oU6r42Th37Db9fC).

Program weryfikacyjny jest wdrażany przez [zespół OtterSec](https://osec.io/) i
nie został jeszcze zamrożony, co oznacza, że może być aktualizowany w dowolnym
momencie.

Fundacja Solana, OtterSec oraz zespół Ellipsis Labs nie ponoszą
odpowiedzialności za jakiekolwiek straty lub szkody, które mogą wyniknąć z
korzystania z pipeline'u zweryfikowanych kompilacji.

# Security.txt dla programów Solana

Oprócz zweryfikowanych kompilacji możesz również dodać plik `security.txt` do
swojego programu. W przyszłości, po wdrożeniu, `security.txt` będzie zawierać
publiczny klucz weryfikatora, umożliwiając łatwy dostęp do danych
weryfikacyjnych przechowywanych w PDA weryfikacyjnym. PDA zawierające wszystkie
informacje potrzebne do kompilacji i weryfikacji programu jest wyprowadzane z
adresu programu i publicznego klucza weryfikatora. Domyślnie jest to ten sam
publiczny klucz, który skompilował i wdrożył program. Może to być jednak również
inny publiczny klucz, który można określić w `security.txt`.

Funkcja `security.txt` pozwala deweloperom na osadzenie informacji kontaktowych
i dotyczących bezpieczeństwa bezpośrednio w swoich smart kontraktach Solana.
Zainspirowana [securitytxt.org](https://securitytxt.org), ta metoda zapewnia
ustandaryzowany sposób, w jaki badacze bezpieczeństwa mogą skontaktować się z
opiekunami projektu, nawet jeśli znają tylko adres kontraktu.

## Dlaczego warto używać security.txt?

Dla wielu projektów, zwłaszcza mniejszych lub prywatnych, identyfikacja
deweloperów na podstawie samego adresu kontraktu może być trudna i czasochłonna.
Osadzenie pliku `security.txt` w programie zapewnia, że badacze bezpieczeństwa
mogą łatwo skontaktować się z odpowiednimi osobami, co może zapobiec exploitom i
zapewnić terminowe zgłaszanie błędów.

## Jak wdrożyć security.txt

Aby dodać `security.txt` do swojego programu Solana, wykonaj następujące kroki:

Dodaj zależność `solana-security-txt` do swojego `Cargo.toml`:

```toml title="Cargo.toml"
[dependencies]
solana-security-txt = "1.1.1"
```

Użyj makra `security_txt!` w swoim kontrakcie, aby zdefiniować informacje o
bezpieczeństwie. Możesz uwzględnić dane kontaktowe, adresy URL projektu, a nawet
politykę bezpieczeństwa. Oto przykład:

```rust
#[cfg(not(feature = "no-entrypoint"))]
use {default_env::default_env, solana_security_txt::security_txt};

#[cfg(not(feature = "no-entrypoint"))]
security_txt! {
    name: "MyProject",
    project_url: "https://myproject.com",
    contacts: "email:security@myproject.com,discord:security#1234",
    policy: "https://myproject.com/security-policy",

    // Optional Fields
    preferred_languages: "en,de",
    source_code: "https://github.com/solana-developers/solana-game-preset",
    source_revision: "5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    source_release: "",
    encryption: "",
    auditors: "Verifier pubkey: 5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    acknowledgements: "Thank you to our bug bounty hunters!"
}
```

Gdy informacje `security.txt` zostaną osadzone w Twoim programie, można je łatwo
odczytać za pomocą narzędzi takich jak Solana Explorer, co zapewnia dostępność
Twoich danych kontaktowych i informacji o bezpieczeństwie dla każdego, kto chce
zgłosić potencjalne problemy.

## Najlepsze praktyki

- Używaj linków: W przypadku informacji, które mogą się zmieniać (np. dane
  kontaktowe), zaleca się podlinkowanie strony internetowej zamiast twardego
  kodowania ich w kontrakcie. Dzięki temu unika się konieczności częstych
  aktualizacji programu.

- Weryfikacja: Przed wdrożeniem zweryfikuj format i treść za pomocą narzędzia
  `query-security-txt`, które może sprawdzić zarówno programy onchain, jak i
  lokalne pliki binarne:

```bash
query-security-txt target/bpfel-unknown-unknown/release/my_contract.so
```

Osadzając informacje kontaktowe dotyczące bezpieczeństwa bezpośrednio w swoim
kontrakcie, ułatwiasz badaczom dotarcie do Ciebie, wspierając lepsze
bezpieczeństwo i komunikację w ekosystemie Solana.

Oto
[przykład, jak wygląda security.txt w Solana Explorer](https://explorer.solana.com/address/HPxKXnBN4vJ8RjpdqDCU7gvNQHeeyGnSviYTJ4fBrDt4/security?cluster=devnet)

Projekt `security.txt` jest utrzymywany przez
[Neodyme Labs](https://github.com/neodyme-labs)
