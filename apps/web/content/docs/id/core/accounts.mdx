---
title: Akun
description:
  Pelajari tentang model akun Solana, termasuk bagaimana akun menyimpan data dan
  program, mekanisme rent, kepemilikan akun, dan hubungan antara program dan
  akun data. Pahami konsep inti dari sistem penyimpanan key-value Solana.
---

Semua data di jaringan Solana disimpan dalam akun. Anda dapat menganggap
jaringan Solana sebagai database publik dengan satu tabel Akun. Hubungan antara
akun dan alamatnya mirip dengan pasangan key-value, dengan key sebagai alamat
dan value sebagai akun.

Setiap akun memiliki [struktur](#account-structure) dasar yang sama dan dapat
ditemukan menggunakan [alamat](#account-address)-nya.

![Diagram 3 akun dan alamatnya. Termasuk definisi struktur akun.](/assets/docs/core/accounts/accounts.png)

## Alamat akun

Alamat akun adalah ID unik 32-byte yang digunakan untuk menemukan akun di
blockchain Solana. Alamat akun sering ditampilkan sebagai string yang dikodekan
base58. Kebanyakan akun menggunakan [kunci publik](#public-key)
[Ed25519](https://ed25519.cr.yp.to/) sebagai alamat mereka, tetapi ini tidak
diwajibkan, karena Solana juga mendukung
[alamat turunan program](#program-derived-address).

![Sebuah akun dengan alamat kunci publik yang dikodekan base58](/assets/docs/core/accounts/account-address.svg)

### Kunci publik

Contoh di bawah ini menunjukkan cara menggunakan SDK Solana untuk membuat
keypair.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner } from "@solana/kit";

// Kit does not enable extractable private keys
const keypairSigner = await generateKeyPairSigner();
console.log(keypairSigner);
```

```ts !! title="Legacy"
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);
console.log(`Secret Key: ${keypair.secretKey}`);
```

```rs !! title="Rust"
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() {
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());
    println!("Secret Key: {:?}", keypair.to_bytes());
}
```

</CodeTabs>

### Program derived address

[Program derived address](/docs/core/pda) (PDA) adalah alamat yang ditentukan
secara deterministik menggunakan ID program dan satu atau lebih input opsional
(seeds). Contoh di bawah ini menunjukkan cara menggunakan SDK Solana untuk
membuat program derived address.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey; // macro
use solana_sdk::pubkey::Pubkey;

#[tokio::main]
async fn main() {
    let program_address = pubkey!("11111111111111111111111111111111");
    let seeds = [b"helloWorld".as_ref()];
    let (pda, bump) = Pubkey::find_program_address(&seeds, &program_address);
    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
}
```

</CodeTabs>

## Struktur akun

Setiap
[`Account`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L48-L60)
memiliki ukuran maksimum
[10MiB](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/system_instruction.rs#L85)
dan berisi informasi berikut:

<WithMentions>

- [`lamports`](mention:lamports): Jumlah [lamport](#lamports) dalam akun
- [`data`](mention:data): [Data](#data) akun
- [`owner`](mention:owner): ID program yang [memiliki](#owner) akun tersebut
- [`executable`](mention:executable): Menunjukkan apakah akun berisi binary yang
  [dapat dieksekusi](#executable)
- [`rent_epoch`](mention:rent_epoch): Kolom [rent epoch](#rent-epoch) yang sudah
  tidak digunakan lagi

```rust title="Account"
pub struct Account {
    /// lamports in the account
    // !mention lamports
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    // !mention data
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    // !mention owner
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    // !mention executable
    pub executable: bool,
    /// the epoch at which this account will next owe rent
    // !mention rent_epoch
    pub rent_epoch: Epoch,
}
```

</WithMentions>

<ScrollyCoding>

## !!steps Lamports

Saldo akun dalam [lamport](/docs/references/terminology#lamport).

Setiap akun harus memiliki saldo lamport minimum, yang disebut
[rent](/docs/references/terminology#rent), yang memungkinkan datanya disimpan di
blockchain. Rent sebanding dengan ukuran akun.

<Callout type="info">
  Meskipun saldo ini disebut rent, cara kerjanya lebih seperti deposit, karena
  saldo penuh dapat dikembalikan ketika akun ditutup. (Nama "rent" berasal dari
  kolom [rent epoch](#rent-epoch) yang sekarang sudah tidak digunakan lagi.)
</Callout>

(Lihat rumus
[saldo minimum](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97)
dan
[konstanta](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L47-L70)
yang berlaku.)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    // !focus
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    // !focus
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Data

Kolom ini umumnya disebut sebagai "data akun". `data` dalam kolom ini dianggap
arbitrer karena dapat berisi urutan byte apa pun. Setiap program mendefinisikan
struktur data yang disimpan dalam kolom ini.

- Akun program: Kolom ini berisi kode program yang dapat dieksekusi atau alamat
  [akun data program](#program-data-accounts) yang menyimpan kode program yang
  dapat dieksekusi.
- Akun data: Kolom ini umumnya menyimpan data state, yang dimaksudkan untuk
  dibaca.

Membaca data dari akun Solana melibatkan dua langkah:

1. Mengambil akun menggunakan [alamatnya](#account-address)
2. Mendeserialkan kolom `data` akun dari byte mentah menjadi struktur data yang
   sesuai, sebagaimana didefinisikan oleh program yang memiliki akun tersebut.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    // !focus
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    // !focus
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    // !focus
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    // !focus
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Pemilik

Bidang ini berisi ID program dari pemilik akun.

Setiap akun Solana memiliki [program](/docs/core/programs) yang ditunjuk sebagai
pemiliknya. Pemilik akun adalah satu-satunya program yang dapat mengubah `data`
akun atau mengurangi lamports, sebagaimana ditunjukkan oleh instruksi program.

(Dalam kasus program account, pemiliknya adalah
[loader program](https://solana.com/docs/core/programs#loader-programs).)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    // !focus
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    // !focus
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Dapat Dieksekusi

Bidang ini menunjukkan apakah sebuah akun adalah
[program account](#program-accounts) atau [data account](#data-accounts)

- Jika `true`: Akun tersebut adalah program account
- Jika `false`: Akun tersebut adalah data account

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    // !focus
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    // !focus
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Epoch sewa

**Bidang `rent_epoch` sudah tidak digunakan lagi.**

Di masa lalu, bidang ini melacak kapan sebuah akun perlu membayar rent. Namun,
mekanisme pengumpulan rent ini sejak itu telah dihentikan.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    // !focus
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    // !focus
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

</ScrollyCoding>

## Jenis-jenis akun

Ada dua kategori dasar akun:

- [Program accounts](#program-accounts): Akun yang berisi kode yang dapat
  dieksekusi
- [Data accounts](#data-accounts): Akun yang tidak berisi kode yang dapat
  dieksekusi

Pemisahan ini berarti bahwa kode program yang dapat dieksekusi dan statusnya
disimpan dalam akun terpisah. (Mirip dengan sistem operasi, yang biasanya
memiliki file terpisah untuk program dan data mereka.)

### Program accounts

Setiap program dimiliki oleh
[loader program](/docs/core/programs#loader-programs), yang digunakan untuk
menerapkan dan mengelola akun. Ketika [program](/docs/core/programs) baru
diterapkan, sebuah akun dibuat untuk menyimpan kode
[executable](#executable)-nya. Ini disebut program account. (Untuk
menyederhanakan, Anda dapat menganggap program account sebagai program itu
sendiri.)

Dalam diagram di bawah, Anda dapat melihat loader program digunakan untuk
menerapkan program account. Bidang `data` program account berisi kode program
yang dapat dieksekusi.

![Diagram akun program, 4 komponennya dan program loader-nya.](/assets/docs/core/accounts/program-account-simple.svg)

#### Akun data program

Program yang diterapkan menggunakan loader-v3 tidak berisi kode program di
bidang data mereka. Sebaliknya, data mereka menunjuk ke **akun data program**
terpisah, yang berisi kode program. (Lihat diagram di bawah.)

![Akun program dengan data. Data tersebut menunjuk ke akun data program terpisah](/assets/docs/core/accounts/program-account-expanded.svg)

<Callout>
  Selama penerapan atau peningkatan program, akun buffer digunakan untuk
  sementara menyiapkan unggahan.
</Callout>

Contoh di bawah ini mengambil akun Token Program. Perhatikan bahwa bidang
executable diatur ke true, menunjukkan akun tersebut adalah program.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const programId = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address;

const accountInfo = await rpc
  .getAccountInfo(programId, { encoding: "base64" })
  .send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Connection, PublicKey } from "@solana/web3.js";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const programId = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

const accountInfo = await connection.getAccountInfo(programId);
// !collapse(1:17) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::pubkey;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let program_id = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let account_info = connection.get_account(&program_id).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

### Akun data

Akun data tidak berisi kode yang dapat dieksekusi. Sebaliknya, mereka menyimpan
informasi.

#### Akun state program

Program menggunakan akun data untuk mempertahankan state mereka. Untuk
melakukannya, mereka harus terlebih dahulu membuat akun data baru. Proses
pembuatan akun state program sering diabstraksikan, tetapi penting untuk
memahami proses yang mendasarinya.

Untuk mengelola state-nya, program baru harus:

1. Memanggil [System Program](/docs/core/programs#the-system-program) untuk
   membuat akun. (System Program kemudian mentransfer kepemilikan ke program
   baru.)
2. Menginisialisasi data akun, sebagaimana didefinisikan oleh
   [instruksi](/docs/core/instructions)-nya.

![Diagram akun data yang dimiliki oleh akun program](/assets/docs/core/accounts/data-account.svg)

Contoh di bawah ini membuat dan mengambil akun Token Mint yang dimiliki oleh
program Token 2022.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  fetchMint
} from "@solana-program/token-2022";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer
const feePayer = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Instruction to create new account for mint (token 2022 program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token 2022 program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address
});

const instructions = [createAccountInstruction, initializeMintInstruction];

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }), // Create transaction message
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx), // Set fee payer
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set transaction blockhash
  (tx) => appendTransactionMessageInstructions(instructions, tx) // Append instructions
);

// Sign transaction message with required signers (fee payer and mint keypair)
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Mint Address:", mint.address);
console.log("Transaction Signature:", transactionSignature);

const accountInfo = await rpc.getAccountInfo(mint.address).send();
console.log(accountInfo);

const mintAccount = await fetchMint(rpc, mint.address);
console.log(mintAccount);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  TOKEN_2022_PROGRAM_ID,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const recentBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: recentBlockhash.blockhash,
  lastValidBlockHeight: recentBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Generate keypair to use as address of mint
const mint = Keypair.generate();

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: await getMinimumBalanceForRentExemptMint(connection),
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);

const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint] // Signers
);

console.log("Mint Address: ", mint.publicKey.toBase58());
console.log("Transaction Signature: ", transactionSignature);

const accountInfo = await connection.getAccountInfo(mint.publicKey);

// !collapse(1:16) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);

const mintAccount = await getMint(
  connection,
  mint.publicKey,
  "confirmed",
  TOKEN_2022_PROGRAM_ID
);
console.log(mintAccount);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    program_pack::Pack,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_token_2022_interface::{
    id as token_2022_program_id, instruction::initialize_mint, state::Mint,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let recent_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    let space = Mint::LEN;
    let rent = client.get_minimum_balance_for_rent_exemption(space).await?;

    // Create account instruction
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),      // fee payer
        &mint.pubkey(),           // mint address
        rent,                     // rent
        space as u64,             // space
        &token_2022_program_id(), // program id
    );

    // Initialize mint instruction
    let initialize_mint_instruction = initialize_mint(
        &token_2022_program_id(),
        &mint.pubkey(),            // mint address
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        9,                         // decimals
    )?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        recent_blockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    let account_info = client.get_account(&mint.pubkey()).await?;
    println!("{:#?}", account_info);

    let mint_account = Mint::unpack(&account_info.data)?;
    println!("{:#?}", mint_account);

    Ok(())
}
```

</CodeTabs>

#### Akun sistem

Tidak semua akun ditetapkan pemilik baru setelah dibuat oleh System Program.
Akun yang dimiliki oleh System Program disebut akun sistem. Semua akun dompet
adalah akun sistem, yang memungkinkan mereka membayar
[biaya transaksi](docs/core/fees).

![Dompet yang dimiliki oleh System Program berisi 1.000.000 lamports](/assets/docs/core/accounts/system-account.svg)

Ketika SOL dikirim ke alamat baru untuk pertama kalinya, sebuah akun dibuat di
alamat tersebut yang dimiliki oleh System Program.

Dalam contoh di bawah ini, sebuah keypair baru dibuat dan didanai dengan SOL.
Setelah menjalankan kode, Anda dapat melihat alamat dari `owner` akun tersebut
adalah `11111111111111111111111111111111`
([System Program](/docs/core/programs#the-system-program)).

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  generateKeyPairSigner,
  lamports
} from "@solana/kit";

// Create a connection to Solana cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate a new keypair
const keypair = await generateKeyPairSigner();
console.log(`Public Key: ${keypair.address}`);

// Funding an address with SOL automatically creates an account
const signature = await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: keypair.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

const accountInfo = await rpc.getAccountInfo(keypair.address).send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";

// Generate a new keypair
const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);

// Create a connection to the Solana cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Funding an address with SOL automatically creates an account
const signature = await connection.requestAirdrop(
  keypair.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const accountInfo = await connection.getAccountInfo(keypair.publicKey);
console.log(JSON.stringify(accountInfo, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signer::{keypair::Keypair, Signer},
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate a new keypair
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());

    // Create a connection to Solana cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Funding an address with SOL automatically creates an account
    let signature = connection
        .request_airdrop(&keypair.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = connection.confirm_transaction(&signature).await?;
        if confirmed {
            break;
        }
    }

    let account_info = connection.get_account(&keypair.pubkey()).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

#### Akun Sysvar

Akun Sysvar ada di alamat yang telah ditentukan sebelumnya dan menyediakan akses
ke data status cluster. Mereka diperbarui secara dinamis dengan data tentang
cluster jaringan. Lihat daftar lengkap
[Akun Sysvar](https://docs.anza.xyz/runtime/sysvars).

Contoh di bawah ini mengambil dan mendeserialkan data dari akun Sysvar Clock.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { createSolanaRpc } from "@solana/kit";
import { fetchSysvarClock, SYSVAR_CLOCK_ADDRESS } from "@solana/sysvars";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const accountInfo = await rpc
  .getAccountInfo(SYSVAR_CLOCK_ADDRESS, { encoding: "base64" })
  .send();
console.log(accountInfo);

// Automatically fetch and deserialize the account data
const clock = await fetchSysvarClock(rpc);
console.log(clock);
```

```ts !! title="Legacy"
import { Connection, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getSysvarClockCodec } from "@solana/sysvars";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const accountInfo = await connection.getAccountInfo(SYSVAR_CLOCK_PUBKEY);

// Deserialize the account data
const decodedClock = getSysvarClockCodec().decode(
  new Uint8Array(accountInfo?.data ?? [])
);
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
console.log(decodedClock);
```

```rs !! title="Rust"
use anyhow::Result;
use bincode::deserialize;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::sysvar::{self, clock::Clock};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let account = connection.get_account(&sysvar::clock::ID).await?;
    // Deserialize the account data
    let clock: Clock = deserialize(&account.data)?;

    println!("{:#?}", account);
    println!("{:#?}", clock);

    Ok(())
}
```

</CodeTabs>
