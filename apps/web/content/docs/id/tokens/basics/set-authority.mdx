---
title: Mengatur Authority
description: Pelajari cara mengatur authority untuk mint atau token account.
---

## Memahami Token Authorities

### Mint Account Authorities

- **Mint Authority**: Mengontrol pembuatan token baru. Dapat mencetak token ke
  token account mana pun. Sering dicabut setelah pasokan awal dibuat untuk
  menciptakan token dengan pasokan tetap.
- **Freeze Authority**: Mengontrol kemampuan untuk membekukan dan mencairkan
  token account. Dapat mencegah token account mentransfer token. Sering dicabut
  untuk menjamin pengguna bahwa token mereka tidak dapat dibekukan.

### Token Account Authorities

- **Account Owner**: Memiliki kendali penuh atas token account. Dapat
  mentransfer token, membakar token, menyetujui delegasi, dan menutup akun
  ketika saldo nol.
- **Close Authority**: Dapat menutup token account ketika saldonya nol. Secara
  default, ini adalah pemilik akun tetapi dapat didelegasikan ke akun lain.

## Cara mengatur authority

Instruksi
[`SetAuthority`](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/program/src/instruction.rs#L153)
mengubah atau mencabut authority pada mint dan token account. Hanya authority
saat ini yang dapat mentransfer izin mereka ke alamat baru atau mencabutnya
secara permanen dengan mengatur authority ke null. Setelah dicabut, authority
tidak dapat dipulihkan.

<Callout type="info">
  [Token
  Program](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/program/src/instruction.rs#L153)
  dan [Token Extension
  Program](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/instruction.rs#L195)
  berbagi implementasi serupa untuk mencapai fungsionalitas yang sama.
</Callout>

### Typescript

<CodeTabs storage="token-ts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_PROGRAM_ADDRESS,
  findAssociatedTokenPda,
  getCreateAssociatedTokenInstructionAsync,
  getSetAuthorityInstruction,
  AuthorityType
} from "@solana-program/token";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer and new authority
const feePayer = await generateKeyPairSigner();
const newAuthority = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Instruction to create new account for mint (token program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address,
  freezeAuthority: feePayer.address
});

// Use findAssociatedTokenPda to derive the ATA address
const [associatedTokenAddress] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: feePayer.address,
  tokenProgram: TOKEN_PROGRAM_ADDRESS
});

// Create instruction to create the associated token account
const createAtaInstruction = await getCreateAssociatedTokenInstructionAsync({
  payer: feePayer,
  mint: mint.address,
  owner: feePayer.address
});

const instructions = [
  createAccountInstruction,
  initializeMintInstruction,
  createAtaInstruction
];

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions(instructions, tx)
);

// Sign transaction message with all required signers
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("\nMint Address:", mint.address.toString());
console.log("New Authority Address:", newAuthority.address.toString());
console.log(
  "Associated Token Account Address:",
  associatedTokenAddress.toString()
);
console.log("\nTransaction Signature:", transactionSignature);

// Get a fresh blockhash for the authority change transaction
const { value: authorityBlockhash } = await rpc.getLatestBlockhash().send();

// 1. Change Mint Authority (MintTokens)
const setMintAuthorityIx = getSetAuthorityInstruction({
  owned: mint.address,
  owner: feePayer,
  authorityType: AuthorityType.MintTokens,
  newAuthority: newAuthority.address
});

// 2. Change Freeze Authority (FreezeAccount)
const setFreezeAuthorityIx = getSetAuthorityInstruction({
  owned: mint.address,
  owner: feePayer,
  authorityType: AuthorityType.FreezeAccount,
  newAuthority: newAuthority.address
});

// Create transaction message for authority changes
const authorityTxMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(authorityBlockhash, tx),
  (tx) =>
    appendTransactionMessageInstructions(
      [setMintAuthorityIx, setFreezeAuthorityIx],
      tx
    )
);

// Sign transaction message with all required signers
const signedAuthorityTx =
  await signTransactionMessageWithSigners(authorityTxMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedAuthorityTx,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature2 = getSignatureFromTransaction(signedAuthorityTx);

console.log("\nSuccessfully changed mint and freeze authorities");
console.log("Transaction Signature:", transactionSignature2);

// Get a fresh blockhash for the revoke transaction
const { value: revokeBlockhash } = await rpc.getLatestBlockhash().send();

// 3. Example of revoking authority (setting to null)
const revokeMintAuthorityIx = getSetAuthorityInstruction({
  owned: mint.address,
  owner: newAuthority,
  authorityType: AuthorityType.MintTokens,
  newAuthority: null
});

// Create transaction message for revoking
const revokeTxMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(revokeBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([revokeMintAuthorityIx], tx)
);

// Sign transaction message with all required signers (newAuthority needs to sign)
const signedRevokeTx = await signTransactionMessageWithSigners(revokeTxMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedRevokeTx,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature3 = getSignatureFromTransaction(signedRevokeTx);

console.log("\nSuccessfully revoked mint authority");
console.log("Transaction Signature:", transactionSignature3);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  TOKEN_PROGRAM_ID,
  getAssociatedTokenAddressSync,
  createAssociatedTokenAccountInstruction,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  createSetAuthorityInstruction,
  AuthorityType
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const latestBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Generate a new keypair for the new authority
const newAuthority = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Generate keypair to use as address of mint
const mint = Keypair.generate();

// Get minimum balance for rent exemption
const mintRent = await getMinimumBalanceForRentExemptMint(connection);

// Get the associated token account address
const associatedTokenAccount = getAssociatedTokenAddressSync(
  mint.publicKey,
  feePayer.publicKey,
  false, // allowOwnerOffCurve
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID
);

// Create account instruction
const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: mintRent,
  programId: TOKEN_PROGRAM_ID
});

// Initialize mint instruction
const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_PROGRAM_ID
);

// Create associated token account instruction
const createAssociatedTokenAccountIx = createAssociatedTokenAccountInstruction(
  feePayer.publicKey, // payer
  associatedTokenAccount, // associated token account address
  feePayer.publicKey, // owner
  mint.publicKey, // mint
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID
);

// Create and sign transaction with mint creation and ATA creation
const transaction = new Transaction({
  feePayer: feePayer.publicKey,
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight
}).add(
  createAccountInstruction,
  initializeMintInstruction,
  createAssociatedTokenAccountIx
);

// Sign transaction
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint]
);

console.log("\nMint Address:", mint.publicKey.toBase58());
console.log("New Authority Address:", newAuthority.publicKey.toBase58());
console.log(
  "Associated Token Account Address:",
  associatedTokenAccount.toBase58()
);
console.log("\nTransaction Signature:", transactionSignature);

// Get a new blockhash for the authority change transaction
const authorityBlockhash = await connection.getLatestBlockhash();

// 1. Change Mint Authority (MintTokens)
const setMintAuthorityIx = createSetAuthorityInstruction(
  mint.publicKey, // mint account
  feePayer.publicKey, // current authority
  AuthorityType.MintTokens, // authority type
  newAuthority.publicKey, // new authority
  TOKEN_PROGRAM_ID
);

// 2. Change Freeze Authority (FreezeAccount)
const setFreezeAuthorityIx = createSetAuthorityInstruction(
  mint.publicKey, // mint account
  feePayer.publicKey, // current authority
  AuthorityType.FreezeAccount, // authority type
  newAuthority.publicKey, // new authority
  TOKEN_PROGRAM_ID
);

// Create and sign transaction for authority changes
const authorityTransaction = new Transaction({
  feePayer: feePayer.publicKey,
  blockhash: authorityBlockhash.blockhash,
  lastValidBlockHeight: authorityBlockhash.lastValidBlockHeight
}).add(setMintAuthorityIx, setFreezeAuthorityIx);

// Sign and send authority transaction
const transactionSignature2 = await sendAndConfirmTransaction(
  connection,
  authorityTransaction,
  [feePayer]
);

console.log("\nSuccessfully changed mint and freeze authorities");
console.log("Transaction Signature:", transactionSignature2);

// Get a new blockhash for the revoke transaction
const revokeBlockhash = await connection.getLatestBlockhash();

// 3. Example of revoking authority (setting to null)
const revokeMintAuthorityIx = createSetAuthorityInstruction(
  mint.publicKey, // mint account
  newAuthority.publicKey, // current authority (newAuthority is now the authority)
  AuthorityType.MintTokens, // authority type
  null, // new authority (null to revoke)
  TOKEN_PROGRAM_ID
);

// Create and sign transaction for revoking
const revokeTransaction = new Transaction({
  feePayer: feePayer.publicKey,
  blockhash: revokeBlockhash.blockhash,
  lastValidBlockHeight: revokeBlockhash.lastValidBlockHeight
}).add(revokeMintAuthorityIx);

// Sign and send revoke transaction
const transactionSignature3 = await sendAndConfirmTransaction(
  connection,
  revokeTransaction,
  [feePayer, newAuthority] // newAuthority needs to sign
);

console.log("\nSuccessfully revoked mint authority");
console.log("Transaction Signature:", transactionSignature3);
```

```ts !! title="Legacy Helper"
import { Connection, Keypair, LAMPORTS_PER_SOL } from "@solana/web3.js";
import {
  createMint,
  createAssociatedTokenAccount,
  setAuthority,
  AuthorityType,
  TOKEN_PROGRAM_ID
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const latestBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Generate a new keypair for the new authority
const newAuthority = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Create mint using helper function
const mintPubkey = await createMint(
  connection, // connection
  feePayer, // fee payer
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  9, // decimals
  Keypair.generate(), // keypair (optional)
  {
    commitment: "confirmed" // confirmation options
  },
  TOKEN_PROGRAM_ID // program id
);
console.log("\nMint Address:", mintPubkey.toBase58());

// Create associated token account using helper function
const associatedTokenAccount = await createAssociatedTokenAccount(
  connection, // connection
  feePayer, // fee payer
  mintPubkey, // mint
  feePayer.publicKey, // owner
  {
    commitment: "confirmed" // confirmation options
  },
  TOKEN_PROGRAM_ID // program id
);
console.log(
  "\nAssociated Token Account Address:",
  associatedTokenAccount.toBase58()
);
console.log("New Authority Address:", newAuthority.publicKey.toBase58());

// 1. Change Mint Authority (MintTokens)
const setMintAuthoritySignature = await setAuthority(
  connection,
  feePayer,
  mintPubkey,
  feePayer, // Current authority
  AuthorityType.MintTokens,
  newAuthority.publicKey, // New authority
  [],
  {
    commitment: "confirmed"
  },
  TOKEN_PROGRAM_ID
);

console.log("\nSuccessfully changed mint authority");
console.log("Transaction Signature:", setMintAuthoritySignature);

// 2. Change Freeze Authority (FreezeAccount)
const setFreezeAuthoritySignature = await setAuthority(
  connection,
  feePayer,
  mintPubkey,
  feePayer, // Current authority
  AuthorityType.FreezeAccount,
  newAuthority.publicKey, // New authority
  [],
  {
    commitment: "confirmed"
  },
  TOKEN_PROGRAM_ID
);

console.log("\nSuccessfully changed freeze authority");
console.log("Transaction Signature:", setFreezeAuthoritySignature);

// 3. Example of revoking authority (setting to null)
const revokeMintAuthoritySignature = await setAuthority(
  connection,
  feePayer,
  mintPubkey,
  newAuthority, // Current authority (newAuthority is now the authority)
  AuthorityType.MintTokens,
  null, // New authority (null to revoke)
  [],
  {
    commitment: "confirmed"
  },
  TOKEN_PROGRAM_ID
);

console.log("\nSuccessfully revoked mint authority");
console.log("Transaction Signature:", revokeMintAuthoritySignature);

// 4. Example of changing close authority of token account
const setCloseAuthoritySignature = await setAuthority(
  connection,
  feePayer,
  associatedTokenAccount,
  feePayer, // Current authority
  AuthorityType.CloseAccount,
  newAuthority.publicKey, // New authority
  [],
  {
    commitment: "confirmed"
  },
  TOKEN_PROGRAM_ID
);

console.log("\nSuccessfully set close authority");
console.log("Transaction Signature:", setCloseAuthoritySignature);
```

</CodeTabs>

### Rust

<CodeTabs storage="token-rs" flags="r">

```rust !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    program_pack::Pack,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_token_interface::{
    id as token_program_id,
    instruction::{initialize_mint, set_authority, AuthorityType},
    state::Mint,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let latest_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Generate a new keypair for the new authority
    let new_authority = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    // Number of decimals for the mint
    let decimals = 2;

    // Get default mint account size (in bytes), no extensions enabled
    let mint_space = Mint::LEN;
    let mint_rent = client
        .get_minimum_balance_for_rent_exemption(mint_space)
        .await?;

    // Instruction to create new account for mint (token program)
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), // payer
        &mint.pubkey(),      // new account (mint)
        mint_rent,           // lamports
        mint_space as u64,   // space
        &token_program_id(), // program id
    );

    // Instruction to initialize mint account data
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(),            // mint
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        decimals,                  // decimals
    )?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latest_blockhash,
    );

    // Send and confirm transaction
    client.send_and_confirm_transaction(&transaction).await?;

    let mint_account = client.get_account(&mint.pubkey()).await?;
    let mint_data = Mint::unpack(&mint_account.data)?;

    println!("Mint Address: {}", mint.pubkey());
    println!("{:#?}", mint_data);

    // 1. Change Mint Authority (MintTokens)
    let set_mint_authority_ix = set_authority(
        &token_program_id(),           // program id
        &mint.pubkey(),                // mint account
        Some(&new_authority.pubkey()), // new authority
        AuthorityType::MintTokens,     // authority type
        &fee_payer.pubkey(),           // current authority
        &[&fee_payer.pubkey()],        // signers
    )?;

    // 2. Change Freeze Authority (FreezeAccount)
    let set_freeze_authority_ix = set_authority(
        &token_program_id(),           // program id
        &mint.pubkey(),                // mint account
        Some(&new_authority.pubkey()), // new authority
        AuthorityType::FreezeAccount,  // authority type
        &fee_payer.pubkey(),           // current authority
        &[&fee_payer.pubkey()],        // signers
    )?;

    // Create transaction for authority changes
    let transaction = Transaction::new_signed_with_payer(
        &[set_mint_authority_ix, set_freeze_authority_ix],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        latest_blockhash,
    );

    // Send and confirm transaction
    client.send_and_confirm_transaction(&transaction).await?;

    let mint_account = client.get_account(&mint.pubkey()).await?;
    let mint_data = Mint::unpack(&mint_account.data)?;
    println!("\nMint and Freeze Authorities Updated");
    println!("{:#?}", mint_data);

    // 3. Example of revoking authority (setting to null)
    let revoke_mint_authority_ix = set_authority(
        &token_program_id(),        // program id
        &mint.pubkey(),             // mint account
        None,                       // new authority (None to revoke)
        AuthorityType::MintTokens,  // authority type
        &new_authority.pubkey(),    // current authority
        &[&new_authority.pubkey()], // signers
    )?;

    // Create transaction for revoking
    let transaction = Transaction::new_signed_with_payer(
        &[revoke_mint_authority_ix],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &new_authority], // new_authority needs to sign
        latest_blockhash,
    );

    // Send and confirm transaction
    client.send_and_confirm_transaction(&transaction).await?;

    let mint_account = client.get_account(&mint.pubkey()).await?;
    let mint_data = Mint::unpack(&mint_account.data)?;
    println!("\nMint Authority Revoked");
    println!("{:#?}", mint_data);

    Ok(())
}
```

</CodeTabs>

### Python

<CodeTabs flags="r">

```py !! title="Python"
#!/usr/bin/env python3

import asyncio
from solana.rpc.async_api import AsyncClient
from solders.keypair import Keypair
from solders.pubkey import Pubkey
from solders.transaction import VersionedTransaction
from solders.message import MessageV0
from spl.token.instructions import set_authority, SetAuthorityParams
from spl.token.constants import TOKEN_PROGRAM_ID
from spl.token.instructions import AuthorityType

async def main():
    rpc = AsyncClient("http://localhost:8899")

    # Example keypairs and addresses
    payer = Keypair()
    current_authority = Keypair()
    new_authority = Keypair()
    mint_or_account = Pubkey.from_string("4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU")

    async with rpc:
        # Set new mint authority
        set_mint_authority_instruction = set_authority(
            SetAuthorityParams(
                program_id=TOKEN_PROGRAM_ID,
                account=mint_or_account,
                authority=AuthorityType.MINT_TOKENS,
                current_authority=current_authority.pubkey(),
                new_authority=new_authority.pubkey()
            )
        )

        # Get latest blockhash
        recent_blockhash = await rpc.get_latest_blockhash()

        # Create message
        message = MessageV0.try_compile(
            payer=payer.pubkey(),
            instructions=[set_mint_authority_instruction],
            address_lookup_table_accounts=[],
            recent_blockhash=recent_blockhash.value.blockhash
        )

        # Create transaction
        transaction = VersionedTransaction(message, [payer, current_authority])

        print(f"Account/Mint: {mint_or_account}")
        print(f"Current Authority: {current_authority.pubkey()}")
        print(f"New Authority: {new_authority.pubkey()}")
        print(f"Authority Type: MintTokens")
        print(f"Payer: {payer.pubkey()}")
        print(f"Set authority transaction created successfully")

async def set_freeze_authority_example():
    """Example of setting freeze authority"""
    rpc = AsyncClient("http://localhost:8899")

    payer = Keypair()
    current_authority = Keypair()
    new_authority = Keypair()
    mint_address = Pubkey.from_string("4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU")

    async with rpc:
        # Set freeze authority
        set_freeze_authority_instruction = set_authority(
            SetAuthorityParams(
                program_id=TOKEN_PROGRAM_ID,
                account=mint_address,
                authority=AuthorityType.FREEZE_ACCOUNT,
                current_authority=current_authority.pubkey(),
                new_authority=new_authority.pubkey()
            )
        )

        recent_blockhash = await rpc.get_latest_blockhash()
        message = MessageV0.try_compile(
            payer=payer.pubkey(),
            instructions=[set_freeze_authority_instruction],
            address_lookup_table_accounts=[],
            recent_blockhash=recent_blockhash.value.blockhash
        )

        transaction = VersionedTransaction(message, [payer, current_authority])

        print(f"\nFreeze Authority Example:")
        print(f"Mint: {mint_address}")
        print(f"Current Freeze Authority: {current_authority.pubkey()}")
        print(f"New Freeze Authority: {new_authority.pubkey()}")
        print(f"Set freeze authority transaction created successfully")

if __name__ == "__main__":
    asyncio.run(main())
    asyncio.run(set_freeze_authority_example())
```

</CodeTabs>
