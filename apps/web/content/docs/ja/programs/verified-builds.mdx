---
title: プログラムの検証
description: 検証済みビルドは、プログラムをそのソースコードにリンクし、提供されたソースコードからプログラムが確かに構築されたことを誰もが独自に検証できるようにする方法です。
---

このガイドは、Solana上でプログラムの検証済みビルドを実装したい開発者向けのリファレンスです。検証済みビルドとは何か、その使用方法、特別な考慮事項、およびオンチェーンでのプログラムの信頼性を確保するためのベストプラクティスについて説明します。

# 検証済みビルドとは何ですか？

検証済みビルドは、Solanaネットワークにデプロイする実行可能なプログラムが、リポジトリ内のソースコードと一致することを保証します。これにより、開発者とユーザーは、オンチェーンで実行されているプログラムが公開されているコードベースと完全に一致していることを確信でき、透明性とセキュリティを促進します。

検証プロセスでは、オンチェーンプログラムのハッシュとソースコードからローカルでビルドされたプログラムのハッシュを比較します。これにより、2つのバージョン間に相違がないことが保証されます。

> 検証済みビルドは未検証のビルドよりも安全であるとは限りませんが、ビルドによって開発者はソースコードがオンチェーンにデプロイされたものと一致することを自己検証できます。ソースコードを使用して、開発者はトランザクションを送信する際にコードが実行する内容を検証できます。

検証済みビルドのパイプラインは[Ellipsis Labs](https://ellipsislabs.xyz/)と[OtterSec](https://osec.io/)によって考案され、維持されています。詳細については、[オリジナルの検証済みビルド](https://github.com/Ellipsis-Labs/solana-verifiable-build)リポジトリのガイドに従い、また検証ビルドプロセスを[Anza](https://www.anza.xyz/)ツールスイートに直接組み込んでください（サポートされた場合）。

# どのように機能しますか？

検証プロセスは、オンチェーンプログラムのハッシュとソースコードからローカルでビルドされたプログラムのハッシュを比較することで行われます。Solana
Verify
CLIとDockerを使用して、制御された環境でプログラムをビルドします。これにより、ビルドプロセスが決定論的になり、異なるシステム間で一貫性が保たれます。実行可能ファイルができたら、Solanaネットワークにデプロイできます。ビルドプロセス中に[verify program](https://github.com/otter-sec/otter-verify)の[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)が作成されます。このPDAにはプログラムを検証するために必要なすべてのデータが含まれています。PDAにはプログラムアドレス、gitのURL、コミットハッシュ、およびプログラムをビルドするために使用された引数が含まれています。

PDAのデータを使用して、誰でもローカルで検証プログラムコマンドを実行し、プログラムが提供されたソースコードからビルドされたかどうかを確認できます。その後、完全に信頼性を確保しながら自分自身で検証したり、[OtterSec](https://github.com/otter-sec)が維持している独自の[verify API](https://github.com/otter-sec/solana-verified-programs-api)を実行して、ユーザーが検証を簡単に確認できるアクセスポイントを提供することができます。これらの[APIコール](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)は、[Solana Explorer](https://explorer.solana.com/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/verified-build)や[SolanaFM](https://solana.fm/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/transactions?cluster=mainnet-alpha)など、さまざまな場所ですでに使用されています。

# 検証済みビルドを使用する理由

検証済みビルドを使用すると、以下のメリットがあります：

- セキュリティ：オンチェーンで実行されているプログラムがソースコードと一致することを保証し、悪意のある改変を防止します。

- 透明性：他のユーザーや開発者が、オンチェーンプログラムを公開コードベースと比較することで、信頼性を検証できるようにします。

- 信頼：検証済みビルドはプログラムのオンチェーン動作が公開コードと一致していることを示すため、ユーザーの信頼を高めます。検証可能なプログラムを構築することで、不正または悪意のあるコードの実行に関連するリスクを最小限に抑えることができます。また、ベストプラクティスに準拠し、セキュリティ研究者が簡単に連絡できる方法を提供することも保証します。さらに、ウォレットやその他のツールは、プログラムが検証されている限り、そのプログラムからのトランザクションをより簡単に許可することができます。

- 発見可能性：プログラムの検証済みビルドを提供すると、誰でもソースコード、ドキュメント、プログラムSDKまたはIDLを見つけることができ、問題がある場合はGitHubを通じて簡単に連絡を取ることができます。

# 検証済みビルドを作成するにはどうすればよいですか？

検証済みビルドを作成するには、次の手順に従う必要があります：

概要：

- コードを公開リポジトリにコミットする
- Dockerで検証済みビルドを構築する
- 検証済みビルドをデプロイする
- デプロイされたプログラムを公開APIに対して検証する

Dockerコンテナ内で構築されていないプログラムを検証しようとすると、Solanaプログラムのビルドは異なるシステム間で決定論的ではないため、ほとんどの場合失敗します。

<Steps>
<Step>

### DockerとCargoのインストール

必要なツールをインストールし、DockerとCargoがインストールされていることを確認してください。Dockerは一貫性を確保するための制御された構築環境を提供し、CargoはRustパッケージの管理に使用されます。

- Docker：[Dockerウェブサイト](https://docs.docker.com/engine/install/)の手順に従って、お使いのプラットフォーム用のDockerをインストールしてください。インストール後、このガイドに従ってDockerサービスが実行されていることを確認してください。
- Cargo：まだCargoがインストールされていない場合は、次のコマンドを実行してインストールできます：

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

</Step>
<Step>

### Solana Verify CLIのインストール

Solana Verify CLIは、ビルドを検証するために使用される主要なツールです。Solana
Verify
CLIは現在[Ellipsis Labs](https://ellipsislabs.xyz/)によって維持されており、Cargoを使用してインストールできます。

次のコマンドを実行してインストールできます：

```bash
cargo install solana-verify
```

CLIの特定のバージョンが必要な場合は、バージョンを固定できます：

```bash
cargo install solana-verify --version $VERSION
```

必要に応じて、特定のコミットから直接バージョンをインストールすることもできます：

```bash
cargo install solana-verify --git https://github.com/Ellipsis-Labs/solana-verifiable-build --rev 13a1db2
```

</Step>
<Step>

### プロジェクトの準備

リポジトリに対して検証するには、リポジトリのルートディレクトリに `Cargo.lock`
ファイルが必要です。リポジトリに1つのプログラムしかなく、ルートに `cargo.lock`
ファイルがある場合は、次のステップに直接進んでプログラムをビルドできます。

プログラムがサブフォルダにあり、Rustワークスペースを使用している場合は、リポジトリのルートディレクトリにワークスペース
`Cargo.toml` ファイルを作成する必要があります。

このような `Cargo.toml` の例をプリセットとして使用できます：

```toml title="Cargo.toml"
[workspace]
members = ["program/programs/*"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1

[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
```

プログラムが `workspace/members` 配列に含まれていること、およびプログラムの
`Cargo.toml` に正しい `lib` 名が設定されていることを確認してください。

> 重要なのはパッケージ名ではなく `lib name` です！

次のような感じです：

```toml title="waffle/Cargo.toml"
[package]
name = "waffle"
version = "0.1.0"
edition = "2021"

[lib]
name = "waffle"
crate-type = ["cdylib", "lib"]

[dependencies]
solana-program = "2.1.0"
```

この[リポジトリ](https://github.com/solana-developers/verified-program)では、サブフォルダにプログラムがあるワークスペースの例を見ることができます。また、プログラムがサブフォルダにある場合、後でこのフォルダを
`--mount-path` として `verify-from-repo`
コマンドに追加する必要があることにも注意してください。

この[リポジトリ](https://github.com/solana-developers/solana-game-preset)ではAnchorの例を見つけることができます。この[リポジトリ](https://github.com/solana-developers/verified-program-root)ではネイティブRustの例を見つけることができます。

この `Cargo.toml` ファイルを配置したら、`cargo generate-lockfile`
を実行してロックファイルを作成し、プログラムのビルドに進むことができます。

</Step>
<Step>

### 検証可能なプログラムのビルド

Solanaプログラムを検証可能な方法でビルドするには、ワークスペースの `Cargo.toml`
ファイルを含むディレクトリに移動し、次のコマンドを実行します：

```bash
solana-verify build
```

これにより、環境がDockerコンテナにコピーされ、決定論的な方法でビルドされます。

> 実際に検証済みのビルドをデプロイし、`anchor build` や `cargo build-sbf`
> で誤って上書きしないようにしてください。これらは同じハッシュを生成しない可能性が高く、検証が失敗することになります。

複数のプログラムを持つプロジェクトでは、ライブラリ名（パッケージ名ではない）を使用して特定のプログラムをビルドできます：

```bash
solana-verify build --library-name $PROGRAM_LIB_NAME
```

このプロセスは決定論的なビルドを保証しますが、特に特定のシステム（例：M1
MacBook）ではDockerコンテナ内で実行されるため、時間がかかることがあります。より速いビルドのためには、x86アーキテクチャを実行しているLinuxマシンの使用が推奨されます。

ビルドが完了したら、次のコマンドを使用して実行可能ファイルのハッシュを取得できます：

```bash
solana-verify get-executable-hash target/deploy/$PROGRAM_LIB_NAME.so
```

</Step>
<Step>

### 検証可能なプログラムのデプロイ

プログラムをビルドしてハッシュを取得したら、Solanaネットワークにデプロイできます。安全なデプロイのためには、[Squads Protocol](https://squads.so/protocol)のようなマルチシグネチャやガバナンスソリューションを使用することが推奨されますが、以下のように直接デプロイすることもできます：

```bash
solana program deploy -u $NETWORK_URL target/deploy/$PROGRAM_LIB_NAME.so --program-id $PROGRAM_ID --with-compute-unit-price 50000 --max-sign-attempts 100 --use-rpc
```

現在適切な低優先度の手数料は、例えば[Quicknode](https://www.quicknode.com/gas-tracker/solana)などのRPCプロバイダーから取得できます。

デプロイされたプログラムがビルドされた実行可能ファイルと一致することを確認するには、次のコマンドを実行します：

```bash
solana-verify get-program-hash -u $NETWORK_URL $PROGRAM_ID
```

> 異なるバージョンが異なる[Solanaクラスター](/docs/references/clusters)（つまり、devnet、testnet、mainnet）にデプロイされている場合があります。検証したいSolanaクラスターに対して正しいネットワークURLを使用していることを確認してください。リモート検証はメインネットでのみ機能します。

</Step>
<Step>

### リポジトリに対する検証

公開リポジトリに対してプログラムを検証するには、次のコマンドを使用します：

```bash
solana-verify verify-from-repo -u $NETWORK_URL --program-id $PROGRAM_ID https://github.com/$REPO_PATH --commit-hash $COMMIT_HASH --library-name $PROGRAM_LIB_NAME --mount-path $MOUNT_PATH
```

> プログラムディレクトリで検証済みビルドを実行する場合、`verify-from-repo`
> を実行する際には `--mount-path`
> フラグを追加する必要があります。これはプログラムのライブラリ名を含む
> `Cargo.toml` を含むフォルダへのパスになります。

このコマンドは、オンチェーンのプログラムハッシュと指定されたコミットハッシュのソースからビルドされた実行可能ファイルのハッシュを比較します。

コマンドの最後に、検証データをオンチェーンにアップロードするかどうか尋ねられます。アップロードすると、Solana
Explorerがすぐにプログラムの検証データを表示します。リモートビルドによって検証されるまでは、未検証として表示されます。次のステップでは、公開APIに対してプログラムを検証する方法について学びます。

特定のリリースに検証をロックしたい場合は、コマンドに `--commit-hash`
フラグを追加できます。

</Step>
<Step>

### 公開APIに対して検証する

最後に、検証APIを実行している誰に対しても直接プログラムを検証することができます：

```bash
solana-verify verify-from-repo --remote -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

> 無料RPCのレート制限に引っかかる可能性があるため、有料のRPC
> URLを使用することをお勧めします。そのため、`-um`
> の代わりに、より信頼性の高い検証のために `--url yourRpcUrl` を使用すべきです。

`--remote` フラグはOtterSec
APIにビルドリクエストを送信し、プログラムのリモートビルドをトリガーします。ビルドが完了すると、システムはプログラムのオンチェーンハッシュがリポジトリから生成されたビルド成果物のハッシュと一致することを検証します。

デフォルトは[OtterSec API](https://github.com/otter-sec/solana-verified-programs-api)です。

検証データをオンチェーンにアップロードするかどうか尋ねられたら、必ず「はい」を選択してください。これはAPIがあなたが検証データをアップロードしたことを確認するために使用されます。

以下のコマンドを使用して、手動でリモートジョブをトリガーすることもできます：

```bash
solana-verify remote submit-job --program-id <program-id> --uploader <address>
```

アップローダーはPDAに書き込む権限を持つアドレスです。ほとんどの場合、これはプログラム権限であるべきです。プログラムがマルチシグによって制御されている場合は、このガイドの下部にある
[マルチシグ検証](#how-to-verify-your-program-when-its-controlled-by-a-multisig-like-squads)
セクションに進んでください。

これによりOtterSec
APIにジョブが送信され、以下のコマンドでジョブのステータスを確認できます：

```bash
solana-verify remote get-job-status --job-id <job-id>
```

検証が正常に完了すると（時間がかかる場合があります）、
[単一プログラム用OtterSec API](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)、
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY/verified-build)、
[SolanaFM](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY?cluster=mainnet-alpha)、
[SolScan](https://solscan.io/account/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY#programVerification)
でプログラムが検証済みとして表示されます。また、最終的には
[0xDeep](https://x.com/0xDeep)によって維持されているコミュニティ運営のウェブサイト
[SolanaVerify.org](https://www.solanaverify.org/)や
[OtterSec検証済みプログラムAPI](https://verify.osec.io/verified-programs)、そして[検証済みプログラムDuneダッシュボード](https://dune.com/jonashahn/verified-programs/dedf21e1-9b71-42c8-89f9-02ed94628657)
にも表示され、より健全なSolanaエコシステムに貢献します。

</Step>
</Steps>

## Squadsのようなマルチシグによってプログラムが制御されている場合の検証方法

リモート検証を機能させるには、プログラム権限によって署名されたPDAに検証データを書き込む必要があります。プログラムがマルチシグによって制御されている場合は、このPDA書き込みトランザクションをエクスポートし、[Squads Protocol](https://squads.so/protocol)
またはお好みの他のマルチシグソリューションを通じて送信することができます。

<Steps>
<Step>

### 1. 検証可能なプログラムをビルドする

まず、プログラムをビルドします：

```bash
solana-verify build
```

これにより、`Cargo.lock`ファイルで指定されたsolanaバージョンを使用して、Dockerコンテナを使用した検証可能なビルドが作成されます。

</Step>
<Step>

### 2. プログラムをデプロイする

```bash
solana config set --url "PayedMainnetRPCAddress" // the public endpoint will be rate limited too much
solana program deploy target/deploy/verify_squads.so
```

このマルチシグガイドの残りの部分では、プログラムIDの例として
`6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`を使用します。

</Step>
<Step>

### 3. リポジトリに対してコミットして検証する

それが完了したら、プロジェクトをGitHubにコミットします。例えば：
https://github.com/solana-developers/verify-squads

オプション：まずローカルで検証できるか確認してみてください（このコマンドはサンプルプログラムIDを使用しています
`6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`）：

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
```

パラメータが正しいことを確認するためです。

</Step>
<Step>

### 4. プログラム権限をマルチシグに転送する

まだプログラムの権限をマルチシグに転送していない場合は、マルチシグの権限をコピーしてください。次のステップで必要になります。

</Step>
<Step>

### 5. PDAトランザクションをエクスポートする

プログラム権限をローカルに持っている場合、コマンド
`solana-verify verify-from-repo`
を使用すると、ビルドデータをオンチェーンにアップロードするよう促されます。

マルチシグを使用している場合はそれができないため、PDAトランザクションを手動でエクスポートし、Squadsを通じてトランザクションをトリガーする必要があります。

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader <your program authority> --encoding base58 --compute-unit-price 0
```

これによりbase58形式のトランザクションが返されます。トランザクションインスペクターで使用するためにbase64エンコードされたトランザクションが必要な場合は、`--encoding base64`
を使用できます。

```bash
P6vBfcPaaXb8fZoT3NBAYEcdtEj7tubA1k2gBxmFKZ3UWF5YyrmDMFTvLKALCJoUuRsPAjMckudYruCu3eeWQtuDrFbEMLxLFutnKXac974fnkMivcwUdY66VLjbxQT6ATmcy7F4hBtz1G4P1h6iBJLhb8WtrtgY3i4qq45MUEb7RjuMEfUFXKrNgPdGxkz5xvMHq3dxKRcpmEK5k2DkeW6SUQYBVe19Ga3B9GyhTX8k3CMt9JCEah13WyRnQd8GjoK6sTEvGJym6xDNvmd8yiJYSNcaYwEJsjHEUf4Yh6kAC7ki2KRvVAr3NVe1gjqK9McrwSQjtUatvydTG8Zovcr7PPUEMf3yPMgKXjZLB2QpkH63yTTYdNAnWFuv9E6b6nYRqye5XcNi436yKw5U14fXh65yK34bgYLi9328UT1huJELsJU9BRGnGUmb6GWp6c2WL5BhnzgNTSnt9TXFfEgUMzhvKzpVBxLP44hwqqBdyUhHFysCF37531PnmiESq8x1xou23xJ6FcQbc199754MkqQd7tX9CUznGzAEqHGkzn3VBoJnojsKtgYmiTYbdRsT1CU18MbYEE7WvGAvXyxxbpNzbAcc94HrnM6cqRGmwhEBroPfFghTdmzg9D
```

</Step>
<Step>

### 6. Squadsを通じてトランザクションを送信する

Squadsのトランザクションビルダーに移動し、base58エンコードされたトランザクションをインポートします。シミュレーションでは、トランザクションにosec検証プログラムとコンピュータバジェットプログラムへの呼び出しのみが含まれ、他には何も含まれていないことを確認してください！

</Step>
<Step>

### 7. リモート検証ジョブを送信する

Squadsへのトランザクションが成功したら、リモートジョブを送信できます：

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
--uploader <your program authority>
```

これで完了です！公開リポジトリに対してプログラムを検証し、OtterSec
APIにリモートジョブを送信しました。これでSolanaエクスプローラーや他の場所で反映されているのが確認できるはずです。

</Step>
<Step>

### 8. プログラムの更新（任意）

プログラムを更新する際は、新しいPDAトランザクションをエクスポートし、再度Squadsを通じて提出する必要があります。

プログラムの更新手順：

```bash
solana-verify build
solana program write-buffer target/deploy/verify_squads.so --with-compute-unit-price 50000 --max-sign-attempts 50
```

その後、そのバッファ権限をマルチシグに転送するか、マルチシグの権限で直接バッファを作成します。

```bash
solana program set-buffer-authority Fu3k79g53ZozAj47uq1tXrFy4QbQYh7y745DDsxjtyLR --new-buffer-authority 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

</Step>
<Step>

### 9. 新しいPDAトランザクションのエクスポートと提出

変更をGitHubにコミットすることを忘れないでください。PDAアップグレードトランザクションを再度エクスポートします：

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

トランザクションを再度Squadsを通じて提出します。

トランザクションの例は[こちら](https://solana.fm/tx/4zJ1vK2KToAwxuEYzTMLqPkcebjoi9rdeeyxtEEx9L5Q4vWDA8h6Rr4kPRuRxcV7ZLKMr6qx1LTWb6x3ZpUJaFUW?cluster=mainnet-alpha)で確認できます。

その後、リモートビルドを再度提出します：

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

以下のような結果が表示されるはずです：

```shell
Verification request sent with request id: b63339d2-163e-49ac-b55d-3454c1c2b5b3
Verification in progress... ⏳ [00:18:02] ✅ Process completed. (Done in 18
minutes) Program 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD has been verified.
✅ The provided GitHub build matches the on-chain hash. On Chain Hash:
96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Executable
Hash: 96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Repo URL:
https://github.com/Woody4618/verify-squads/tree/0fb0a2e30c15c51732c0ad5e837975a6f7bbc7ed
Check the verification status at:
https://verify.osec.io/status/6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD Job
url: https://verify.osec.io/job/b63339d2-163e-49ac-b55d-3454c1c2b5b3
```

おめでとうございます！マルチシグアップグレード後にプログラムを検証することができました！

</Step>
</Steps>

## Dockerイメージからの検証

以下のコマンドを実行することで、Dockerイメージに対してプログラムを検証することもできます：

```bash
solana-verify verify-from-image -e
examples/hello_world/target/deploy/hello_world.so -i
ellipsislabs/hello_world_verifiable_build:latest -p
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn
```

このコマンドは`ellipsislabs/hello_world_verifiable_build:latest`に保存されているイメージをロードし、コンテナ内の実行可能ファイルのハッシュがコマンドに提供されたオンチェーンプログラムのハッシュと同じであることを検証します。イメージにビルドが既にアップロードされているため、時間のかかる実行可能ファイルの完全な再ビルドは必要ありません。

イメージ`ellipsislabs/hello_world_verifiable_build:latest`を作成するDockerfileは、Ellipsis
Labsのリポジトリ[/examples/hello_world](https://github.com/Ellipsis-Labs/solana-verifiable-build/tree/master/examples/hello_world)にあります。

以下は予想される出力です：

```bash
Verifying image: "ellipsislabs/hello_world_verifiable_build:latest", on network
"https://api.mainnet.solana.com" against program ID
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn Executable path in container:
"examples/hello_world/target/deploy/hello_world.so"

Executable hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Program hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Executable
matches on-chain program data ✅
```

## 検証ビルドの例

こちらは、ID
`FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv`を持つサンプルプログラムを、この
[リポジトリ](https://github.com/solana-developers/verified-program)のソースコードを使用して検証する例です：

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

デフォルトでは、`verify-from-repo`コマンドはメインブランチの最新コミットを使用します。リポジトリでの作業を継続したい場合は、`commit-hash`パラメータを使用して特定のコミットを指定することもできます：
`--commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e`

最後に、OtterSec APIに対して直接プログラムを検証することもできます：

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --remote --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

`--remote`コマンドはOtterSec
APIにビルドリクエストを送信し、プログラムのリモートビルドをトリガーします。ビルドが完了すると、システムはプログラムのオンチェーンハッシュがリポジトリから生成されたビルド成果物のハッシュと一致することを検証します。

## すでに検証済みの人気プログラム

### Phoenix

```shell
solana-verify verify-from-repo -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

最終出力：

```shell
Executable Program Hash from repo: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
On-chain Program Hash: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
Program hash matches ✅
```

### Squads V3

```shell
solana-verify verify-from-repo https://github.com/Squads-Protocol/squads-mpl --commit-hash c95b7673d616c377a349ca424261872dfcf8b19d --program-id SMPLecH534NA9acpos4G6x7uf3LWbCAwZQE9e8ZekMu -um --library-name squads_mpl --bpf
```

> Squadsリポジトリには複数のプログラムが含まれているため、`library-name`を指定する必要があることに注意してください。`squads_mpl`は以前にAnchorで検証されていたため、`--bpf`フラグを使用します。

最終出力：

```shell
Executable Program Hash from repo: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
On-chain Program Hash: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
Program hash matches ✅
```

### Drift V2

```shell
solana-verify verify-from-repo -um --program-id dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH https://github.com/drift-labs/protocol-v2 --commit-hash 110d3ff4f8ba07c178d69f9bfc7b30194fac56d6 --library-name drift
```

最終出力：

```shell
Executable Program Hash from repo: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
On-chain Program Hash: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
Program hash matches ✅
```

### Marginfi V2

```shell
solana-verify verify-from-repo -um --program-id MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA https://github.com/mrgnlabs/marginfi-v2 --commit-hash d33e649e415c354cc2a1e3c49131725552d69ba0 --library-name marginfi -- --features mainnet-beta
```

最終出力：

```shell
Executable Program Hash from repo: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
On-chain Program Hash: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
Program hash matches ✅
```

# 結論

[Solanaの検証済みビルド](/developers/guides/advanced/verified-builds)を使用することで、ネットワーク上のプログラムの整合性と信頼性を確保し、開発者はSolana
Explorerから直接SDKを見つけることができます。Solana Verify
CLIやDockerなどのツールを活用することで、ソースコードと一致する検証可能で安全なビルドを維持できます。一貫した環境を使用するために必要な予防措置を常に講じ、安全なアップグレードとデプロイメントのためのガバナンスソリューションを検討してください。

## セキュリティ + 免責事項

検証済みビルドはSolanaプログラムの整合性を確保するための強力なツールですが、デフォルトの設定では完全に信頼性が担保されているわけではありません。Dockerイメージは、Solana
Foundationによって構築およびホストされています。

プロジェクトをダウンロードしたDockerイメージ内でビルドしており、潜在的に機密情報を含むセットアップ全体がそのDockerイメージにコピーされることに注意してください。

完全に信頼性の高いセットアップを希望する場合は、自分でDockerイメージを構築し、自分のインフラストラクチャでホストすることができます。これにより、Dockerイメージが改ざんされていないことを確認できます。独自のDockerイメージを作成するためのスクリプトは[検証済みビルドリポジトリ](https://github.com/Ellipsis-Labs/solana-verifiable-build)で見つけることができ、フォークして自分でGitHubアクションを実行したり、それらが正しいことを検証したりできます。

さらに、リモート検証については、OtterSec
APIと[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)をある程度信頼する必要があります。

APIまたはSolana
Explorerが侵害された場合、誤った情報が表示される可能性があります。

完全に信頼性の高いセットアップを希望する場合は、[Verify API](https://github.com/otter-sec/solana-verified-programs-api)を自分で実行するか、`verify-from-repo`コマンドを使用してプログラム検証をローカルで実行できます。これはプログラムのデプロイ権限と[検証プログラム](https://explorer.solana.com/address/verifycLy8mB96wd9wqq3WDXQwM4oU6r42Th37Db9fC)から派生した[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)に保存されているオンチェーン検証データを使用します。

検証プログラムは[OtterSecチーム](https://osec.io/)によってデプロイされており、まだフリーズされていないため、いつでもアップグレードできます。

Solana財団、OtterSec、およびEllipsis
Labsチームは、検証済みビルドパイプラインの使用によって発生する可能性のある損失や損害について責任を負いません。

# Solanaプログラム用のsecurity.txt

検証済みビルドに加えて、プログラムに`security.txt`ファイルを追加することもできます。将来的には、実装後、`security.txt`には検証PDAに保存されている検証データに簡単にアクセスするための検証者のpubkeyが含まれます。プログラムのビルドと検証に必要なすべての情報を含むPDAは、プログラムのアドレスと検証者のpubkeyから派生します。デフォルトでは、これはプログラムをビルドしてデプロイしたのと同じpubkeyです。ただし、`security.txt`で指定できる別のpubkeyにすることもできます。

`security.txt`機能により、開発者はSolanaスマートコントラクト内に連絡先とセキュリティ情報を直接埋め込むことができます。[securitytxt.org](https://securitytxt.org)にインスパイアされたこのアプローチは、セキュリティ研究者がコントラクトのアドレスしか知らない場合でも、プロジェクトのメンテナに連絡するための標準化された方法を提供します。

## security.txtを使用する理由

多くのプロジェクト、特に小規模または非公開のプロジェクトでは、コントラクトアドレスだけから開発者を特定することが難しく時間がかかる場合があります。プログラム内に`security.txt`ファイルを埋め込むことで、セキュリティ研究者が適切な人物に簡単に連絡できるようになり、潜在的な悪用を防ぎ、タイムリーなバグレポートを確保できます。

## security.txtの実装方法

Solanaプログラムに`security.txt`を追加するには、次の手順を含めます：

`solana-security-txt` 依存関係を `Cargo.toml` に追加してください：

```toml title="Cargo.toml"
[dependencies]
solana-security-txt = "1.1.1"
```

コントラクトで `security_txt!`
マクロを使用してセキュリティ情報を定義します。連絡先の詳細、プロジェクトURL、さらにはセキュリティポリシーも含めることができます。以下は例です：

```rust
#[cfg(not(feature = "no-entrypoint"))]
use {default_env::default_env, solana_security_txt::security_txt};

#[cfg(not(feature = "no-entrypoint"))]
security_txt! {
    name: "MyProject",
    project_url: "https://myproject.com",
    contacts: "email:security@myproject.com,discord:security#1234",
    policy: "https://myproject.com/security-policy",

    // Optional Fields
    preferred_languages: "en,de",
    source_code: "https://github.com/solana-developers/solana-game-preset",
    source_revision: "5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    source_release: "",
    encryption: "",
    auditors: "Verifier pubkey: 5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    acknowledgements: "Thank you to our bug bounty hunters!"
}
```

`security.txt` 情報がプログラムに埋め込まれると、Solana
Explorerなどのツールを通じて簡単に照会でき、潜在的な問題を報告しようとする人なら誰でも連絡先やセキュリティの詳細情報を確認できるようになります。

## ベストプラクティス

- リンクを使用する：変更される可能性が高い情報（連絡先の詳細など）については、コントラクトにハードコーディングするのではなく、ウェブページへのリンクを設定することをお勧めします。これにより、頻繁なプログラムのアップグレードが不要になります。

- 検証：デプロイする前に、`query-security-txt`
  ツールを使用してフォーマットと内容を検証してください。このツールはオンチェーンプログラムとローカルバイナリの両方を検証できます：

```bash
query-security-txt target/bpfel-unknown-unknown/release/my_contract.so
```

セキュリティ連絡先情報をコントラクトに直接埋め込むことで、研究者があなたに連絡しやすくなり、Solanaエコシステム内でのセキュリティとコミュニケーションが向上します。

これは[Solana Explorerでのsecurity.txtの表示例](https://explorer.solana.com/address/HPxKXnBN4vJ8RjpdqDCU7gvNQHeeyGnSviYTJ4fBrDt4/security?cluster=devnet)です

`security.txt`
プロジェクトは[Neodyme Labs](https://github.com/neodyme-labs)によって維持されています
