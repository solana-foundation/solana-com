---
title: プログラム派生アドレス
description:
  Solanaのプログラム派生アドレス（PDA）について学びましょう —
  安全なプログラム署名を可能にする決定論的なアカウントアドレスです。PDAの導出、正規バンプ、およびPDAアカウントの作成方法を理解しましょう。
---

Solanaの[アカウントアドレス](/docs/core/accounts#account-address)は、ブロックチェーン上のアカウントの場所を指します。多くのアカウントアドレスはkeypairの公開鍵であり、その場合、対応する秘密鍵がアカウントに関連するトランザクションの署名に使用されます。

公開鍵アドレスの便利な代替手段として、プログラム派生アドレス（PDA）があります。PDAはプログラムの状態を保存、マッピング、取得するための簡単な方法を提供します。PDAはプログラムIDとオプションの事前定義された入力の組み合わせを使用して決定論的に作成されるアドレスです。PDAは公開鍵アドレスに似ていますが、対応する秘密鍵はありません。

Solanaランタイムは、秘密鍵を必要とせずにプログラムがPDAに署名することを可能にします。PDAを使用することで、アカウントのアドレスを追跡する必要がなくなります。代わりに、PDAの導出に使用された特定の入力を思い出すことができます。（プログラムがPDAを署名にどのように使用するかについては、[クロスプログラム呼び出し](/docs/core/cpi)セクションを参照してください。）

## 背景

Solanaの[keypair](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/keypair/src/lib.rs#L26)は、[Ed25519曲線](https://ed25519.cr.yp.to/)（楕円曲線暗号）上の点です。これらは公開鍵と秘密鍵で構成されています。公開鍵がアカウントアドレスになり、秘密鍵はアカウントの有効な[署名](/docs/core/transactions#signatures)を生成するために使用されます。

![曲線上のアドレスを持つ2つのアカウント](/assets/docs/core/pda/address-on-curve.svg)

PDAは意図的にEd25519曲線から外れるように導出されます。これは、有効な対応する秘密鍵を持たず、暗号操作（署名の提供など）を実行できないことを意味します。ただし、Solanaはプログラムが秘密鍵なしでPDAに署名することを可能にします。

![オフカーブアドレス](/assets/docs/core/pda/address-off-curve.svg)

PDAは、事前に定義された入力セット（例えば、文字列、数値、その他のアカウントアドレスなど）を使用して、オンチェーン上にハッシュマップのような構造を作成する方法と考えることができます。

![Program Derived Address](/assets/docs/core/pda/pda.svg)

## PDAの導出

PDAを持つアカウントを作成する前に、まずアドレスを導出する必要があります。PDAを導出しても、そのアドレスにオンチェーンアカウントが自動的に作成されるわけではありません - アカウントはPDAの導出に使用されたプログラムを通じて明示的に作成する必要があります。PDAは地図上のアドレスのようなものと考えることができます：アドレスが存在するからといって、そこに何かが建てられているわけではありません。

Solana
SDKはPDA作成を以下の表に示す関数でサポートしています。各関数は次の入力を受け取ります：

- **プログラムID**：PDAの導出に使用されるプログラムのアドレス。このプログラムはPDAの代わりに署名することができます。
- **オプションのseed**：文字列、数値、または他のアカウントアドレスなどの事前定義された入力。

| SDK                            | 関数                                                                                                                             |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `@solana/kit` (Typescript)     | [`getProgramDerivedAddress`](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L157) |
| `@solana/web3.js` (Typescript) | [`findProgramAddressSync`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/publickey.ts#L212)               |
| `solana_sdk` (Rust)            | [`find_program_address`](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/pubkey/src/lib.rs#L617)                        |

この関数はプログラムIDとオプションのseedを使用し、bump値を反復処理して有効なプログラムアドレスを作成しようとします。bump値の反復は255から始まり、有効なPDAが見つかるまで1ずつ減少します。有効なPDAが見つかると、関数はPDAとbump
seedを返します。

<Callout>
  bump
  seedは、有効なオフカーブアドレスが生成されることを保証するために、オプションのseedに追加される追加のバイトです。
</Callout>

![PDA導出](/assets/docs/core/pda/pda-derivation.svg)

### 正規バンプ

バンプseedは任意のseedsに追加される追加バイトです。導出関数は255から始まり1ずつ減少するバンプ値を反復処理し、有効なオフカーブアドレスが生成されるまで続けます。有効なオフカーブアドレスを生成する最初のバンプ値が「正規バンプ」と呼ばれます。

以下の例では、可能なすべてのバンプseed（255から0）を使用したPDA導出を示しています：

<Callout type="info">
  [createProgramDerivedAddress](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L101)
  関数がエクスポートされていないため、Kitの例は含まれていません。
</Callout>

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const optionalSeed = "helloWorld";

// Loop through all bump seeds (255 down to 0)
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(optionalSeed), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed = b"helloWorld";

    // Loop through all bump seeds (255 down to 0)
    for bump in (0..=255).rev() {
        match Pubkey::create_program_address(&[optional_seed.as_ref(), &[bump]], &program_id) {
            Ok(pda) => println!("bump {}: {}", bump, pda),
            Err(err) => println!("bump {}: {}", bump, err),
        }
    }

    Ok(())
}
```

</CodeTabs>

<CodeTabs>

```sh !! title="Expected TS Output"
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// remaining bump outputs
```

```sh !! title="Expected Rust Output"
bump 255: Provided seeds do not result in a valid address
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Provided seeds do not result in a valid address
...
// remaining bump outputs
```

</CodeTabs>

この例では、最初のバンプseedはエラーをスローします。有効なPDAを導出する最初のバンプseedは254です。バンプseed
253-251も一意の有効なPDAを導出します。

これは、同じ任意のseedsと`programId`が与えられた場合でも、異なる値を持つバンプseedでも有効なPDAを導出できることを意味します。

<Callout type="warn">
  プログラムに渡されるPDAが正規バンプから導出されていることを確認するセキュリティチェックを常に含めてください。これを怠ると、プログラムのinstructionsで予期しないアカウントが使用される可能性がある脆弱性が生じる可能性があります。PDAを導出する際は正規バンプのみを使用することがベストプラクティスです。
</Callout>

### 例

以下の例ではSolana
SDKを使用してPDAを導出します。**&#9655; 実行**をクリックしてコードを実行してください。

#### 文字列seedを使用したPDAの導出

以下の例では、プログラムIDと任意の文字列seedを使用してPDAを導出します。

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus
const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus
const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let seeds: &[&[u8]] = &[b"helloWorld"];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### アドレスseedでPDAを導出する

以下の例は、プログラムIDとオプションのアドレスseedを使用してPDAを導出します。

<CodeTabs storage="pda-examples"flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:4)
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

// !focus(1:3)
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### 複数のseedでPDAを導出する

以下の例は、プログラムIDと複数のオプションseedを使用してPDAを導出します。

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:5)
const optionalSeedString = "helloWorld";
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedString, optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus(1:4)
const optionalSeedString = "helloWorld";
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [Buffer.from(optionalSeedString), optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus(1:2)
    let optional_seed_bytes = b"helloWorld";
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

## PDAアカウントを作成する

<WithMentions>

以下の例では、[Anchorフレームワーク](https://www.anchor-lang.com/docs)を使用して、プログラム派生アドレスを持つ新しいアカウントを作成します。このプログラムには、新しいアカウントを作成するための単一の[`initialize`](mention:initialize)命令が含まれており、[ユーザーアドレス](mention:user-address)とPDAの導出に使用された[bump seed](mention:bump)を保存します。

```rs title="Program"
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    // !mention initialize
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        // !mark
        // !mention user-address
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bumpd
        // !mark
        // !mention bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    // !mention user-address
    pub user: Signer<'info>,

    #[account(
        init,
        // define the seeds to derive the PDA
        // !mark
        // !mention user-address
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        // !mark
        // !mention bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(InitSpace)]
pub struct DataAccount {
    // !mark
    // !mention user-address
    pub user: Pubkey,
    // !mark
    // !mention bump
    pub bump: u8,
}
```

</WithMentions>

<WithMentions>

[`init`](mention:init)制約は、Anchorに[System Programを呼び出す](/docs/core/programs#the-system-program)よう指示し、PDAをアドレスとして使用して新しいアカウントを作成します。PDAの作成に使用される[seeds](mention:seeds)は次のとおりです：

- 命令で提供されるユーザーアカウントのアドレス
- 固定文字列：「data」
- 正規の[bump seed](mention:bump)

この例では、bump制約に値が割り当てられていないため、Anchorは`find_program_address`を使用してPDAを導出し、bumpを見つけます。

```rust title="pda_account"
#[account(
    // !mention init
    init,
    // !mention seeds
    seeds = [b"data", user.key().as_ref()],
    // !mention bump
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

</WithMentions>

<WithMentions>

以下のテストファイルには、新しいアカウントをプログラム派生アドレスで作成するために
[`initialize`](mention:initialize)
instructionを呼び出すトランザクションが含まれています。このファイルには
[PDAを導出する](mention:pda)コードが含まれています。

この例では、作成される新しいアカウントを[取得する](mention:fetch)方法も示しています。

```ts title="Test"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PdaAccount } from "../target/types/pda_account";
import { PublicKey } from "@solana/web3.js";

describe("pda-account", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.PdaAccount as Program<PdaAccount>;
  const user = provider.wallet as anchor.Wallet;

  // !mention(1:5) pda
  // Derive the PDA address using the seeds specified on the program
  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("data"), user.publicKey.toBuffer()],
    program.programId
  );

  it("Is initialized!", async () => {
    const transactionSignature = await program.methods
      // !mention initialize
      .initialize()
      .accounts({
        user: user.publicKey
      })
      .rpc();

    console.log("Transaction Signature:", transactionSignature);
  });

  it("Fetch Account", async () => {
    // !mention fetch
    const pdaAccount = await program.account.dataAccount.fetch(PDA);
    console.log(JSON.stringify(pdaAccount, null, 2));
  });
});
```

</WithMentions>

<Callout type="warn">
  同じ`user`アドレスseedで`initialize`
  instructionを再度呼び出すと、トランザクションは失敗します。これは、導出されたアドレスにすでにアカウントが存在するためです。
</Callout>
