---
title: トランザクション
description: Solanaトランザクションについて学びましょう—Solanaブロックチェーンと対話するための基本的な構成要素です。実用的な例を通じてトランザクション構造とinstruction構成を理解しましょう。
---

Solanaネットワークと対話するには、トランザクションを送信する必要があります。トランザクションは、いくつかのフォームを含む封筒のようなものと考えることができます。各フォームはネットワークに何をすべきかを指示するinstructionです。トランザクションを送信することは、フォームが処理されるように封筒を郵送するようなものです。

以下の例は、2つのトランザクションの簡略版を示しています。最初のトランザクションが処理されると、単一のinstructionが実行されます。2番目のトランザクションが処理されると、**順番に**3つのinstructionが実行されます：まずinstruction
1、次にinstruction 2、そしてinstruction 3の順です。

<Callout type="warn">
  トランザクションは**アトミック**です：単一のinstructionが失敗すると、トランザクション全体が失敗し、変更は一切発生しません。
</Callout>

![2つのトランザクションを示す簡略図](/assets/docs/core/transactions/transaction-simple.svg)

[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)は以下の情報で構成されています：

<WithMentions>

- [`signatures`](mention:signatures): [署名](#signatures)の配列
- [`message`](mention:message): 処理されるinstructionsのリストを含むトランザクション情報

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![トランザクションの2つの部分を示す図](/assets/docs/core/transactions/tx_format.png)

トランザクションの総サイズ制限は[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)バイトです。この制限には[`signatures`](#signatures)配列と[`message`](#message)構造体の両方が含まれます。

<Callout>
  この制限はIPv6の最大伝送単位（MTU）サイズ1280バイトから、ネットワークヘッダー用の48バイト（IPv6用40バイト
  + ヘッダー用8バイト）を引いたものです。
</Callout>

![トランザクションフォーマットとサイズ制限を示す図](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## 署名

トランザクションの`signatures`配列には`Signature`構造体が含まれています。各[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)は64バイトで、アカウントの秘密鍵でトランザクションの`Message`に署名することで作成されます。トランザクションのinstructionsに含まれる各[署名者アカウント](#account-addresses)には署名を提供する必要があります。

最初の署名は、トランザクションの[基本手数料](docs/core/fees#base-fee)を支払うアカウントに属し、トランザクション署名となります。このトランザクション署名を使用して、ネットワーク上でトランザクションの詳細を検索することができます。

## メッセージ

トランザクションの `message` は
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)
構造体であり、以下の情報を含んでいます：

<WithMentions>

- [`header`](mention:message-header): メッセージの[ヘッダー](#header)
- [`account_keys`](mention:account-addresses): トランザクションのinstructionsに必要な[アカウントアドレス](#account-addresses)の配列
- [`recent_blockhash`](mention:recent-blockhash): トランザクションのタイムスタンプとして機能する[ブロックハッシュ](#recent-blockhash)
- [`instructions`](mention:instructions): [instructions](#instructions)の配列

<Callout>
  スペースを節約するため、トランザクションは各アカウントの権限を個別に保存しません。代わりに、アカウントの権限は
  `header` と `account_keys` を使用して決定されます。
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### ヘッダー

<WithMentions>

メッセージの `header` は
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
構造体です。以下の情報を含んでいます：

- [`num_required_signatures`](mention:num_required_signatures): トランザクションに必要な署名の総数
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts): 署名が必要な読み取り専用アカウントの総数
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts): 署名が不要な読み取り専用アカウントの総数

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![メッセージヘッダーの3つの部分を示す図](/assets/docs/core/transactions/message_header.png)

### アカウントアドレス

メッセージの
[`account_keys`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
はアカウントアドレスの配列で、[コンパクト配列形式](/docs/references/terminology#compact-array-format)で送信されます。配列のプレフィックスはその長さを示します。配列の各項目は公開鍵であり、instructionsで使用されるアカウントを指しています。`accounts_keys`
配列は完全で、以下の順序に厳密に従う必要があります：

1. 署名者 + 書き込み可能
2. 署名者 + 読み取り専用
3. 署名者でない + 書き込み可能
4. 署名者でない + 読み取り専用

<Callout>
  厳密な順序付けにより、`account_keys`
  配列をメッセージの[`header`](#header)の情報と組み合わせて、各アカウントの権限を決定することができます。
</Callout>

![アカウントアドレス配列の順序を示す図](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### 最新のブロックハッシュ

メッセージの `recent_blockhash`
は、トランザクションのタイムスタンプとして機能し、重複トランザクションを防止するハッシュ値です。ブロックハッシュは[150ブロック](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)後に期限切れになります。（各ブロックが400msと仮定すると、約1分に相当します。）ブロックの期限が切れると、トランザクションも期限切れとなり、処理できなくなります。

<Callout>
  [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash)
  RPCメソッドを使用すると、現在のブロックハッシュとそのブロックハッシュが有効な最後のブロック高を取得できます。
</Callout>

### Instructions

メッセージの[`instructions`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)は、処理されるすべてのinstructionの配列で、[コンパクト配列形式](/docs/references/terminology#compact-array-format)で送信されます。配列のプレフィックスはその長さを示します。配列の各項目は[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)構造体であり、以下の情報を含んでいます：

<WithMentions>

1. [`program_id_index`](mention:program-id-index)：[`account_keys`](#account-addresses)配列内のアドレスを指すインデックス。この値はinstructionを処理するプログラムのアドレスを示します。
2. [`accounts`](mention:account-indexes)：`account_keys`配列内のアドレスを指すインデックスの配列。各インデックスはこのinstructionに必要なアカウントのアドレスを指します。
3. [`data`](mention:instruction-data)：プログラム上で呼び出すinstructionを指定するバイト配列。また、instructionに必要な追加データも含まれます。（例えば、関数の引数など）

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Instructionのコンパクト配列](/assets/docs/core/transactions/compact_array_of_ixs.png)

## トランザクション構造の例

以下の例は、単一のSOL送金instructionを含むトランザクションの構造を示しています。

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
以下のコードは、前述のコードスニペットからの出力を示しています。
フォーマットはSDKによって異なりますが、
各instructionが同じ必要な情報を含んでいることに注目してください。

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

トランザクションが送信された後、トランザクションシグネチャと[getTransaction](/docs/rpc/http/gettransaction)
RPCメソッドを使用して、その詳細を取得できます。レスポンスは以下のスニペットに似た構造になります。

<Callout>
  [Solana
  Explorer](https://explorer.solana.com)を使用してトランザクションを確認することもできます。
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
