---
title: 명령어
description:
  솔라나 블록체인과 상호작용하기 위한 기본 구성 요소인 솔라나 명령어에 대해
  알아보세요. 실용적인 예제를 통해 명령어 구성을 이해하세요.
---

명령어는 솔라나 블록체인과 상호작용하기 위한 기본 구성 요소입니다. 명령어는
본질적으로 솔라나 네트워크를 사용하는 모든 사람이 호출할 수 있는 공개
함수입니다. 각 명령어는 특정 작업을 수행하는 데 사용됩니다. 명령어의 실행 로직은
[프로그램](/docs/core/programs)에 저장되며, 각 프로그램은 자체적인 명령어 세트를
정의합니다. 솔라나 네트워크와 상호작용하려면 하나 이상의 명령어를
[트랜잭션](/docs/core/transactions)에 추가하여 처리를 위해 네트워크로
전송합니다.

## SOL 전송 예제

아래 다이어그램은 트랜잭션과 명령어가 함께 작동하여 사용자가 네트워크와
상호작용할 수 있게 하는 방법을 보여줍니다. 이 예제에서는 SOL이 한 계정에서 다른
계정으로 전송됩니다.

송신자 계정의 [메타데이터](#account-metadata)는 트랜잭션에 서명해야 함을
나타냅니다. (이를 통해 시스템 프로그램이
[lamport](/docs/references/terminology#lamport)를 차감할 수 있습니다.) 송신자와
수신자 계정 모두 lamport 잔액을 변경하기 위해 쓰기 가능해야 합니다. 이 명령어를
실행하기 위해 송신자의 지갑은 [서명](/docs/references/terminology#signature)과
SOL 전송 명령어가 포함된 메시지가 담긴 트랜잭션을 전송합니다.

![SOL 전송 다이어그램](/assets/docs/core/transactions/sol-transfer.svg)

트랜잭션이 전송된 후, 시스템 프로그램은 전송 명령어를 처리하고 두 계정의 lamport
잔액을 업데이트합니다.

![SOL 전송 처리 다이어그램](/assets/docs/core/transactions/sol-transfer-process.svg)

아래 예제는 위 다이어그램과 관련된 코드를 보여줍니다. (시스템 프로그램의 전송
[명령어](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L183)를
참조하세요.)

<CodeTabs flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

// Create a connection to cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Fund sender with airdrop
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: sender.address,
  lamports: lamports(LAMPORTS_PER_SOL), // 1 SOL
  commitment: "confirmed"
});

// Check balance before transfer
const { value: preBalance1 } = await rpc.getBalance(sender.address).send();
const { value: preBalance2 } = await rpc.getBalance(recipient.address).send();

// !mark(1:6)
// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount // 0.01 SOL in lamports
});

// Add the transfer instruction to a new transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

// Send the transaction to the network
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);
const transactionSignature = getSignatureFromTransaction(signedTransaction);

// Check balance after transfer
const { value: postBalance1 } = await rpc.getBalance(sender.address).send();
const { value: postBalance2 } = await rpc.getBalance(recipient.address).send();

console.log(
  "Sender prebalance:",
  Number(preBalance1) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Recipient prebalance:",
  Number(preBalance2) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Sender postbalance:",
  Number(postBalance1) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Recipient postbalance:",
  Number(postBalance2) / Number(LAMPORTS_PER_SOL)
);
console.log("Transaction Signature:", transactionSignature);
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

// Create a connection to cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Fund sender with airdrop
const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Check balance before transfer
const preBalance1 = await connection.getBalance(sender.publicKey);
const preBalance2 = await connection.getBalance(recipient.publicKey);

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// !mark(1:6)
// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

// Add the transfer instruction to a new transaction
const transaction = new Transaction().add(transferInstruction);

// Send the transaction to the network
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [sender] // signer
);

// Check balance after transfer
const postBalance1 = await connection.getBalance(sender.publicKey);
const postBalance2 = await connection.getBalance(recipient.publicKey);

console.log("Sender prebalance:", preBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient prebalance:", preBalance2 / LAMPORTS_PER_SOL);
console.log("Sender postbalance:", postBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient postbalance:", postBalance2 / LAMPORTS_PER_SOL);
console.log("Transaction Signature:", transactionSignature);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    // Create a connection to cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Fund sender with airdrop
    let airdrop_signature = connection
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;
    loop {
        let confirmed = connection.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Check balance before transfer
    let pre_balance1 = connection.get_balance(&sender.pubkey()).await?;
    let pre_balance2 = connection.get_balance(&recipient.pubkey()).await?;

    // Define the amount to transfer
    let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    // Add the transfer instruction to a new transaction
    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    let blockhash = connection.get_latest_blockhash().await?;
    transaction.sign(&[&sender], blockhash);

    // Send the transaction to the network
    let transaction_signature = connection
        .send_and_confirm_transaction(&transaction)
        .await?;

    // Check balance after transfer
    let post_balance1 = connection.get_balance(&sender.pubkey()).await?;
    let post_balance2 = connection.get_balance(&recipient.pubkey()).await?;

    println!(
        "Sender prebalance: {}",
        pre_balance1 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Recipient prebalance: {}",
        pre_balance2 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Sender postbalance: {}",
        post_balance1 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Recipient postbalance: {}",
        post_balance2 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

</CodeTabs>

<WithMentions>

## 명령어

![3개 구성 요소로 나뉜 명령어가 포함된 트랜잭션을 보여주는 다이어그램](/assets/docs/core/transactions/instruction.svg)

[`Instruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)는
다음 정보로 구성됩니다:

- [`program_id`](mention:program-id): 호출되는 프로그램의
  [ID](#program-id)입니다.
- [`accounts`](mention:accounts): [계정 메타데이터](#account-metadata)의
  배열입니다.
- [`data`](mention:instruction-data): 명령어에서 사용할 추가 [데이터]가 포함된
  바이트 배열입니다.

```rust title="Instruction struct"
pub struct Instruction {
    /// Pubkey of the program that executes this instruction.
    // !mention program-id
    pub program_id: Pubkey,
    /// Metadata describing accounts that should be passed to the program.
    // !mention accounts
    pub accounts: Vec<AccountMeta>,
    /// Opaque data passed to the program for its own interpretation.
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

### 프로그램 ID

명령어의 [`program_id`](/docs/references/terminology#program-id)는 명령어의
비즈니스 로직을 포함하는 프로그램의 공개 키 주소입니다.

### 계정 메타데이터

<WithMentions>

명령어의 `accounts` 배열은
[`AccountMeta`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25)
구조체의 배열입니다. 명령어가 상호작용하는 각 계정에 대한 메타데이터를 제공해야
합니다. (이를 통해 트랜잭션은 동일한 계정을 수정하지 않는 한 명령어를 병렬로
실행할 수 있습니다.)

아래 다이어그램은 단일 명령어를 포함하는 트랜잭션을 보여줍니다. 명령어의
`accounts` 배열에는 두 계정에 대한 메타데이터가 포함되어 있습니다.

![하나의 명령어가 있는 트랜잭션. 명령어는 `accounts` 배열에 두 개의 `AccountMeta` 구조체를 포함합니다.](/assets/docs/core/transactions/accountmeta.svg)

계정 메타데이터에는 다음 정보가 포함됩니다:

- [pubkey](mention:pubkey): 계정의 공개 키 주소
- [is_signer](mention:is-signer): 계정이 트랜잭션에 서명해야 하는 경우 `true`로
  설정
- [is_writable](mention:is-writable): 명령어가 계정의 데이터를 수정하는 경우
  `true`로 설정

<Callout>
  명령어가 어떤 계정을 필요로 하는지, 그리고 어떤 계정이 쓰기 가능, 읽기
  전용이어야 하는지, 또는 트랜잭션에 서명해야 하는지 알기 위해서는 프로그램에
  정의된 명령어의 구현을 참조해야 합니다.
</Callout>

```rust title="AccountMeta"
pub struct AccountMeta {
    /// An account's public key.
    // !mention pubkey
    pub pubkey: Pubkey,
    /// True if an `Instruction` requires a `Transaction` signature matching `pubkey`.
    // !mention is-signer
    pub is_signer: bool,
    /// True if the account data or metadata may be mutated during program execution.
    // !mention is-writable
    pub is_writable: bool,
}
```

</WithMentions>

### 데이터

명령어의 `data`는 프로그램의 어떤 명령어를 호출할지 지정하는 바이트 배열입니다.
또한 명령어에 필요한 인수도 포함합니다.

## 명령어 생성 예제

아래 예제는 SOL 전송 명령어의 구조를 보여줍니다.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner, lamports } from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair
} from "@solana/web3.js";

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_sdk::{native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Define the amount to transfer
    let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    println!("{:#?}", transfer_instruction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>

아래 코드는 이전 코드 스니펫의 출력을 보여줍니다. SDK에 따라 형식이 다를 수
있지만, 각 명령에는 동일한 세 가지 필수 정보가 포함되어 있습니다:
[`program_id`](mention:program-id), [`accounts`](mention:accounts),
[`data`](mention:data).

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  // !mention(1:16) accounts
  "accounts": [
    {
      "address": "Hu28vRMGWpQXN56eaE7jRiDDRRz3vCXEs7EKHRfL6bC",
      "role": 3,
      "signer": {
        "address": "Hu28vRMGWpQXN56eaE7jRiDDRRz3vCXEs7EKHRfL6bC",
        "keyPair": {
          "privateKey": {},
          "publicKey": {}
        }
      }
    },
    {
      "address": "2mBY6CTgeyJNJDzo6d2Umipw2aGUquUA7hLdFttNEj7p",
      "role": 1
    }
  ],
  // !mention program-id
  "programAddress": "11111111111111111111111111111111",
  // !mention(1:14) data
  "data": {
    "0": 2,
    "1": 0,
    "2": 0,
    "3": 0,
    "4": 128,
    "5": 150,
    "6": 152,
    "7": 0,
    "8": 0,
    "9": 0,
    "10": 0,
    "11": 0
  }
}
```

```json !! title="Legacy"
{
  // !mention(1:12) accounts
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  // !mention program-id
  "programId": "11111111111111111111111111111111",
  // !mention data
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

```json !! title="Rust"
{
  // !mention program-id
  "program_id": "11111111111111111111111111111111",
  // !mention(1:12) accounts
  "accounts": [
    {
      "pubkey": "Hhh6vrA6xUNwaNftJVAXSTzfHiRiAKFKLGmHdcRH6Pmo",
      "is_signer": true,
      "is_writable": true
    },
    {
      "pubkey": "6RYMY3mFLixELbfNCMA7zNtzgNfRyEZs5YYkZQb8aK4t",
      "is_signer": false,
      "is_writable": true
    }
  ],
  // !mention data
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

</CodeTabs>

</WithMentions>

아래 예제는 전송 명령을 수동으로 구축하는 방법을 보여줍니다.
(`Expanded Instruction` 탭은 기능적으로 `Instruction` 탭과 동일합니다.)

<Callout type="info">
  실제로는 보통 `Instruction`를 수동으로 구성할 필요가 없습니다. 대부분의
  프로그램은 명령을 생성하는 헬퍼 함수가 있는 클라이언트 라이브러리를
  제공합니다. 라이브러리를 사용할 수 없는 경우 수동으로 명령을 구축할 수
  있습니다.
</Callout>

<Tabs items={['Kit', 'Legacy', 'Rust']}>

<Tab value="Kit">

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const TRANSFER_INSTRUCTION_INDEX = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(TRANSFER_INSTRUCTION_INDEX, 0);
instructionData.writeBigUInt64LE(transferAmount * LAMPORTS_PER_SOL, 4);

const SYSTEM_PROGRAM_ADDRESS = "11111111111111111111111111111111" as Address;

// Manually create the transfer instruction
const transferInstruction: IInstruction = {
  programAddress: SYSTEM_PROGRAM_ADDRESS,
  accounts: [
    {
      address: sender.address,
      role: AccountRole.WRITABLE_SIGNER
    },
    {
      address: recipient.address,
      role: AccountRole.WRITABLE
    }
  ],
  data: new Uint8Array(instructionData)
};
```

</CodeTabs>

</Tab>

<Tab value="Legacy">

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const transferInstructionIndex = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(transferInstructionIndex, 0);
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// Manually create a transfer instruction
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true }, // from account, is signer and is writable
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true } // to account, is not signer but is writable
  ],
  programId: SystemProgram.programId,
  data: instructionData
});
```

</CodeTabs>

</Tab>

<Tab value="Rust">

<CodeTabs>

```rs !! title="Instruction"
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

let transfer_instruction =
    system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);
```

```rs !! title="Expanded Instruction"
// Instruction index for the System Program's transfer instruction
let transfer_instruction_index: u32 = 2;

// Define the amount to transfer
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

// Create instruction data manually (12 bytes: 4 for u32 index + 8 for u64 lamports)
let mut instruction_data = Vec::with_capacity(12);
instruction_data.extend_from_slice(&transfer_instruction_index.to_le_bytes());
instruction_data.extend_from_slice(&transfer_amount.to_le_bytes());

// Manually create the transfer instruction
let transfer_instruction = Instruction {
    program_id: system_program::id(),
    accounts: vec![
        AccountMeta::new(sender.pubkey(), true), // from account, is signer and is writable
        AccountMeta::new(recipient.pubkey(), false), // to account, is not signer but is writable
    ],
    data: instruction_data,
};
```

</CodeTabs>

</Tab>

</Tabs>
