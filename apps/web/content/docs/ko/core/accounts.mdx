---
title: 계정
description:
  Solana의 계정 모델에 대해 알아보세요. 계정이 데이터와 프로그램을 저장하는
  방법, 렌트 메커니즘, 계정 소유권, 그리고 프로그램과 데이터 계정 간의 관계를
  포함합니다. Solana의 키-값 저장 시스템의 핵심 개념을 이해해 보세요.
---

솔라나 네트워크의 모든 데이터는 계정에 저장됩니다. 솔라나 네트워크를 단일 계정
테이블이 있는 공개 데이터베이스로 생각할 수 있습니다. 계정과 그 주소 간의 관계는
키-값 쌍과 유사하며, 키는 주소이고 값은 계정입니다.

각 계정은 동일한 기본 [구조](#account-structure)를 가지며
[주소](#account-address)를 사용하여 찾을 수 있습니다.

![3개의 계정과 그 주소를 보여주는 다이어그램. 계정 구조 정의 포함.](/assets/docs/core/accounts/accounts.png)

## 계정 주소

계정 주소는 솔라나 블록체인에서 계정을 찾는 데 사용되는 32바이트 고유 ID입니다.
계정 주소는 종종 base58로 인코딩된 문자열로 표시됩니다. 대부분의 계정은
[Ed25519](https://ed25519.cr.yp.to/) [공개 키](#public-key)를 주소로 사용하지만,
솔라나는 [Program Derived Address](#program-derived-address)도 지원하므로 이는
필수가 아닙니다.

![base58로 인코딩된 공개 키 주소를 가진 계정](/assets/docs/core/accounts/account-address.svg)

### 공개 키

아래 예제는 Solana SDK를 사용하여 keypair를 생성하는 방법을 보여줍니다.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner } from "@solana/kit";

// Kit does not enable extractable private keys
const keypairSigner = await generateKeyPairSigner();
console.log(keypairSigner);
```

```ts !! title="Legacy"
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);
console.log(`Secret Key: ${keypair.secretKey}`);
```

```rs !! title="Rust"
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() {
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());
    println!("Secret Key: {:?}", keypair.to_bytes());
}
```

</CodeTabs>

### Program Derived Address

[Program Derived Address](/docs/core/pda)(PDA)는 프로그램 ID와 하나 이상의
선택적 입력(시드)을 사용하여 결정론적으로 도출되는 주소입니다. 아래 예제는
Solana SDK를 사용하여 Program Derived Address를 생성하는 방법을 보여줍니다.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey; // macro
use solana_sdk::pubkey::Pubkey;

#[tokio::main]
async fn main() {
    let program_address = pubkey!("11111111111111111111111111111111");
    let seeds = [b"helloWorld".as_ref()];
    let (pda, bump) = Pubkey::find_program_address(&seeds, &program_address);
    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
}
```

</CodeTabs>

## 계정 구조

모든
[`Account`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L48-L60)는
최대 크기가
[10MiB](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/system_instruction.rs#L85)이며
다음 정보를 포함합니다:

<WithMentions>

- [`lamports`](mention:lamports): 계정에 있는 [lamports](#lamports)의 수
- [`data`](mention:data): 계정의 [데이터](#data)
- [`owner`](mention:owner): 계정을 [소유](#owner)한 프로그램의 ID
- [`executable`](mention:executable): 계정이 [실행 가능한](#executable)
  바이너리를 포함하는지 여부를 나타냄
- [`rent_epoch`](mention:rent_epoch): 더 이상 사용되지 않는
  [rent epoch](#rent-epoch) 필드

```rust title="Account"
pub struct Account {
    /// lamports in the account
    // !mention lamports
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    // !mention data
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    // !mention owner
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    // !mention executable
    pub executable: bool,
    /// the epoch at which this account will next owe rent
    // !mention rent_epoch
    pub rent_epoch: Epoch,
}
```

</WithMentions>

<ScrollyCoding>

## !!steps Lamports

[lamport](/docs/references/terminology#lamport)로 표시된 계정의 잔액입니다.

모든 계정은 [rent](/docs/references/terminology#rent)라고 불리는 최소 lamport
잔액을 가져야 하며, 이를 통해 데이터를 온체인에 저장할 수 있습니다. Rent는 계정
크기에 비례합니다.

<Callout type="info">
  이 잔액이 rent라고 불리지만, 계정이 닫힐 때 전체 잔액을 회수할 수 있기 때문에
  보증금처럼 작동합니다. ("rent"라는 이름은 이제 더 이상 사용되지 않는 [rent
  epoch](#rent-epoch) 필드에서 유래되었습니다.)
</Callout>

([최소 잔액](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97)
공식과 적용 가능한
[상수](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L47-L70)를
참조하세요.)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    // !focus
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    // !focus
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps 데이터

이 필드는 일반적으로 "계정 데이터"라고 불립니다. 이 필드의 `data`는 어떤 바이트
시퀀스도 포함할 수 있기 때문에 임의적인 것으로 간주됩니다. 각 프로그램은 이
필드에 저장된 데이터의 구조를 정의합니다.

- Program account: 이 필드는 실행 가능한 프로그램 코드 또는 실행 가능한 프로그램
  코드를 저장하는 [program data account](#program-data-accounts)의 주소를
  포함합니다.
- 데이터 계정: 이 필드는 일반적으로 읽기 위한 상태 데이터를 저장합니다.

Solana 계정에서 데이터를 읽는 것은 두 단계로 이루어집니다:

1. [주소](#account-address)를 사용하여 계정 가져오기
2. 계정의 `data` 필드를 원시 바이트에서 계정을 소유한 프로그램이 정의한 적절한
   데이터 구조로 역직렬화하기

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    // !focus
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    // !focus
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    // !focus
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    // !focus
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps 소유자

이 필드는 계정 소유자의 프로그램 ID를 포함합니다.

모든 Solana 계정에는 소유자로 지정된 [프로그램](/docs/core/programs)이 있습니다.
계정의 소유자는 프로그램의 명령에 따라 계정의 `data`를 변경하거나 lamport를
차감할 수 있는 유일한 프로그램입니다.

(program account의 경우, 소유자는
[로더 프로그램](https://solana.com/docs/core/programs#loader-programs)입니다.)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    // !focus
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    // !focus
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps 실행 가능

이 필드는 계정이 [program account](#program-accounts)인지
[data account](#data-accounts)인지를 나타냅니다

- `true`인 경우: 계정은 program account입니다
- `false`인 경우: 계정은 data account입니다

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    // !focus
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    // !focus
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Rent epoch

**`rent_epoch` 필드는 더 이상 사용되지 않습니다.**

과거에는 이 필드가 계정이 rent를 지불해야 하는 시기를 추적했습니다. 그러나 이
rent 수금 메커니즘은 이후 폐지되었습니다.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    // !focus
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    // !focus
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

</ScrollyCoding>

## 계정 유형

계정은 두 가지 기본 카테고리로 나뉩니다:

- [Program accounts](#program-accounts): 실행 가능한 코드를 포함하는 계정
- [Data accounts](#data-accounts): 실행 가능한 코드를 포함하지 않는 계정

이러한 분리는 프로그램의 실행 가능한 코드와 상태가 별도의 계정에 저장된다는 것을
의미합니다. (일반적으로 프로그램과 해당 데이터에 대해 별도의 파일을 가지는 운영
체제와 유사합니다.)

### Program accounts

모든 프로그램은 [로더 프로그램](/docs/core/programs#loader-programs)이 소유하며,
이는 계정을 배포하고 관리하는 데 사용됩니다. 새로운
[프로그램](/docs/core/programs)이 배포될 때, [실행 가능한](#executable) 코드를
저장하기 위한 계정이 생성됩니다. 이를 program account라고 합니다. (간단히
말해서, program account를 프로그램 자체로 간주할 수 있습니다.)

아래 다이어그램에서 로더 프로그램이 program account를 배포하는 데 사용되는 것을
볼 수 있습니다. program account의 `data`에는 실행 가능한 프로그램 코드가
포함되어 있습니다.

![프로그램 계정, 그 4가지 구성 요소 및 로더 프로그램의 다이어그램.](/assets/docs/core/accounts/program-account-simple.svg)

#### Program data accounts

loader-v3를 사용하여 배포된 프로그램은 `data` 필드에 프로그램 코드를 포함하지
않습니다. 대신, 그들의 `data`는 프로그램 코드를 포함하는 별도의 **program data
account**를 가리킵니다. (아래 다이어그램 참조.)

![System 계정](/assets/docs/core/accounts/system-account.svg)

SOL이 처음으로 새 주소로 전송될 때, System Program이 소유한 계정이 해당 주소에
자동으로 생성됩니다.

아래 예제에서는 새 keypair가 생성되고 SOL로 자금이 지원됩니다. 코드를 실행하여
출력을 확인하세요. 계정의 `owner` 필드가 주소
`11111111111111111111111111111111`인 System Program임을 주목하세요.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  generateKeyPairSigner,
  lamports
} from "@solana/kit";

// Create a connection to Solana cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate a new keypair
const keypair = await generateKeyPairSigner();
console.log(`Public Key: ${keypair.address}`);

// Funding an address with SOL automatically creates an account
const signature = await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: keypair.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

const accountInfo = await rpc.getAccountInfo(keypair.address).send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";

// Generate a new keypair
const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);

// Create a connection to the Solana cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Funding an address with SOL automatically creates an account
const signature = await connection.requestAirdrop(
  keypair.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const accountInfo = await connection.getAccountInfo(keypair.publicKey);
console.log(JSON.stringify(accountInfo, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signer::{keypair::Keypair, Signer},
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate a new keypair
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());

    // Create a connection to Solana cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Funding an address with SOL automatically creates an account
    let signature = connection
        .request_airdrop(&keypair.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = connection.confirm_transaction(&signature).await?;
        if confirmed {
            break;
        }
    }

    let account_info = connection.get_account(&keypair.pubkey()).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

## Sysvar 계정

Sysvar 계정은 클러스터 상태 데이터에 접근할 수 있게 해주는 미리 정의된 주소에
있는 특별한 계정입니다. 이 계정들은 네트워크 클러스터에 관한 데이터로 동적으로
업데이트됩니다. Sysvar 계정의 전체 목록은
[여기](https://docs.anza.xyz/runtime/sysvars)에서 확인할 수 있습니다.

다음 예제는 Sysvar Clock 계정에서 데이터를 가져와 역직렬화하는 방법을
보여줍니다.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { createSolanaRpc } from "@solana/kit";
import { fetchSysvarClock, SYSVAR_CLOCK_ADDRESS } from "@solana/sysvars";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const accountInfo = await rpc
  .getAccountInfo(SYSVAR_CLOCK_ADDRESS, { encoding: "base64" })
  .send();
console.log(accountInfo);

// Automatically fetch and deserialize the account data
const clock = await fetchSysvarClock(rpc);
console.log(clock);
```

```ts !! title="Legacy"
import { Connection, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getSysvarClockCodec } from "@solana/sysvars";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const accountInfo = await connection.getAccountInfo(SYSVAR_CLOCK_PUBKEY);

// Deserialize the account data
const decodedClock = getSysvarClockCodec().decode(
  new Uint8Array(accountInfo?.data ?? [])
);
// !collapse(1:16) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
console.log(decodedClock);
```

```rs !! title="Rust"
use anyhow::Result;
use bincode::deserialize;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::sysvar::{self, clock::Clock};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let account = connection.get_account(&sysvar::clock::ID).await?;
    // Deserialize the account data
    let clock: Clock = deserialize(&account.data)?;

    println!("{:#?}", account);
    println!("{:#?}", clock);

    Ok(())
}
```

</CodeTabs>

## Program Account

Solana 프로그램을 배포하면 실행 가능한 program account가 생성됩니다. program
account는 프로그램의 실행 가능한 코드를 저장합니다. program account는
[로더 프로그램](/docs/core/programs#loader-programs)이 소유합니다.

![Program Account](/assets/docs/core/accounts/program-account-simple.svg)

간단히 말해서, program account를 프로그램 자체로 취급할 수 있습니다. 프로그램의
명령을 호출할 때, program account의 주소(일반적으로 "Program ID"라고 불림)를
지정합니다.

다음 예제는 Token Program 계정을 가져와 program account가 동일한 기본 `Account`
유형을 가지고 있음을 보여주지만, `executable` 필드가 `true`로 설정되어 있습니다.
program account는 데이터 필드에 실행 가능한 코드를 포함하고 있기 때문에,
데이터를 역직렬화하지 않습니다.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const programId = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address;

const accountInfo = await rpc
  .getAccountInfo(programId, { encoding: "base64" })
  .send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Connection, PublicKey } from "@solana/web3.js";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const programId = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

const accountInfo = await connection.getAccountInfo(programId);
// !collapse(1:17) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::pubkey;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let program_id = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let account_info = connection.get_account(&program_id).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

<Callout type="info">

Solana 프로그램을 배포할 때, 이는 program account에 저장됩니다. program
account는 [로더 프로그램](/docs/core/programs#loader-programs)이 소유합니다.
로더의 여러 버전이 있지만, loader-v3를 제외한 모든 버전은 실행 가능한 코드를
program account에 직접 저장합니다. loader-v3는 실행 가능한 코드를 별도의
"program data account"에 저장하고 program account는 단지 이를 가리킵니다. 새
프로그램을 배포할 때, Solana CLI는 기본적으로 최신 로더 버전을 사용합니다.

</Callout>

### 버퍼 계정

Loader-v3는 배포 또는 업그레이드 중에 프로그램 업로드를 임시로 준비하기 위한
특별한 계정 유형을 가지고 있습니다.

### 프로그램 데이터 계정

Loader-v3는 다른 모든 BPF 로더 프로그램과 다르게 작동합니다. program account는
실제 실행 가능한 코드를 저장하는 프로그램 데이터 계정의 주소만 포함합니다:

![프로그램 데이터 계정](/assets/docs/core/accounts/program-account-expanded.svg)

이러한 프로그램 데이터 계정을 프로그램의 데이터 계정(아래 참조)과 혼동하지
마세요.

## 데이터 계정

솔라나에서는 프로그램의 실행 코드가 프로그램의 상태와 다른 계정에 저장됩니다.
이는 운영 체제가 일반적으로 프로그램과 해당 데이터를 위한 별도의 파일을 가지는
방식과 유사합니다.

상태를 유지하기 위해 프로그램은 자신이 소유한 별도의 계정을 생성하는 명령을
정의합니다. 이러한 각 계정은 고유한 주소를 가지며 프로그램에 의해 정의된 임의의
데이터를 저장할 수 있습니다.

![데이터 계정](/assets/docs/core/accounts/data-account.svg)
