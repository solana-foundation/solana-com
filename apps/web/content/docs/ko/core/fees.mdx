---
title: 트랜잭션 수수료
description:
  Solana의 트랜잭션 수수료에 대해 알아보세요. 기본 수수료와 우선순위 수수료,
  각각의 적용 방법, 그리고 트랜잭션에서 컴퓨트 유닛을 관리하는 모범 사례를
  포함합니다.
---

모든 Solana 트랜잭션은 SOL로 지불하는 트랜잭션 수수료가 필요합니다. 트랜잭션
수수료는 기본 수수료와 우선순위 수수료 두 부분으로 나뉩니다. 기본 수수료는
트랜잭션 처리에 대해 validator에게 보상합니다. 우선순위 수수료는 현재 리더가
귀하의 트랜잭션을 처리할 가능성을 높이기 위한 선택적 수수료입니다.

## 기본 수수료

모든 트랜잭션은 포함된 서명당 5000
[lamports](/docs/references/terminology#lamport)의 비용이 듭니다. 이 수수료는
트랜잭션의 첫 번째 서명자가 지불하며 System Program이 소유한 계정에서 지불해야
합니다. 기본 수수료는 다음과 같이 분배됩니다:

- **50% 소각:** 절반은
  [소각](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)됩니다
  (유통 중인 SOL 공급량에서 제외).
- **50% 분배:** 절반은
  [트랜잭션을 처리한 validator에게 지급](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)됩니다.

## 우선순위 수수료

[우선순위 수수료](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)는
현재 리더(validator)가 귀하의 트랜잭션을 처리할 가능성을 높이기 위한 선택적
수수료입니다. validator는
[우선순위 수수료의 100%](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md)를
받습니다. 우선순위 수수료는 트랜잭션의
[컴퓨트 유닛](/docs/references/terminology#compute-units) (CU) 가격과 CU 한도를
조정하여 설정할 수 있습니다. (우선순위 수수료에 대한 자세한 내용은
[우선순위 수수료 사용 가이드](/developers/guides/advanced/how-to-use-priority-fees)를
참조하세요.)

우선순위 수수료는 다음과 같이 계산됩니다:

```text title="Prioritization fee formula"
Prioritization fee = CU limit * CU price
```

우선순위 수수료는 다른 트랜잭션과 비교하여
[트랜잭션의 우선순위](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646)를
결정하는 데 사용됩니다. 다음 공식을 사용하여 계산됩니다:

```text title="Transaction priority formula"
Priority = (Prioritization fee + Base fee) / (1 + CU limit + Signature CUs + Write lock CUs)
```

#### 컴퓨트 유닛 한도

[기본적으로](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
각 명령어에는
[200,000 CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)가
할당되고 각 트랜잭션에는
[1.4백만 CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14)가
할당됩니다. 트랜잭션에
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
명령어를 포함시켜 이러한 기본값을 변경할 수 있습니다.

트랜잭션에 적합한 컴퓨트 유닛 한도를 계산하기 위해 다음 단계를 권장합니다:

1. 트랜잭션을
   [시뮬레이션](/developers/guides/advanced/how-to-request-optimal-compute)하여
   필요한 컴퓨트 유닛을 추정합니다
2. 이 추정치에 10%의 안전 마진을 추가합니다

<Callout type="warn">
  우선순위 수수료는 실제 사용된 컴퓨트 유닛 수가 아닌, 요청된 컴퓨트 유닛 한도
  트랜잭션에 의해 결정됩니다. 컴퓨트 유닛 한도를 너무 높게 설정하거나 기본 값을
  사용하면 사용하지 않은 컴퓨트 유닛에 대해 비용을 지불할 수 있습니다.
</Callout>

#### 컴퓨트 유닛 가격

컴퓨트 유닛 가격은 요청된 각 CU에 대해 지불하는 선택적인
[마이크로-램포트](/docs/references/terminology#micro-lamports) 금액입니다. CU
가격은 validator가 귀하의 트랜잭션에 우선순위를 부여하도록 장려하는 팁으로
생각할 수 있습니다. CU 가격을 설정하려면 트랜잭션에
[ComputeBudgetProgram.setComputeUnitPrice](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
명령어를 포함하세요.

<Callout>
  기본 CU 가격은 0이며, 이는 기본 우선순위 수수료도 0임을 의미합니다.
</Callout>

트랜잭션에 가장 적합한 CU 가격을 결정하는 데 도움이 필요하면, 아래 표에 나열된
실시간 CU 가격 추천을 참조하세요.

| 제공자                                  | 우선순위 수수료 API                                                      |
| --------------------------------------- | ------------------------------------------------------------------------ |
| [Helius](https://www.helius.dev/)       | [문서](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [문서](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [문서](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### 예시

아래 예시는 Solana SDK를 사용하여 트랜잭션에 CU 한도와 CU 가격을 설정하는 방법을
보여줍니다.

| SDK                          | 소스 코드 참조                                                                                                               |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| @solana/web3.js (Typescript) | [ComputeBudgetProgram](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| solana-sdk (Rust)            | [ComputeBudgetInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
