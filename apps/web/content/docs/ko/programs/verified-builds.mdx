---
title: 프로그램 검증하기
description:
  검증된 빌드는 프로그램을 소스 코드에 연결하고 모든 사람이 제공된 소스 코드에서
  실제로 프로그램이 빌드되었는지 독립적으로 확인할 수 있게 해주는 방법입니다.
---

이 가이드는 솔라나에서 자신의 프로그램에 대한 검증된 빌드를 구현하고자 하는
개발자를 위한 참고 자료입니다. 검증된 빌드가 무엇인지, 어떻게 사용하는지, 특별한
고려사항 및 온체인 프로그램의 신뢰성을 보장하기 위한 모범 사례를 다룰 것입니다.

# 검증된 빌드란 무엇인가요?

검증된 빌드는 솔라나 네트워크에 배포하는 실행 가능한 프로그램이 저장소의 소스
코드와 일치하는지 확인합니다. 이를 통해 개발자와 사용자는 온체인에서 실행되는
프로그램이 공개 코드베이스와 정확히 일치한다는 확신을 가질 수 있어 투명성과
보안을 촉진합니다.

검증 과정은 온체인 프로그램의 해시와 소스 코드에서 로컬로 빌드된 프로그램의
해시를 비교하는 것을 포함합니다. 이는 두 버전 간에 불일치가 없음을 보장합니다.

> 검증된 빌드가 검증되지 않은 빌드보다 더 안전하다고 간주되어서는 안 되지만, 이
> 빌드는 개발자가 소스 코드가 온체인에 배포된 것과 일치하는지 스스로 확인할 수
> 있게 합니다. 소스 코드를 사용하여 개발자는 트랜잭션을 보낼 때 코드가 실행하는
> 내용을 검증할 수 있습니다.

검증된 빌드 파이프라인은 [Ellipsis Labs](https://ellipsislabs.xyz/)와
[OtterSec](https://osec.io/)에 의해 고안되고 유지되고 있습니다. 자세한 내용은
[원본 검증된 빌드](https://github.com/Ellipsis-Labs/solana-verifiable-build)
저장소의 가이드를 따르고, 지원되면 [Anza](https://www.anza.xyz/) 도구 모음에
직접 빌드 프로세스를 검증하세요.

# 어떻게 작동하나요?

검증 프로세스는 온체인 프로그램의 해시와 소스 코드에서 로컬로 빌드된 프로그램의
해시를 비교하여 수행됩니다. Solana Verify CLI와 Docker를 사용하여 제어된
환경에서 프로그램을 빌드합니다. 이를 통해 빌드 프로세스가 다양한 시스템에서
결정적이고 일관되게 유지됩니다. 실행 파일을 얻은 후에는 Solana 네트워크에 배포할
수 있습니다. 빌드 프로세스 중에
[verify 프로그램](https://github.com/otter-sec/otter-verify)의
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)가
생성됩니다. 이 PDA에는 프로그램을 검증하는 데 필요한 모든 데이터가 포함되어
있습니다. PDA에는 프로그램 주소, git URL, 커밋 해시 및 프로그램을 빌드하는 데
사용된 인수가 포함됩니다.

PDA의 데이터를 사용하여 누구나 로컬에서 verify 프로그램 명령을 실행하고
프로그램이 제공된 소스 코드에서 빌드되었는지 확인할 수 있습니다. 그런 다음 모든
사람이 완전히 신뢰 없이 직접 검증하거나
[OtterSec](https://github.com/otter-sec)에서 유지 관리하는 자체
[verify API](https://github.com/otter-sec/solana-verified-programs-api)를
실행하여 사용자가 검증을 쉽게 확인할 수 있는 접근점을 제공할 수 있습니다. 이미
[Solana Explorer](https://explorer.solana.com/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/verified-build)와
[SolanaFM](https://solana.fm/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/transactions?cluster=mainnet-alpha)
등 여러 곳에서 이러한
[API 호출](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)이
사용되는 것을 볼 수 있습니다.

# 왜 검증된 빌드를 사용해야 하나요?

검증된 빌드를 사용하면 다음과 같은 이점이 있습니다:

- 보안: 온체인에서 실행 중인 프로그램이 소스 코드와 일치하는지 보장하여 악의적인
  변경을 방지합니다.

- 투명성: 다른 사용자와 개발자가 온체인 프로그램을 공개 코드베이스와 비교하여
  신뢰할 수 있는지 검증할 수 있습니다.

- 신뢰: 검증된 빌드는 프로그램의 온체인 동작이 공개 코드와 일치함을 보여주므로
  사용자 신뢰도를 높입니다. 검증 가능한 프로그램을 구축할 때 승인되지 않거나
  악의적인 코드 실행과 관련된 위험을 최소화합니다. 또한 모범 사례를 준수하고
  보안 연구원이 쉽게 연락할 수 있는 방법을 제공합니다. 또한 지갑 및 기타 도구는
  프로그램이 검증되는 한 해당 프로그램의 트랜잭션을 더 쉽게 허용할 수 있습니다.

- 발견 가능성: 프로그램의 검증된 빌드를 제공하면 모든 사람이 소스 코드, 문서,
  프로그램 SDK 또는 IDL을 찾을 수 있으며, 문제가 있을 경우 GitHub을 통해 쉽게
  연락할 수 있습니다.

# 검증된 빌드는 어떻게 만드나요?

검증된 빌드를 만들려면 다음 단계를 따라야 합니다:

요약:

- 코드를 공개 저장소에 커밋하기
- Docker에서 검증된 빌드 만들기
- 검증된 빌드 배포하기
- 배포된 프로그램을 공개 API와 대조하여 검증하기

Docker 컨테이너에서 빌드되지 않은 프로그램을 검증하려고 하면 대부분 실패할
것입니다. 이는 Solana 프로그램 빌드가 서로 다른 시스템에서 결정적이지 않기
때문입니다.

<Steps>
<Step>

### Docker와 Cargo 설치하기

필요한 도구를 설치하고 Docker와 Cargo가 설치되어 있는지 확인하세요. Docker는
일관성을 보장하기 위한 제어된 빌드 환경을 제공하며, Cargo는 Rust 패키지 관리에
사용됩니다.

- Docker: [Docker 웹사이트](https://docs.docker.com/engine/install/)에서
  플랫폼에 맞는 Docker 설치 단계를 따르세요. 설치 후, 이 가이드를 계속 따라
  Docker 서비스가 실행 중인지 확인하세요.
- Cargo: 아직 Cargo가 설치되어 있지 않다면, 다음 명령어를 실행하여 설치할 수
  있습니다:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

</Step>
<Step>

### Solana Verify CLI 설치하기

Solana Verify CLI는 빌드를 검증하는 데 사용되는 주요 도구입니다. Solana Verify
CLI는 현재 [Ellipsis Labs](https://ellipsislabs.xyz/)에서 유지 관리하고 있으며
Cargo를 사용하여 설치할 수 있습니다.

다음 명령어를 실행하여 설치할 수 있습니다:

```bash
cargo install solana-verify
```

특정 버전의 CLI가 필요한 경우, 다음과 같이 버전을 지정할 수 있습니다:

```bash
cargo install solana-verify --version $VERSION
```

원하는 경우, 특정 커밋에서 직접 버전을 설치할 수 있습니다:

```bash
cargo install solana-verify --git https://github.com/Ellipsis-Labs/solana-verifiable-build --rev 13a1db2
```

</Step>
<Step>

### 프로젝트 준비

저장소에 대해 검증하려면 저장소의 루트 디렉토리에 `Cargo.lock` 파일이 있어야
합니다. 저장소에 프로그램이 하나만 있고 루트에 `cargo.lock` 파일이 있다면 다음
단계로 바로 이동하여 프로그램을 빌드할 수 있습니다.

프로그램이 하위 폴더에 있고 러스트 워크스페이스가 있다면 저장소의 루트
디렉토리에 워크스페이스 `Cargo.toml` 파일을 생성해야 합니다.

다음 `Cargo.toml` 예제를 프리셋으로 사용할 수 있습니다:

```toml title="Cargo.toml"
[workspace]
members = ["program/programs/*"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1

[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
```

프로그램이 `workspace/members` 배열에 포함되어 있고 프로그램의 `Cargo.toml`에
올바른 `lib` 이름이 구성되어 있는지 확인하세요.

> 중요한 것은 패키지 이름이 아닌 `lib name`입니다!

다음과 같이 구성됩니다:

```toml title="waffle/Cargo.toml"
[package]
name = "waffle"
version = "0.1.0"
edition = "2021"

[lib]
name = "waffle"
crate-type = ["cdylib", "lib"]

[dependencies]
solana-program = "2.1.0"
```

이 [저장소](https://github.com/solana-developers/verified-program)에서 하위
폴더에 프로그램이 있는 워크스페이스의 예를 볼 수 있습니다. 또한 프로그램이 하위
폴더에 있을 때는 나중에 이 폴더를 `verify-from-repo` 명령에 `--mount-path`로
추가해야 합니다.

이 [저장소](https://github.com/solana-developers/solana-game-preset)에서 Anchor
예제를 찾을 수 있습니다. 이
[저장소](https://github.com/solana-developers/verified-program-root)에서는
네이티브 러스트 예제를 찾을 수 있습니다.

이 `Cargo.toml` 파일을 준비한 후 `cargo generate-lockfile`를 실행하여 잠금
파일을 생성하고 프로그램 빌드를 계속할 수 있습니다.

</Step>
<Step>

### 검증 가능한 프로그램 빌드하기

Solana 프로그램을 검증 가능하게 빌드하려면 워크스페이스의 `Cargo.toml` 파일이
있는 디렉토리로 이동하여 다음을 실행하세요:

```bash
solana-verify build
```

이렇게 하면 환경이 도커 컨테이너로 복사되어 결정적인 방식으로 빌드됩니다.

> 실제로 검증된 빌드를 배포하고 `anchor build` 또는 `cargo build-sbf`로 실수로
> 덮어쓰지 않도록 주의하세요. 이러한 명령은 대부분 동일한 해시를 생성하지 않아
> 검증이 실패할 가능성이 높습니다.

여러 프로그램이 있는 프로젝트의 경우, 라이브러리 이름(패키지 이름이 아님)을
사용하여 특정 프로그램을 빌드할 수 있습니다:

```bash
solana-verify build --library-name $PROGRAM_LIB_NAME
```

이 과정은 결정적 빌드를 보장하며, 특히 특정 시스템(예: M1 맥북)에서는 도커
컨테이너 내에서 실행되기 때문에 시간이 걸릴 수 있습니다. 더 빠른 빌드를 위해서는
x86 아키텍처를 실행하는 리눅스 머신을 사용하는 것이 좋습니다.

빌드가 완료되면 다음 명령어를 사용하여 실행 파일의 해시를 검색할 수 있습니다:

```bash
solana-verify get-executable-hash target/deploy/$PROGRAM_LIB_NAME.so
```

</Step>
<Step>

### 검증 가능한 프로그램 배포하기

프로그램을 빌드하고 해시를 검색한 후에는 Solana 네트워크에 배포할 수 있습니다.
안전한 배포를 위해 [Squads Protocol](https://squads.so/protocol)과 같은 다중
서명 또는 거버넌스 솔루션을 사용하는 것이 좋지만, 다음과 같이 직접 배포할 수도
있습니다:

```bash
solana program deploy -u $NETWORK_URL target/deploy/$PROGRAM_LIB_NAME.so --program-id $PROGRAM_ID --with-compute-unit-price 50000 --max-sign-attempts 100 --use-rpc
```

현재 적합한 낮은 우선순위 수수료는
[Quicknode](https://www.quicknode.com/gas-tracker/solana)와 같은 RPC
제공업체에서 요청할 수 있습니다.

배포된 프로그램이 빌드된 실행 파일과 일치하는지 확인하려면 다음을 실행하세요:

```bash
solana-verify get-program-hash -u $NETWORK_URL $PROGRAM_ID
```

> 다른 [Solana 클러스터](/docs/references/clusters)(예: devnet, testnet,
> mainnet)에 다른 버전이 배포되어 있을 수 있습니다. 프로그램을 검증하려는 Solana
> 클러스터에 맞는 올바른 네트워크 URL을 사용하세요. 원격 검증은 메인넷에서만
> 작동합니다.

</Step>
<Step>

### 저장소에 대한 검증

공개 저장소에 대해 프로그램을 검증하려면 다음을 사용하세요:

```bash
solana-verify verify-from-repo -u $NETWORK_URL --program-id $PROGRAM_ID https://github.com/$REPO_PATH --commit-hash $COMMIT_HASH --library-name $PROGRAM_LIB_NAME --mount-path $MOUNT_PATH
```

> 프로그램 디렉토리에서 검증된 빌드를 실행하는 동안, `verify-from-repo`를 실행할
> 때는 `--mount-path` 플래그를 추가해야 합니다. 이것은 프로그램의 라이브러리
> 이름이 포함된 `Cargo.toml` 파일이 있는 폴더의 경로가 됩니다.

이 명령은 온체인 프로그램 해시와 지정된 커밋 해시의 소스에서 빌드된 실행 파일
해시를 비교합니다.

명령 마지막에 검증 데이터를 온체인에 업로드할지 물어볼 것입니다. 업로드하면
Solana 익스플로러에 즉시 프로그램의 검증 데이터가 표시됩니다. 원격 빌드로 검증될
때까지는 미검증 상태로 표시됩니다. 다음 단계에서 공개 API를 통해 프로그램을
검증하는 방법을 알아보세요.

특정 릴리스에 검증을 고정하려면 명령에 `--commit-hash` 플래그를 추가하면 됩니다.

</Step>
<Step>

### 공개 API를 통한 검증

마지막으로 검증 API를 실행하는 누구에게나 직접 프로그램을 검증할 수도 있습니다:

```bash
solana-verify verify-from-repo --remote -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

> 무료 RPC의 속도 제한에 걸릴 수 있으므로 유료 RPC URL을 사용하는 것이 좋습니다.
> 따라서 `-um` 대신 더 안정적인 검증을 위해 `--url yourRpcUrl`를 사용해야
> 합니다.

`--remote` 플래그는 OtterSec API에 빌드 요청을 보내 프로그램의 원격 빌드를
트리거합니다. 빌드가 완료되면 시스템은 프로그램의 온체인 해시가 저장소에서
생성된 빌드 아티팩트의 해시와 일치하는지 확인합니다.

기본값은
[OtterSec API](https://github.com/otter-sec/solana-verified-programs-api)입니다.

검증 데이터를 온체인에 업로드할지 물어볼 때 '예'를 선택하세요. 이는 API가 검증
데이터를 업로드했는지 확인하는 데 사용됩니다.

다음을 사용하여 수동으로 원격 작업을 트리거할 수도 있습니다:

```bash
solana-verify remote submit-job --program-id <program-id> --uploader <address>
```

업로더는 PDA에 쓰기 권한이 있는 주소입니다. 대부분의 경우 프로그램 권한이어야
합니다. 만약 프로그램이 멀티시그에 의해 제어되는 경우, 이 가이드 아래의
[멀티시그 검증](#how-to-verify-your-program-when-its-controlled-by-a-multisig-like-squads)
부분을 계속 진행하세요.

이것은 OtterSec API에 작업을 제출하고 다음 명령으로 작업 상태를 확인할 수
있습니다:

```bash
solana-verify remote get-job-status --job-id <job-id>
```

검증이 성공적으로 완료되면(시간이 다소 걸릴 수 있음), 프로그램이 검증된 것을
다음에서 확인할 수 있습니다:
[단일 프로그램용 OtterSec API](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY),
[Solana 익스플로러](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY/verified-build),
[SolanaFM](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY?cluster=mainnet-alpha),
[SolScan](https://solscan.io/account/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY#programVerification),
그리고 결국 [0xDeep](https://x.com/0xDeep)이 유지 관리하는 커뮤니티 운영
웹사이트인 [SolanaVerify.org](https://www.solanaverify.org/)와
[OtterSec 검증 프로그램 API](https://verify.osec.io/verified-programs),
마지막으로
[검증된 프로그램 Dune 대시보드](https://dune.com/jonashahn/verified-programs/dedf21e1-9b71-42c8-89f9-02ed94628657)에서도
확인할 수 있으며, 이는 더 건강한 Solana 생태계에 기여합니다.

</Step>
</Steps>

## Squads와 같은 멀티시그에 의해 제어되는 프로그램을 검증하는 방법

원격 검증이 작동하려면 프로그램 권한에 의해 서명된 PDA에 검증 데이터를 작성해야
합니다. 프로그램이 멀티시그에 의해 제어되는 경우, 이 PDA 작성 트랜잭션을
내보내고 [Squads Protocol](https://squads.so/protocol) 또는 다른 멀티시그
솔루션을 통해 제출할 수 있습니다.

<Steps>
<Step>

### 1. 검증 가능한 프로그램 빌드하기

먼저 프로그램을 빌드합니다:

```bash
solana-verify build
```

이것은 `Cargo.lock` 파일에 지정된 솔라나 버전을 사용하여 도커 컨테이너를 통해
검증 가능한 빌드를 생성합니다.

</Step>
<Step>

### 2. 프로그램 배포하기

```bash
solana config set --url "PayedMainnetRPCAddress" // the public endpoint will be rate limited too much
solana program deploy target/deploy/verify_squads.so
```

이 멀티시그 가이드의 나머지 부분에서는 예시 프로그램 ID로
`6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`를 사용할 것입니다.

</Step>
<Step>

### 3. 저장소에 커밋하고 검증하기

완료되면 프로젝트를 깃허브에 커밋합니다. 다음은 예시입니다:
https://github.com/solana-developers/verify-squads

선택 사항: 먼저 로컬에서 검증이 가능한지 확인해보세요 (이 명령은 예시 프로그램
ID를 사용합니다 `6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`):

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
```

매개변수가 올바른지 확인하기 위함입니다.

</Step>
<Step>

### 4. 프로그램 권한을 멀티시그으로 이전하기

아직 프로그램 권한을 멀티시그으로 이전하지 않았다면 멀티시그 권한을 복사하세요.
다음 단계에서 필요합니다.

</Step>
<Step>

### 5. PDA 트랜잭션 내보내기

프로그램 권한을 로컬에서 가지고 있을 때 `solana-verify verify-from-repo` 명령을
사용하면 빌드 데이터를 온체인에 업로드하라는 메시지가 표시됩니다.

멀티시그을 사용할 때는 이 작업을 수행할 수 없으므로 PDA 트랜잭션을 수동으로
내보낸 다음 Squads를 통해 트랜잭션을 실행해야 합니다.

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader <your program authority> --encoding base58 --compute-unit-price 0
```

이 명령은 base58 트랜잭션을 반환합니다. 트랜잭션 검사기에서 사용할 base64로
인코딩된 트랜잭션이 필요하다면 `--encoding base64`를 사용할 수 있습니다.

```bash
P6vBfcPaaXb8fZoT3NBAYEcdtEj7tubA1k2gBxmFKZ3UWF5YyrmDMFTvLKALCJoUuRsPAjMckudYruCu3eeWQtuDrFbEMLxLFutnKXac974fnkMivcwUdY66VLjbxQT6ATmcy7F4hBtz1G4P1h6iBJLhb8WtrtgY3i4qq45MUEb7RjuMEfUFXKrNgPdGxkz5xvMHq3dxKRcpmEK5k2DkeW6SUQYBVe19Ga3B9GyhTX8k3CMt9JCEah13WyRnQd8GjoK6sTEvGJym6xDNvmd8yiJYSNcaYwEJsjHEUf4Yh6kAC7ki2KRvVAr3NVe1gjqK9McrwSQjtUatvydTG8Zovcr7PPUEMf3yPMgKXjZLB2QpkH63yTTYdNAnWFuv9E6b6nYRqye5XcNi436yKw5U14fXh65yK34bgYLi9328UT1huJELsJU9BRGnGUmb6GWp6c2WL5BhnzgNTSnt9TXFfEgUMzhvKzpVBxLP44hwqqBdyUhHFysCF37531PnmiESq8x1xou23xJ6FcQbc199754MkqQd7tX9CUznGzAEqHGkzn3VBoJnojsKtgYmiTYbdRsT1CU18MbYEE7WvGAvXyxxbpNzbAcc94HrnM6cqRGmwhEBroPfFghTdmzg9D
```

</Step>
<Step>

### 6. Squads를 통해 트랜잭션 제출하기

Squads 트랜잭션 빌더로 이동하여 base58로 인코딩된 트랜잭션을 가져옵니다.
시뮬레이션에서 트랜잭션이 osec 검증 프로그램과 컴퓨터 예산 프로그램에만 호출하고
다른 것은 없는지 확인하세요!

</Step>
<Step>

### 7. 원격 검증 작업 제출하기

Squads에 트랜잭션이 성공적으로 제출되면 원격 작업을 제출할 수 있습니다:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
--uploader <your program authority>
```

이것으로 완료되었습니다! 공개 저장소에 대해 프로그램을 검증하고 OtterSec API에
원격 작업을 제출했습니다. 이제 솔라나 익스플로러와 다른 곳에서 반영된 것을
확인할 수 있을 것입니다.

</Step>
<Step>

### 8. 프로그램 업데이트하기 (선택사항)

프로그램을 업데이트할 때는 새로운 PDA 트랜잭션을 내보내고 Squads를 통해 다시
제출해야 합니다.

프로그램 업데이트 방법:

```bash
solana-verify build
solana program write-buffer target/deploy/verify_squads.so --with-compute-unit-price 50000 --max-sign-attempts 50
```

그런 다음 해당 버퍼 권한을 멀티시그로 이전하거나 멀티시그의 권한으로 직접 버퍼를
생성합니다.

```bash
solana program set-buffer-authority Fu3k79g53ZozAj47uq1tXrFy4QbQYh7y745DDsxjtyLR --new-buffer-authority 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

</Step>
<Step>

### 9. 새 PDA 트랜잭션 내보내기 및 제출하기

변경 사항을 깃허브에 커밋하는 것을 잊지 마세요. PDA 업그레이드 트랜잭션을 다시
내보냅니다:

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

Squads를 통해 트랜잭션을 다시 제출하세요.

예시 트랜잭션은
[여기](https://solana.fm/tx/4zJ1vK2KToAwxuEYzTMLqPkcebjoi9rdeeyxtEEx9L5Q4vWDA8h6Rr4kPRuRxcV7ZLKMr6qx1LTWb6x3ZpUJaFUW?cluster=mainnet-alpha)에서
확인할 수 있습니다.

그런 다음 원격 빌드를 다시 제출하세요:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

다음과 같은 결과가 나와야 합니다:

```shell
Verification request sent with request id: b63339d2-163e-49ac-b55d-3454c1c2b5b3
Verification in progress... ⏳ [00:18:02] ✅ Process completed. (Done in 18
minutes) Program 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD has been verified.
✅ The provided GitHub build matches the on-chain hash. On Chain Hash:
96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Executable
Hash: 96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Repo URL:
https://github.com/Woody4618/verify-squads/tree/0fb0a2e30c15c51732c0ad5e837975a6f7bbc7ed
Check the verification status at:
https://verify.osec.io/status/6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD Job
url: https://verify.osec.io/job/b63339d2-163e-49ac-b55d-3454c1c2b5b3
```

축하합니다! 멀티시그 업그레이드 후 프로그램을 검증했습니다!

</Step>
</Steps>

## 도커 이미지에서 검증하기

다음 명령을 실행하여 도커 이미지로 프로그램을 검증할 수도 있습니다:

```bash
solana-verify verify-from-image -e
examples/hello_world/target/deploy/hello_world.so -i
ellipsislabs/hello_world_verifiable_build:latest -p
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn
```

이 명령은 `ellipsislabs/hello_world_verifiable_build:latest`에 저장된 이미지를
로드하고, 컨테이너 내 실행 파일 경로의 해시가 명령에 제공된 온체인 프로그램의
해시와 동일한지 확인합니다. 빌드가 이미 이미지에 업로드되었기 때문에 오랜 시간이
걸릴 수 있는 실행 파일의 전체 재빌드가 필요하지 않습니다.

`ellipsislabs/hello_world_verifiable_build:latest` 이미지를 생성하는
Dockerfile은 Ellipsis Labs 저장소
[/examples/hello_world](https://github.com/Ellipsis-Labs/solana-verifiable-build/tree/master/examples/hello_world)에서
찾을 수 있습니다.

아래는 예상되는 출력 결과입니다:

```bash
Verifying image: "ellipsislabs/hello_world_verifiable_build:latest", on network
"https://api.mainnet-beta.solana.com" against program ID
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn Executable path in container:
"examples/hello_world/target/deploy/hello_world.so"

Executable hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Program hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Executable
matches on-chain program data ✅
```

## 검증된 빌드 예시

다음은 ID가 `FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv`인 예제 프로그램을 이
[저장소](https://github.com/solana-developers/verified-program)의 소스 코드를
사용하여 검증하는 예시입니다:

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

기본적으로 `verify-from-repo` 명령은 메인 브랜치의 마지막 커밋을 사용합니다.
저장소에서 계속 작업하려는 경우 `commit-hash` 매개변수를 사용하여 특정 커밋을
지정할 수도 있습니다: `--commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e`

마지막으로 OtterSec API를 통해 직접 프로그램을 검증할 수도 있습니다:

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --remote --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

`--remote` 명령은 OtterSec API에 빌드 요청을 보내고, 이는 프로그램의 원격 빌드를
트리거합니다. 빌드가 완료되면, 시스템은 체인상의 프로그램 해시가 저장소에서
생성된 빌드 결과물의 해시와 일치하는지 확인합니다.

## 이미 검증된 인기 프로그램들

### Phoenix

```shell
solana-verify verify-from-repo -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

최종 출력:

```shell
Executable Program Hash from repo: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
On-chain Program Hash: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
Program hash matches ✅
```

### Squads V3

```shell
solana-verify verify-from-repo https://github.com/Squads-Protocol/squads-mpl --commit-hash c95b7673d616c377a349ca424261872dfcf8b19d --program-id SMPLecH534NA9acpos4G6x7uf3LWbCAwZQE9e8ZekMu -um --library-name squads_mpl --bpf
```

> Squads 저장소에는 여러 프로그램이 포함되어 있기 때문에 `library-name`를
> 지정해야 했습니다. `squads_mpl`가 이전에 Anchor로 검증되었기 때문에 `--bpf`
> 플래그를 사용합니다.

최종 출력:

```shell
Executable Program Hash from repo: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
On-chain Program Hash: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
Program hash matches ✅
```

### Drift V2

```shell
solana-verify verify-from-repo -um --program-id dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH https://github.com/drift-labs/protocol-v2 --commit-hash 110d3ff4f8ba07c178d69f9bfc7b30194fac56d6 --library-name drift
```

최종 출력:

```shell
Executable Program Hash from repo: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
On-chain Program Hash: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
Program hash matches ✅
```

### Marginfi V2

```shell
solana-verify verify-from-repo -um --program-id MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA https://github.com/mrgnlabs/marginfi-v2 --commit-hash d33e649e415c354cc2a1e3c49131725552d69ba0 --library-name marginfi -- --features mainnet-beta
```

최종 출력:

```shell
Executable Program Hash from repo: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
On-chain Program Hash: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
Program hash matches ✅
```

# 결론

[Solana에서의 검증된 빌드](/developers/guides/advanced/verified-builds)를
사용하면 네트워크에서 프로그램의 무결성과 신뢰성을 보장하고 개발자가 Solana
익스플로러에서 직접 SDK를 찾을 수 있습니다. Solana Verify CLI와 Docker와 같은
도구를 활용하여 소스 코드와 일치하는 검증 가능하고 안전한 빌드를 유지할 수
있습니다. 항상 일관된 환경을 사용하기 위해 필요한 예방 조치를 취하고, 안전한
업그레이드와 배포를 위한 거버넌스 솔루션을 고려하세요.

## 보안 + 면책 조항

검증된 빌드는 Solana 프로그램의 무결성을 보장하는 강력한 도구이지만 기본
설정에서는 완전히 무신뢰(trustless)하지는 않습니다. Docker 이미지는 Solana
재단에서 빌드하고 호스팅합니다.

프로젝트를 다운로드한 Docker 이미지에서 빌드하고 잠재적으로 민감한 정보를 포함한
전체 설정이 해당 Docker 이미지에 복사된다는 점을 유의하세요.

완전히 무신뢰 설정을 원한다면 Docker 이미지를 직접 빌드하고 자체 인프라에서
호스팅할 수 있습니다. 이렇게 하면 Docker 이미지가 변조되지 않았음을 확신할 수
있습니다. 자체 Docker 이미지를 만들기 위한 스크립트는
[검증된 빌드 저장소](https://github.com/Ellipsis-Labs/solana-verifiable-build)에서
찾을 수 있으며, 이를 포크하여 직접 GitHub 액션을 실행하거나 올바른지 검증할 수
있습니다.

또한 원격 검증의 경우 OtterSec API와
[Solana 익스플로러](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)를
어느 정도 신뢰해야 합니다.

API 또는 Solana 익스플로러가 손상된 경우 잘못된 정보를 표시할 가능성이 있습니다.

완전히 무신뢰 설정을 원한다면
[Verify API](https://github.com/otter-sec/solana-verified-programs-api)를 직접
실행하거나 `verify-from-repo` 명령을 사용하여 로컬에서 프로그램 검증을 직접
실행할 수 있습니다. 이는 프로그램의 배포 권한과
[검증 프로그램](https://explorer.solana.com/address/verifycLy8mB96wd9wqq3WDXQwM4oU6r42Th37Db9fC)에서
파생된
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)에
저장된 온체인 검증 데이터를 사용합니다.

검증 프로그램은 [OtterSec 팀](https://osec.io/)에 의해 배포되었으며 아직
고정되지 않아 언제든지 업그레이드될 수 있습니다.

Solana 재단, OtterSec 및 Ellipsis Labs 팀은 검증된 빌드 파이프라인을 사용하면서
발생할 수 있는 손실이나 손해에 대해 책임을 지지 않습니다.

# Solana 프로그램을 위한 Security.txt

검증된 빌드 외에도 `security.txt` 파일을 프로그램에 추가할 수 있습니다. 향후
구현되면, `security.txt`는 검증 PDA에 저장된 검증 데이터에 쉽게 접근할 수 있도록
검증자 pubkey를 보관합니다. 프로그램을 빌드하고 검증하는 데 필요한 모든 정보를
포함하는 PDA는 프로그램 주소와 검증자 pubkey에서 파생됩니다. 기본적으로 이는
프로그램을 빌드하고 배포한 동일한 pubkey입니다. 그러나 `security.txt`에 지정할
수 있는 다른 pubkey일 수도 있습니다.

`security.txt` 기능을 통해 개발자는 연락처 및 보안 정보를 Solana 스마트
컨트랙트에 직접 포함시킬 수 있습니다.
[securitytxt.org](https://securitytxt.org)에서 영감을 받은 이 접근 방식은 보안
연구원이 컨트랙트 주소만 알고 있어도 프로젝트 관리자에게 연락할 수 있는 표준화된
방법을 제공합니다.

## security.txt를 사용하는 이유는 무엇인가요?

특히 소규모 또는 비공개 프로젝트의 경우, 컨트랙트 주소만으로 개발자를 식별하는
것은 어렵고 시간이 많이 소요될 수 있습니다. 프로그램 내에 `security.txt` 파일을
포함시키면 보안 연구원이 올바른 사람에게 쉽게 연락할 수 있어, 잠재적인 취약점
악용을 방지하고 시기적절한 버그 보고를 보장할 수 있습니다.

## security.txt 구현 방법

Solana 프로그램에 `security.txt`를 추가하려면 다음 단계를 포함하세요:

`solana-security-txt` 의존성을 `Cargo.toml`에 추가하세요:

```toml title="Cargo.toml"
[dependencies]
solana-security-txt = "1.1.1"
```

계약에서 `security_txt!` 매크로를 사용하여 보안 정보를 정의하세요. 연락처 정보,
프로젝트 URL, 심지어 보안 정책까지 포함할 수 있습니다. 다음은 예시입니다:

```rust
#[cfg(not(feature = "no-entrypoint"))]
use {default_env::default_env, solana_security_txt::security_txt};

#[cfg(not(feature = "no-entrypoint"))]
security_txt! {
    name: "MyProject",
    project_url: "https://myproject.com",
    contacts: "email:security@myproject.com,discord:security#1234",
    policy: "https://myproject.com/security-policy",

    // Optional Fields
    preferred_languages: "en,de",
    source_code: "https://github.com/solana-developers/solana-game-preset",
    source_revision: "5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    source_release: "",
    encryption: "",
    auditors: "Verifier pubkey: 5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    acknowledgements: "Thank you to our bug bounty hunters!"
}
```

`security.txt` 정보가 프로그램에 내장되면 Solana 익스플로러와 같은 도구를 통해
쉽게 조회할 수 있어, 잠재적인 문제를 보고하려는 사람들에게 연락처와 보안 세부
정보를 제공할 수 있습니다.

## 모범 사례

- 링크 사용: 변경될 가능성이 있는 정보(예: 연락처 정보)의 경우, 계약에
  하드코딩하는 대신 웹 페이지로 링크하는 것이 좋습니다. 이렇게 하면 프로그램을
  자주 업그레이드할 필요가 없습니다.

- 검증: 배포하기 전에 `query-security-txt` 도구를 사용하여 형식과 내용을
  확인하세요. 이 도구는 온체인 프로그램과 로컬 바이너리 모두 검증할 수 있습니다:

```bash
query-security-txt target/bpfel-unknown-unknown/release/my_contract.so
```

보안 연락처 정보를 계약에 직접 내장함으로써 연구자들이 쉽게 연락할 수 있게 하여
Solana 생태계 내에서 더 나은 보안과 소통을 촉진할 수 있습니다.

이것은
[Solana 익스플로러에서 security.txt가 어떻게 보이는지에 대한 예시](https://explorer.solana.com/address/HPxKXnBN4vJ8RjpdqDCU7gvNQHeeyGnSviYTJ4fBrDt4/security?cluster=devnet)입니다

`security.txt` 프로젝트는 [Neodyme Labs](https://github.com/neodyme-labs)에서
유지 관리합니다
