---
title: Адреса, похідна від програми
description:
  Дізнайтеся про адреси, похідні від програми (PDA) Solana — детерміновані
  адреси рахунків, які забезпечують безпечне підписання програмами. Зрозумійте
  виведення PDA, канонічні бампи та як створювати рахунки PDA.
---

[Адреса рахунку](/docs/core/accounts#account-address) Solana вказує на
місцезнаходження рахунку в блокчейні. Багато адрес рахунків є публічним ключем
keypair, і в такому випадку відповідний приватний ключ використовується для
підписання транзакцій, пов'язаних із рахунком.

Корисною альтернативою адресі публічного ключа є адреса, похідна від програми
(PDA). PDA надають простий метод для зберігання, відображення та отримання стану
програми. PDA — це адреса, яка створюється детерміновано з використанням ID
програми та комбінації опціональних попередньо визначених вхідних даних. PDA
виглядають подібно до адрес публічних ключів, але не мають відповідного
приватного ключа.

Середовище виконання Solana дозволяє програмам підписувати PDA без необхідності
приватного ключа. Використання PDA усуває необхідність відстежувати адресу
рахунку. Замість цього ви можете згадати конкретні вхідні дані, використані для
виведення PDA. (Щоб дізнатися, як програми використовують PDA для підписання,
див. розділ [Міжпрограмні виклики](/docs/core/cpi).)

## Передумови

[Keypair](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/keypair/src/lib.rs#L26)
Solana — це точки на [кривій Ed25519](https://ed25519.cr.yp.to/) (криптографія
на еліптичних кривих). Вони складаються з публічного ключа та приватного ключа.
Публічний ключ стає адресою рахунку, а приватний ключ використовується для
генерації дійсного [підпису](/docs/core/transactions#signatures) для рахунку.

![Два рахунки з адресами на кривій](/assets/docs/core/pda/address-on-curve.svg)

PDA навмисно виводиться так, щоб не потрапляти на криву Ed25519. Це означає, що
вона не має дійсного відповідного приватного ключа і не може виконувати
криптографічні операції. (Наприклад, надавати підпис.) Однак Solana дозволяє
програмам підписувати PDA без необхідності приватного ключа.

![Off Curve Address](/assets/docs/core/pda/address-off-curve.svg)

Ви можете розглядати PDA як спосіб створення структур, подібних до хеш-мап, у
блокчейні, використовуючи заздалегідь визначений набір вхідних даних.
(Наприклад, рядки, числа та інші адреси облікових записів.)

![Program Derived Address](/assets/docs/core/pda/pda.svg)

## Отримання PDA

Перед створенням облікового запису з PDA, ви повинні спочатку отримати адресу.
Отримання PDA _не_ створює автоматично обліковий запис у блокчейні за цією
адресою — обліковий запис повинен бути явно створений через програму, яка
використовується для отримання PDA. Ви можете розглядати PDA як адресу на карті:
лише тому, що адреса існує, не означає, що там щось побудовано.

SDK Solana підтримують створення PDA за допомогою функцій, показаних у таблиці
нижче. Кожна функція отримує такі вхідні дані:

- **Program ID**: Адреса програми, яка використовується для отримання PDA. Ця
  програма може підписуватися від імені PDA.
- **Optional seeds**: Заздалегідь визначені вхідні дані, такі як рядки, числа
  або інші адреси облікових записів.

| SDK                            | Функція                                                                                                                          |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `@solana/kit` (Typescript)     | [`getProgramDerivedAddress`](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L157) |
| `@solana/web3.js` (Typescript) | [`findProgramAddressSync`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/publickey.ts#L212)               |
| `solana_sdk` (Rust)            | [`find_program_address`](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/pubkey/src/lib.rs#L617)                        |

Функція використовує Program ID та optional seeds, а потім перебирає значення
bump для спроби створити дійсну адресу програми. Перебір значень bump
починається з 255 і зменшується на 1, доки не буде знайдено дійсний PDA. Після
знаходження дійсного PDA функція повертає PDA та bump seed.

<Callout>
  Bump seed — це додатковий байт, який додається до optional seeds, щоб
  забезпечити генерацію дійсної адреси поза кривою.
</Callout>

![Отримання PDA](/assets/docs/core/pda/pda-derivation.svg)

### Канонічний bump

Bump seed — це додатковий байт, який додається до необов'язкових seed. Функція
отримання перебирає значення bump, починаючи з 255 і зменшуючи на 1, доки
значення не створить дійсну адресу поза кривою. Перше значення, яке створює
дійсну адресу поза кривою, називається "канонічним bump".

Наступні приклади показують отримання PDA з використанням усіх можливих bump
seed (від 255 до 0):

<Callout type="info">
  Приклад Kit не включено, оскільки функція
  [createProgramDerivedAddress](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L101)
  не експортується.
</Callout>

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const optionalSeed = "helloWorld";

// Loop through all bump seeds (255 down to 0)
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(optionalSeed), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed = b"helloWorld";

    // Loop through all bump seeds (255 down to 0)
    for bump in (0..=255).rev() {
        match Pubkey::create_program_address(&[optional_seed.as_ref(), &[bump]], &program_id) {
            Ok(pda) => println!("bump {}: {}", bump, pda),
            Err(err) => println!("bump {}: {}", bump, err),
        }
    }

    Ok(())
}
```

</CodeTabs>

<CodeTabs>

```sh !! title="Expected TS Output"
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// remaining bump outputs
```

```sh !! title="Expected Rust Output"
bump 255: Provided seeds do not result in a valid address
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Provided seeds do not result in a valid address
...
// remaining bump outputs
```

</CodeTabs>

У цьому прикладі перший bump seed викликає помилку. Перший bump seed, який
отримує дійсний PDA, — 254. Bump seed 253-251 також отримують унікальні, дійсні
PDA.

Це означає, що за умови однакових опціональних seeds та `programId`, bump seed з
іншим значенням все одно може вивести валідну PDA.

<Callout type="warn">
  Завжди включайте перевірки безпеки, щоб переконатися, що PDA, переданий
  програмі, отримано з канонічного bump. Невиконання цієї вимоги може призвести
  до вразливостей, які дозволяють використовувати неочікувані облікові записи в
  інструкціях програми. Найкращою практикою є використання лише канонічного bump
  при отриманні PDA.
</Callout>

### Приклади

Наведені нижче приклади отримують PDA за допомогою SDK Solana. Натисніть
**&#9655; Run**, щоб виконати код.

#### Отримання PDA з рядковим seed

Наведений нижче приклад отримує PDA, використовуючи ID програми та
необов'язковий рядковий seed.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus
const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus
const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let seeds: &[&[u8]] = &[b"helloWorld"];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Отримання PDA з адресою як seed

Приклад нижче отримує PDA, використовуючи ідентифікатор програми та
необов'язкову адресу як seed.

<CodeTabs storage="pda-examples"flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:4)
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

// !focus(1:3)
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Отримання PDA з кількома seeds

Приклад нижче отримує PDA, використовуючи ідентифікатор програми та кілька
необов'язкових seeds.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:5)
const optionalSeedString = "helloWorld";
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedString, optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus(1:4)
const optionalSeedString = "helloWorld";
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [Buffer.from(optionalSeedString), optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus(1:2)
    let optional_seed_bytes = b"helloWorld";
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

## Створення облікового запису PDA

<WithMentions>

Приклад нижче використовує [фреймворк Anchor](https://www.anchor-lang.com/docs)
для створення нового акаунта з адресою, виведеною програмою. Програма включає
одну інструкцію [`initialize`](mention:initialize) для створення нового акаунта,
який зберігатиме [адресу користувача](mention:user-address) та
[bump seed](mention:bump), використані для виведення PDA.

```rs title="Program"
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    // !mention initialize
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        // !mark
        // !mention user-address
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bumpd
        // !mark
        // !mention bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    // !mention user-address
    pub user: Signer<'info>,

    #[account(
        init,
        // define the seeds to derive the PDA
        // !mark
        // !mention user-address
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        // !mark
        // !mention bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(InitSpace)]
pub struct DataAccount {
    // !mark
    // !mention user-address
    pub user: Pubkey,
    // !mark
    // !mention bump
    pub bump: u8,
}
```

</WithMentions>

<WithMentions>

Обмеження [`init`](mention:init) вказує Anchor
[викликати System Program](/docs/core/programs#the-system-program) для створення
нового акаунта, використовуючи PDA як адресу. [Seeds](mention:seeds),
використані для створення PDA:

- Адреса облікового запису користувача, надана в інструкції
- Фіксований рядок: "data"
- Канонічний [bump seed](mention:bump)

У цьому прикладі обмеженню bump не присвоєно значення, тому Anchor використає
`find_program_address` для виведення PDA та знаходження bump.

```rust title="pda_account"
#[account(
    // !mention init
    init,
    // !mention seeds
    seeds = [b"data", user.key().as_ref()],
    // !mention bump
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

</WithMentions>

<WithMentions>

Тестовий файл нижче містить транзакцію, яка викликає інструкцію
[`initialize`](mention:initialize) для створення нового акаунта з адресою,
виведеною програмою. Файл містить код для [виведення PDA](mention:pda).

Приклад також показує, як [отримати](mention:fetch) новий обліковий запис, який
буде створено.

```ts title="Test"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PdaAccount } from "../target/types/pda_account";
import { PublicKey } from "@solana/web3.js";

describe("pda-account", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.PdaAccount as Program<PdaAccount>;
  const user = provider.wallet as anchor.Wallet;

  // !mention(1:5) pda
  // Derive the PDA address using the seeds specified on the program
  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("data"), user.publicKey.toBuffer()],
    program.programId
  );

  it("Is initialized!", async () => {
    const transactionSignature = await program.methods
      // !mention initialize
      .initialize()
      .accounts({
        user: user.publicKey
      })
      .rpc();

    console.log("Transaction Signature:", transactionSignature);
  });

  it("Fetch Account", async () => {
    // !mention fetch
    const pdaAccount = await program.account.dataAccount.fetch(PDA);
    console.log(JSON.stringify(pdaAccount, null, 2));
  });
});
```

</WithMentions>

<Callout type="warn">
  Якщо ви викличете інструкцію `initialize` знову з тим самим seed адреси
  `user`, транзакція не виконається. Це відбувається тому, що акаунт уже існує
  за виведеною адресою.
</Callout>
