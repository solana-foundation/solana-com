---
title: Транзакції
description:
  Дізнайтеся про транзакції Solana — фундаментальні будівельні блоки для
  взаємодії з блокчейном Solana. Зрозумійте структуру транзакцій та композицію
  інструкцій з практичними прикладами.
---

Для взаємодії з мережею Solana вам необхідно надіслати транзакцію. Транзакцію
можна уявити як конверт, що містить кілька форм. Кожна форма — це інструкція,
яка вказує мережі, що робити. Надсилання транзакції подібне до відправлення
конверта поштою, щоб форми могли бути оброблені.

Приклад нижче показує спрощену версію двох транзакцій. Коли перша транзакція
обробляється, вона виконає одну інструкцію. Коли друга транзакція обробляється,
вона виконає три інструкції **у послідовному порядку**: спочатку інструкцію 1,
потім інструкцію 2, а потім інструкцію 3.

<Callout type="warn">
  Транзакції є **атомарними**: якщо одна інструкція не виконується, вся
  транзакція не вдається, і жодних змін не відбувається.
</Callout>

![Спрощена діаграма, що показує дві транзакції](/assets/docs/core/transactions/transaction-simple.svg)

[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
складається з такої інформації:

<WithMentions>

- [`signatures`](mention:signatures): Масив [підписів](#signatures)
- [`message`](mention:message): Інформація про транзакцію, включаючи список
  інструкцій для обробки

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![Діаграма, що показує дві частини транзакції](/assets/docs/core/transactions/tx_format.png)

Транзакції мають загальне обмеження розміру
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
байти. Це обмеження включає як масив [`signatures`](#signatures), так і
структуру [`message`](#message).

<Callout>
  Це обмеження походить від розміру максимальної одиниці передачі (MTU) IPv6 у
  1280 байтів, мінус 48 байтів для мережевих заголовків (40 байтів IPv6 + 8
  байтів заголовка).
</Callout>

![Діаграма, що показує формат транзакції та обмеження розміру](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## Підписи

Масив `signatures` транзакції містить структури `Signature`. Кожен
[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
має розмір 64 байти і створюється шляхом підписання `Message` транзакції за
допомогою приватного ключа облікового запису. Підпис повинен бути наданий для
кожного [облікового запису підписувача](#account-addresses), включеного до
будь-якої з інструкцій транзакції.

Перший підпис належить обліковому запису, який сплатить
[базову комісію](docs/core/fees#base-fee) транзакції і є підписом транзакції.
Підпис транзакції можна використовувати для пошуку деталей транзакції в мережі.

## Повідомлення

`message` транзакції — це структура
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131),
яка містить наступну інформацію:

<WithMentions>

- [`header`](mention:message-header): [Заголовок](#header) повідомлення
- [`account_keys`](mention:account-addresses): Масив
  [адрес облікових записів](#account-addresses), необхідних для інструкцій
  транзакції
- [`recent_blockhash`](mention:recent-blockhash):
  [Хеш блоку](#recent-blockhash), який діє як часова мітка для транзакції
- [`instructions`](mention:instructions): Масив [інструкцій](#instructions)

<Callout>
  Щоб заощадити місце, транзакція не зберігає дозволи для кожного облікового
  запису окремо. Натомість дозволи облікових записів визначаються за допомогою
  `header` та `account_keys`.
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### Заголовок

<WithMentions>

`header` повідомлення — це структура
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97).
Вона містить наступну інформацію:

- [`num_required_signatures`](mention:num_required_signatures): Загальна
  кількість підписів, необхідних для транзакції
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts):
  Загальна кількість облікових записів лише для читання, які потребують підписів
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts):
  Загальна кількість облікових записів лише для читання, які не потребують
  підписів

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![Діаграма, що показує три частини заголовка повідомлення](/assets/docs/core/transactions/message_header.png)

### Адреси облікових записів

[`account_keys`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
повідомлення — це масив адрес облікових записів, надісланий у
[компактному форматі масиву](/docs/references/terminology#compact-array-format).
Префікс масиву вказує на його довжину. Кожен елемент у масиві — це публічний
ключ, що вказує на обліковий запис, який використовується його інструкціями.
Масив `accounts_keys` повинен бути повним і строго впорядкованим наступним
чином:

1. Підписувач + Доступний для запису
2. Підписувач + Лише для читання
3. Не підписувач + Доступний для запису
4. Не підписувач + Лише для читання

<Callout>
  Строге впорядкування дозволяє поєднувати масив `account_keys` з інформацією в
  [`header`](#header) повідомлення для визначення дозволів для кожного
  облікового запису.
</Callout>

![Діаграма, що показує порядок масиву адрес облікових записів](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Останній блокхеш

`recent_blockhash` повідомлення — це хеш-значення, яке діє як часова мітка
транзакції та запобігає дублюванню транзакцій. Блокхеш закінчується після
[150 блоків](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134).
(Еквівалентно одній хвилині — за умови, що кожен блок триває 400 мс.) Після
закінчення терміну дії блоку транзакція стає недійсною і не може бути оброблена.

<Callout>
  Метод RPC [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) дозволяє
  отримати поточний блокхеш та висоту останнього блоку, на якому блокхеш буде
  дійсним.
</Callout>

### Інструкції

[`instructions`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
повідомлення — це масив усіх інструкцій, які потрібно обробити, надісланих у
[компактному форматі масиву](/docs/references/terminology#compact-array-format).
Префікс масиву вказує на його довжину. Кожен елемент у масиві є структурою
[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
і містить таку інформацію:

<WithMentions>

1. [`program_id_index`](mention:program-id-index): Індекс, що вказує на адресу в
   масиві [`account_keys`](#account-addresses). Це значення вказує на адресу
   програми, яка обробляє інструкцію.
2. [`accounts`](mention:account-indexes): Масив індексів, що вказують на адреси
   в масиві `account_keys`. Кожен індекс вказує на адресу облікового запису,
   необхідного для цієї інструкції.
3. [`data`](mention:instruction-data): Байтовий масив, що визначає, яку
   інструкцію викликати в програмі. Він також включає будь-які додаткові дані,
   необхідні для інструкції. (Наприклад, аргументи функції)

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Компактний масив інструкцій](/assets/docs/core/transactions/compact_array_of_ixs.png)

## Приклад структури транзакції

Наступний приклад показує структуру транзакції, яка містить одну інструкцію
переказу SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
Код нижче показує вивід з попередніх фрагментів коду.
Формат відрізняється між SDK,
але зверніть увагу, що кожна інструкція містить однакову необхідну інформацію.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

Після відправлення транзакції ви можете отримати її деталі, використовуючи
підпис транзакції та метод RPC [getTransaction](/docs/rpc/http/gettransaction).
Відповідь матиме структуру, подібну до наступного фрагмента.

<Callout>
  Ви також можете знайти транзакцію за допомогою [Solana
  Explorer](https://explorer.solana.com).
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
