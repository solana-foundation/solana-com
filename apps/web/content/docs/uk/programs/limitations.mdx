---
title: Обмеження
---

Розробка програм на блокчейні Solana має деякі властиві обмеження, пов'язані з
нею. Нижче наведено список поширених обмежень, з якими ви можете зіткнутися.

## Бібліотеки Rust

Оскільки програми на основі Rust, що працюють у блокчейні, повинні бути
детерміністичними і виконуватися в середовищі з обмеженими ресурсами та одним
потоком, вони мають певні обмеження щодо різних бібліотек.

Програми Rust, що працюють в мережі, підтримують більшість libstd, libcore та
liballoc з Rust, а також багато сторонніх пакетів.

Існують деякі обмеження, оскільки ці програми працюють в однопотоковому
середовищі з обмеженими ресурсами, а також повинні бути детерміністичними:

- Немає доступу до
  - `rand`
  - `std::fs`
  - `std::net`
  - `std::future`
  - `std::process`
  - `std::sync`
  - `std::task`
  - `std::thread`
  - `std::time`
- Обмежений доступ до:
  - `std::hash`
  - `std::os`
- Bincode є надзвичайно ресурсомістким як за кількістю циклів, так і за глибиною
  викликів, тому його слід уникати
- Форматування рядків слід уникати, оскільки воно також є ресурсомістким
- Немає підтримки `println!`, `print!`, натомість використовуйте макрос
  [`msg!`](https://github.com/solana-labs/solana/blob/d9b0fc0e3eec67dfe4a97d9298b15969b2804fab/sdk/program/src/log.rs#L33)
- Середовище виконання встановлює ліміт на кількість інструкцій, які програма
  може виконати під час обробки однієї інструкції. Докладніше див.
  [обчислювальний бюджет](/docs/core/fees#compute-budget)

## Обчислювальний бюджет

Щоб запобігти зловживанню обчислювальними ресурсами блокчейну, кожній транзакції
виділяється
[обчислювальний бюджет](/docs/references/terminology#compute-budget).
Перевищення цього обчислювального бюджету призведе до невдачі транзакції.

Дивіться документацію про
[обчислювальні обмеження](/docs/core/fees#compute-budget) для отримання більш
конкретних деталей.

## Глибина стека викликів — помилка `CallDepthExceeded`

Програми Solana обмежені швидким виконанням, і для полегшення цього стек
викликів програми обмежений максимальною глибиною **64 фрейми**.

Коли програма перевищує дозволений ліміт глибини стека викликів, вона отримує
помилку `CallDepthExceeded`.

## Глибина викликів CPI — помилка `CallDepth`

Міжпрограмні виклики дозволяють програмам викликати інші програми безпосередньо,
але глибина наразі обмежена значенням `4`.

Коли програма перевищує дозволену
[глибину міжпрограмних викликів](/docs/core/cpi), вона отримує помилку
`CallDepth`

## Підтримка типів з плаваючою комою у Rust

Програми підтримують обмежений набір операцій з плаваючою комою у Rust. Якщо
програма намагається використати операцію з плаваючою комою, яка не
підтримується, середовище виконання повідомить про помилку нерозв'язаного
символу.

Операції з плаваючою комою виконуються через програмні бібліотеки, зокрема
вбудовані функції LLVM для чисел з плаваючою комою. Через програмну емуляцію
вони споживають більше обчислювальних одиниць, ніж цілочисельні операції.
Загалом, де можливо, рекомендується використовувати операції з фіксованою комою.

Тести
[математичної бібліотеки Solana Program Library](https://github.com/solana-labs/solana-program-library/tree/master/libraries/math)
показують продуктивність деяких математичних операцій. Щоб запустити тест,
синхронізуйте репозиторій і виконайте:

```shell
cargo test-sbf -- --nocapture --test-threads=1
```

Останні результати показують, що операції з плаваючою комою потребують більше
інструкцій порівняно з цілочисельними еквівалентами. Реалізації з фіксованою
комою можуть відрізнятися, але також будуть менш ресурсомісткими, ніж
еквіваленти з плаваючою комою:

```text
          u64   f32
Multiply    8   176
Divide      9   219
```

## Статичні дані, що записуються

Програмні спільні об'єкти не підтримують спільні дані, що записуються. Програми
використовуються одночасно в кількох паралельних виконаннях, використовуючи один
і той самий спільний код і дані лише для читання. Це означає, що розробники не
повинні включати жодних статичних змінних для запису або глобальних змінних у
програмах. У майбутньому може бути доданий механізм копіювання при записі для
підтримки даних, що записуються.

## Ділення зі знаком

Набір інструкцій SBF не підтримує ділення зі знаком.
