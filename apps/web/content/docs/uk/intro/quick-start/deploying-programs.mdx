---
title: Розгортання програми
description:
  Дізнайтеся, як створити, розгорнути та протестувати вашу першу програму Solana
  за допомогою фреймворку Anchor та Solana Playground. Цей посібник для
  початківців проведе вас через створення простої програми, її розгортання в
  devnet, запуск тестів та закриття програми.
h1: Розгорніть вашу першу програму Solana
---

Створіть, розгорніть та протестуйте вашу першу [програму](/docs/core/programs) у
блокчейні Solana за допомогою фреймворку Anchor. Цей посібник допоможе вам краще
ознайомитися з Solana Playground та підготує вас до використання Program Derived
Address (PDA) та Cross Program Invocation (CPI).

<Steps>

<Step>

### Створення проєкту Anchor

1. Відкрийте [Solana Playground](https://beta.solpg.io) у вашому веб-браузері
2. На лівій панелі натисніть **+ Create a new project**
3. Введіть **Project name** (назву проєкту)
4. Виберіть **Anchor (Rust)** як фреймворк
5. Натисніть **Create**

![Новий проєкт](/assets/docs/intro/quickstart/pg-new-project.gif)

Відкриється вихідний файл `src/lib.rs`. Він містить одну структуру під назвою
`Initialize`, яка виконує наступне:

- Отримує обов'язковий параметр під назвою _rs`data: u64`_
- Створює новий рахунок
- Зберігає значення _rs`data: u64`_ у новому рахунку
- Додає повідомлення до програмних логів транзакції

<WithNotes>

```rust title="lib.rs"
use anchor_lang::prelude::*;

// This is your program's public key and it will update
// automatically when you build the project.
// !tooltip[/declare_id/] declare_id
declare_id!("11111111111111111111111111111111");

// !tooltip[/program/] program
#[program]
mod hello_anchor {
    use super::*;
    // !tooltip[/data: u64/] parameter
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        // !tooltip[/ctx.accounts.new_account.data = data/] initialize
        ctx.accounts.new_account.data = data;
        // !tooltip[/msg!/] msg
        msg!("Changed data to: {}!", data); // Message will show up in the tx logs
        Ok(())
    }
}

// !tooltip[/Accounts/] accounts
#[derive(Accounts)]
pub struct Initialize<'info> {
    // We must specify the space in order to initialize an account.
    // First 8 bytes are default account discriminator,
    // next 8 bytes come from NewAccount.data being type u64.
    // (u64 = 64 bits unsigned integer = 8 bytes)
    // !tooltip[/account/] constraints
    #[account(
      // !tooltip[/init/] init
      init,
      // !tooltip[/payer/] payer
      payer = signer,
      // !tooltip[/space/] space
      space = 8 + 8
    )]
    pub new_account: Account<'info, NewAccount>,
    // !tooltip[/account/] constraints
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

// !tooltip[/account/] account
#[account]
pub struct NewAccount {
    data: u64
}
```

### !declare_id

Адреса вашої програми в блокчейні. Вона оновиться, коли ви збудуєте проєкт

### !program

Модуль, що містить інструкції програми

### !accounts

Анотує структуру, що містить рахунки програми

### !account

Структура, яка представляє типи даних рахунків, які ця програма може створювати
та якими володіє

### !constraints

Обмеження рахунків. Наприклад, загальні перевірки або функції, що підвищують
безпеку програми

### !parameter

Значення, яке передається інструкції при її виклику

### !initialize

Отримує доступ до поля `data` рахунку `new_account` та встановлює його значення
рівним `data: u64`

### !msg

Макрос _rs`msg!`_ записує повідомлення до програмних логів транзакції

### !init

Викликає System Program для створення нового рахунку та робить цю програму його
власником. Як власник програми, ця програма може записувати дані в рахунок

### !payer

Рахунок, який оплачує створення нового рахунку

### !space

Кількість байтів для виділення під рахунок

</WithNotes>

<Accordions>

<Accordion title="Пояснення">

<WithMentions>

- Макрос [`declare_id!`](mention:one) вказує адресу вашої програми в мережі.
  Solana Playground автоматично оновить цю адресу, коли ви скомпілюєте програму.

```rs
// !mention one
declare_id!("11111111111111111111111111111111");
```

</WithMentions>

<WithMentions>

- Атрибут [`#[program]`](mention:one) позначає модуль, що містить функції, які
  представляють інструкції програми.

```rs
// !mention one
#[program]
mod hello_anchor {
    use super::*;
    // !mention two
    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        // !mention three
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data); // Message will show up in the tx logs
        Ok(())
    }
}
```

У цьому прикладі інструкція [`initialize`](mention:two) приймає два параметри:

- `ctx: Context<Initialize>`: Передає функції рахунки, необхідні для цієї
  інструкції, як зазначено в структурі `Initialize`.
- `data: u64`: Користувацький параметр, який ви повинні надати при виклику
  інструкції.

Тіло функції [встановлює поле `data` рахунку `new_account`](mention:three) на
наданий аргумент `data`, а потім виводить повідомлення в програмні логи.

</WithMentions>

<WithMentions>

- Атрибут [`#[derive(Accounts)]`](mention:one) визначає структуру, яка вказує
  облікові записи, необхідні для певної інструкції. Кожне поле представляє
  окремий обліковий запис.

  Anchor автоматично обробляє поширені перевірки безпеки, пов'язані з валідацією
  облікових записів через типи полів (наприклад, `Signer<'info>`) та обмеження
  (наприклад, `#[account(mut)]`).

  ```rs
  // !mention one
  #[derive(Accounts)]
  pub struct Initialize<'info> {
      #[account(init, payer = signer, space = 8 + 8)]
      pub new_account: Account<'info, NewAccount>,
      #[account(mut)]
      pub signer: Signer<'info>,
      pub system_program: Program<'info, System>,
  }
  ```

</WithMentions>

<WithMentions>

- Атрибут [`#[account]`](mention:one) визначає структуру, яка представляє тип
  даних для облікових записів, які ця програма створює та якими володіє.

```rs
// !mention one
#[account]
pub struct NewAccount {
  data: u64
}
```

</WithMentions>

</Accordion>
</Accordions>

</Step>

<Step>

### Збірка та розгортання програми

1. Скомпілюйте код програми

```terminal
$ build
Building...
Build successful. Completed in 1.46s.
```

<Callout>
  Ваш [ідентифікатор програми](/docs/intro/quick-start/deploying-programs),
  визначений у _rs`declare_id!()`_, тепер буде оновлено.
</Callout>

2. Додайте SOL до свого гаманця _(Опціонально)_

Розгортання програми вимагає наявності SOL в обліковому записі програми в
мережі. Якщо необхідно,
[додайте SOL до свого гаманця](/docs/intro/quick-start#add-sol-to-your-wallet)
перед переходом до кроку 3.

3. Розгорніть програму в мережі

```terminal
$ deploy
Deploying... This could take a while depending on the program size and network conditions.
Warning: 1 transaction not confirmed, retrying...
Deployment successful. Completed in 19s.
```

<Callout type="info">
  Після розгортання байт-код програми зберігається у виконуваному program
  account.
</Callout>

**Примітка:** За бажанням ви можете використовувати кнопки **Build** та
**Deploy** на боковій панелі зліва, як показано на знімку екрана нижче.

![Збірка та розгортання](/assets/docs/intro/quickstart/pg-build-deploy.png)

</Step>

<Step>

### Тестування програми

<WithMentions>

1. Відкрийте тестовий файл під назвою `tests/anchor.test.ts`. Цей файл
   демонструє, як викликати структуру [`initialize`](mention:one) програми з
   клієнта.

```ts title="anchor.test.ts"
// No imports needed: web3, anchor, pg and more are globally available

describe("Test", () => {
  it("initialize", async () => {
    // Generate keypair for the new account
    const newAccountKp = new web3.Keypair();

    // Send transaction
    const data = new BN(42);
    const txHash = await pg.program.methods
      // !mention one
      .initialize(data)
      .accounts({
        newAccount: newAccountKp.publicKey,
        signer: pg.wallet.publicKey,
        systemProgram: web3.SystemProgram.programId
      })
      .signers([newAccountKp])
      .rpc();
    console.log(`Use 'solana confirm -v ${txHash}' to see the logs`);

    // Confirm transaction
    await pg.connection.confirmTransaction(txHash);

    // Fetch the created account
    const newAccount = await pg.program.account.newAccount.fetch(
      newAccountKp.publicKey
    );

    console.log("On-chain data is:", newAccount.data.toString());

    // Check whether the data on-chain is equal to local 'data'
    assert(data.eq(newAccount.data));
  });
});
```

</WithMentions>

2. Запустіть тестовий файл

```terminal
$ test
Running tests...
  hello_anchor.test.ts:
  hello_anchor
    Use 'solana confirm -v 3TewJtiUz1EgtT88pLJHvKFzqrzDNuHVi8CfD2mWmHEBAaMfC5NAaHdmr19qQYfTiBace6XUmADvR4Qrhe8gH5uc' to see the logs
    On-chain data is: 42
    ✔ initialize (961ms)
  1 passing (963ms)
```

3. Збережіть хеш транзакції (`TxHash`), включений у вивід

(У наведеному вище прикладі хеш транзакції —
`3TewJtiUz1EgtT88pLJHvKFzqrzDNuHVi8CfD2mWmHEBAaMfC5NAaHdmr19qQYfTiBace6XUmADvR4Qrhe8gH5uc`.)

**Примітка:** За бажанням ви можете використовувати кнопку `Test` на лівій
бічній панелі.

![Запуск тесту](/assets/docs/intro/quickstart/pg-test.png)

4. Запустіть `solana confirm -v [TxHash]` для перегляду журналів транзакцій

```terminal
$ solana confirm -v 3TewJtiUz1EgtT88pLJHvKFzqrzDNuHVi8CfD2mWmHEBAaMfC5NAaHdmr19qQYfTiBace6XUmADvR4Qrhe8gH5uc
RPC URL: https://api.devnet.solana.com
Default Signer: Playground Wallet
Commitment: confirmed

Transaction executed in slot 308150984:
  Block Time: 2024-06-25T12:52:05-05:00
  Version: legacy
  Recent Blockhash: 7AnZvY37nMhCybTyVXJ1umcfHSZGbngnm4GZx6jNRTNH
  Signature 0: 3TewJtiUz1EgtT88pLJHvKFzqrzDNuHVi8CfD2mWmHEBAaMfC5NAaHdmr19qQYfTiBace6XUmADvR4Qrhe8gH5uc
  Signature 1: 3TrRbqeMYFCkjsxdPExxBkLAi9SB2pNUyg87ryBaTHzzYtGjbsAz9udfT9AkrjSo1ZjByJgJHBAdRVVTZv6B87PQ
  Account 0: srw- 3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R (fee payer)
  Account 1: srw- c7yy8zdP8oeZ2ewbSb8WWY2yWjDpg3B43jk3478Nv7J
  Account 2: -r-- 11111111111111111111111111111111
  Account 3: -r-x 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r
  Instruction 0
    Program:   2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r (3)
    Account 0: c7yy8zdP8oeZ2ewbSb8WWY2yWjDpg3B43jk3478Nv7J (1)
    Account 1: 3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R (0)
    Account 2: 11111111111111111111111111111111 (2)
    Data: [175, 175, 109, 31, 13, 152, 155, 237, 42, 0, 0, 0, 0, 0, 0, 0]
  Status: Ok
    Fee: ◎0.00001
    Account 0 balance: ◎5.47001376 -> ◎5.46900152
    Account 1 balance: ◎0 -> ◎0.00100224
    Account 2 balance: ◎0.000000001
    Account 3 balance: ◎0.00139896
  Log Messages:
    Program 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r invoke [1]
    Program log: Instruction: Initialize
    Program 11111111111111111111111111111111 invoke [2]
    Program 11111111111111111111111111111111 success
    Program log: Changed data to: 42!
    Program 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r consumed 5661 of 200000 compute units
    Program 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r success

Confirmed
```

4. Перегляньте деталі транзакції

Відкрийте [SolanaFM](https://solana.fm/) або
[Solana Explorer](https://explorer.solana.com/?cluster=devnet) і знайдіть хеш
транзакції.

<Callout type="warn">
  **Solana Explorer:** Встановіть мережевий кластер на `devnet`, щоб він
  відповідав кластеру Solana Playground.
</Callout>

</Step>

<Step>

### Закриття програми

Закрийте програму, щоб повернути SOL, виділений для програми в мережі. Для цього
запустіть `solana program close [ProgramID]`, використовуючи адресу програми,
збережену в макросі _rs`declare_id!()`_.

```terminal
$ solana program close 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r
Closed Program Id 2VvQ11q8xrn5tkPNyeraRsPaATdiPx8weLAD8aD4dn2r, 2.79511512 SOL reclaimed
```

<Callout type="warn">
  Програми можуть бути **лише** закриті або оновлені обліковим записом, що має
  права на оновлення. Ваш гаманець Playground автоматично отримує права на
  оновлення для кожної програми під час її розгортання. Якщо права на оновлення
  відкликано, програма стає незмінною.
</Callout>

Вітаємо! Ви створили та розгорнули свою першу програму Solana за допомогою
Anchor.

</Step>

</Steps>

## Наступні кроки

Тепер, коли ви розгорнули свою першу програму, ви готові дослідити
[адреси, похідні від програми](/docs/intro/quick-start/program-derived-address)
та [міжпрограмний виклик](/docs/intro/quick-start/cross-program-invocation).
