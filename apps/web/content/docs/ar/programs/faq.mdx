---
title: الأسئلة الشائعة
---

اطرح أسئلتك على [ستاك إكستشينج](https://solana.stackexchange.com/questions/ask).

## مرشح حزم بيركلي (BPF)

يتم تجميع البرامج المثبتة على سلسلة سولانا عبر
[بنية المترجم LLVM](https://llvm.org/) إلى
[تنسيق قابل للتنفيذ والربط (ELF)](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)
يحتوي على نوع من
[مرشح حزم بيركلي (BPF)](https://en.wikipedia.org/wiki/Berkeley_Packet_Filter)
بايت كود.

نظرًا لأن سولانا تستخدم بنية مترجم LLVM، يمكن كتابة البرنامج بأي لغة برمجة
يمكنها استهداف الواجهة الخلفية BPF لـ LLVM.

يوفر BPF
[مجموعة تعليمات](https://github.com/iovisor/bpf-docs/blob/master/eBPF.md) فعالة
يمكن تنفيذها في آلة افتراضية مفسرة أو كتعليمات أصلية مترجمة في الوقت المناسب
بكفاءة.

## خريطة الذاكرة

خريطة ذاكرة العنوان الافتراضي المستخدمة بواسطة برامج سولانا SBF ثابتة ومرتبة على
النحو التالي

- يبدأ كود البرنامج عند 0x100000000
- تبدأ بيانات المكدس عند 0x200000000
- تبدأ بيانات الكومة عند 0x300000000
- تبدأ معلمات إدخال البرنامج عند 0x400000000

العناوين الافتراضية المذكورة أعلاه هي عناوين البداية ولكن يتم منح البرامج حق
الوصول إلى مجموعة فرعية من خريطة الذاكرة. سيتوقف البرنامج فجأة إذا حاول قراءة أو
كتابة عنوان افتراضي لم يُمنح حق الوصول إليه، وسيتم إرجاع خطأ `AccessViolation`
يحتوي على العنوان وحجم الانتهاك المحاول.

## InvalidAccountData

يمكن أن يحدث خطأ البرنامج هذا لأسباب كثيرة. عادةً، يحدث بسبب تمرير حساب إلى
البرنامج لا يتوقعه البرنامج، إما في موضع خاطئ في التعليمات أو حساب غير متوافق مع
التعليمات التي يتم تنفيذها.

قد يتسبب تنفيذ البرنامج أيضًا في حدوث هذا الخطأ عند إجراء تعليمات بين البرامج
ونسيان توفير الحساب للبرنامج الذي تقوم باستدعائه.

## InvalidInstructionData

قد يحدث خطأ البرنامج هذا أثناء محاولة فك تسلسل التعليمات، تحقق من أن البنية
الممررة تتطابق تمامًا مع التعليمات. قد يكون هناك بعض الحشو بين الحقول. إذا كان
البرنامج ينفذ سمة Rust `Pack` فحاول تعبئة وفك تعبئة نوع التعليمات `T` لتحديد
الترميز الدقيق الذي يتوقعه البرنامج.

## MissingRequiredSignature

تتطلب بعض التعليمات أن يكون الحساب موقعًا؛ يتم إرجاع هذا الخطأ إذا كان من
المتوقع أن يكون الحساب موقعًا ولكنه ليس كذلك.

قد يتسبب تنفيذ البرنامج أيضًا في حدوث هذا الخطأ عند إجراء
[استدعاء بين البرامج](/docs/core/cpi) يتطلب عنوان برنامج موقع، ولكن بذور التوقيع
الممررة إلى `invoke_signed` لا تتطابق مع بذور التوقيع المستخدمة لإنشاء عنوان
البرنامج [`create_program_address`](/docs/core/pda#createprogramaddress).

## Stack

يستخدم SBF إطارات المكدس بدلاً من مؤشر المكدس المتغير. كل إطار مكدس بحجم 4
كيلوبايت.

إذا انتهك البرنامج حجم إطار المكدس هذا، فسيبلغ المترجم عن التجاوز كتحذير.

على سبيل المثال:

```text
Error: Function _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082E Stack offset of -30728 exceeded max offset of -4096 by 26632 bytes, please minimize large stack variables
```

تحدد الرسالة أي رمز يتجاوز إطار المكدس الخاص به، ولكن قد يكون الاسم مشوهًا.

> لإلغاء تشويه رمز Rust استخدم [rustfilt](https://github.com/luser/rustfilt).

جاء التحذير أعلاه من برنامج Rust، لذا فإن اسم الرمز غير المشوه هو:

```shell
rustfilt _ZN16curve25519_dalek7edwards21EdwardsBasepointTable6create17h178b3d2411f7f082E
curve25519_dalek::edwards::EdwardsBasepointTable::create
```

السبب في الإبلاغ عن تحذير بدلاً من خطأ هو أن بعض الصناديق التابعة قد تتضمن وظائف
تنتهك قيود إطار المكدس حتى إذا كان البرنامج لا يستخدم تلك الوظائف. إذا انتهك
البرنامج حجم المكدس في وقت التشغيل، فسيتم الإبلاغ عن خطأ `AccessViolation`.

تشغل إطارات مكدس SBF نطاق عناوين افتراضية تبدأ من `0x200000000`.

## حجم الكومة

تمتلك البرامج إمكانية الوصول إلى كومة وقت التشغيل عبر واجهات برمجة التطبيقات
`alloc` في Rust. لتسهيل عمليات التخصيص السريعة، يتم استخدام كومة بسيطة بحجم 32
كيلوبايت. لا تدعم الكومة `free` أو `realloc`.

داخليًا، تمتلك البرامج إمكانية الوصول إلى منطقة ذاكرة بحجم 32 كيلوبايت تبدأ من
العنوان الافتراضي 0x300000000 ويمكنها تنفيذ كومة مخصصة بناءً على احتياجات
البرنامج المحددة.

تقوم برامج Rust بتنفيذ الكومة مباشرة من خلال تعريف
[`global_allocator`](https://github.com/solana-labs/solana/blob/d9b0fc0e3eec67dfe4a97d9298b15969b2804fab/sdk/program/src/entrypoint.rs#L72)
مخصص

## المحمّلات

يتم نشر البرامج وتنفيذها بواسطة محمّلات وقت التشغيل، حاليًا هناك محمّلان مدعومان
[BPF Loader](https://github.com/solana-labs/solana/blob/7ddf10e602d2ed87a9e3737aa8c32f1db9f909d8/sdk/program/src/bpf_loader.rs#L17)
و
[BPF loader deprecated](https://github.com/solana-labs/solana/blob/7ddf10e602d2ed87a9e3737aa8c32f1db9f909d8/sdk/program/src/bpf_loader_deprecated.rs#L14)

قد تدعم المحمّلات واجهات ثنائية تطبيقية مختلفة، لذا يجب على المطورين كتابة
برامجهم ونشرها على نفس المحمّل. إذا تم نشر برنامج مكتوب لمحمّل معين على محمّل
مختلف، فإن النتيجة عادة ما تكون خطأ `AccessViolation` بسبب عدم تطابق فك تسلسل
معلمات إدخال البرنامج.

لجميع الأغراض العملية، يجب دائمًا كتابة البرامج لتستهدف أحدث محمّل BPF، وأحدث
محمّل هو الافتراضي لواجهة سطر الأوامر وواجهات برمجة تطبيقات جافا سكريبت.

- [نقاط دخول برنامج Rust](/docs/programs/lang-rust#program-entrypoint)

### النشر

نشر برنامج SBF هو عملية تحميل كائن BPF مشترك إلى بيانات حساب البرنامج وتحديد
الحساب كقابل للتنفيذ. يقوم العميل بتقسيم كائن BPF المشترك إلى أجزاء أصغر ويرسلها
كبيانات تعليمات
[`Write`](https://github.com/solana-labs/solana/blob/bc7133d7526a041d1aaee807b80922baa89b6f90/sdk/program/src/loader_instruction.rs#L13)
إلى المحمّل حيث يكتب المحمّل تلك البيانات في بيانات حساب البرنامج. بمجرد استلام
جميع الأجزاء، يرسل العميل تعليمات
[`Finalize`](https://github.com/solana-labs/solana/blob/bc7133d7526a041d1aaee807b80922baa89b6f90/sdk/program/src/loader_instruction.rs#L30)
إلى المحمّل، ثم يتحقق المحمّل من صحة بيانات SBF ويحدد حساب البرنامج كـ _قابل
للتنفيذ_. بمجرد تحديد حساب البرنامج كقابل للتنفيذ، يمكن للمعاملات اللاحقة إصدار
تعليمات لذلك البرنامج لمعالجتها.

عندما يتم توجيه تعليمات إلى برنامج SBF قابل للتنفيذ، يقوم المحمّل بتكوين بيئة
تنفيذ البرنامج، وتسلسل معلمات إدخال البرنامج، واستدعاء نقطة دخول البرنامج،
والإبلاغ عن أي أخطاء تمت مواجهتها.

لمزيد من المعلومات، راجع [نشر البرامج](/docs/programs/deploying).

### تسلسل معلمات الإدخال

تقوم محملات SBF بتسلسل معلمات إدخال البرنامج في مصفوفة بايت يتم تمريرها بعد ذلك
إلى نقطة دخول البرنامج، حيث يكون البرنامج مسؤولاً عن فك التسلسل على السلسلة. أحد
التغييرات بين المحمل المهمل والمحمل الحالي هو أن معلمات الإدخال يتم تسلسلها
بطريقة تؤدي إلى وقوع المعلمات المختلفة على إزاحات متوافقة داخل مصفوفة البايت
المتوافقة. هذا يسمح لتنفيذات فك التسلسل بالإشارة مباشرة إلى مصفوفة البايت وتوفير
مؤشرات متوافقة للبرنامج.

- [فك تسلسل معلمات برنامج Rust](/docs/programs/lang-rust#parameter-deserialization)

يقوم المحمل الأحدث بتسلسل معلمات إدخال البرنامج على النحو التالي (جميع الترميزات
بالترتيب الصغير أولاً):

- 8 بايت عدد غير موقع للحسابات
- لكل حساب
  - 1 بايت يشير إلى ما إذا كان هذا حسابًا مكررًا، إذا لم يكن مكررًا فإن القيمة
    هي 0xff، وإلا فإن القيمة هي فهرس الحساب الذي هو نسخة مكررة منه.
  - إذا كان مكررًا: 7 بايت من الحشو
  - إذا لم يكن مكررًا:
    - 1 بايت منطقي، صحيح إذا كان الحساب موقعًا
    - 1 بايت منطقي، صحيح إذا كان الحساب قابلاً للكتابة
    - 1 بايت منطقي، صحيح إذا كان الحساب قابلاً للتنفيذ
    - 4 بايت من الحشو
    - 32 بايت من المفتاح العام للحساب
    - 32 بايت من المفتاح العام لمالك الحساب
    - 8 بايت عدد غير موقع من lamport المملوكة للحساب
    - 8 بايت عدد غير موقع من بايتات بيانات الحساب
    - x بايت من بيانات الحساب
    - 10 كيلو بايت من الحشو، تستخدم لإعادة التخصيص
    - حشو كافٍ لمحاذاة الإزاحة إلى 8 بايت.
    - 8 بايت من عصر الإيجار
- 8 بايت من العدد غير الموقع لبيانات instruction data
- x بايت من بيانات التعليمات
- 32 بايت من معرف البرنامج
