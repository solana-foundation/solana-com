---
title: المعاملات
description:
  تعرف على معاملات سولانا - اللبنات الأساسية للتفاعل مع بلوكتشين سولانا. افهم
  بنية المعاملات وتكوين التعليمات مع أمثلة عملية.
---

للتفاعل مع شبكة سولانا، يجب عليك إرسال معاملة. يمكنك التفكير في المعاملة كمظروف
يحتوي على عدة نماذج. كل نموذج هو تعليمة تخبر الشبكة بما يجب القيام به. إرسال
المعاملة يشبه إرسال المظروف بالبريد حتى يمكن معالجة النماذج.

يوضح المثال أدناه نسخة مبسطة من معاملتين. عند معالجة المعاملة الأولى، ستنفذ
تعليمة واحدة. عند معالجة المعاملة الثانية، ستنفذ ثلاث تعليمات **بترتيب متسلسل**:
أولاً التعليمة 1، تليها التعليمة 2، ثم التعليمة 3.

<Callout type="warn">
  المعاملات **ذرية**: إذا فشلت تعليمة واحدة، ستفشل المعاملة بأكملها ولن تحدث أي
  تغييرات.
</Callout>

![رسم توضيحي مبسط يوضح معاملتين](/assets/docs/core/transactions/transaction-simple.svg)

تتكون
[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
من المعلومات التالية:

<WithMentions>

- [`signatures`](mention:signatures): مصفوفة من [التوقيعات](#signatures)
- [`message`](mention:message): معلومات المعاملة، بما في ذلك قائمة التعليمات
  التي سيتم معالجتها

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![رسم توضيحي يوضح جزأي المعاملة](/assets/docs/core/transactions/tx_format.png)

تمتلك المعاملات حد حجم إجمالي يبلغ
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
بايت. يشمل هذا الحد كلاً من مصفوفة [`signatures`](#signatures) وبنية
[`message`](#message).

<Callout>
  يأتي هذا الحد من حجم وحدة الإرسال القصوى (MTU) لبروتوكول IPv6 البالغ 1280
  بايت، ناقص 48 بايت لرؤوس الشبكة (40 بايت IPv6 + 8 بايت للرأس).
</Callout>

![رسم توضيحي يوضح تنسيق المعاملة وحدود الحجم](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## التوقيعات

تحتوي مصفوفة `signatures` الخاصة بالمعاملة على بنيات `Signature`. كل
[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
هو 64 بايت ويتم إنشاؤه عن طريق توقيع `Message` الخاص بالمعاملة باستخدام المفتاح
الخاص للحساب. يجب توفير توقيع لكل [حساب موقّع](#account-addresses) مدرج في أي من
تعليمات المعاملة.

التوقيع الأول ينتمي إلى الحساب الذي سيدفع
[الرسوم الأساسية](docs/core/fees#base-fee) للمعاملة وهو توقيع المعاملة. يمكن
استخدام توقيع المعاملة للبحث عن تفاصيل المعاملة على الشبكة.

## الرسالة

تتكون `message` الخاصة بالمعاملة من بنية
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)
تحتوي على المعلومات التالية:

<WithMentions>

- [`header`](mention:message-header): [رأس](#header) الرسالة
- [`account_keys`](mention:account-addresses): مصفوفة من
  [عناوين الحسابات](#account-addresses) المطلوبة بواسطة تعليمات المعاملة
- [`recent_blockhash`](mention:recent-blockhash): [هاش كتلة](#recent-blockhash)
  يعمل كطابع زمني للمعاملة
- [`instructions`](mention:instructions): مصفوفة من [التعليمات](#instructions)

<Callout>
  لتوفير المساحة، لا تخزن المعاملة أذونات لكل حساب بشكل فردي. بدلاً من ذلك، يتم
  تحديد أذونات الحساب باستخدام `header` و `account_keys`.
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### الرأس

<WithMentions>

يتكون `header` الخاص بالرسالة من بنية
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97).
وتحتوي على المعلومات التالية:

- [`num_required_signatures`](mention:num_required_signatures): العدد الإجمالي
  للتوقيعات المطلوبة بواسطة المعاملة
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts): العدد
  الإجمالي للحسابات للقراءة فقط التي تتطلب توقيعات
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts):
  العدد الإجمالي للحسابات للقراءة فقط التي لا تتطلب توقيعات

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![رسم توضيحي يوضح الأجزاء الثلاثة لرأس الرسالة](/assets/docs/core/transactions/message_header.png)

### عناوين الحسابات

تتكون
[`account_keys`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
الخاصة بالرسالة من مصفوفة من عناوين الحسابات، مرسلة بتنسيق
[مصفوفة مضغوطة](/docs/references/terminology#compact-array-format). تشير بادئة
المصفوفة إلى طولها. كل عنصر في المصفوفة هو مفتاح عام، يشير إلى حساب تستخدمه
التعليمات. يجب أن تكون مصفوفة `accounts_keys` كاملة ومرتبة بدقة على النحو
التالي:

1. موقّع + قابل للكتابة
2. موقّع + للقراءة فقط
3. ليس موقّعًا + قابل للكتابة
4. ليس موقّعًا + للقراءة فقط

<Callout>
  يسمح الترتيب الصارم بدمج مصفوفة `account_keys` مع المعلومات الموجودة في
  [`header`](#header) الخاص بالرسالة لتحديد الأذونات لكل حساب.
</Callout>

![رسم توضيحي يوضح ترتيب مصفوفة عناوين الحسابات](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### كتلة التجزئة الأخيرة

تعتبر `recent_blockhash` الخاصة بالرسالة قيمة تجزئة تعمل كطابع زمني للمعاملة
وتمنع المعاملات المكررة. تنتهي صلاحية كتلة التجزئة بعد
[150 كتلة](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134).
(ما يعادل دقيقة واحدة - بافتراض أن كل كتلة تستغرق 400 مللي ثانية.) بعد انتهاء
صلاحية الكتلة، تنتهي صلاحية المعاملة ولا يمكن معالجتها.

<Callout>
  تتيح لك طريقة RPC [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash)
  الحصول على كتلة التجزئة الحالية وارتفاع آخر كتلة ستكون فيها كتلة التجزئة
  صالحة.
</Callout>

### التعليمات

تعتبر
[`instructions`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
الخاصة بالرسالة مصفوفة لجميع التعليمات التي سيتم معالجتها، وترسل بتنسيق
[المصفوفة المضغوطة](/docs/references/terminology#compact-array-format). تشير
بادئة المصفوفة إلى طولها. كل عنصر في المصفوفة هو بنية
[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
وتتضمن المعلومات التالية:

<WithMentions>

1. [`program_id_index`](mention:program-id-index): فهرس يشير إلى عنوان في مصفوفة
   [`account_keys`](#account-addresses). تشير هذه القيمة إلى عنوان البرنامج الذي
   يعالج التعليمة.
2. [`accounts`](mention:account-indexes): مصفوفة من الفهارس تشير إلى عناوين في
   مصفوفة `account_keys`. يشير كل فهرس إلى عنوان حساب مطلوب لهذه التعليمة.
3. [`data`](mention:instruction-data): مصفوفة بايت تحدد التعليمة التي سيتم
   استدعاؤها في البرنامج. كما تتضمن أي بيانات إضافية مطلوبة بواسطة التعليمة.
   (على سبيل المثال، وسائط الدالة)

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![مصفوفة مضغوطة من التعليمات](/assets/docs/core/transactions/compact_array_of_ixs.png)

## مثال على بنية المعاملة

يوضح المثال التالي بنية معاملة تحتوي على تعليمة واحدة لتحويل SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
يوضح الكود أدناه الناتج من مقتطفات الكود السابقة.
يختلف التنسيق بين مجموعات أدوات التطوير (SDKs)،
ولكن لاحظ أن كل تعليمة تحتوي على نفس المعلومات المطلوبة.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

بعد إرسال المعاملة، يمكنك استرداد تفاصيلها باستخدام توقيع المعاملة وطريقة RPC
[getTransaction](/docs/rpc/http/gettransaction). سيكون للاستجابة بنية مشابهة
للمقتطف التالي.

<Callout>
  يمكنك أيضًا العثور على المعاملة باستخدام [مستكشف
  سولانا](https://explorer.solana.com).
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
