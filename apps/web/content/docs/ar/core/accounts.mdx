---
title: الحسابات
description:
  تعرف على نموذج حساب سولانا، بما في ذلك كيفية تخزين الحسابات للبيانات والبرامج،
  وآليات الإيجار (rent)، وملكية الحساب، والعلاقة بين البرامج وحسابات البيانات.
  افهم المفاهيم الأساسية لنظام تخزين المفاتيح والقيم في سولانا.
---

يتم تخزين جميع البيانات على شبكة سولانا في حسابات. يمكنك التفكير في شبكة سولانا
كقاعدة بيانات عامة تحتوي على جدول حسابات واحد. العلاقة بين الحساب وعنوانه تشبه
زوج المفتاح والقيمة، حيث يكون المفتاح هو العنوان والقيمة هي الحساب.

يمتلك كل حساب نفس [البنية](#account-structure) الأساسية ويمكن تحديد موقعه
باستخدام [عنوانه](#account-address).

![رسم توضيحي لـ 3 حسابات وعناوينها. يتضمن تعريف بنية الحساب.](/assets/docs/core/accounts/accounts.png)

## عنوان الحساب

عنوان الحساب هو معرّف فريد مكون من 32 بايت يُستخدم لتحديد موقع الحساب على
بلوكتشين سولانا. غالبًا ما يتم عرض عناوين الحسابات كسلاسل مشفرة بنظام base58.
تستخدم معظم الحسابات [مفتاح عام](#public-key) من نوع
[Ed25519](https://ed25519.cr.yp.to/) كعنوان لها، ولكن هذا ليس مطلوبًا، حيث تدعم
سولانا أيضًا [العناوين المشتقة من البرامج](#program-derived-address).

![حساب مع عنوان المفتاح العام المشفر بنظام base58](/assets/docs/core/accounts/account-address.svg)

### المفتاح العام

يوضح المثال أدناه كيفية استخدام مكتبة تطوير سولانا لإنشاء زوج مفاتيح.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner } from "@solana/kit";

// Kit does not enable extractable private keys
const keypairSigner = await generateKeyPairSigner();
console.log(keypairSigner);
```

```ts !! title="Legacy"
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);
console.log(`Secret Key: ${keypair.secretKey}`);
```

```rs !! title="Rust"
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() {
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());
    println!("Secret Key: {:?}", keypair.to_bytes());
}
```

</CodeTabs>

### العنوان المشتق من البرنامج

[العنوان المشتق من البرنامج](/docs/core/pda) (PDA) هو عنوان يتم اشتقاقه بشكل
حتمي باستخدام معرّف البرنامج ومدخل واحد أو أكثر اختياري (بذور). يوضح المثال
أدناه كيفية استخدام مكتبة تطوير سولانا لإنشاء عنوان مشتق من البرنامج.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey; // macro
use solana_sdk::pubkey::Pubkey;

#[tokio::main]
async fn main() {
    let program_address = pubkey!("11111111111111111111111111111111");
    let seeds = [b"helloWorld".as_ref()];
    let (pda, bump) = Pubkey::find_program_address(&seeds, &program_address);
    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
}
```

</CodeTabs>

## بنية الحساب

كل
[`Account`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L48-L60)
له حجم أقصى يبلغ
[10MiB](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/system_instruction.rs#L85)
ويحتوي على المعلومات التالية:

<WithMentions>

- [`lamports`](mention:lamports): عدد [لامبورتس](#lamports) في الحساب
- [`data`](mention:data): [بيانات](#data) الحساب
- [`owner`](mention:owner): معرّف البرنامج الذي [يملك](#owner) الحساب
- [`executable`](mention:executable): يشير إلى ما إذا كان الحساب يحتوي على ثنائي
  [قابل للتنفيذ](#executable)
- [`rent_epoch`](mention:rent_epoch): حقل [فترة الإيجار](#rent-epoch) المهمل

```rust title="Account"
pub struct Account {
    /// lamports in the account
    // !mention lamports
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    // !mention data
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    // !mention owner
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    // !mention executable
    pub executable: bool,
    /// the epoch at which this account will next owe rent
    // !mention rent_epoch
    pub rent_epoch: Epoch,
}
```

</WithMentions>

<ScrollyCoding>

## !!steps لامبورت

رصيد الحساب بوحدة [lamport](/docs/references/terminology#lamport).

يجب أن يكون لكل حساب حد أدنى من رصيد lamport، يسمى
[rent](/docs/references/terminology#rent)، والذي يسمح بتخزين بياناته على
السلسلة. يتناسب الإيجار مع حجم الحساب.

<Callout type="info">
  على الرغم من أن هذا الرصيد يسمى إيجار، إلا أنه يعمل أكثر مثل وديعة، حيث يمكن
  استرداد الرصيد الكامل عند إغلاق الحساب. (يأتي اسم "rent" من حقل [rent
  epoch](#rent-epoch) الذي تم إلغاؤه الآن.)
</Callout>

(انظر صيغة
[الحد الأدنى للرصيد](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97)
و[الثوابت](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L47-L70)
المطبقة.)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    // !focus
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    // !focus
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps البيانات

يشار إلى هذا الحقل عادةً باسم "بيانات الحساب". تعتبر `data` في هذا الحقل عشوائية
لأنها يمكن أن تحتوي على أي تسلسل من البايتات. يحدد كل برنامج هيكل البيانات
المخزنة في هذا الحقل.

- حسابات البرامج: يحتوي هذا الحقل إما على كود البرنامج القابل للتنفيذ أو عنوان
  [حساب بيانات البرنامج](#program-data-accounts) الذي يخزن كود البرنامج القابل
  للتنفيذ.
- حسابات البيانات: يخزن هذا الحقل عمومًا بيانات الحالة، المقصود قراءتها.

تتضمن قراءة البيانات من حساب سولانا خطوتين:

1. جلب الحساب باستخدام [عنوانه](#account-address)
2. فك تشفير حقل `data` الخاص بالحساب من البايتات الخام إلى هيكل البيانات
   المناسب، كما هو محدد من قبل البرنامج الذي يملك الحساب.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    // !focus
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    // !focus
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    // !focus
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    // !focus
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps المالك

يحتوي هذا الحقل على معرف البرنامج الخاص بمالك الحساب.

كل حساب في سولانا له [برنامج](/docs/core/programs) معين كمالك له. مالك الحساب هو
البرنامج الوحيد الذي يمكنه تغيير `data` الخاصة بالحساب أو خصم وحدات lamport، كما
هو موضح في تعليمات البرنامج.

(في حالة حساب البرنامج، يكون المالك هو
[برنامج التحميل الخاص به](https://solana.com/docs/core/programs#loader-programs).)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    // !focus
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    // !focus
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps قابل للتنفيذ

يشير هذا الحقل إلى ما إذا كان الحساب هو [حساب برنامج](#program-accounts) أو
[حساب بيانات](#data-accounts)

- إذا كان `true`: فالحساب هو حساب برنامج
- إذا كان `false`: فالحساب هو حساب بيانات

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    // !focus
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    // !focus
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps فترة الإيجار

**حقل `rent_epoch` مهمل.**

في الماضي، كان هذا الحقل يتتبع متى سيحتاج الحساب إلى دفع الإيجار. ومع ذلك، تم
إهمال آلية تحصيل الإيجار هذه منذ ذلك الحين.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    // !focus
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    // !focus
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

</ScrollyCoding>

## أنواع الحسابات

هناك فئتان أساسيتان تندرج فيهما الحسابات:

- [حسابات البرامج](#program-accounts): حسابات تحتوي على رمز قابل للتنفيذ
- [حسابات البيانات](#data-accounts): حسابات لا تحتوي على رمز قابل للتنفيذ

هذا الفصل يعني أن الرمز القابل للتنفيذ للبرنامج وحالته يتم تخزينهما في حسابات
منفصلة. (مشابه لأنظمة التشغيل، التي عادة ما يكون لديها ملفات منفصلة للبرامج
وبياناتها.)

### حسابات البرامج

كل برنامج مملوك من قبل [برنامج التحميل](/docs/core/programs#loader-programs)،
الذي يستخدم لنشر وإدارة الحساب. عندما يتم نشر [برنامج](/docs/core/programs)
جديد، يتم إنشاء حساب لتخزين رمزه [القابل للتنفيذ](#executable). يسمى هذا حساب
البرنامج. (للتبسيط، يمكنك اعتبار حساب البرنامج هو البرنامج نفسه.)

في الرسم البياني أدناه، يمكنك رؤية استخدام برنامج التحميل لنشر حساب برنامج.
يحتوي حقل `data` الخاص بحساب البرنامج على رمز البرنامج القابل للتنفيذ.

![رسم توضيحي لحساب برنامج، ومكوناته الأربعة وبرنامج التحميل الخاص به.](/assets/docs/core/accounts/program-account-simple.svg)

#### حسابات بيانات البرامج

البرامج المنشورة باستخدام loader-v3 لا تحتوي على رمز البرنامج في حقل `data`
الخاص بها. بدلاً من ذلك، يشير حقل `data` إلى **حساب بيانات البرنامج** منفصل،
والذي يحتوي على رمز البرنامج. (انظر الرسم البياني أدناه.)

![حساب برنامج مع بيانات. البيانات تشير إلى حساب بيانات برنامج منفصل](/assets/docs/core/accounts/program-account-expanded.svg)

<Callout>
  أثناء نشر البرنامج أو الترقيات، يتم استخدام حسابات المخزن المؤقت لتجهيز
  التحميل مؤقتًا.
</Callout>

المثال أدناه يجلب حساب Token Program. لاحظ أن حقل `executable` مضبوط على `true`،
مما يشير إلى أن الحساب هو برنامج.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const programId = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address;

const accountInfo = await rpc
  .getAccountInfo(programId, { encoding: "base64" })
  .send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Connection, PublicKey } from "@solana/web3.js";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const programId = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

const accountInfo = await connection.getAccountInfo(programId);
// !collapse(1:17) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::pubkey;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let program_id = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let account_info = connection.get_account(&program_id).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

### حسابات البيانات

حسابات البيانات لا تحتوي على كود قابل للتنفيذ. بدلاً من ذلك، تقوم بتخزين
المعلومات.

#### حساب حالة البرنامج

تستخدم البرامج حسابات البيانات للحفاظ على حالتها. للقيام بذلك، يجب عليها أولاً
إنشاء حساب بيانات جديد. غالبًا ما يتم تجريد عملية إنشاء حساب حالة البرنامج، ولكن
من المفيد فهم العملية الأساسية.

لإدارة حالته، يجب على البرنامج الجديد:

1. استدعاء [System Program](/docs/core/programs#the-system-program) لإنشاء حساب.
   (ثم ينقل System Program الملكية إلى البرنامج الجديد.)
2. تهيئة بيانات الحساب، كما هو محدد في [تعليماته](/docs/core/instructions).

![رسم تخطيطي لحساب بيانات مملوك من قبل حساب برنامج](/assets/docs/core/accounts/data-account.svg)

المثال أدناه ينشئ ويجلب حساب Token Mint مملوك من قبل برنامج Token 2022.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  fetchMint
} from "@solana-program/token-2022";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer
const feePayer = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Instruction to create new account for mint (token 2022 program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token 2022 program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address
});

const instructions = [createAccountInstruction, initializeMintInstruction];

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }), // Create transaction message
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx), // Set fee payer
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set transaction blockhash
  (tx) => appendTransactionMessageInstructions(instructions, tx) // Append instructions
);

// Sign transaction message with required signers (fee payer and mint keypair)
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Mint Address:", mint.address);
console.log("Transaction Signature:", transactionSignature);

const accountInfo = await rpc.getAccountInfo(mint.address).send();
console.log(accountInfo);

const mintAccount = await fetchMint(rpc, mint.address);
console.log(mintAccount);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  TOKEN_2022_PROGRAM_ID,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const recentBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: recentBlockhash.blockhash,
  lastValidBlockHeight: recentBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Generate keypair to use as address of mint
const mint = Keypair.generate();

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: await getMinimumBalanceForRentExemptMint(connection),
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);

const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint] // Signers
);

console.log("Mint Address: ", mint.publicKey.toBase58());
console.log("Transaction Signature: ", transactionSignature);

const accountInfo = await connection.getAccountInfo(mint.publicKey);

// !collapse(1:16) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);

const mintAccount = await getMint(
  connection,
  mint.publicKey,
  "confirmed",
  TOKEN_2022_PROGRAM_ID
);
console.log(mintAccount);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    program_pack::Pack,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_token_2022_interface::{
    id as token_2022_program_id, instruction::initialize_mint, state::Mint,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let recent_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    let space = Mint::LEN;
    let rent = client.get_minimum_balance_for_rent_exemption(space).await?;

    // Create account instruction
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),      // fee payer
        &mint.pubkey(),           // mint address
        rent,                     // rent
        space as u64,             // space
        &token_2022_program_id(), // program id
    );

    // Initialize mint instruction
    let initialize_mint_instruction = initialize_mint(
        &token_2022_program_id(),
        &mint.pubkey(),            // mint address
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        9,                         // decimals
    )?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        recent_blockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    let account_info = client.get_account(&mint.pubkey()).await?;
    println!("{:#?}", account_info);

    let mint_account = Mint::unpack(&account_info.data)?;
    println!("{:#?}", mint_account);

    Ok(())
}
```

</CodeTabs>

#### حسابات النظام

ليست كل الحسابات يتم تعيين مالك جديد لها بعد إنشائها بواسطة System Program. تسمى
الحسابات المملوكة من قبل System Program بحسابات النظام. جميع حسابات المحفظة هي
حسابات نظام، مما يسمح لها بدفع [رسوم المعاملات](docs/core/fees).

![محفظة مملوكة من قبل System Program تحتوي على 1,000,000 لامبورت](/assets/docs/core/accounts/system-account.svg)

عندما يتم إرسال SOL إلى عنوان جديد لأول مرة، يتم إنشاء حساب في ذلك العنوان مملوك
من قبل System Program.

في المثال أدناه، يتم إنشاء keypair جديد وتمويله بـ SOL. بعد تشغيل الكود، يمكنك
رؤية أن عنوان `owner` للحساب هو `11111111111111111111111111111111` (وهو
[System Program](/docs/core/programs#the-system-program)).

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  generateKeyPairSigner,
  lamports
} from "@solana/kit";

// Create a connection to Solana cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate a new keypair
const keypair = await generateKeyPairSigner();
console.log(`Public Key: ${keypair.address}`);

// Funding an address with SOL automatically creates an account
const signature = await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: keypair.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

const accountInfo = await rpc.getAccountInfo(keypair.address).send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";

// Generate a new keypair
const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);

// Create a connection to the Solana cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Funding an address with SOL automatically creates an account
const signature = await connection.requestAirdrop(
  keypair.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const accountInfo = await connection.getAccountInfo(keypair.publicKey);
console.log(JSON.stringify(accountInfo, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signer::{keypair::Keypair, Signer},
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate a new keypair
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());

    // Create a connection to Solana cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Funding an address with SOL automatically creates an account
    let signature = connection
        .request_airdrop(&keypair.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = connection.confirm_transaction(&signature).await?;
        if confirmed {
            break;
        }
    }

    let account_info = connection.get_account(&keypair.pubkey()).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

#### حسابات Sysvar

توجد حسابات Sysvar في عناوين محددة مسبقًا وتوفر وصولاً إلى بيانات حالة المجموعة.
تتحدث ديناميكيًا مع بيانات حول مجموعة الشبكة. راجع القائمة الكاملة لـ
[حسابات Sysvar](https://docs.anza.xyz/runtime/sysvars).

المثال أدناه يجلب ويفك تشفير البيانات من حساب Sysvar Clock.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { createSolanaRpc } from "@solana/kit";
import { fetchSysvarClock, SYSVAR_CLOCK_ADDRESS } from "@solana/sysvars";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const accountInfo = await rpc
  .getAccountInfo(SYSVAR_CLOCK_ADDRESS, { encoding: "base64" })
  .send();
console.log(accountInfo);

// Automatically fetch and deserialize the account data
const clock = await fetchSysvarClock(rpc);
console.log(clock);
```

```ts !! title="Legacy"
import { Connection, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getSysvarClockCodec } from "@solana/sysvars";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const accountInfo = await connection.getAccountInfo(SYSVAR_CLOCK_PUBKEY);

// Deserialize the account data
const decodedClock = getSysvarClockCodec().decode(
  new Uint8Array(accountInfo?.data ?? [])
);
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
console.log(decodedClock);
```

```rs !! title="Rust"
use anyhow::Result;
use bincode::deserialize;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::sysvar::{self, clock::Clock};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let account = connection.get_account(&sysvar::clock::ID).await?;
    // Deserialize the account data
    let clock: Clock = deserialize(&account.data)?;

    println!("{:#?}", account);
    println!("{:#?}", clock);

    Ok(())
}
```

</CodeTabs>
