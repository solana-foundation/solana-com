---
title: رسوم المعاملات
description:
  تعرف على رسوم معاملات سولانا، بما في ذلك الرسوم الأساسية ورسوم الأولوية،
  وكيفية تطبيق كل منها، وأفضل الممارسات لإدارة وحدات الحوسبة في معاملاتك.
---

تتطلب كل معاملة على سولانا رسوم معاملة، تُدفع بعملة SOL. تنقسم رسوم المعاملات
إلى جزأين: الرسوم الأساسية ورسوم الأولوية. تعوض الرسوم الأساسية المدققين عن
معالجة المعاملة. رسوم الأولوية هي رسوم اختيارية، لزيادة فرصة معالجة المعاملة من
قبل القائد الحالي.

## الرسوم الأساسية

تكلف كل معاملة 5000 [لامبورت](/docs/references/terminology#lamport) لكل توقيع
مضمن. يتم دفع هذه الرسوم من قبل الموقع الأول على المعاملة ويجب أن تُدفع من حساب
مملوك لـ System Program. يتم تقسيم الرسوم الأساسية كما يلي:

- **50% يتم حرقها:** نصف الرسوم يتم
  [حرقها](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (إزالتها من إمدادات SOL المتداولة).
- **50% يتم توزيعها:** النصف الآخر يتم
  [دفعه إلى المدقق](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
  الذي عالج المعاملة.

## رسوم الأولوية

[رسوم الأولوية](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
هي رسوم اختيارية تُستخدم لزيادة فرصة معالجة معاملتك من قبل القائد الحالي
(المدقق). يتلقى المدقق
[100% من رسوم الأولوية](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
يمكن تحديد رسوم الأولوية عن طريق ضبط سعر وحدة الحوسبة
[computation unit](/docs/references/terminology#compute-units) (CU) وحد CU
للمعاملة. (راجع
[دليل كيفية استخدام رسوم الأولوية](/developers/guides/advanced/how-to-use-priority-fees)
لمزيد من التفاصيل حول رسوم الأولوية.)

يتم حساب رسوم الأولوية على النحو التالي:

```text title="Prioritization fee formula"
Prioritization fee = CU limit * CU price
```

تُستخدم رسوم الأولوية لتحديد
[أولوية معاملتك](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646)،
بالنسبة للمعاملات الأخرى. يتم حسابها باستخدام الصيغة التالية:

```text title="Transaction priority formula"
Priority = (Prioritization fee + Base fee) / (1 + CU limit + Signature CUs + Write lock CUs)
```

#### حد وحدة الحوسبة

[افتراضيًا](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197)،
يتم تخصيص
[200,000 وحدة حوسبة](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
لكل تعليمة
و[1.4 مليون وحدة حوسبة](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14)
لكل معاملة. يمكنك تغيير هذه الإعدادات الافتراضية عن طريق تضمين تعليمة
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
في معاملتك.

لحساب حد وحدات الحوسبة المناسب لمعاملتك، نوصي باتباع الخطوات التالية:

1. قم بتقدير وحدات الحوسبة المطلوبة عن طريق
   [محاكاة](/developers/guides/advanced/how-to-request-optimal-compute) المعاملة
2. أضف هامش أمان بنسبة 10% إلى هذا التقدير

<Callout type="warn">
  يتم تحديد رسوم الأولوية من خلال حد وحدات الحوسبة المطلوبة للمعاملة، *وليس*
  العدد الفعلي لوحدات الحوسبة المستخدمة. إذا قمت بتعيين حد وحدات حوسبة مرتفع
  جدًا أو استخدمت المقدار الافتراضي، فقد تدفع مقابل وحدات حوسبة غير مستخدمة.
</Callout>

#### سعر وحدة الحوسبة

سعر وحدة الحوسبة هو مبلغ اختياري من
[مايكرو-لامبورت](/docs/references/terminology#micro-lamports) يُدفع مقابل كل
وحدة حوسبة مطلوبة. يمكنك اعتبار سعر وحدة الحوسبة كإكرامية لتشجيع الـvalidator
على إعطاء الأولوية لمعاملتك. لتعيين سعر وحدة الحوسبة، قم بتضمين تعليمات
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
في معاملتك.

<Callout>
  سعر وحدة الحوسبة الافتراضي هو 0، مما يعني أن رسوم الأولوية الافتراضية هي أيضًا
  0.
</Callout>

للمساعدة في تحديد أفضل سعر لوحدة الحوسبة لمعاملتك، راجع توصية سعر وحدة الحوسبة
في الوقت الفعلي المدرجة في الجدول أدناه.

| المزود                                  | واجهة برمجة تطبيقات رسوم الأولوية                                           |
| --------------------------------------- | --------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [التوثيق](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [التوثيق](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [التوثيق](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### مثال

توضح الأمثلة أدناه كيفية تعيين حد وحدات الحوسبة وسعر وحدة الحوسبة على معاملة
باستخدام مجموعات تطوير برمجيات سولانا.

| مجموعة تطوير البرمجيات         | مرجع الشفرة المصدرية                                                                                                           |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (تايبسكريبت) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (رست)             | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
