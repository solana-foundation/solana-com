---
title: التعليمات
description:
  تعرف على تعليمات سولانا - اللبنات الأساسية للتفاعل مع بلوكتشين سولانا. افهم
  تكوين التعليمات من خلال أمثلة عملية.
---

التعليمات هي اللبنة الأساسية للتفاعل مع بلوكتشين سولانا. التعليمة هي في الأساس
دالة عامة يمكن لأي شخص يستخدم شبكة سولانا استدعاؤها. تُستخدم كل تعليمة لتنفيذ
إجراء محدد. يتم تخزين منطق تنفيذ التعليمات في [البرامج](/docs/core/programs)،
حيث يحدد كل برنامج مجموعته الخاصة من التعليمات. للتفاعل مع شبكة سولانا، يتم
إضافة تعليمة واحدة أو أكثر إلى [معاملة](/docs/core/transactions) وإرسالها إلى
الشبكة لمعالجتها.

## مثال على تحويل SOL

يوضح الرسم البياني أدناه كيف تعمل المعاملات والتعليمات معًا للسماح للمستخدمين
بالتفاعل مع الشبكة. في هذا المثال، يتم تحويل SOL من حساب إلى آخر.

تشير [بيانات التعريف](#account-metadata) لحساب المرسل إلى أنه يجب عليه التوقيع
على المعاملة. (هذا يسمح للبرنامج النظام بخصم
[لامبورت](/docs/references/terminology#lamport).) يجب أن يكون كل من حساب المرسل
والمستلم قابلين للكتابة، حتى يتمكن رصيد اللامبورت الخاص بهما من التغيير. لتنفيذ
هذه التعليمة، ترسل محفظة المرسل المعاملة التي تحتوي على
[توقيعها](/docs/references/terminology#signature) والرسالة التي تحتوي على تعليمة
تحويل SOL.

![رسم بياني لتحويل SOL](/assets/docs/core/transactions/sol-transfer.svg)

بعد إرسال المعاملة، يقوم System Program بمعالجة تعليمة التحويل وتحديث رصيد
اللامبورت لكلا الحسابين.

![رسم بياني لعملية تحويل SOL](/assets/docs/core/transactions/sol-transfer-process.svg)

يوضح المثال أدناه الكود المتعلق بالرسوم البيانية أعلاه. (انظر
[تعليمة](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L183)
التحويل الخاصة بـ System Program.)

<CodeTabs flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

// Create a connection to cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Fund sender with airdrop
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: sender.address,
  lamports: lamports(LAMPORTS_PER_SOL), // 1 SOL
  commitment: "confirmed"
});

// Check balance before transfer
const { value: preBalance1 } = await rpc.getBalance(sender.address).send();
const { value: preBalance2 } = await rpc.getBalance(recipient.address).send();

// !mark(1:6)
// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount // 0.01 SOL in lamports
});

// Add the transfer instruction to a new transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

// Send the transaction to the network
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);
const transactionSignature = getSignatureFromTransaction(signedTransaction);

// Check balance after transfer
const { value: postBalance1 } = await rpc.getBalance(sender.address).send();
const { value: postBalance2 } = await rpc.getBalance(recipient.address).send();

console.log(
  "Sender prebalance:",
  Number(preBalance1) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Recipient prebalance:",
  Number(preBalance2) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Sender postbalance:",
  Number(postBalance1) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Recipient postbalance:",
  Number(postBalance2) / Number(LAMPORTS_PER_SOL)
);
console.log("Transaction Signature:", transactionSignature);
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

// Create a connection to cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Fund sender with airdrop
const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Check balance before transfer
const preBalance1 = await connection.getBalance(sender.publicKey);
const preBalance2 = await connection.getBalance(recipient.publicKey);

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// !mark(1:6)
// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

// Add the transfer instruction to a new transaction
const transaction = new Transaction().add(transferInstruction);

// Send the transaction to the network
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [sender] // signer
);

// Check balance after transfer
const postBalance1 = await connection.getBalance(sender.publicKey);
const postBalance2 = await connection.getBalance(recipient.publicKey);

console.log("Sender prebalance:", preBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient prebalance:", preBalance2 / LAMPORTS_PER_SOL);
console.log("Sender postbalance:", postBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient postbalance:", postBalance2 / LAMPORTS_PER_SOL);
console.log("Transaction Signature:", transactionSignature);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, signature::Signer,
    signer::keypair::Keypair, system_instruction, transaction::Transaction,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create a connection to cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Fund sender with airdrop
    let airdrop_signature = connection
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;
    loop {
        let confirmed = connection.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Check balance before transfer
    let pre_balance1 = connection.get_balance(&sender.pubkey()).await?;
    let pre_balance2 = connection.get_balance(&recipient.pubkey()).await?;

    // Define the amount to transfer
    let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

    // !mark(1:3)
    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction =
        system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    // Add the transfer instruction to a new transaction
    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    let blockhash = connection.get_latest_blockhash().await?;
    transaction.sign(&[&sender], blockhash);

    // Send the transaction to the network
    let transaction_signature = connection
        .send_and_confirm_transaction(&transaction)
        .await?;

    // Check balance after transfer
    let post_balance1 = connection.get_balance(&sender.pubkey()).await?;
    let post_balance2 = connection.get_balance(&recipient.pubkey()).await?;

    println!(
        "Sender prebalance: {}",
        pre_balance1 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Recipient prebalance: {}",
        pre_balance2 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Sender postbalance: {}",
        post_balance1 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Recipient postbalance: {}",
        post_balance2 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

</CodeTabs>

<WithMentions>

## التعليمات

![رسم بياني يوضح معاملة تحتوي على تعليمة، مقسمة إلى 3 مكونات](/assets/docs/core/transactions/instruction.svg)

تتكون
[`Instruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)
من المعلومات التالية:

- [`program_id`](mention:program-id): [معرّف](#program-id) البرنامج الذي يتم
  استدعاؤه.
- [`accounts`](mention:accounts): مصفوفة من
  [بيانات وصفية للحساب](#account-metadata)
- [`data`](mention:instruction-data): مصفوفة بايت تحتوي على [بيانات] إضافية
  لاستخدامها بواسطة التعليمة.

```rust title="Instruction struct"
pub struct Instruction {
    /// Pubkey of the program that executes this instruction.
    // !mention program-id
    pub program_id: Pubkey,
    /// Metadata describing accounts that should be passed to the program.
    // !mention accounts
    pub accounts: Vec<AccountMeta>,
    /// Opaque data passed to the program for its own interpretation.
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

### معرّف البرنامج

[`program_id`](/docs/references/terminology#program-id) الخاص بالتعليمة هو عنوان
المفتاح العام للبرنامج الذي يحتوي على منطق الأعمال للتعليمة.

### البيانات الوصفية للحساب

<WithMentions>

مصفوفة `accounts` الخاصة بالتعليمة هي مصفوفة من هياكل
[`AccountMeta`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25).
يجب توفير البيانات الوصفية لكل حساب تتفاعل معه التعليمة. (هذا يسمح للمعاملة
بتنفيذ التعليمات بالتوازي، طالما أنها لا تقوم بتعديل نفس الحساب.)

يوضح الرسم البياني أدناه معاملة تحتوي على تعليمة واحدة. تحتوي مصفوفة `accounts`
الخاصة بالتعليمة على بيانات وصفية لحسابين.

![معاملة بتعليمة واحدة. تحتوي التعليمة على هيكلين من نوع `AccountMeta` في مصفوفة `accounts` الخاصة بها.](/assets/docs/core/transactions/accountmeta.svg)

تتضمن البيانات الوصفية للحساب المعلومات التالية:

- [pubkey](mention:pubkey): عنوان المفتاح العام للحساب
- [is_signer](mention:is-signer): يتم تعيينه إلى `true` إذا كان يجب على الحساب
  التوقيع على المعاملة
- [is_writable](mention:is-writable): يتم تعيينه إلى `true` إذا كانت التعليمة
  تقوم بتعديل بيانات الحساب

<Callout>
  لمعرفة الحسابات التي تتطلبها التعليمة، بما في ذلك تلك التي يجب أن تكون قابلة
  للكتابة، أو للقراءة فقط، أو التي يجب أن توقع على المعاملة، يجب عليك الرجوع إلى
  تنفيذ التعليمة، كما هو محدد بواسطة البرنامج.
</Callout>

```rust title="AccountMeta"
pub struct AccountMeta {
    /// An account's public key.
    // !mention pubkey
    pub pubkey: Pubkey,
    /// True if an `Instruction` requires a `Transaction` signature matching `pubkey`.
    // !mention is-signer
    pub is_signer: bool,
    /// True if the account data or metadata may be mutated during program execution.
    // !mention is-writable
    pub is_writable: bool,
}
```

</WithMentions>

### البيانات

`data` الخاصة بالتعليمة هي مصفوفة بايت تحدد أي من تعليمات البرنامج سيتم
استدعاؤها. كما تتضمن أي وسائط مطلوبة بواسطة التعليمة.

## مثال على إنشاء تعليمة

يوضح المثال أدناه بنية تعليمة تحويل SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner, lamports } from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair
} from "@solana/web3.js";

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_sdk::{native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Define the amount to transfer
    let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    println!("{:#?}", transfer_instruction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>

يوضح الكود أدناه المخرجات من مقتطفات الكود السابقة. قد يختلف التنسيق بين مجموعات
تطوير البرمجيات (SDKs)، ولكن لاحظ أن كل تعليمة تحتوي على نفس المعلومات الثلاثة
المطلوبة: [`program_id`](mention:program-id)، [`accounts`](mention:accounts)،
[`data`](mention:data).

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  // !mention(1:16) accounts
  "accounts": [
    {
      "address": "Hu28vRMGWpQXN56eaE7jRiDDRRz3vCXEs7EKHRfL6bC",
      "role": 3,
      "signer": {
        "address": "Hu28vRMGWpQXN56eaE7jRiDDRRz3vCXEs7EKHRfL6bC",
        "keyPair": {
          "privateKey": {},
          "publicKey": {}
        }
      }
    },
    {
      "address": "2mBY6CTgeyJNJDzo6d2Umipw2aGUquUA7hLdFttNEj7p",
      "role": 1
    }
  ],
  // !mention program-id
  "programAddress": "11111111111111111111111111111111",
  // !mention(1:14) data
  "data": {
    "0": 2,
    "1": 0,
    "2": 0,
    "3": 0,
    "4": 128,
    "5": 150,
    "6": 152,
    "7": 0,
    "8": 0,
    "9": 0,
    "10": 0,
    "11": 0
  }
}
```

```json !! title="Legacy"
{
  // !mention(1:12) accounts
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  // !mention program-id
  "programId": "11111111111111111111111111111111",
  // !mention data
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

```json !! title="Rust"
{
  // !mention program-id
  "program_id": "11111111111111111111111111111111",
  // !mention(1:12) accounts
  "accounts": [
    {
      "pubkey": "Hhh6vrA6xUNwaNftJVAXSTzfHiRiAKFKLGmHdcRH6Pmo",
      "is_signer": true,
      "is_writable": true
    },
    {
      "pubkey": "6RYMY3mFLixELbfNCMA7zNtzgNfRyEZs5YYkZQb8aK4t",
      "is_signer": false,
      "is_writable": true
    }
  ],
  // !mention data
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

</CodeTabs>

</WithMentions>

توضح الأمثلة أدناه كيفية بناء تعليمة التحويل يدويًا. (علامة التبويب
`Expanded Instruction` مكافئة وظيفيًا لعلامة التبويب `Instruction`)

<Callout type="info">
  في الواقع العملي، عادةً لا تحتاج إلى إنشاء `Instruction` يدويًا. توفر معظم
  البرامج مكتبات عميلة مع دوال مساعدة تقوم بإنشاء التعليمات نيابة عنك. إذا لم
  تكن هناك مكتبة متاحة، يمكنك بناء التعليمة يدويًا.
</Callout>

<Tabs items={['Kit', 'Legacy', 'Rust']}>

<Tab value="Kit">

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const TRANSFER_INSTRUCTION_INDEX = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(TRANSFER_INSTRUCTION_INDEX, 0);
instructionData.writeBigUInt64LE(transferAmount * LAMPORTS_PER_SOL, 4);

const SYSTEM_PROGRAM_ADDRESS = "11111111111111111111111111111111" as Address;

// Manually create the transfer instruction
const transferInstruction: IInstruction = {
  programAddress: SYSTEM_PROGRAM_ADDRESS,
  accounts: [
    {
      address: sender.address,
      role: AccountRole.WRITABLE_SIGNER
    },
    {
      address: recipient.address,
      role: AccountRole.WRITABLE
    }
  ],
  data: new Uint8Array(instructionData)
};
```

</CodeTabs>

</Tab>

<Tab value="Legacy">

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const transferInstructionIndex = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(transferInstructionIndex, 0);
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// Manually create a transfer instruction
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true }, // from account, is signer and is writable
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true } // to account, is not signer but is writable
  ],
  programId: SystemProgram.programId,
  data: instructionData
});
```

</CodeTabs>

</Tab>

<Tab value="Rust">

<CodeTabs>

```rs !! title="Instruction"
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

let transfer_instruction =
    system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);
```

```rs !! title="Expanded Instruction"
// Instruction index for the System Program's transfer instruction
let transfer_instruction_index: u32 = 2;

// Define the amount to transfer
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

// Create instruction data manually (12 bytes: 4 for u32 index + 8 for u64 lamports)
let mut instruction_data = Vec::with_capacity(12);
instruction_data.extend_from_slice(&transfer_instruction_index.to_le_bytes());
instruction_data.extend_from_slice(&transfer_amount.to_le_bytes());

// Manually create the transfer instruction
let transfer_instruction = Instruction {
    program_id: system_program::id(),
    accounts: vec![
        AccountMeta::new(sender.pubkey(), true), // from account, is signer and is writable
        AccountMeta::new(recipient.pubkey(), false), // to account, is not signer but is writable
    ],
    data: instruction_data,
};
```

</CodeTabs>

</Tab>

</Tabs>
