---
title: Λογαριασμοί
description:
  Μάθετε για το μοντέλο λογαριασμού του Solana, συμπεριλαμβανομένου του τρόπου
  με τον οποίο οι λογαριασμοί αποθηκεύουν δεδομένα και προγράμματα, τους
  μηχανισμούς rent, την ιδιοκτησία λογαριασμών και τη σχέση μεταξύ προγραμμάτων
  και λογαριασμών δεδομένων. Κατανοήστε τις βασικές έννοιες του συστήματος
  αποθήκευσης key-value του Solana.
---

Όλα τα δεδομένα στο δίκτυο Solana αποθηκεύονται σε λογαριασμούς. Μπορείτε να
σκεφτείτε το δίκτυο Solana ως μια δημόσια βάση δεδομένων με έναν μοναδικό πίνακα
Λογαριασμών. Η σχέση μεταξύ ενός λογαριασμού και της διεύθυνσής του είναι
παρόμοια με αυτή ενός ζεύγους κλειδιού-τιμής, όπου το κλειδί είναι η διεύθυνση
και η τιμή είναι ο λογαριασμός.

Κάθε λογαριασμός έχει την ίδια βασική [δομή](#account-structure) και μπορεί να
εντοπιστεί χρησιμοποιώντας τη [διεύθυνσή](#account-address) του.

![Διάγραμμα 3 λογαριασμών και των διευθύνσεών τους. Περιλαμβάνει τον ορισμό της δομής λογαριασμού.](/assets/docs/core/accounts/accounts.png)

## Διεύθυνση λογαριασμού

Η διεύθυνση του λογαριασμού είναι ένα μοναδικό αναγνωριστικό 32 byte που
χρησιμοποιείται για τον εντοπισμό του λογαριασμού στο blockchain της Solana. Οι
διευθύνσεις λογαριασμών συχνά εμφανίζονται ως συμβολοσειρές κωδικοποιημένες σε
base58. Οι περισσότεροι λογαριασμοί χρησιμοποιούν ένα
[δημόσιο κλειδί](#public-key) [Ed25519](https://ed25519.cr.yp.to/) ως διεύθυνσή
τους, αλλά αυτό δεν είναι απαραίτητο, καθώς η Solana υποστηρίζει επίσης
[διευθύνσεις παραγόμενες από προγράμματα](#program-derived-address).

![Ένας λογαριασμός με τη διεύθυνση δημόσιου κλειδιού του κωδικοποιημένη σε base58](/assets/docs/core/accounts/account-address.svg)

### Δημόσιο κλειδί

Το παρακάτω παράδειγμα δείχνει πώς να χρησιμοποιήσετε το SDK της Solana για να
δημιουργήσετε ένα keypair.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner } from "@solana/kit";

// Kit does not enable extractable private keys
const keypairSigner = await generateKeyPairSigner();
console.log(keypairSigner);
```

```ts !! title="Legacy"
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);
console.log(`Secret Key: ${keypair.secretKey}`);
```

```rs !! title="Rust"
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() {
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());
    println!("Secret Key: {:?}", keypair.to_bytes());
}
```

</CodeTabs>

### Program Derived Address

Ένα [Program Derived Address](/docs/core/pda) (PDA) είναι μια διεύθυνση που
προσδιορίζεται ντετερμινιστικά χρησιμοποιώντας ένα αναγνωριστικό προγράμματος
και μία ή περισσότερες προαιρετικές εισόδους (seeds). Το παρακάτω παράδειγμα
δείχνει πώς να χρησιμοποιήσετε το SDK της Solana για να δημιουργήσετε ένα
Program Derived Address.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey; // macro
use solana_sdk::pubkey::Pubkey;

#[tokio::main]
async fn main() {
    let program_address = pubkey!("11111111111111111111111111111111");
    let seeds = [b"helloWorld".as_ref()];
    let (pda, bump) = Pubkey::find_program_address(&seeds, &program_address);
    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
}
```

</CodeTabs>

## Δομή λογαριασμού

Κάθε
[`Account`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L48-L60)
έχει μέγιστο μέγεθος
[10MiB](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/system_instruction.rs#L85)
και περιέχει τις ακόλουθες πληροφορίες:

<WithMentions>

- [`lamports`](mention:lamports): Ο αριθμός των [lamports](#lamports) στον
  λογαριασμό
- [`data`](mention:data): Τα [δεδομένα](#data) του λογαριασμού
- [`owner`](mention:owner): Το αναγνωριστικό του προγράμματος που
  [κατέχει](#owner) τον λογαριασμό
- [`executable`](mention:executable): Υποδεικνύει εάν ο λογαριασμός περιέχει
  εκτελέσιμο [δυαδικό αρχείο](#executable)
- [`rent_epoch`](mention:rent_epoch): Το παρωχημένο πεδίο
  [epoch ενοικίου](#rent-epoch)

```rust title="Account"
pub struct Account {
    /// lamports in the account
    // !mention lamports
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    // !mention data
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    // !mention owner
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    // !mention executable
    pub executable: bool,
    /// the epoch at which this account will next owe rent
    // !mention rent_epoch
    pub rent_epoch: Epoch,
}
```

</WithMentions>

<ScrollyCoding>

## !!steps Lamports

Το υπόλοιπο του λογαριασμού σε [lamports](/docs/references/terminology#lamport).

Κάθε λογαριασμός πρέπει να έχει ένα ελάχιστο υπόλοιπο lamport, που ονομάζεται
[rent](/docs/references/terminology#rent), το οποίο επιτρέπει την αποθήκευση των
δεδομένων του στην αλυσίδα. Το rent είναι ανάλογο με το μέγεθος του λογαριασμού.

<Callout type="info">
  Παρόλο που αυτό το υπόλοιπο ονομάζεται rent, λειτουργεί περισσότερο σαν
  κατάθεση, καθώς το πλήρες υπόλοιπο μπορεί να ανακτηθεί όταν ο λογαριασμός
  κλείσει. (Το όνομα "rent" προέρχεται από το πλέον παρωχημένο πεδίο [rent
  epoch](#rent-epoch).)
</Callout>

(Δείτε τον τύπο
[ελάχιστου υπολοίπου](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97)
και τις εφαρμοστέες
[σταθερές](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L47-L70).)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    // !focus
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    // !focus
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Δεδομένα

Αυτό το πεδίο αναφέρεται συνήθως ως "δεδομένα λογαριασμού". Τα `data` σε αυτό το
πεδίο θεωρούνται αυθαίρετα καθώς μπορούν να περιέχουν οποιαδήποτε ακολουθία
bytes. Κάθε πρόγραμμα καθορίζει τη δομή των δεδομένων που αποθηκεύονται σε αυτό
το πεδίο.

- Program accounts: Αυτό το πεδίο περιέχει είτε εκτελέσιμο κώδικα προγράμματος
  είτε τη διεύθυνση ενός
  [λογαριασμού δεδομένων προγράμματος](#program-data-accounts) που αποθηκεύει
  τον εκτελέσιμο κώδικα προγράμματος.
- Λογαριασμοί δεδομένων: Αυτό το πεδίο γενικά αποθηκεύει δεδομένα κατάστασης,
  που προορίζονται για ανάγνωση.

Η ανάγνωση δεδομένων από έναν λογαριασμό Solana περιλαμβάνει δύο βήματα:

1. Ανάκτηση του λογαριασμού χρησιμοποιώντας τη [διεύθυνσή του](#account-address)
2. Αποσειριοποίηση του πεδίου `data` του λογαριασμού από ακατέργαστα bytes στην
   κατάλληλη δομή δεδομένων, όπως ορίζεται από το πρόγραμμα που κατέχει τον
   λογαριασμό.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    // !focus
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    // !focus
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    // !focus
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    // !focus
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Ιδιοκτήτης

Αυτό το πεδίο περιέχει το αναγνωριστικό προγράμματος του ιδιοκτήτη του
λογαριασμού.

Κάθε λογαριασμός Solana έχει ένα [πρόγραμμα](/docs/core/programs) που ορίζεται
ως ιδιοκτήτης του. Ο ιδιοκτήτης του λογαριασμού είναι το μόνο πρόγραμμα που
μπορεί να αλλάξει τα `data` του λογαριασμού ή να αφαιρέσει lamports, όπως
υποδεικνύεται από τις οδηγίες του προγράμματος.

(Στην περίπτωση ενός program account, ο ιδιοκτήτης είναι το
[πρόγραμμα φορτωτή](https://solana.com/docs/core/programs#loader-programs).)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    // !focus
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    // !focus
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Εκτελέσιμο

Αυτό το πεδίο υποδεικνύει εάν ένας λογαριασμός είναι ένας
[program account](#program-accounts) ή ένας
[λογαριασμός δεδομένων](#data-accounts)

- Αν `true`: Ο λογαριασμός είναι program account
- Αν `false`: Ο λογαριασμός είναι λογαριασμός δεδομένων

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    // !focus
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    // !focus
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Εποχή rent

**Το πεδίο `rent_epoch` είναι παρωχημένο.**

Στο παρελθόν, αυτό το πεδίο παρακολουθούσε πότε ένας λογαριασμός θα χρειαζόταν
να πληρώσει rent. Ωστόσο, αυτός ο μηχανισμός συλλογής rent έχει πλέον
καταργηθεί.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    // !focus
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    // !focus
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

</ScrollyCoding>

## Τύποι λογαριασμών

Υπάρχουν δύο βασικές κατηγορίες στις οποίες εμπίπτουν οι λογαριασμοί:

- [Program accounts](#program-accounts): Λογαριασμοί που περιέχουν εκτελέσιμο
  κώδικα
- [Λογαριασμοί δεδομένων](#data-accounts): Λογαριασμοί που δεν περιέχουν
  εκτελέσιμο κώδικα

Αυτός ο διαχωρισμός σημαίνει ότι ο εκτελέσιμος κώδικας ενός προγράμματος και η
κατάστασή του αποθηκεύονται σε ξεχωριστούς λογαριασμούς. (Παρόμοια με τα
λειτουργικά συστήματα, τα οποία συνήθως έχουν ξεχωριστά αρχεία για τα
προγράμματα και τα δεδομένα τους.)

### Program accounts

Κάθε πρόγραμμα ανήκει σε ένα
[πρόγραμμα φορτωτή](/docs/core/programs#loader-programs), το οποίο
χρησιμοποιείται για την ανάπτυξη και διαχείριση του λογαριασμού. Όταν
αναπτύσσεται ένα νέο [πρόγραμμα](/docs/core/programs), δημιουργείται ένας
λογαριασμός για την αποθήκευση του [εκτελέσιμου](#executable) κώδικά του. Αυτός
ονομάζεται program account. (Για απλότητα, μπορείτε να θεωρήσετε τον program
account ως το ίδιο το πρόγραμμα.)

Στο παρακάτω διάγραμμα, μπορείτε να δείτε ότι ένα πρόγραμμα φορτωτή
χρησιμοποιείται για την ανάπτυξη ενός program account. Το πεδίο `data` του
program account περιέχει τον εκτελέσιμο κώδικα του προγράμματος.

![Διάγραμμα ενός program account, των 4 συστατικών του και του προγράμματος φορτωτή του.](/assets/docs/core/accounts/program-account-simple.svg)

#### Λογαριασμοί δεδομένων προγράμματος

Τα προγράμματα που αναπτύσσονται με τη χρήση του loader-v3 δεν περιέχουν κώδικα
προγράμματος στο πεδίο `data` τους. Αντίθετα, το πεδίο `data` τους δείχνει σε
έναν ξεχωριστό **λογαριασμό δεδομένων προγράμματος**, ο οποίος περιέχει τον
κώδικα του προγράμματος. (Δείτε το παρακάτω διάγραμμα.)

![Ένας λογαριασμός προγράμματος με δεδομένα. Τα δεδομένα δείχνουν σε έναν ξεχωριστό λογαριασμό δεδομένων προγράμματος](/assets/docs/core/accounts/program-account-expanded.svg)

<Callout>
  Κατά την ανάπτυξη ή αναβάθμιση προγραμμάτων, οι λογαριασμοί buffer
  χρησιμοποιούνται για την προσωρινή σταδιακή μεταφόρτωση.
</Callout>

Το παρακάτω παράδειγμα ανακτά τον λογαριασμό του Token Program. Παρατηρήστε ότι
το πεδίο `executable` έχει οριστεί σε `true`, υποδεικνύοντας ότι ο λογαριασμός
είναι πρόγραμμα.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const programId = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address;

const accountInfo = await rpc
  .getAccountInfo(programId, { encoding: "base64" })
  .send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Connection, PublicKey } from "@solana/web3.js";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const programId = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

const accountInfo = await connection.getAccountInfo(programId);
// !collapse(1:17) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::pubkey;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let program_id = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let account_info = connection.get_account(&program_id).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

### Λογαριασμοί δεδομένων

Οι λογαριασμοί δεδομένων δεν περιέχουν εκτελέσιμο κώδικα. Αντίθετα, αποθηκεύουν
πληροφορίες.

#### Λογαριασμός κατάστασης προγράμματος

Τα προγράμματα χρησιμοποιούν λογαριασμούς δεδομένων για να διατηρούν την
κατάστασή τους. Για να το κάνουν αυτό, πρέπει πρώτα να δημιουργήσουν έναν νέο
λογαριασμό δεδομένων. Η διαδικασία δημιουργίας ενός λογαριασμού κατάστασης
προγράμματος συχνά αφαιρείται, αλλά είναι χρήσιμο να κατανοήσουμε την υποκείμενη
διαδικασία.

Για να διαχειριστεί την κατάστασή του, ένα νέο πρόγραμμα πρέπει:

1. Να επικαλεστεί το [System Program](/docs/core/programs#the-system-program)
   για να δημιουργήσει έναν λογαριασμό. (Το System Program στη συνέχεια
   μεταφέρει την ιδιοκτησία στο νέο πρόγραμμα.)
2. Να αρχικοποιήσει τα δεδομένα του λογαριασμού, όπως ορίζεται από τις
   [οδηγίες](/docs/core/instructions) του.

![Διάγραμμα ενός λογαριασμού δεδομένων που ανήκει σε έναν λογαριασμό προγράμματος](/assets/docs/core/accounts/data-account.svg)

Το παρακάτω παράδειγμα δημιουργεί και ανακτά έναν λογαριασμό Token Mint που
ανήκει στο πρόγραμμα Token 2022.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  fetchMint
} from "@solana-program/token-2022";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer
const feePayer = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Instruction to create new account for mint (token 2022 program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token 2022 program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address
});

const instructions = [createAccountInstruction, initializeMintInstruction];

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }), // Create transaction message
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx), // Set fee payer
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set transaction blockhash
  (tx) => appendTransactionMessageInstructions(instructions, tx) // Append instructions
);

// Sign transaction message with required signers (fee payer and mint keypair)
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Mint Address:", mint.address);
console.log("Transaction Signature:", transactionSignature);

const accountInfo = await rpc.getAccountInfo(mint.address).send();
console.log(accountInfo);

const mintAccount = await fetchMint(rpc, mint.address);
console.log(mintAccount);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  TOKEN_2022_PROGRAM_ID,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const recentBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: recentBlockhash.blockhash,
  lastValidBlockHeight: recentBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Generate keypair to use as address of mint
const mint = Keypair.generate();

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: await getMinimumBalanceForRentExemptMint(connection),
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);

const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint] // Signers
);

console.log("Mint Address: ", mint.publicKey.toBase58());
console.log("Transaction Signature: ", transactionSignature);

const accountInfo = await connection.getAccountInfo(mint.publicKey);

// !collapse(1:16) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);

const mintAccount = await getMint(
  connection,
  mint.publicKey,
  "confirmed",
  TOKEN_2022_PROGRAM_ID
);
console.log(mintAccount);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    program_pack::Pack,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_token_2022_interface::{
    id as token_2022_program_id, instruction::initialize_mint, state::Mint,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let recent_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    let space = Mint::LEN;
    let rent = client.get_minimum_balance_for_rent_exemption(space).await?;

    // Create account instruction
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),      // fee payer
        &mint.pubkey(),           // mint address
        rent,                     // rent
        space as u64,             // space
        &token_2022_program_id(), // program id
    );

    // Initialize mint instruction
    let initialize_mint_instruction = initialize_mint(
        &token_2022_program_id(),
        &mint.pubkey(),            // mint address
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        9,                         // decimals
    )?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        recent_blockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    let account_info = client.get_account(&mint.pubkey()).await?;
    println!("{:#?}", account_info);

    let mint_account = Mint::unpack(&account_info.data)?;
    println!("{:#?}", mint_account);

    Ok(())
}
```

</CodeTabs>

#### Λογαριασμοί συστήματος

Δεν ανατίθενται όλοι οι λογαριασμοί σε νέο ιδιοκτήτη μετά τη δημιουργία τους από
το System Program. Οι λογαριασμοί που ανήκουν στο System Program ονομάζονται
λογαριασμοί συστήματος. Όλοι οι λογαριασμοί πορτοφολιού είναι λογαριασμοί
συστήματος, γεγονός που τους επιτρέπει να πληρώνουν
[χρεώσεις συναλλαγών](docs/core/fees).

![Ένα πορτοφόλι που ανήκει στο System Program και περιέχει 1.000.000 lamports](/assets/docs/core/accounts/system-account.svg)

Όταν αποστέλλεται SOL σε μια νέα διεύθυνση για πρώτη φορά, δημιουργείται ένας
λογαριασμός σε αυτή τη διεύθυνση που ανήκει στο System Program.

Στο παρακάτω παράδειγμα, δημιουργείται ένα νέο keypair και χρηματοδοτείται με
SOL. Μετά την εκτέλεση του κώδικα, μπορείτε να δείτε ότι η διεύθυνση του `owner`
του λογαριασμού είναι `11111111111111111111111111111111` (το
[System Program](/docs/core/programs#the-system-program)).

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  generateKeyPairSigner,
  lamports
} from "@solana/kit";

// Create a connection to Solana cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate a new keypair
const keypair = await generateKeyPairSigner();
console.log(`Public Key: ${keypair.address}`);

// Funding an address with SOL automatically creates an account
const signature = await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: keypair.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

const accountInfo = await rpc.getAccountInfo(keypair.address).send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";

// Generate a new keypair
const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);

// Create a connection to the Solana cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Funding an address with SOL automatically creates an account
const signature = await connection.requestAirdrop(
  keypair.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const accountInfo = await connection.getAccountInfo(keypair.publicKey);
console.log(JSON.stringify(accountInfo, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signer::{keypair::Keypair, Signer},
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate a new keypair
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());

    // Create a connection to Solana cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Funding an address with SOL automatically creates an account
    let signature = connection
        .request_airdrop(&keypair.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = connection.confirm_transaction(&signature).await?;
        if confirmed {
            break;
        }
    }

    let account_info = connection.get_account(&keypair.pubkey()).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

#### Λογαριασμοί Sysvar

Οι λογαριασμοί Sysvar υπάρχουν σε προκαθορισμένες διευθύνσεις και παρέχουν
πρόσβαση σε δεδομένα κατάστασης του συμπλέγματος. Ενημερώνονται δυναμικά με
δεδομένα σχετικά με το δίκτυο του συμπλέγματος. Δείτε την πλήρη λίστα των
[Λογαριασμών Sysvar](https://docs.anza.xyz/runtime/sysvars).

Το παρακάτω παράδειγμα ανακτά και αποσειριοποιεί δεδομένα από τον λογαριασμό
Sysvar Clock.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { createSolanaRpc } from "@solana/kit";
import { fetchSysvarClock, SYSVAR_CLOCK_ADDRESS } from "@solana/sysvars";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const accountInfo = await rpc
  .getAccountInfo(SYSVAR_CLOCK_ADDRESS, { encoding: "base64" })
  .send();
console.log(accountInfo);

// Automatically fetch and deserialize the account data
const clock = await fetchSysvarClock(rpc);
console.log(clock);
```

```ts !! title="Legacy"
import { Connection, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getSysvarClockCodec } from "@solana/sysvars";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const accountInfo = await connection.getAccountInfo(SYSVAR_CLOCK_PUBKEY);

// Deserialize the account data
const decodedClock = getSysvarClockCodec().decode(
  new Uint8Array(accountInfo?.data ?? [])
);
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
console.log(decodedClock);
```

```rs !! title="Rust"
use anyhow::Result;
use bincode::deserialize;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::sysvar::{self, clock::Clock};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let account = connection.get_account(&sysvar::clock::ID).await?;
    // Deserialize the account data
    let clock: Clock = deserialize(&account.data)?;

    println!("{:#?}", account);
    println!("{:#?}", clock);

    Ok(())
}
```

</CodeTabs>
