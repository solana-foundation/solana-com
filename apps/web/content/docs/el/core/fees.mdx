---
title: Τέλη Συναλλαγών
description:
  Μάθετε για τα τέλη συναλλαγών του Solana, συμπεριλαμβανομένων των βασικών και
  των τελών προτεραιότητας, πώς εφαρμόζεται το καθένα, και τις βέλτιστες
  πρακτικές για τη διαχείριση των υπολογιστικών μονάδων στις συναλλαγές σας.
---

Κάθε συναλλαγή Solana απαιτεί ένα τέλος συναλλαγής, που πληρώνεται σε SOL. Τα
τέλη συναλλαγών χωρίζονται σε δύο μέρη: το βασικό τέλος και το τέλος
προτεραιότητας. Το βασικό τέλος αποζημιώνει τους validators για την επεξεργασία
της συναλλαγής. Το τέλος προτεραιότητας είναι ένα προαιρετικό τέλος, για να
αυξήσει την πιθανότητα ο τρέχων ηγέτης να επεξεργαστεί τη συναλλαγή σας.

## Βασικό τέλος

Κάθε συναλλαγή κοστίζει 5000 [lamports](/docs/references/terminology#lamport)
ανά συμπεριλαμβανόμενη υπογραφή. Αυτό το τέλος καταβάλλεται από τον πρώτο
υπογράφοντα της συναλλαγής και πρέπει να πληρωθεί από έναν λογαριασμό που ανήκει
στο System Program. Το βασικό τέλος κατανέμεται ως εξής:

- **50% καίγεται:** Το μισό
  [καίγεται](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (αφαιρείται από την κυκλοφορούσα προσφορά SOL).
- **50% διανέμεται:** Το μισό
  [πληρώνεται στον validator](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
  που επεξεργάστηκε τη συναλλαγή.

## Τέλος προτεραιότητας

Ένα
[τέλος προτεραιότητας](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
είναι ένα προαιρετικό τέλος που χρησιμοποιείται για να αυξήσει την πιθανότητα ο
τρέχων ηγέτης (validator) να επεξεργαστεί τη συναλλαγή σας. Ο validator λαμβάνει
[το 100% του τέλους προτεραιότητας](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Τα τέλη προτεραιότητας μπορούν να οριστούν προσαρμόζοντας την τιμή της
[υπολογιστικής μονάδας](/docs/references/terminology#compute-units) (CU) της
συναλλαγής και το όριο CU. (Δείτε τον
[Οδηγό Χρήσης Τελών Προτεραιότητας](/developers/guides/advanced/how-to-use-priority-fees)
για περισσότερες λεπτομέρειες σχετικά με τα τέλη προτεραιότητας.)

Το τέλος προτεραιότητας υπολογίζεται ως εξής:

**Τέλος προτεραιότητας = Όριο μονάδων υπολογισμού × Τιμή μονάδας υπολογισμού**

Το τέλος προτεραιότητας χρησιμοποιείται για να καθορίσει την
[προτεραιότητα της συναλλαγής σας](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646),
σε σχέση με άλλες συναλλαγές. Υπολογίζεται χρησιμοποιώντας τον ακόλουθο τύπο:

**Προτεραιότητα συναλλαγής = Τέλος προτεραιότητας / Όριο μονάδων υπολογισμού**

#### Όριο υπολογιστικών μονάδων

[Από προεπιλογή](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
κάθε εντολή διαθέτει
[200.000 CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
και κάθε συναλλαγή διαθέτει
[1,4 εκατομμύρια CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14).
Μπορείτε να αλλάξετε αυτές τις προεπιλογές συμπεριλαμβάνοντας μια εντολή
[ComputeBudgetInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
στη συναλλαγή σας.

Για να υπολογίσετε το κατάλληλο όριο CU για τη συναλλαγή σας, συνιστούμε τα
ακόλουθα βήματα:

1. Εκτιμήστε τις απαιτούμενες μονάδες CU
   [προσομοιώνοντας](/developers/guides/advanced/how-to-request-optimal-compute)
   τη συναλλαγή
2. Προσθέστε ένα περιθώριο ασφαλείας 10% σε αυτήν την εκτίμηση

<Callout type="warn">
  Το τέλος προτεραιότητας καθορίζεται από το ζητούμενο όριο υπολογιστικών
  μονάδων της συναλλαγής, *όχι* από τον πραγματικό αριθμό υπολογιστικών μονάδων
  που χρησιμοποιούνται. Εάν ορίσετε ένα όριο υπολογιστικών μονάδων που είναι
  πολύ υψηλό ή χρησιμοποιήσετε το προεπιλεγμένο ποσό, μπορεί να πληρώσετε για
  αχρησιμοποίητες υπολογιστικές μονάδες.
</Callout>

#### Τιμή υπολογιστικής μονάδας

Η τιμή υπολογιστικής μονάδας είναι ένα προαιρετικό ποσό
[micro-lamports](/docs/references/terminology#micro-lamports) που πληρώνεται για
κάθε ζητούμενη CU. Μπορείτε να σκεφτείτε την τιμή CU ως φιλοδώρημα για να
ενθαρρύνετε τον validator να δώσει προτεραιότητα στη συναλλαγή σας. Για να
ορίσετε την τιμή CU, συμπεριλάβετε μια
[ComputeBudgetInstruction::SetComputeUnitPrice](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
εντολή στη συναλλαγή σας.

<Callout>
  Η προεπιλεγμένη τιμή CU είναι 0, που σημαίνει ότι το προεπιλεγμένο τέλος
  προτεραιότητας είναι επίσης 0.
</Callout>

Για βοήθεια στον καθορισμό της καλύτερης τιμής CU για τη συναλλαγή σας, δείτε τη
σύσταση τιμής CU σε πραγματικό χρόνο που παρέχεται στον παρακάτω πίνακα.

| Πάροχος                                 | API τέλους προτεραιότητας                                                      |
| --------------------------------------- | ------------------------------------------------------------------------------ |
| [Helius](https://www.helius.dev/)       | [Τεκμηρίωση](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Τεκμηρίωση](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Τεκμηρίωση](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Παράδειγμα

Τα παρακάτω παραδείγματα δείχνουν πώς να ορίσετε το όριο CU και την τιμή CU σε
μια συναλλαγή χρησιμοποιώντας τα SDK της Solana.

| SDK                          | Αναφορά πηγαίου κώδικα                                                                                                                           |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| @solana/web3.js (Typescript) | [ComputeBudgetProgram.setComputeUnitPrice](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| solana-sdk (Rust)            | [ComputeBudgetInstruction::set_compute_unit_price](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)             |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
