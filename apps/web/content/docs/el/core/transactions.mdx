---
title: Συναλλαγές και Οδηγίες
description:
  Μάθετε για τις συναλλαγές και τις οδηγίες της Solana - τα θεμελιώδη δομικά
  στοιχεία για την αλληλεπίδραση με το blockchain της Solana. Κατανοήστε τη δομή
  των συναλλαγών και τη σύνθεση των οδηγιών με πρακτικά παραδείγματα.
---

Στη Solana, οι χρήστες στέλνουν
[συναλλαγές](/docs/core/transactions#transaction) για να αλληλεπιδράσουν με το
δίκτυο. Οι συναλλαγές περιέχουν μία ή περισσότερες
[οδηγίες](/docs/core/transactions#instruction) που καθορίζουν τις λειτουργίες
προς επεξεργασία. Η λογική εκτέλεσης για τις οδηγίες αποθηκεύεται σε
[προγράμματα](/docs/core/programs) που έχουν αναπτυχθεί στο δίκτυο της Solana,
όπου κάθε πρόγραμμα ορίζει το δικό του σύνολο οδηγιών.

Παρακάτω παρουσιάζονται βασικές λεπτομέρειες σχετικά με την επεξεργασία
συναλλαγών της Solana:

- Εάν μια συναλλαγή περιλαμβάνει πολλαπλές οδηγίες, οι οδηγίες εκτελούνται με τη
  σειρά που προστέθηκαν στη συναλλαγή.
- Οι συναλλαγές είναι "ατομικές" - όλες οι οδηγίες πρέπει να επεξεργαστούν
  επιτυχώς, διαφορετικά ολόκληρη η συναλλαγή αποτυγχάνει και δεν
  πραγματοποιούνται αλλαγές.

Μια συναλλαγή είναι ουσιαστικά ένα αίτημα για επεξεργασία μίας ή περισσότερων
εντολών. Μπορείτε να σκεφτείτε μια συναλλαγή ως έναν φάκελο που περιέχει έντυπα.
Κάθε έντυπο είναι μια εντολή που λέει στο δίκτυο τι να κάνει. Η αποστολή της
συναλλαγής είναι σαν να ταχυδρομείτε τον φάκελο για να επεξεργαστούν τα έντυπα.

![Απλοποιημένη Συναλλαγή](/assets/docs/core/transactions/transaction-simple.svg)

## Βασικά σημεία

- Οι συναλλαγές Solana περιλαμβάνουν οδηγίες που καλούν προγράμματα στο δίκτυο.
- Οι συναλλαγές είναι **ατομικές** - αν οποιαδήποτε οδηγία αποτύχει, ολόκληρη η
  συναλλαγή αποτυγχάνει και δεν πραγματοποιούνται αλλαγές.
- Οι οδηγίες σε μια συναλλαγή εκτελούνται με διαδοχική σειρά.
- Το όριο μεγέθους συναλλαγής είναι
  [1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
  bytes.
- Κάθε οδηγία απαιτεί τρία στοιχεία πληροφοριών:
  1. Τη διεύθυνση του προγράμματος που θα κληθεί
  2. Τους λογαριασμούς από τους οποίους η οδηγία διαβάζει ή στους οποίους γράφει
  3. Οποιαδήποτε επιπλέον δεδομένα απαιτούνται από την οδηγία (π.χ., ορίσματα
     συνάρτησης)

## Παράδειγμα μεταφοράς SOL

Το παρακάτω διάγραμμα αναπαριστά μια συναλλαγή με μία μόνο εντολή για τη
μεταφορά SOL από έναν αποστολέα σε έναν παραλήπτη.

Στο Solana, τα "πορτοφόλια" είναι λογαριασμοί που ανήκουν στο
[System Program](/docs/core/accounts#system-program). Μόνο ο ιδιοκτήτης του
προγράμματος μπορεί να αλλάξει τα δεδομένα ενός λογαριασμού, οπότε η μεταφορά
SOL απαιτεί την αποστολή μιας συναλλαγής για να καλέσει το System Program.

![Μεταφορά SOL](/assets/docs/core/transactions/sol-transfer.svg)

Ο λογαριασμός του αποστολέα πρέπει να υπογράψει (`is_signer`) τη συναλλαγή για
να επιτρέψει στο System Program να αφαιρέσει το υπόλοιπο των lamport του. Οι
λογαριασμοί του αποστολέα και του παραλήπτη πρέπει να είναι εγγράψιμοι
(`is_writable`) αφού τα υπόλοιπα των lamport τους αλλάζουν.

Μετά την αποστολή της συναλλαγής, το System Program επεξεργάζεται την εντολή
μεταφοράς. Το System Program στη συνέχεια ενημερώνει τα υπόλοιπα των lamport
τόσο του λογαριασμού του αποστολέα όσο και του παραλήπτη.

![Διαδικασία μεταφοράς SOL](/assets/docs/core/transactions/sol-transfer-process.svg)

Τα παρακάτω παραδείγματα δείχνουν πώς να στείλετε μια συναλλαγή που μεταφέρει
SOL από έναν λογαριασμό σε έναν άλλο. Δείτε τον πηγαίο κώδικα της εντολής
μεταφοράς του System Program
[εδώ](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L183).

<CodeTabs flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

// Create a connection to cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Fund sender with airdrop
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: sender.address,
  lamports: lamports(LAMPORTS_PER_SOL), // 1 SOL
  commitment: "confirmed"
});

// Check balance before transfer
const { value: preBalance1 } = await rpc.getBalance(sender.address).send();
const { value: preBalance2 } = await rpc.getBalance(recipient.address).send();

// !mark(1:6)
// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount // 0.01 SOL in lamports
});

// Add the transfer instruction to a new transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

// Send the transaction to the network
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);
const transactionSignature = getSignatureFromTransaction(signedTransaction);

// Check balance after transfer
const { value: postBalance1 } = await rpc.getBalance(sender.address).send();
const { value: postBalance2 } = await rpc.getBalance(recipient.address).send();

console.log(
  "Sender prebalance:",
  Number(preBalance1) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Recipient prebalance:",
  Number(preBalance2) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Sender postbalance:",
  Number(postBalance1) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Recipient postbalance:",
  Number(postBalance2) / Number(LAMPORTS_PER_SOL)
);
console.log("Transaction Signature:", transactionSignature);
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

// Create a connection to cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Fund sender with airdrop
const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Check balance before transfer
const preBalance1 = await connection.getBalance(sender.publicKey);
const preBalance2 = await connection.getBalance(recipient.publicKey);

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// !mark(1:6)
// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

// Add the transfer instruction to a new transaction
const transaction = new Transaction().add(transferInstruction);

// Send the transaction to the network
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [sender] // signer
);

// Check balance after transfer
const postBalance1 = await connection.getBalance(sender.publicKey);
const postBalance2 = await connection.getBalance(recipient.publicKey);

console.log("Sender prebalance:", preBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient prebalance:", preBalance2 / LAMPORTS_PER_SOL);
console.log("Sender postbalance:", postBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient postbalance:", postBalance2 / LAMPORTS_PER_SOL);
console.log("Transaction Signature:", transactionSignature);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, signature::Signer,
    signer::keypair::Keypair, system_instruction, transaction::Transaction,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create a connection to cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Fund sender with airdrop
    let airdrop_signature = connection
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;
    loop {
        let confirmed = connection.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Check balance before transfer
    let pre_balance1 = connection.get_balance(&sender.pubkey()).await?;
    let pre_balance2 = connection.get_balance(&recipient.pubkey()).await?;

    // Define the amount to transfer
    let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

    // !mark(1:3)
    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction =
        system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    // Add the transfer instruction to a new transaction
    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    let blockhash = connection.get_latest_blockhash().await?;
    transaction.sign(&[&sender], blockhash);

    // Send the transaction to the network
    let transaction_signature = connection
        .send_and_confirm_transaction(&transaction)
        .await?;

    // Check balance after transfer
    let post_balance1 = connection.get_balance(&sender.pubkey()).await?;
    let post_balance2 = connection.get_balance(&recipient.pubkey()).await?;

    println!(
        "Sender prebalance: {}",
        pre_balance1 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Recipient prebalance: {}",
        pre_balance2 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Sender postbalance: {}",
        post_balance1 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Recipient postbalance: {}",
        post_balance2 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

</CodeTabs>

Οι βιβλιοθήκες πελάτη συχνά αφαιρούν τις λεπτομέρειες για τη δημιουργία οδηγιών
προγράμματος. Αν δεν υπάρχει διαθέσιμη βιβλιοθήκη, μπορείτε να δημιουργήσετε
χειροκίνητα την οδηγία. Αυτό απαιτεί να γνωρίζετε τις λεπτομέρειες υλοποίησης
της οδηγίας.

Τα παρακάτω παραδείγματα δείχνουν πώς να δημιουργήσετε χειροκίνητα την οδηγία
μεταφοράς. Η καρτέλα `Expanded Instruction` είναι λειτουργικά ισοδύναμη με την
καρτέλα `Instruction`.

<Tabs items={['Kit', 'Legacy', 'Rust']}>

<Tab value="Kit">

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const TRANSFER_INSTRUCTION_INDEX = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(TRANSFER_INSTRUCTION_INDEX, 0);
instructionData.writeBigUInt64LE(transferAmount * LAMPORTS_PER_SOL, 4);

const SYSTEM_PROGRAM_ADDRESS = "11111111111111111111111111111111" as Address;

// Manually create the transfer instruction
const transferInstruction: IInstruction = {
  programAddress: SYSTEM_PROGRAM_ADDRESS,
  accounts: [
    {
      address: sender.address,
      role: AccountRole.WRITABLE_SIGNER
    },
    {
      address: recipient.address,
      role: AccountRole.WRITABLE
    }
  ],
  data: new Uint8Array(instructionData)
};
```

</CodeTabs>

</Tab>

<Tab value="Legacy">

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const transferInstructionIndex = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(transferInstructionIndex, 0);
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// Manually create a transfer instruction
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true }, // from account, is signer and is writable
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true } // to account, is not signer but is writable
  ],
  programId: SystemProgram.programId,
  data: instructionData
});
```

</CodeTabs>

</Tab>

<Tab value="Rust">

<CodeTabs>

```rs !! title="Instruction"
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

let transfer_instruction =
    system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);
```

```rs !! title="Expanded Instruction"
// Instruction index for the System Program's transfer instruction
let transfer_instruction_index: u32 = 2;

// Define the amount to transfer
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

// Create instruction data manually (12 bytes: 4 for u32 index + 8 for u64 lamports)
let mut instruction_data = Vec::with_capacity(12);
instruction_data.extend_from_slice(&transfer_instruction_index.to_le_bytes());
instruction_data.extend_from_slice(&transfer_amount.to_le_bytes());

// Manually create the transfer instruction
let transfer_instruction = Instruction {
    program_id: system_program::id(),
    accounts: vec![
        AccountMeta::new(sender.pubkey(), true), // from account, is signer and is writable
        AccountMeta::new(recipient.pubkey(), false), // to account, is not signer but is writable
    ],
    data: instruction_data,
};
```

</CodeTabs>

</Tab>

</Tabs>

Στις παρακάτω ενότητες, θα εξετάσουμε λεπτομερώς τις συναλλαγές και τις οδηγίες.

## Οδηγίες

Μια
[εντολή](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)
στο [πρόγραμμα](/docs/core/accounts#program-account) της Solana μπορεί να
θεωρηθεί ως μια δημόσια συνάρτηση που μπορεί να κληθεί από οποιονδήποτε
χρησιμοποιεί το δίκτυο Solana.

Μπορείτε να σκεφτείτε ένα πρόγραμμα Solana ως έναν διακομιστή ιστού που
φιλοξενείται στο δίκτυο Solana, όπου κάθε εντολή είναι σαν ένα δημόσιο σημείο
πρόσβασης API που οι χρήστες μπορούν να καλέσουν για να εκτελέσουν συγκεκριμένες
ενέργειες. Η επίκληση μιας εντολής είναι παρόμοια με την αποστολή ενός `POST`
αιτήματος σε ένα σημείο πρόσβασης API, επιτρέποντας στους χρήστες να εκτελέσουν
την επιχειρησιακή λογική του προγράμματος.

<WithMentions>

Για να καλέσετε μια εντολή προγράμματος στη Solana, χρειάζεται να δημιουργήσετε
μια `Instruction` με τρία στοιχεία πληροφοριών:

- [Αναγνωριστικό προγράμματος](mention:program-id): Η διεύθυνση του προγράμματος
  με την επιχειρησιακή λογική για την εντολή που καλείται.
- [Λογαριασμοί](mention:accounts): Η λίστα όλων των λογαριασμών από τους οποίους
  η εντολή διαβάζει ή στους οποίους γράφει.
- [Instruction Data](mention:instruction-data): Ένας πίνακας byte που καθορίζει
  ποια εντολή θα κληθεί στο πρόγραμμα και τυχόν απαιτούμενα ορίσματα για την
  εντολή.

```rust title="Instruction"
pub struct Instruction {
    /// Pubkey of the program that executes this instruction.
    // !mention program-id
    pub program_id: Pubkey,
    /// Metadata describing accounts that should be passed to the program.
    // !mention accounts
    pub accounts: Vec<AccountMeta>,
    /// Opaque data passed to the program for its own interpretation.
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Εντολή συναλλαγής](/assets/docs/core/transactions/instruction.svg)

### AccountMeta

<WithMentions>

Κατά τη δημιουργία μιας `Instruction`, πρέπει να παρέχετε κάθε απαιτούμενο
λογαριασμό ως
[`AccountMeta`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25).
Το `AccountMeta` καθορίζει τα εξής:

- [pubkey](mention:pubkey): Η διεύθυνση του λογαριασμού
- [is_signer](mention:is-signer): Αν ο λογαριασμός πρέπει να υπογράψει τη
  συναλλαγή
- [is_writable](mention:is-writable): Αν η εντολή τροποποιεί τα δεδομένα του
  λογαριασμού

```rust title="AccountMeta"
pub struct AccountMeta {
    /// An account's public key.
    // !mention pubkey
    pub pubkey: Pubkey,
    /// True if an `Instruction` requires a `Transaction` signature matching `pubkey`.
    // !mention is-signer
    pub is_signer: bool,
    /// True if the account data or metadata may be mutated during program execution.
    // !mention is-writable
    pub is_writable: bool,
}
```

</WithMentions>

Καθορίζοντας εκ των προτέρων ποιους λογαριασμούς διαβάζει ή γράφει μια εντολή,
οι συναλλαγές που δεν τροποποιούν τους ίδιους λογαριασμούς μπορούν να
εκτελεστούν παράλληλα.

<Callout type="info">

Για να γνωρίζετε ποιους λογαριασμούς απαιτεί μια εντολή, συμπεριλαμβανομένου του
ποιοι πρέπει να είναι εγγράψιμοι, μόνο για ανάγνωση ή να υπογράψουν τη
συναλλαγή, πρέπει να ανατρέξετε στην υλοποίηση της εντολής όπως ορίζεται από το
πρόγραμμα.

Στην πράξη, συνήθως δεν χρειάζεται να κατασκευάσετε ένα Instruction χειροκίνητα.
Οι περισσότεροι προγραμματιστές εφαρμογών παρέχουν βιβλιοθήκες πελάτη με
βοηθητικές συναρτήσεις που δημιουργούν τις οδηγίες για εσάς.

</Callout>

![AccountMeta](/assets/docs/core/transactions/accountmeta.svg)

### Παράδειγμα δομής οδηγίας

Εκτελέστε τα παρακάτω παραδείγματα για να δείτε τη δομή μιας οδηγίας μεταφοράς
SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner, lamports } from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair
} from "@solana/web3.js";

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair, system_instruction,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Define the amount to transfer
    let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = system_instruction::transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        transfer_amount,
    );

    println!("{:#?}", transfer_instruction);

    Ok(())
}
```

</CodeTabs>

Τα παρακάτω παραδείγματα δείχνουν την έξοδο από τα προηγούμενα αποσπάσματα
κώδικα. Η ακριβής μορφή διαφέρει ανάλογα με το SDK, αλλά κάθε οδηγία Solana
απαιτεί τις ακόλουθες πληροφορίες:

<WithMentions>

- [Program ID](mention:program-id): Η διεύθυνση του προγράμματος που θα
  εκτελέσει την οδηγία.
- [Accounts](mention:accounts): Μια λίστα λογαριασμών που απαιτούνται από την
  οδηγία. Για κάθε λογαριασμό, η οδηγία πρέπει να καθορίζει τη διεύθυνσή του, αν
  πρέπει να υπογράψει τη συναλλαγή, και αν θα γίνει εγγραφή σε αυτόν.
- [Data](mention:data): Ένας buffer bytes που λέει στο πρόγραμμα ποια οδηγία να
  εκτελέσει και περιλαμβάνει τυχόν απαιτούμενα ορίσματα από την οδηγία.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  // !mention(1:16) accounts
  "accounts": [
    {
      "address": "Hu28vRMGWpQXN56eaE7jRiDDRRz3vCXEs7EKHRfL6bC",
      "role": 3,
      "signer": {
        "address": "Hu28vRMGWpQXN56eaE7jRiDDRRz3vCXEs7EKHRfL6bC",
        "keyPair": {
          "privateKey": {},
          "publicKey": {}
        }
      }
    },
    {
      "address": "2mBY6CTgeyJNJDzo6d2Umipw2aGUquUA7hLdFttNEj7p",
      "role": 1
    }
  ],
  // !mention program-id
  "programAddress": "11111111111111111111111111111111",
  // !mention(1:14) data
  "data": {
    "0": 2,
    "1": 0,
    "2": 0,
    "3": 0,
    "4": 128,
    "5": 150,
    "6": 152,
    "7": 0,
    "8": 0,
    "9": 0,
    "10": 0,
    "11": 0
  }
}
```

```json !! title="Legacy"
{
  // !mention(1:12) accounts
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  // !mention program-id
  "programId": "11111111111111111111111111111111",
  // !mention data
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

```json !! title="Rust"
{
  // !mention program-id
  "program_id": "11111111111111111111111111111111",
  // !mention(1:12) accounts
  "accounts": [
    {
      "pubkey": "Hhh6vrA6xUNwaNftJVAXSTzfHiRiAKFKLGmHdcRH6Pmo",
      "is_signer": true,
      "is_writable": true
    },
    {
      "pubkey": "6RYMY3mFLixELbfNCMA7zNtzgNfRyEZs5YYkZQb8aK4t",
      "is_signer": false,
      "is_writable": true
    }
  ],
  // !mention data
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

</CodeTabs>

</WithMentions>

## Συναλλαγές

Αφού δημιουργήσετε τις οδηγίες που θέλετε να επικαλεστείτε, το επόμενο βήμα
είναι να δημιουργήσετε ένα Transaction και να προσθέσετε τις οδηγίες στη
συναλλαγή. Μια
[συναλλαγή](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
Solana αποτελείται από:

<WithMentions>

1. [Signatures](mention:signatures): Ένας πίνακας
   [υπογραφών](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
   από όλους τους λογαριασμούς που απαιτούνται ως υπογράφοντες για τις οδηγίες
   στη συναλλαγή. Μια υπογραφή δημιουργείται υπογράφοντας το message της
   συναλλαγής με το ιδιωτικό κλειδί του λογαριασμού.
2. [Message](mention:message): Το
   [μήνυμα](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)
   της συναλλαγής περιλαμβάνει τη λίστα των οδηγιών που θα επεξεργαστούν
   ατομικά.

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![Μορφή Συναλλαγής](/assets/docs/core/transactions/tx_format.png)

Η δομή ενός μηνύματος συναλλαγής αποτελείται από:

<WithMentions>

- [Κεφαλίδα Μηνύματος](mention:message-header): Καθορίζει τον αριθμό των
  λογαριασμών υπογραφόντων και μόνο για ανάγνωση.
- [Διευθύνσεις Λογαριασμών](mention:account-addresses): Ένας πίνακας διευθύνσεων
  λογαριασμών που απαιτούνται από τις οδηγίες στη συναλλαγή.
- [Πρόσφατο Blockhash](mention:recent-blockhash): Λειτουργεί ως χρονοσφραγίδα
  για τη συναλλαγή.
- [Οδηγίες](mention:instructions): Ένας πίνακας οδηγιών προς εκτέλεση.

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### Μέγεθος Συναλλαγής

Οι συναλλαγές Solana έχουν όριο μεγέθους
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
bytes. Αυτό το όριο προέρχεται από το μέγεθος της Μέγιστης Μονάδας Μετάδοσης
(MTU) του IPv6 που είναι 1280 bytes, μείον 48 bytes για τις κεφαλίδες δικτύου
(40 bytes IPv6 + 8 bytes κεφαλίδα).

Το συνολικό μέγεθος μιας συναλλαγής (υπογραφές και μήνυμα) πρέπει να παραμένει
κάτω από αυτό το όριο και περιλαμβάνει:

- Υπογραφές: 64 bytes η καθεμία
- Μήνυμα: Κεφαλίδα (3 bytes), κλειδιά λογαριασμών (32 bytes το καθένα), πρόσφατο
  blockhash (32 bytes), και οδηγίες

![Μορφή Συναλλαγής](/assets/docs/core/transactions/issues_with_legacy_txs.png)

### Κεφαλίδα Μηνύματος

Η
[κεφαλίδα μηνύματος](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
καθορίζει τα δικαιώματα για τον λογαριασμό στη συναλλαγή. Λειτουργεί σε
συνδυασμό με τις αυστηρά ταξινομημένες
[διευθύνσεις λογαριασμών](/docs/core/transactions#array-of-account-addresses)
για να καθορίσει ποιοι λογαριασμοί είναι υπογράφοντες και ποιοι είναι
εγγράψιμοι.

<WithMentions>
1. [Ο αριθμός των υπογραφών που απαιτούνται για όλες τις οδηγίες στη συναλλαγή.](mention:num_required_signatures)
2. [Ο αριθμός των υπογεγραμμένων λογαριασμών που είναι μόνο για ανάγνωση.](mention:num_readonly_signed_accounts)
3. [Ο αριθμός των μη υπογεγραμμένων λογαριασμών που είναι μόνο για ανάγνωση.](mention:num_readonly_unsigned_accounts)

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![Κεφαλίδα Μηνύματος](/assets/docs/core/transactions/message_header.png)

### Μορφή Συμπαγούς-Πίνακα

Ένας συμπαγής πίνακας σε ένα μήνυμα συναλλαγής είναι ένας πίνακας που
σειριοποιείται στην ακόλουθη μορφή:

1. Το μήκος του πίνακα (κωδικοποιημένο ως
   [compact-u16](https://github.com/anza-xyz/agave/blob/v2.1.13/short-vec/src/lib.rs))
2. Τα στοιχεία του πίνακα καταχωρημένα το ένα μετά το άλλο

![Μορφή συμπαγούς πίνακα](/assets/docs/core/transactions/compact_array_format.png)

Αυτή η μορφή χρησιμοποιείται για την κωδικοποίηση των μηκών των πινάκων
[Διευθύνσεις Λογαριασμών](/docs/core/transactions#array-of-account-addresses)
και [Οδηγίες](/docs/core/transactions#array-of-instructions) στα μηνύματα
συναλλαγών.

### Πίνακας Διευθύνσεων Λογαριασμών

Ένα μήνυμα συναλλαγής περιέχει μια μοναδική λίστα όλων των
[διευθύνσεων λογαριασμών](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
που απαιτούνται από τις οδηγίες του. Ο πίνακας ξεκινά με έναν
[compact-u16](/docs/core/transactions#compact-array-format) αριθμό που
υποδεικνύει πόσες διευθύνσεις περιέχει.

Για εξοικονόμηση χώρου, η συναλλαγή δεν αποθηκεύει δικαιώματα για κάθε
λογαριασμό ξεχωριστά. Αντίθετα, βασίζεται σε έναν συνδυασμό του `MessageHeader`
και μιας αυστηρής ταξινόμησης των διευθύνσεων λογαριασμών για τον καθορισμό των
δικαιωμάτων.

Οι διευθύνσεις ταξινομούνται πάντα με τον ακόλουθο τρόπο:

1.  Λογαριασμοί που είναι **εγγράψιμοι και υπογράφοντες**
2.  Λογαριασμοί που είναι **μόνο για ανάγνωση και υπογράφοντες**
3.  Λογαριασμοί που είναι **εγγράψιμοι και όχι υπογράφοντες**
4.  Λογαριασμοί που είναι **μόνο για ανάγνωση και όχι υπογράφοντες**

Το `MessageHeader` παρέχει τις τιμές που χρησιμοποιούνται για τον καθορισμό του
αριθμού των λογαριασμών για κάθε ομάδα δικαιωμάτων.

![Συμπαγής πίνακας διευθύνσεων λογαριασμών](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Πρόσφατο Blockhash

Κάθε συναλλαγή απαιτεί ένα
[πρόσφατο blockhash](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L141)
που εξυπηρετεί δύο σκοπούς:

1. Λειτουργεί ως χρονική σήμανση για το πότε δημιουργήθηκε η συναλλαγή
2. Αποτρέπει τις διπλές συναλλαγές

Ένα blockhash λήγει μετά από
[150](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)
μπλοκ (περίπου 1 λεπτό υποθέτοντας χρόνους μπλοκ 400ms), μετά το οποίο η
συναλλαγή θεωρείται ληγμένη και δεν μπορεί να επεξεργαστεί.

Μπορείτε να χρησιμοποιήσετε τη μέθοδο RPC
[`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) για να λάβετε το
τρέχον blockhash και το τελευταίο ύψος μπλοκ στο οποίο το blockhash θα είναι
έγκυρο.

### Πίνακας Οδηγιών

Ένα μήνυμα συναλλαγής περιέχει έναν πίνακα
[οδηγιών](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
στον τύπο
[CompiledInstruction](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22).
Οι οδηγίες μετατρέπονται σε αυτόν τον τύπο όταν προστίθενται σε μια συναλλαγή.

Όπως ο πίνακας διευθύνσεων λογαριασμών στο μήνυμα, ξεκινά με ένα
[compact-u16](/docs/core/transactions#compact-array-format) μήκος ακολουθούμενο
από τα δεδομένα οδηγίας. Κάθε οδηγία περιέχει:

<WithMentions>

1. [Δείκτης Αναγνωριστικού Προγράμματος](mention:program-id-index): Ένας δείκτης
   που δείχνει στη διεύθυνση του προγράμματος στον πίνακα διευθύνσεων
   λογαριασμών. Αυτό καθορίζει το πρόγραμμα που επεξεργάζεται την εντολή.
2. [Δείκτες Λογαριασμών](mention:account-indexes): Ένας πίνακας δεικτών που
   δείχνουν στις διευθύνσεις λογαριασμών που απαιτούνται για αυτήν την εντολή.
3. [Instruction Data](mention:instruction-data): Ένας πίνακας byte που καθορίζει
   ποια εντολή θα εκτελεστεί στο πρόγραμμα και οποιαδήποτε πρόσθετα δεδομένα
   απαιτούνται από την εντολή (π.χ. ορίσματα συνάρτησης).

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Συμπαγής πίνακας Εντολών](/assets/docs/core/transactions/compact_array_of_ixs.png)

### Παράδειγμα Δομής Συναλλαγής

Εκτελέστε τα παρακάτω παραδείγματα για να δείτε τη δομή μιας συναλλαγής με μία
μόνο εντολή μεταφοράς SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, signature::Signer,
    signer::keypair::Keypair, system_instruction, transaction::Transaction,
};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = system_instruction::transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

Τα ακόλουθα παραδείγματα δείχνουν την έξοδο του μηνύματος συναλλαγής από τα
προηγούμενα αποσπάσματα κώδικα. Η ακριβής μορφή διαφέρει ανάλογα με το SDK, αλλά
περιλαμβάνει τις ίδιες πληροφορίες.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>

Μετά την υποβολή μιας συναλλαγής, μπορείτε να ανακτήσετε τις λεπτομέρειές της
χρησιμοποιώντας τη μέθοδο RPC [getTransaction](/docs/rpc/http/gettransaction). Η
απάντηση θα έχει μια δομή παρόμοια με το ακόλουθο απόσπασμα. Εναλλακτικά,
μπορείτε να επιθεωρήσετε τη συναλλαγή χρησιμοποιώντας το
[Solana Explorer](https://explorer.solana.com).

<Callout type="info">

Μια "υπογραφή συναλλαγής" προσδιορίζει μοναδικά μια συναλλαγή στο Solana.
Χρησιμοποιείτε αυτήν την υπογραφή για να αναζητήσετε τις λεπτομέρειες της
συναλλαγής στο δίκτυο. Η υπογραφή συναλλαγής είναι απλώς η πρώτη υπογραφή στη
συναλλαγή. Σημειώστε ότι η πρώτη υπογραφή είναι επίσης η υπογραφή του πληρωτή
τελών συναλλαγής.

</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
