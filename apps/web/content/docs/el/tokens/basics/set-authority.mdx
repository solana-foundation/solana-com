---
title: Ορισμός Εξουσιοδότησης
description:
  Μάθετε πώς να ορίσετε εξουσιοδότηση για mint accounts ή token accounts.
---

## Κατανόηση των Εξουσιοδοτήσεων Token

### Εξουσιοδοτήσεις Mint Account

- **Εξουσιοδότηση Mint**: Ελέγχει τη δημιουργία νέων tokens. Μπορεί να
  δημιουργήσει tokens σε οποιοδήποτε token account. Συχνά ανακαλείται μετά τη
  δημιουργία της αρχικής προσφοράς για να δημιουργηθεί ένα token με σταθερή
  προσφορά.
- **Εξουσιοδότηση Παγώματος**: Ελέγχει τη δυνατότητα παγώματος και ξεπαγώματος
  των token accounts. Μπορεί να αποτρέψει οποιοδήποτε token account από τη
  μεταφορά tokens. Συχνά ανακαλείται για να εγγυηθεί στους χρήστες ότι τα tokens
  τους δεν μπορούν να παγώσουν.

### Εξουσιοδοτήσεις Token Account

- **Κάτοχος Λογαριασμού**: Έχει πλήρη έλεγχο του token account. Μπορεί να
  μεταφέρει tokens, να κάψει tokens, να εγκρίνει εκπροσώπους και να κλείσει τον
  λογαριασμό όταν το υπόλοιπο είναι μηδέν.
- **Εξουσιοδότηση Κλεισίματος**: Μπορεί να κλείσει το token account όταν το
  υπόλοιπό του είναι μηδέν. Από προεπιλογή, αυτός είναι ο κάτοχος του
  λογαριασμού, αλλά μπορεί να ανατεθεί σε άλλο λογαριασμό.

## Πώς να ορίσετε εξουσιοδότηση

Η εντολή
[`SetAuthority`](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/program/src/instruction.rs#L153)
αλλάζει ή ανακαλεί εξουσιοδοτήσεις σε mint accounts και token accounts. Μόνο η
τρέχουσα εξουσιοδότηση μπορεί να μεταφέρει τα δικαιώματά της σε μια νέα
διεύθυνση ή να τα ανακαλέσει μόνιμα ορίζοντας την εξουσιοδότηση ως null. Μόλις
ανακληθεί, η εξουσιοδότηση δεν μπορεί να αποκατασταθεί.

<Callout type="info">
  Το [Token
  Program](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/program/src/instruction.rs#L153)
  και το [Token Extension
  Program](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/instruction.rs#L195)
  μοιράζονται παρόμοιες υλοποιήσεις για την επίτευξη της ίδιας λειτουργικότητας.
</Callout>

### Typescript

<CodeTabs storage="token-ts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_PROGRAM_ADDRESS,
  findAssociatedTokenPda,
  getCreateAssociatedTokenInstructionAsync,
  getSetAuthorityInstruction,
  AuthorityType
} from "@solana-program/token";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer and new authority
const feePayer = await generateKeyPairSigner();
const newAuthority = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Instruction to create new account for mint (token program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address,
  freezeAuthority: feePayer.address
});

// Use findAssociatedTokenPda to derive the ATA address
const [associatedTokenAddress] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: feePayer.address,
  tokenProgram: TOKEN_PROGRAM_ADDRESS
});

// Create instruction to create the associated token account
const createAtaInstruction = await getCreateAssociatedTokenInstructionAsync({
  payer: feePayer,
  mint: mint.address,
  owner: feePayer.address
});

const instructions = [
  createAccountInstruction,
  initializeMintInstruction,
  createAtaInstruction
];

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions(instructions, tx)
);

// Sign transaction message with all required signers
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("\nMint Address:", mint.address.toString());
console.log("New Authority Address:", newAuthority.address.toString());
console.log(
  "Associated Token Account Address:",
  associatedTokenAddress.toString()
);
console.log("\nTransaction Signature:", transactionSignature);

// Get a fresh blockhash for the authority change transaction
const { value: authorityBlockhash } = await rpc.getLatestBlockhash().send();

// 1. Change Mint Authority (MintTokens)
const setMintAuthorityIx = getSetAuthorityInstruction({
  owned: mint.address,
  owner: feePayer,
  authorityType: AuthorityType.MintTokens,
  newAuthority: newAuthority.address
});

// 2. Change Freeze Authority (FreezeAccount)
const setFreezeAuthorityIx = getSetAuthorityInstruction({
  owned: mint.address,
  owner: feePayer,
  authorityType: AuthorityType.FreezeAccount,
  newAuthority: newAuthority.address
});

// Create transaction message for authority changes
const authorityTxMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(authorityBlockhash, tx),
  (tx) =>
    appendTransactionMessageInstructions(
      [setMintAuthorityIx, setFreezeAuthorityIx],
      tx
    )
);

// Sign transaction message with all required signers
const signedAuthorityTx =
  await signTransactionMessageWithSigners(authorityTxMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedAuthorityTx,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature2 = getSignatureFromTransaction(signedAuthorityTx);

console.log("\nSuccessfully changed mint and freeze authorities");
console.log("Transaction Signature:", transactionSignature2);

// Get a fresh blockhash for the revoke transaction
const { value: revokeBlockhash } = await rpc.getLatestBlockhash().send();

// 3. Example of revoking authority (setting to null)
const revokeMintAuthorityIx = getSetAuthorityInstruction({
  owned: mint.address,
  owner: newAuthority,
  authorityType: AuthorityType.MintTokens,
  newAuthority: null
});

// Create transaction message for revoking
const revokeTxMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(revokeBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([revokeMintAuthorityIx], tx)
);

// Sign transaction message with all required signers (newAuthority needs to sign)
const signedRevokeTx = await signTransactionMessageWithSigners(revokeTxMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedRevokeTx,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature3 = getSignatureFromTransaction(signedRevokeTx);

console.log("\nSuccessfully revoked mint authority");
console.log("Transaction Signature:", transactionSignature3);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  TOKEN_PROGRAM_ID,
  getAssociatedTokenAddressSync,
  createAssociatedTokenAccountInstruction,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  createSetAuthorityInstruction,
  AuthorityType
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const latestBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Generate a new keypair for the new authority
const newAuthority = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Generate keypair to use as address of mint
const mint = Keypair.generate();

// Get minimum balance for rent exemption
const mintRent = await getMinimumBalanceForRentExemptMint(connection);

// Get the associated token account address
const associatedTokenAccount = getAssociatedTokenAddressSync(
  mint.publicKey,
  feePayer.publicKey,
  false, // allowOwnerOffCurve
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID
);

// Create account instruction
const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: mintRent,
  programId: TOKEN_PROGRAM_ID
});

// Initialize mint instruction
const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_PROGRAM_ID
);

// Create associated token account instruction
const createAssociatedTokenAccountIx = createAssociatedTokenAccountInstruction(
  feePayer.publicKey, // payer
  associatedTokenAccount, // associated token account address
  feePayer.publicKey, // owner
  mint.publicKey, // mint
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID
);

// Create and sign transaction with mint creation and ATA creation
const transaction = new Transaction({
  feePayer: feePayer.publicKey,
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight
}).add(
  createAccountInstruction,
  initializeMintInstruction,
  createAssociatedTokenAccountIx
);

// Sign transaction
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint]
);

console.log("\nMint Address:", mint.publicKey.toBase58());
console.log("New Authority Address:", newAuthority.publicKey.toBase58());
console.log(
  "Associated Token Account Address:",
  associatedTokenAccount.toBase58()
);
console.log("\nTransaction Signature:", transactionSignature);

// Get a new blockhash for the authority change transaction
const authorityBlockhash = await connection.getLatestBlockhash();

// 1. Change Mint Authority (MintTokens)
const setMintAuthorityIx = createSetAuthorityInstruction(
  mint.publicKey, // mint account
  feePayer.publicKey, // current authority
  AuthorityType.MintTokens, // authority type
  newAuthority.publicKey, // new authority
  TOKEN_PROGRAM_ID
);

// 2. Change Freeze Authority (FreezeAccount)
const setFreezeAuthorityIx = createSetAuthorityInstruction(
  mint.publicKey, // mint account
  feePayer.publicKey, // current authority
  AuthorityType.FreezeAccount, // authority type
  newAuthority.publicKey, // new authority
  TOKEN_PROGRAM_ID
);

// Create and sign transaction for authority changes
const authorityTransaction = new Transaction({
  feePayer: feePayer.publicKey,
  blockhash: authorityBlockhash.blockhash,
  lastValidBlockHeight: authorityBlockhash.lastValidBlockHeight
}).add(setMintAuthorityIx, setFreezeAuthorityIx);

// Sign and send authority transaction
const transactionSignature2 = await sendAndConfirmTransaction(
  connection,
  authorityTransaction,
  [feePayer]
);

console.log("\nSuccessfully changed mint and freeze authorities");
console.log("Transaction Signature:", transactionSignature2);

// Get a new blockhash for the revoke transaction
const revokeBlockhash = await connection.getLatestBlockhash();

// 3. Example of revoking authority (setting to null)
const revokeMintAuthorityIx = createSetAuthorityInstruction(
  mint.publicKey, // mint account
  newAuthority.publicKey, // current authority (newAuthority is now the authority)
  AuthorityType.MintTokens, // authority type
  null, // new authority (null to revoke)
  TOKEN_PROGRAM_ID
);

// Create and sign transaction for revoking
const revokeTransaction = new Transaction({
  feePayer: feePayer.publicKey,
  blockhash: revokeBlockhash.blockhash,
  lastValidBlockHeight: revokeBlockhash.lastValidBlockHeight
}).add(revokeMintAuthorityIx);

// Sign and send revoke transaction
const transactionSignature3 = await sendAndConfirmTransaction(
  connection,
  revokeTransaction,
  [feePayer, newAuthority] // newAuthority needs to sign
);

console.log("\nSuccessfully revoked mint authority");
console.log("Transaction Signature:", transactionSignature3);
```

```ts !! title="Legacy Helper"
import { Connection, Keypair, LAMPORTS_PER_SOL } from "@solana/web3.js";
import {
  createMint,
  createAssociatedTokenAccount,
  setAuthority,
  AuthorityType,
  TOKEN_PROGRAM_ID
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const latestBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Generate a new keypair for the new authority
const newAuthority = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Create mint using helper function
const mintPubkey = await createMint(
  connection, // connection
  feePayer, // fee payer
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  9, // decimals
  Keypair.generate(), // keypair (optional)
  {
    commitment: "confirmed" // confirmation options
  },
  TOKEN_PROGRAM_ID // program id
);
console.log("\nMint Address:", mintPubkey.toBase58());

// Create associated token account using helper function
const associatedTokenAccount = await createAssociatedTokenAccount(
  connection, // connection
  feePayer, // fee payer
  mintPubkey, // mint
  feePayer.publicKey, // owner
  {
    commitment: "confirmed" // confirmation options
  },
  TOKEN_PROGRAM_ID // program id
);
console.log(
  "\nAssociated Token Account Address:",
  associatedTokenAccount.toBase58()
);
console.log("New Authority Address:", newAuthority.publicKey.toBase58());

// 1. Change Mint Authority (MintTokens)
const setMintAuthoritySignature = await setAuthority(
  connection,
  feePayer,
  mintPubkey,
  feePayer, // Current authority
  AuthorityType.MintTokens,
  newAuthority.publicKey, // New authority
  [],
  {
    commitment: "confirmed"
  },
  TOKEN_PROGRAM_ID
);

console.log("\nSuccessfully changed mint authority");
console.log("Transaction Signature:", setMintAuthoritySignature);

// 2. Change Freeze Authority (FreezeAccount)
const setFreezeAuthoritySignature = await setAuthority(
  connection,
  feePayer,
  mintPubkey,
  feePayer, // Current authority
  AuthorityType.FreezeAccount,
  newAuthority.publicKey, // New authority
  [],
  {
    commitment: "confirmed"
  },
  TOKEN_PROGRAM_ID
);

console.log("\nSuccessfully changed freeze authority");
console.log("Transaction Signature:", setFreezeAuthoritySignature);

// 3. Example of revoking authority (setting to null)
const revokeMintAuthoritySignature = await setAuthority(
  connection,
  feePayer,
  mintPubkey,
  newAuthority, // Current authority (newAuthority is now the authority)
  AuthorityType.MintTokens,
  null, // New authority (null to revoke)
  [],
  {
    commitment: "confirmed"
  },
  TOKEN_PROGRAM_ID
);

console.log("\nSuccessfully revoked mint authority");
console.log("Transaction Signature:", revokeMintAuthoritySignature);

// 4. Example of changing close authority of token account
const setCloseAuthoritySignature = await setAuthority(
  connection,
  feePayer,
  associatedTokenAccount,
  feePayer, // Current authority
  AuthorityType.CloseAccount,
  newAuthority.publicKey, // New authority
  [],
  {
    commitment: "confirmed"
  },
  TOKEN_PROGRAM_ID
);

console.log("\nSuccessfully set close authority");
console.log("Transaction Signature:", setCloseAuthoritySignature);
```

</CodeTabs>

### Rust

<CodeTabs storage="token-rs" flags="r">

```rust !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id, instruction::create_associated_token_account,
};
use spl_token::{
    id as token_program_id,
    instruction::{initialize_mint, set_authority, AuthorityType},
    state::Mint,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let latestBlockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Generate a new keypair for the new authority
    let new_authority = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    // Get default mint account size (in bytes), no extensions enabled
    let mint_space = Mint::LEN;
    let mint_rent = client
        .get_minimum_balance_for_rent_exemption(mint_space)
        .await?;

    // Instruction to create new account for mint (token program)
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),      // payer
        &mint.pubkey(),           // new account (mint)
        mint_rent,                // lamports
        mint_space as u64,        // space
        &token_program_id(), // program id
    );

    // Instruction to initialize mint account data
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(),            // mint
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        9,                         // decimals
    )?;

    // Calculate the associated token account address for fee_payer
    let associated_token_address = get_associated_token_address_with_program_id(
        &fee_payer.pubkey(),      // owner
        &mint.pubkey(),           // mint
        &token_program_id(), // program_id
    );

    // Instruction to create associated token account
    let create_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(),      // funding address
        &fee_payer.pubkey(),      // wallet address
        &mint.pubkey(),           // mint address
        &token_program_id(), // program id
    );

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_account_instruction,
            initialize_mint_instruction,
            create_ata_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latestBlockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("New Authority Address: {}", new_authority.pubkey());
    println!(
        "Associated Token Account Address: {}",
        associated_token_address
    );
    println!("Transaction Signature: {}", transaction_signature);

    // Get the latest blockhash for the authority change transaction
    let latestBlockhash = client.get_latest_blockhash().await?;

    // 1. Change Mint Authority (MintTokens)
    let set_mint_authority_ix = set_authority(
        &token_program_id(), // program id
        &mint.pubkey(),           // mint account
        Some(&new_authority.pubkey()), // new authority
        AuthorityType::MintTokens,     // authority type
        &fee_payer.pubkey(),           // current authority
        &[&fee_payer.pubkey()],        // signers
    )?;

    // 2. Change Freeze Authority (FreezeAccount)
    let set_freeze_authority_ix = set_authority(
        &token_program_id(), // program id
        &mint.pubkey(),            // mint account
        Some(&new_authority.pubkey()), // new authority
        AuthorityType::FreezeAccount,  // authority type
        &fee_payer.pubkey(),           // current authority
        &[&fee_payer.pubkey()],        // signers
    )?;

    // Create transaction for authority changes
    let transaction = Transaction::new_signed_with_payer(
        &[set_mint_authority_ix, set_freeze_authority_ix],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        latestBlockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!(
        "\nSuccessfully changed mint and freeze authorities to: {}",
        new_authority.pubkey()
    );
    println!("Transaction Signature: {}", transaction_signature);

    // Get the latest blockhash for the revoke transaction
    let latestBlockhash = client.get_latest_blockhash().await?;

    // 3. Example of revoking authority (setting to null)
    let revoke_mint_authority_ix = set_authority(
        &token_program_id(), // program id
        &mint.pubkey(),      // mint account
        None,                // new authority (None to revoke)
        AuthorityType::MintTokens, // authority type
        &new_authority.pubkey(),   // current authority
        &[&new_authority.pubkey()], // signers
    )?;

    // Create transaction for revoking
    let transaction = Transaction::new_signed_with_payer(
        &[revoke_mint_authority_ix],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &new_authority], // new_authority needs to sign
        latestBlockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("\nSuccessfully revoked mint authority");
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

```rust !! title="Token Client"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
};
use spl_token::id as token_program_id;
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    spl_token_2022::instruction::AuthorityType,
    token::{ExtensionInitializationParams, Token},
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    // Generate a new keypair for the fee payer
    let payer = Keypair::new();

    // Generate a new keypair for the new authority
    let new_authority = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = rpc_client
        .request_airdrop(&payer.pubkey(), 1_000_000_000)
        .await?;
    rpc_client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = rpc_client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    // Create a new program client
    let program_client = ProgramRpcClient::new(
        Arc::new(RpcClient::new_with_commitment(
            String::from("http://localhost:8899"),
            CommitmentConfig::confirmed(),
        )),
        ProgramRpcClientSendTransaction,
    );

    // Number of decimals for the mint
    let decimals = 9;

    // Create a token client for Token program
    let token = Token::new(
        Arc::new(program_client),
        &token_program_id(),
        &mint.pubkey(),
        Some(decimals),
        Arc::new(payer.insecure_clone()),
    );

    // Create and initialize the mint
    let extension_initialization_params: Vec<ExtensionInitializationParams> = Vec::new();

    let mint_result = token
        .create_mint(
            &payer.pubkey(),                 // mint authority
            Some(&payer.pubkey()),           // freeze authority
            extension_initialization_params, // no extensions
            &[&mint],                        // mint keypair needed as signer
        )
        .await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("New Authority Address: {}", new_authority.pubkey());
    println!("Created Mint Account: {}", mint_result);

    // First, derive the associated token account address without creating it
    let associated_token_address = token.get_associated_token_address(&payer.pubkey());
    println!(
        "Associated Token Account Address: {}",
        associated_token_address
    );

    // Then, create the associated token account
    let create_ata_result = token
        .create_associated_token_account(
            &payer.pubkey(), // owner
        )
        .await?;

    println!("Created Associated Token Account: {}", create_ata_result);

    // 1. Change Mint Authority (MintTokens)
    let transaction_signature = token
        .set_authority(
            &mint.pubkey(),                    // mint account
            &payer.pubkey(),                   // current authority
            Some(&new_authority.pubkey()),    // new authority
            AuthorityType::MintTokens,         // authority type
            &[&payer],                         // signing keypairs
        )
        .await?;

    println!(
        "\nSuccessfully changed mint authority from {} to {}",
        payer.pubkey(),
        new_authority.pubkey()
    );
    println!("Transaction Signature: {}", transaction_signature);

    // 2. Change Freeze Authority (FreezeAccount)
    let transaction_signature = token
        .set_authority(
            &mint.pubkey(),                    // mint account
            &payer.pubkey(),                   // current authority
            Some(&new_authority.pubkey()),    // new authority
            AuthorityType::FreezeAccount,      // authority type
            &[&payer],                         // signing keypairs
        )
        .await?;

    println!(
        "\nSuccessfully changed freeze authority from {} to {}",
        payer.pubkey(),
        new_authority.pubkey()
    );
    println!("Transaction Signature: {}", transaction_signature);

    // 3. Example of revoking authority (setting to null)
    let transaction_signature = token
        .set_authority(
            &mint.pubkey(),                    // mint account
            &new_authority.pubkey(),           // current authority
            None,                              // new authority (None to revoke)
            AuthorityType::MintTokens,         // authority type
            &[&new_authority],                 // signing keypairs
        )
        .await?;

    println!("\nSuccessfully revoked mint authority");
    println!("Transaction Signature: {}", transaction_signature);

    // 4. Example of changing close authority of token account
    let transaction_signature = token
        .set_authority(
            &associated_token_address,         // token account
            &payer.pubkey(),                   // current authority
            Some(&new_authority.pubkey()),    // new authority
            AuthorityType::CloseAccount,       // authority type
            &[&payer],                         // signing keypairs
        )
        .await?;

    println!(
        "\nSuccessfully changed close authority for token account to {}",
        new_authority.pubkey()
    );
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

</CodeTabs>

### Python

<CodeTabs flags="r">

```py !! title="Python"
#!/usr/bin/env python3

import asyncio
from solana.rpc.async_api import AsyncClient
from solders.keypair import Keypair
from solders.pubkey import Pubkey
from solders.transaction import VersionedTransaction
from solders.message import MessageV0
from spl.token.instructions import set_authority, SetAuthorityParams
from spl.token.constants import TOKEN_PROGRAM_ID
from spl.token.instructions import AuthorityType

async def main():
    rpc = AsyncClient("http://localhost:8899")

    # Example keypairs and addresses
    payer = Keypair()
    current_authority = Keypair()
    new_authority = Keypair()
    mint_or_account = Pubkey.from_string("4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU")

    async with rpc:
        # Set new mint authority
        set_mint_authority_instruction = set_authority(
            SetAuthorityParams(
                program_id=TOKEN_PROGRAM_ID,
                account=mint_or_account,
                authority=AuthorityType.MINT_TOKENS,
                current_authority=current_authority.pubkey(),
                new_authority=new_authority.pubkey()
            )
        )

        # Get latest blockhash
        recent_blockhash = await rpc.get_latest_blockhash()

        # Create message
        message = MessageV0.try_compile(
            payer=payer.pubkey(),
            instructions=[set_mint_authority_instruction],
            address_lookup_table_accounts=[],
            recent_blockhash=recent_blockhash.value.blockhash
        )

        # Create transaction
        transaction = VersionedTransaction(message, [payer, current_authority])

        print(f"Account/Mint: {mint_or_account}")
        print(f"Current Authority: {current_authority.pubkey()}")
        print(f"New Authority: {new_authority.pubkey()}")
        print(f"Authority Type: MintTokens")
        print(f"Payer: {payer.pubkey()}")
        print(f"Set authority transaction created successfully")

async def set_freeze_authority_example():
    """Example of setting freeze authority"""
    rpc = AsyncClient("http://localhost:8899")

    payer = Keypair()
    current_authority = Keypair()
    new_authority = Keypair()
    mint_address = Pubkey.from_string("4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU")

    async with rpc:
        # Set freeze authority
        set_freeze_authority_instruction = set_authority(
            SetAuthorityParams(
                program_id=TOKEN_PROGRAM_ID,
                account=mint_address,
                authority=AuthorityType.FREEZE_ACCOUNT,
                current_authority=current_authority.pubkey(),
                new_authority=new_authority.pubkey()
            )
        )

        recent_blockhash = await rpc.get_latest_blockhash()
        message = MessageV0.try_compile(
            payer=payer.pubkey(),
            instructions=[set_freeze_authority_instruction],
            address_lookup_table_accounts=[],
            recent_blockhash=recent_blockhash.value.blockhash
        )

        transaction = VersionedTransaction(message, [payer, current_authority])

        print(f"\nFreeze Authority Example:")
        print(f"Mint: {mint_address}")
        print(f"Current Freeze Authority: {current_authority.pubkey()}")
        print(f"New Freeze Authority: {new_authority.pubkey()}")
        print(f"Set freeze authority transaction created successfully")

if __name__ == "__main__":
    asyncio.run(main())
    asyncio.run(set_freeze_authority_example())
```

</CodeTabs>
