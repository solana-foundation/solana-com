---
title: Transactions
description:
  Découvrez les transactions Solana—les éléments fondamentaux pour interagir
  avec la blockchain Solana. Comprenez la structure des transactions et la
  composition des instructions avec des exemples pratiques.
---

Pour interagir avec le réseau Solana, vous devez envoyer une transaction. Vous
pouvez considérer une transaction comme une enveloppe contenant plusieurs
formulaires. Chaque formulaire est une instruction qui indique au réseau quoi
faire. Envoyer la transaction revient à envoyer l'enveloppe par la poste pour
que les formulaires puissent être traités.

L'exemple ci-dessous montre une version simplifiée de deux transactions. Lorsque
la première transaction est traitée, elle exécutera une seule instruction.
Lorsque la seconde transaction est traitée, elle exécutera trois instructions
**dans un ordre séquentiel** : d'abord l'instruction 1, suivie de l'instruction
2, puis de l'instruction 3.

<Callout type="warn">
  Les transactions sont **atomiques** : si une seule instruction échoue, toute
  la transaction échouera et aucun changement n'aura lieu.
</Callout>

![Un diagramme simplifié montrant deux transactions](/assets/docs/core/transactions/transaction-simple.svg)

Une
[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
comprend les informations suivantes :

<WithMentions>

- [`signatures`](mention:signatures) : Un tableau de [signatures](#signatures)
- [`message`](mention:message) : Informations de transaction, y compris la liste
  des instructions à traiter

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![Diagramme montrant les deux parties d'une transaction](/assets/docs/core/transactions/tx_format.png)

Les transactions ont une limite de taille totale de
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
octets. Cette limite inclut à la fois le tableau [`signatures`](#signatures) et
la structure [`message`](#message).

<Callout>
  Cette limite provient de la taille maximale d'unité de transmission (MTU) IPv6
  de 1280 octets, moins 48 octets pour les en-têtes réseau (40 octets IPv6 + 8
  octets d'en-tête).
</Callout>

![Diagramme montrant le format de transaction et les limites de taille](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## Signatures

Le tableau `signatures` de la transaction contient des structures `Signature`.
Chaque
[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
fait 64 octets et est créée en signant le `Message` de la transaction avec la
clé privée du compte. Une signature doit être fournie pour chaque
[compte signataire](#account-addresses) inclus dans l'une des instructions de la
transaction.

La première signature appartient au compte qui paiera les
[frais de base](docs/core/fees#base-fee) de la transaction et constitue la
signature de la transaction. La signature de la transaction peut être utilisée
pour rechercher les détails de la transaction sur le réseau.

## Message

Le `message` de la transaction est une structure
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)
qui contient les informations suivantes :

<WithMentions>

- [`header`](mention:message-header) : L'[en-tête](#header) du message
- [`account_keys`](mention:account-addresses) : Un tableau
  d'[adresses de comptes](#account-addresses) requises par les instructions de
  la transaction
- [`recent_blockhash`](mention:recent-blockhash) : Un
  [blockhash](#recent-blockhash) qui sert d'horodatage pour la transaction
- [`instructions`](mention:instructions) : Un tableau
  d'[instructions](#instructions)

<Callout>
  Pour économiser de l'espace, la transaction ne stocke pas les permissions pour
  chaque compte individuellement. Au lieu de cela, les permissions des comptes
  sont déterminées en utilisant le `header` et le `account_keys`.
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### En-tête

<WithMentions>

Le `header` du message est une structure
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97).
Il contient les informations suivantes :

- [`num_required_signatures`](mention:num_required_signatures) : Le nombre total
  de signatures requises par la transaction
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts) : Le
  nombre total de comptes en lecture seule qui nécessitent des signatures
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts) :
  Le nombre total de comptes en lecture seule qui ne nécessitent pas de
  signatures

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![Diagramme montrant les trois parties de l'en-tête du message](/assets/docs/core/transactions/message_header.png)

### Adresses des comptes

Le
[`account_keys`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
du message est un tableau d'adresses de comptes, envoyé au
[format de tableau compact](/docs/references/terminology#compact-array-format).
Le préfixe du tableau indique sa longueur. Chaque élément du tableau est une clé
publique, qui pointe vers un compte utilisé par ses instructions. Le tableau
`accounts_keys` doit être complet et strictement ordonné comme suit :

1. Signataire + Modifiable
2. Signataire + Lecture seule
3. Non signataire + Modifiable
4. Non signataire + Lecture seule

<Callout>
  L'ordre strict permet de combiner le tableau `account_keys` avec les
  informations dans le [`header`](#header) du message pour déterminer les
  permissions pour chaque compte.
</Callout>

![Diagramme montrant l'ordre du tableau d'adresses de comptes](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Blockhash récent

Le `recent_blockhash` du message est une valeur de hachage qui agit comme un
horodatage de transaction et empêche les transactions en double. Un blockhash
expire après
[150 blocs](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134).
(Équivalent à une minute — en supposant que chaque bloc dure 400ms.) Après
l'expiration du bloc, la transaction est expirée et ne peut plus être traitée.

<Callout>
  La méthode RPC [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) vous
  permet d'obtenir le blockhash actuel et la dernière hauteur de bloc à laquelle
  le blockhash sera valide.
</Callout>

### Instructions

Le
[`instructions`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
du message est un tableau de toutes les instructions à traiter, envoyé au
[format de tableau compact](/docs/references/terminology#compact-array-format).
Le préfixe du tableau indique sa longueur. Chaque élément du tableau est une
structure
[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
et comprend les informations suivantes :

<WithMentions>

1. [`program_id_index`](mention:program-id-index) : Un index pointant vers une
   adresse dans le tableau [`account_keys`](#account-addresses). Cette valeur
   indique l'adresse du programme qui traite l'instruction.
2. [`accounts`](mention:account-indexes) : Un tableau d'indices pointant vers
   des adresses dans le tableau `account_keys`. Chaque index pointe vers
   l'adresse d'un compte requis pour cette instruction.
3. [`data`](mention:instruction-data) : Un tableau d'octets spécifiant quelle
   instruction invoquer sur le programme. Il inclut également toutes les données
   supplémentaires requises par l'instruction. (Par exemple, les arguments de
   fonction)

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Tableau compact d'instructions](/assets/docs/core/transactions/compact_array_of_ixs.png)

## Structure d'une transaction d'exemple

L'exemple suivant montre la structure d'une transaction qui contient une seule
instruction de transfert de SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
Le code ci-dessous montre la sortie des extraits de code précédents.
Le format diffère entre les SDK,
mais notez que chaque instruction contient les mêmes informations requises.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

Après avoir soumis une transaction, vous pouvez récupérer ses détails en
utilisant la signature de la transaction et la méthode RPC
[getTransaction](/docs/rpc/http/gettransaction). La réponse aura une structure
similaire à l'extrait suivant.

<Callout>
  Vous pouvez également trouver la transaction en utilisant [Solana
  Explorer](https://explorer.solana.com).
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
