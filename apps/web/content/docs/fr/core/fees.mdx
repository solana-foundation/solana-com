---
title: Frais de transaction
description:
  Découvrez les frais de transaction de Solana, y compris les frais de base et
  les frais de priorisation, comment chacun est appliqué, et les meilleures
  pratiques pour gérer les unités de calcul dans vos transactions.
---

Chaque transaction Solana nécessite des frais de transaction, payés en SOL. Les
frais de transaction sont divisés en deux parties : les frais de base et les
frais de priorisation. Les frais de base compensent les validateurs pour le
traitement de la transaction. Les frais de priorisation sont des frais
optionnels, pour augmenter la probabilité que le leader actuel traite votre
transaction.

## Frais de base

Chaque transaction coûte 5000 [lamports](/docs/references/terminology#lamport)
par signature incluse. Ces frais sont payés par le premier signataire de la
transaction. Seuls les comptes détenus par le System Program peuvent payer les
frais de transaction. Les frais de base sont répartis comme suit:

- **50% brûlés :** La moitié est
  [brûlée](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (retirée de l'offre circulante de SOL).
- **50% distribués :** L'autre moitié est
  [versée au validateur](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
  qui a traité la transaction.

## Frais de priorisation

Les
[frais de priorisation](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
sont des frais optionnels utilisés pour augmenter la probabilité que le leader
actuel (validateur) traite votre transaction. Le validateur reçoit
[100% des frais de priorité](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Les frais de priorisation peuvent être définis en ajustant le prix des unités de
calcul (CU) et la limite de CU de la transaction. (Consultez le
[guide Comment utiliser les frais de priorité](/developers/guides/advanced/how-to-use-priority-fees)
pour plus de détails sur les frais de priorisation.)

Les frais de priorisation sont calculés comme suit :

**Frais de priorisation = Limite d'unités de calcul × Prix de l'unité de
calcul**

Les frais de priorisation sont utilisés pour déterminer la
[priorité de votre transaction](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646),
par rapport aux autres transactions. Ils sont calculés selon la formule suivante
:

Priorité de la transaction = Frais de priorisation / Nombre de signatures

#### Limite d'unités de calcul

Par
[défaut](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
chaque instruction se voit attribuer
[200 000 CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
et chaque transaction se voit attribuer
[1,4 million de CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14).
Vous pouvez modifier ces valeurs par défaut en incluant une instruction
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
dans votre transaction.

Pour calculer la limite CU appropriée pour votre transaction, nous recommandons
les étapes suivantes :

1. Estimez les unités CU requises en
   [simulant](/developers/guides/advanced/how-to-request-optimal-compute) la
   transaction
2. Ajoutez une marge de sécurité de 10 % à cette estimation

<Callout type="warn">
  Les frais de priorité sont déterminés par la limite d'unités de calcul
  demandée pour la transaction, *pas* par le nombre réel d'unités de calcul
  utilisées. Si vous définissez une limite d'unités de calcul trop élevée ou
  utilisez le montant par défaut, vous risquez de payer pour des unités de
  calcul non utilisées.
</Callout>

#### Prix de l'unité de calcul

Le prix de l'unité de calcul est un montant optionnel en
[micro-lamports](/docs/references/terminology#micro-lamports) payé pour chaque
CU demandée. Vous pouvez considérer le prix CU comme un pourboire pour
encourager le validator à prioriser votre transaction. Pour définir le prix CU,
incluez une instruction
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
dans votre transaction.

<Callout>
  Le prix CU par défaut est 0, ce qui signifie que les frais de priorisation par
  défaut sont également de 0.
</Callout>

Pour déterminer le meilleur prix CU pour votre transaction, consultez la
recommandation de prix CU en temps réel fournie dans le tableau ci-dessous.

| Fournisseur                             | API de frais prioritaires                                                         |
| --------------------------------------- | --------------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [Documentation](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Documentation](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Documentation](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Exemple

Les exemples ci-dessous montrent comment définir la limite CU et le prix CU sur
une transaction en utilisant les SDK Solana.

| SDK                            | Référence du code source                                                                                                       |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
