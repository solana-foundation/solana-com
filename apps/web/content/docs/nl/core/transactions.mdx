---
title: Transacties
description:
  Leer over Solana-transacties—de fundamentele bouwstenen voor interactie met de
  Solana-blockchain. Begrijp de transactiestructuur en instructiesamenstelling
  met praktische voorbeelden.
---

Om met het Solana-netwerk te communiceren, moet je een transactie versturen. Je
kunt een transactie zien als een envelop die verschillende formulieren bevat.
Elk formulier is een instructie die het netwerk vertelt wat te doen. Het
versturen van de transactie is als het posten van de envelop zodat de
formulieren kunnen worden verwerkt.

Het onderstaande voorbeeld toont een vereenvoudigde versie van twee transacties.
Wanneer de eerste transactie wordt verwerkt, zal deze één enkele instructie
uitvoeren. Wanneer de tweede transactie wordt verwerkt, zal deze drie
instructies **in opeenvolgende volgorde** uitvoeren: eerst instructie 1, gevolgd
door instructie 2, gevolgd door instructie 3.

<Callout type="warn">
  Transacties zijn **atomair**: als een enkele instructie mislukt, zal de hele
  transactie mislukken en zullen er geen wijzigingen plaatsvinden.
</Callout>

![Een vereenvoudigd diagram dat twee transacties toont](/assets/docs/core/transactions/transaction-simple.svg)

Een
[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
bestaat uit de volgende informatie:

<WithMentions>

- [`signatures`](mention:signatures): Een array van
  [handtekeningen](#signatures)
- [`message`](mention:message): Transactie-informatie, inclusief de lijst van
  instructies die moeten worden verwerkt

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![Diagram dat de twee delen van een transactie toont](/assets/docs/core/transactions/tx_format.png)

Transacties hebben een totale groottelimiet van
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
bytes. Deze limiet omvat zowel de [`signatures`](#signatures) array als de
[`message`](#message) struct.

<Callout>
  Deze limiet komt van de IPv6 Maximum Transmission Unit (MTU) grootte van 1280
  bytes, minus 48 bytes voor netwerkheaders (40 bytes IPv6 + 8 bytes header).
</Callout>

![Diagram dat het transactieformaat en de groottelimieten toont](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## Handtekeningen

De `signatures` array van de transactie bevat `Signature` structs. Elke
[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
is 64 bytes en wordt gemaakt door de `Message` van de transactie te ondertekenen
met de privésleutel van het account. Een handtekening moet worden verstrekt voor
elk [ondertekenend account](#account-addresses) dat is opgenomen in een van de
instructies van de transactie.

De eerste handtekening behoort tot het account dat de
[basistarieven](docs/core/fees#base-fee) van de transactie zal betalen en is de
transactiehandtekening. De transactiehandtekening kan worden gebruikt om de
details van de transactie op het netwerk op te zoeken.

## Bericht

Het `message` van de transactie is een
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)
struct die de volgende informatie bevat:

<WithMentions>

- [`header`](mention:message-header): De [header](#header) van het bericht
- [`account_keys`](mention:account-addresses): Een array van
  [accountadressen](#account-addresses) die vereist zijn door de instructies van
  de transactie
- [`recent_blockhash`](mention:recent-blockhash): Een
  [blockhash](#recent-blockhash) die fungeert als tijdstempel voor de transactie
- [`instructions`](mention:instructions): Een array van
  [instructies](#instructions)

<Callout>
  Om ruimte te besparen, slaat de transactie niet voor elk account afzonderlijk
  machtigingen op. In plaats daarvan worden accountmachtigingen bepaald met
  behulp van de `header` en `account_keys`.
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### Header

<WithMentions>

De `header` van het bericht is een
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
struct. Het bevat de volgende informatie:

- [`num_required_signatures`](mention:num_required_signatures): Het totale
  aantal handtekeningen vereist door de transactie
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts): Het
  totale aantal alleen-lezen accounts die handtekeningen vereisen
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts):
  Het totale aantal alleen-lezen accounts die geen handtekeningen vereisen

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![Diagram met de drie delen van de berichtheader](/assets/docs/core/transactions/message_header.png)

### Accountadressen

De
[`account_keys`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
van het bericht is een array van accountadressen, verzonden in
[compact array formaat](/docs/references/terminology#compact-array-format). Het
voorvoegsel van de array geeft de lengte aan. Elk item in de array is een
publieke sleutel, die verwijst naar een account dat door de instructies wordt
gebruikt. De `accounts_keys` array moet volledig zijn en strikt geordend, als
volgt:

1. Ondertekenaar + Beschrijfbaar
2. Ondertekenaar + Alleen-lezen
3. Geen ondertekenaar + Beschrijfbaar
4. Geen ondertekenaar + Alleen-lezen

<Callout>
  Strikte ordening maakt het mogelijk om de `account_keys` array te combineren
  met de informatie in de [`header`](#header) van het bericht om de machtigingen
  voor elk account te bepalen.
</Callout>

![Diagram dat de volgorde van de array met accountadressen toont](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Recente blockhash

De `recent_blockhash` van het bericht is een hashwaarde die fungeert als een
tijdstempel voor de transactie en voorkomt dat transacties worden gedupliceerd.
Een blockhash verloopt na
[150 blokken](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134).
(Gelijk aan één minuut—ervan uitgaande dat elk blok 400ms duurt.) Nadat het blok
is verlopen, is de transactie verlopen en kan deze niet meer worden verwerkt.

<Callout>
  De [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) RPC-methode stelt
  je in staat om de huidige blockhash en de laatste blokhoogte te krijgen waarop
  de blockhash geldig zal zijn.
</Callout>

### Instructies

De
[`instructions`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
van het bericht is een array van alle instructies die verwerkt moeten worden,
verzonden in
[compact array format](/docs/references/terminology#compact-array-format). Het
voorvoegsel van de array geeft de lengte aan. Elk item in de array is een
[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
struct en bevat de volgende informatie:

<WithMentions>

1. [`program_id_index`](mention:program-id-index): Een index die verwijst naar
   een adres in de [`account_keys`](#account-addresses) array. Deze waarde geeft
   het adres aan van het programma dat de instructie verwerkt.
2. [`accounts`](mention:account-indexes): Een array van indices die verwijzen
   naar adressen in de `account_keys` array. Elke index verwijst naar het adres
   van een account dat vereist is voor deze instructie.
3. [`data`](mention:instruction-data): Een byte-array die aangeeft welke
   instructie moet worden aangeroepen op het programma. Het bevat ook eventuele
   aanvullende gegevens die vereist zijn door de instructie. (Bijvoorbeeld
   functieargumenten)

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Compacte array van instructies](/assets/docs/core/transactions/compact_array_of_ixs.png)

## Voorbeeld transactiestructuur

Het volgende voorbeeld toont de structuur van een transactie die een enkele
SOL-overdrachtsinstructie bevat.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
De onderstaande code toont de uitvoer van de vorige codefragmenten.
Het formaat verschilt tussen SDK's,
maar merk op dat elke instructie dezelfde vereiste informatie bevat.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

Nadat een transactie is ingediend, kun je de details ervan ophalen met behulp
van de transactiehandtekening en de
[getTransaction](/docs/rpc/http/gettransaction) RPC-methode. De respons zal een
structuur hebben die vergelijkbaar is met het volgende fragment.

<Callout>
  Je kunt de transactie ook vinden met behulp van [Solana
  Explorer](https://explorer.solana.com).
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
