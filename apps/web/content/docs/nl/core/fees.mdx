---
title: Transactiekosten
description:
  Leer over Solana's transactiekosten, inclusief de basis- en prioriteitskosten,
  hoe elk wordt toegepast, en best practices voor het beheren van
  compute-eenheden in je transacties.
---

Elke Solana-transactie vereist een transactiekosten, betaald in SOL.
Transactiekosten zijn verdeeld in twee delen: de basiskosten en de
prioriteitskosten. De basiskosten compenseren validators voor het verwerken van
de transactie. De prioriteitskosten zijn optionele kosten om de kans te
vergroten dat de huidige leider je transactie verwerkt.

## Basiskosten

Elke transactie kost 5000 [lamports](/docs/references/terminology#lamport) per
opgenomen handtekening. Deze kosten worden betaald door de eerste ondertekenaar
van de transactie en moeten worden betaald door een account dat eigendom is van
het System Program. De basiskosten worden als volgt verdeeld:

- **50% verbrand:** De helft wordt
  [verbrand](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (uit de circulerende SOL-voorraad gehaald).
- **50% gedistribueerd:** De helft wordt
  [betaald aan de validator](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
  die de transactie heeft verwerkt.

## Prioriteitskosten

Een
[prioriteitskosten](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
zijn optionele kosten die worden gebruikt om de kans te vergroten dat de huidige
leider (validator) je transactie verwerkt. De validator ontvangt
[100% van de prioriteitskosten](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Prioriteitskosten kunnen worden ingesteld door de
[compute-eenheden](/docs/references/terminology#compute-units) (CU) prijs en CU
limiet van de transactie aan te passen. (Zie de
[Hoe prioriteitskosten te gebruiken gids](/developers/guides/advanced/how-to-use-priority-fees)
voor meer details over prioriteitskosten.)

De prioriteitskosten worden als volgt berekend:

```text title="Prioritization fee formula"
Prioritization fee = CU limit * CU price
```

De prioriteitskosten worden gebruikt om de
[prioriteit van je transactie](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646)
te bepalen, relatief ten opzichte van andere transacties. Het wordt berekend met
de volgende formule:

```text title="Transaction priority formula"
Priority = (Prioritization fee + Base fee) / (1 + CU limit + Signature CUs + Write lock CUs)
```

#### Compute-eenheidslimiet

Standaard
[standaard](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197)
krijgt elke instructie
[200.000 CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
toegewezen en elke transactie krijgt
[1,4 miljoen CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14).
Je kunt deze standaardwaarden wijzigen door een
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
instructie in je transactie op te nemen.

Om de juiste CU-limiet voor je transactie te berekenen, raden we de volgende
stappen aan:

1. Schat de benodigde CU-eenheden door
   [simulatie](/developers/guides/advanced/how-to-request-optimal-compute) van
   de transactie
2. Voeg een veiligheidsmarge van 10% toe aan deze schatting

<Callout type="warn">
  De prioriteitsvergoeding wordt bepaald door de aangevraagde
  compute-eenhedenlimiet van de transactie, *niet* door het werkelijke aantal
  gebruikte compute-eenheden. Als je een compute-eenhedenlimiet instelt die te
  hoog is of de standaardhoeveelheid gebruikt, betaal je mogelijk voor
  ongebruikte compute-eenheden.
</Callout>

#### Compute-eenheidsprijs

De compute-eenheidsprijs is een optioneel bedrag in
[micro-lamports](/docs/references/terminology#micro-lamports) dat wordt betaald
voor elke aangevraagde CU. Je kunt de CU-prijs zien als een fooi om de validator
aan te moedigen je transactie prioriteit te geven. Om de CU-prijs in te stellen,
neem je een
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
instructie op in je transactie.

<Callout>
  De standaard CU-prijs is 0, wat betekent dat de standaard
  prioriteitsvergoeding ook 0 is.
</Callout>

Voor hulp bij het bepalen van de beste CU-prijs voor je transactie, zie de
realtime CU-prijsaanbeveling in de onderstaande tabel.

| Provider                                | Priority Fee API                                                                 |
| --------------------------------------- | -------------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [Documentatie](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Documentatie](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Documentatie](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Voorbeeld

De onderstaande voorbeelden laten zien hoe je de CU-limiet en CU-prijs instelt
voor een transactie met behulp van Solana SDK's.

| SDK                            | Broncode referentie                                                                                                            |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
