---
title: Writing to the Network
description:
  Learn how to interact with the Solana network by sending transactions and
  instructions. Follow step-by-step examples to transfer SOL tokens and create
  new tokens using the System Program and Token Extensions Program.
---

In the previous section, you learned how to read data from the Solana network.
Now you'll learn how to write data to it. Writing to the Solana network involves
sending transactions that contain one or more instruction.

Programs define the business logic for what each
[instruction](/docs/core/instructions) does. When you submit a
[transaction](/docs/core/transactions), the Solana runtime executes each
instruction in sequence and atomically. The examples in this section show how to
build and send transactions to invoke Solana programs, they include:

1. Transferring SOL between accounts
2. Creating a new token

## Transfer SOL

The example below transfers SOL between two accounts. Each account has an owner
program, which is the only program that can deduct the account's SOL balance.

All wallet accounts are owned by the System Program. To transfer SOL, you must
invoke the System Program's
[transfer](https://github.com/anza-xyz/agave/blob/v2.1.11/programs/system/src/system_processor.rs#L183-L213)
instruction.

<WithNotes>

<CodeTabs flags="r">

```ts !! title="Transfer SOL"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

// !tooltip[/connection/] connection
const connection = new Connection("http://localhost:8899", "confirmed");

// !tooltip[/sender/] sender
const sender = new Keypair();
// !tooltip[/receiver/] receiver
const receiver = new Keypair();

// !tooltip[/requestAirdrop/] airdrop
const signature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

// !tooltip[/transferInstruction/] instruction
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// !tooltip[/transaction/] transaction
const transaction = new Transaction().add(transferInstruction);

// !tooltip[/sendAndConfirmTransaction/] sendAndConfirmTransaction
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [sender]
);

console.log("Transaction Signature:", `${transactionSignature}`);

const senderBalance = await connection.getBalance(sender.publicKey);
const receiverBalance = await connection.getBalance(receiver.publicKey);

console.log("Sender Balance:", `${senderBalance}`);
console.log("Receiver Balance:", `${receiverBalance}`);
```

```rs !! title="Rust"
use anyhow::Result;

use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::{CommitmentConfig, CommitmentLevel};
use solana_sdk::{signature::Keypair, signer::Signer, transaction::Transaction};
use solana_system_interface::instruction as system_instruction;

const LPS: u64 = solana_sdk::native_token::LAMPORTS_PER_SOL;

#[tokio::main]
async fn main() -> Result<()> {
    // !tooltip[/connection/] connection
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig {
            commitment: CommitmentLevel::Confirmed,
        },
    );

    // !tooltip[/sender/] sender
    let sender = Keypair::new();
    // !tooltip[/receiver/] receiver
    let receiver = Keypair::new();

    // !tooltip[/requestAirdrop/] airdrop
    let signature = connection.request_airdrop(&sender.pubkey(), LPS).await?;
    connection
        .confirm_transaction_with_commitment(
            &signature,
            CommitmentConfig {
                commitment: CommitmentLevel::Confirmed,
            },
        )
        .await?;
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;

    // !tooltip[/transferInstruction/] instruction
    let transfer_instruction =
        system_instruction::transfer(&sender.pubkey(), &receiver.pubkey(), LPS / 100);

    let recent_blockhash = connection.get_latest_blockhash().await?;

    // !tooltip[/transaction/] transaction
    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], recent_blockhash);

    // !tooltip[/sendAndConfirmTransaction/] sendAndConfirmTransaction
    let transaction_signature = connection
        .send_and_confirm_transaction(&transaction)
        .await?;

    println!("Transaction signature: {}", transaction_signature);

    let sender_balance = connection.get_balance(&sender.pubkey()).await?;
    let receiver_balance = connection.get_balance(&receiver.pubkey()).await?;

    println!("Sender balance: {}", sender_balance);
    println!("Receiver balance: {}", receiver_balance);

    Ok(())
}
```

</CodeTabs>

### !connection

Create a connection to the a Solana cluster.

### !sender

Generate a new keypair to use as the `sender`.

### !receiver

Generate a new keypair to use as the `receiver`.

### !airdrop

Request an airdrop of SOL to fund the `sender`.

### !instruction

Build instruction to invoke the System Program's transfer instruction.

### !transaction

Create new transaction and add the transfer instruction.

### !sendAndConfirmTransaction

Send the transaction.

</WithNotes>

<ScrollyCoding>

## !!steps

Create a `Connection` to handle sending transactions and fetching account data.

In this example, we're connecting to the local test validator which runs on
`localhost:8899`.

```ts title="Connection"
const connection = new Connection("http://localhost:8899", "confirmed");
```

```rs title="Connection"
// !focus
let connection = RpcClient::new_with_commitment(
    "http://localhost:8899".to_string(),
    CommitmentConfig {
        commitment: CommitmentLevel::Confirmed,
    },
);
```

```ts !! title="Transfer SOL"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

// !focus
const connection = new Connection("http://localhost:8899", "confirmed");
```

## !!steps

Generate new [keypairs](/docs/core/accounts#public-key) to use as the sender and
receiver accounts.

```ts title="Generate keypairs"
const sender = new Keypair();
const receiver = new Keypair();
```

```rs title="Generate keypairs"
// !focus(1:2)
let sender = Keypair::new();
let receiver = Keypair::new();
```

```ts !! title="Transfer SOL"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

// !focus(1:2)
const sender = new Keypair();
const receiver = new Keypair();
```

## !!steps

Add SOL to the sender account. On networks other than mainnet, you can use the
`requestAirdrop` method to get SOL for testing.

```ts title="Airdrop"
const signature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");
```

```rs title="Airdrop"
// !focus(1:7)
let signature = connection.request_airdrop(&sender.pubkey(), LPS).await?;
connection
    .confirm_transaction_with_commitment(
        &signature,
        CommitmentConfig {
            commitment: CommitmentLevel::Confirmed,
        },
    )
    .await?;
```

```ts !! title="Transfer SOL"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = new Keypair();
const receiver = new Keypair();

// !focus(1:5)
const signature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");
```

## !!steps

<WithMentions>

The `SystemProgram.transfer()` method creates an instruction that transfers SOL
from the [`fromPubkey`](mention:from) account to the [`toPubkey`](mention:to)
account for the specified number of [`lamports`](mention:lamports).

```ts title="Transfer instruction"
const transferInstruction = SystemProgram.transfer({
  // !mention from
  fromPubkey: sender.publicKey,
  // !mention to
  toPubkey: receiver.publicKey,
  // !mention lamports
  lamports: 0.01 * LAMPORTS_PER_SOL
});
```

```rs title="Transfer instruction"
let transfer_instruction = system_instruction::transfer(
    // !mention from
    &sender.pubkey(),
    // !mention to
    &receiver.pubkey(),
    // !mention lamports
    LPS / 100,
);
```

</WithMentions>

```ts !! title="Transfer SOL"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = new Keypair();
const receiver = new Keypair();

const signature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

// !focus(1:5)
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});
```

## !!steps

Create a transaction and add the instruction to the transaction. In this
example, we're creating a transaction with a single instruction. However, you
can add multiple instructions to a transaction.

```ts title="Transaction"
const transaction = new Transaction().add(transferInstruction);
```

```rs title="Transaction"
// !focus(1:3)
let recent_blockhash = connection.get_latest_blockhash().await?;
let mut transaction =
    Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
```

```ts !! title="Transfer SOL"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = new Keypair();
const receiver = new Keypair();

const signature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// !focus
const transaction = new Transaction().add(transferInstruction);
```

## !!steps

<WithMentions>

Sign and send the [transaction](mention:transaction) to the network. The
[sender](mention:sender) keypair is required in the signers array to authorize
the transfer of SOL from their account.

```ts title="Send transaction"
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  // !mention transaction
  transaction,
  // !mention sender
  [sender]
);
```

```rs title="Send transaction"
// !mention sender
transaction.sign(&[&sender], recent_blockhash);
let transaction_signature = connection
    .send_and_confirm_transaction(
        // !mention transaction
        &transaction,
    )
    .await?;
```

</WithMentions>

The transaction signature is a unique identifier that can be used to look up the
transaction on Solana Explorer.

```ts !! title="Transfer SOL"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = new Keypair();
const receiver = new Keypair();

const signature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

const transaction = new Transaction().add(transferInstruction);

// !focus(1:6)
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [sender]
);

console.log("Transaction Signature:", `${transactionSignature}`);
```

</ScrollyCoding>

## Create a token

The example below creates a new token on Solana using the Token Extensions
Program. This requires two instructions:

1. Invoke the System Program to create a new account.
2. Invoke the Token Extensions Program to initialize that account as a Mint.

<WithNotes>

<CodeTabs flags="r">

```ts !! title="Create mint account"
import {
  Connection,
  Keypair,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  MINT_SIZE,
  TOKEN_2022_PROGRAM_ID,
  createInitializeMint2Instruction,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

const connection = new Connection("http://localhost:8899", "confirmed");

// !tooltip[/wallet/] wallet
const wallet = new Keypair();
// Fund the wallet with SOL
const signature = await connection.requestAirdrop(
  wallet.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

// Generate keypair to use as address of mint account
// !tooltip[/mint/] mint
const mint = new Keypair();

// Calculate lamports required for rent exemption
// !tooltip[/rentExemptionLamports/] rentExemptionLamports
const rentExemptionLamports =
  await getMinimumBalanceForRentExemptMint(connection);

// Instruction to create new account with space for new mint account
// !tooltip[/createAccountInstruction/] createAccountInstruction
const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: wallet.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: rentExemptionLamports,
  programId: TOKEN_2022_PROGRAM_ID
});

// Instruction to initialize mint account
// !tooltip[/initializeMintInstruction/] initializeMintInstruction
const initializeMintInstruction = createInitializeMint2Instruction(
  mint.publicKey,
  2, // decimals
  wallet.publicKey, // mint authority
  wallet.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

// Build transaction with instructions to create new account and initialize mint account
// !tooltip[/transaction/] transaction
const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);

// !tooltip[/sendAndConfirmTransaction/] sendAndConfirmTransaction
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [
    wallet, // payer
    mint // mint address keypair
  ]
);

console.log("Transaction Signature:", `${transactionSignature}`);

const mintData = await getMint(
  connection,
  mint.publicKey,
  "confirmed",
  TOKEN_2022_PROGRAM_ID
);
// !collapse(1:17) collapsed
console.log(
  "Mint Account:",
  JSON.stringify(
    mintData,
    (key, value) => {
      // Convert BigInt to String
      if (typeof value === "bigint") {
        return value.toString();
      }
      // Handle Buffer objects
      if (Buffer.isBuffer(value)) {
        return `<Buffer ${value.toString("hex")}>`;
      }
      return value;
    },
    2
  )
);
```

```rs !! title="Rust"
use anyhow::Result;

use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::{CommitmentConfig, CommitmentLevel};
use solana_sdk::{
    program_pack::Pack,
    signature::Keypair,
    signer::Signer,
    transaction::Transaction,
};
use solana_system_interface::instruction as system_instruction;
use spl_token_2022_interface::instruction as token_instruction;
use spl_token_2022_interface::state::Mint;

const LAMPORTS_PER_SOL: u64 = solana_sdk::native_token::LAMPORTS_PER_SOL;
const MINT_SIZE: usize = Mint::LEN;

#[tokio::main]
async fn main() -> Result<()> {
    // !tooltip[/connection/] connection
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig {
            commitment: CommitmentLevel::Confirmed,
        },
    );

    // !tooltip[/wallet/] wallet
    let wallet = Keypair::new();

    // Fund the wallet with SOL
    // !tooltip[/airdrop/] airdrop
    let signature = connection
        .request_airdrop(&wallet.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    connection
        .confirm_transaction_with_commitment(
            &signature,
            CommitmentConfig {
                commitment: CommitmentLevel::Confirmed,
            },
        )
        .await?;

    tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;

    // Generate keypair to use as address of mint account
    // !tooltip[/mint/] mint
    let mint = Keypair::new();

    // Calculate lamports required for rent exemption
    // !tooltip[/rentExemptionLamports/] rentExemptionLamports
    let rent_exemption_lamports = connection
        .get_minimum_balance_for_rent_exemption(MINT_SIZE)
        .await?;

    // Instruction to create new account with space for new mint account
    // !tooltip[/createAccountInstruction/] createAccountInstruction
    let create_account_instruction = system_instruction::create_account(
        &wallet.pubkey(),
        &mint.pubkey(),
        rent_exemption_lamports,
        MINT_SIZE as u64,
        &spl_token_2022_interface::ID,
    );

    // Instruction to initialize mint account
    // !tooltip[/initializeMintInstruction/] initializeMintInstruction
    let initialize_mint_instruction = token_instruction::initialize_mint2(
        &spl_token_2022_interface::ID,
        &mint.pubkey(),
        &wallet.pubkey(),
        Some(&wallet.pubkey()),
        2,
    )?;

    // Build transaction with instructions to create new account and initialize mint account
    // !tooltip[/transaction/] transaction
    let mut transaction = Transaction::new_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&wallet.pubkey()),
    );

    let recent_blockhash = connection.get_latest_blockhash().await?;
    transaction.sign(&[&wallet, &mint], recent_blockhash);

    // !tooltip[/sendAndConfirmTransaction/] sendAndConfirmTransaction
    let transaction_signature = connection
        .send_and_confirm_transaction(&transaction)
        .await?;

    println!("Mint created: {}", transaction_signature);
    println!("Mint address: {}", mint.pubkey());

    let mint_account = connection.get_account(&mint.pubkey()).await?;
    let mint_state = Mint::unpack(&mint_account.data)?;
    println!("Mint supply: {}", mint_state.supply);

    Ok(())
}
```

</CodeTabs>

### !wallet

Generate a new keypair to use as the wallet.

### !mint

Generate a new keypair to use as the address of the Mint account to create.

### !rentLamports

Calculate the lamports required for a Mint account.

### !rentExemptionLamports

Calculate the lamports required for rent exemption

### !createAccountInstruction

Build instruction to create a new account with space for the Mint account type
and owned by the Token Extensions Program.

### !initializeMintInstruction

Build instruction to initialize the data of the new account as a Mint account
type.

### !transaction

Create new transaction and add both instructions.

The order of instructions matters here. The `createAccountInstruction` must come
before the `initializeMintInstruction`.

### !sendAndConfirmTransaction

Send the transaction.

</WithNotes>

<ScrollyCoding>

## !!steps

Creating a token requires using both the `@solana/web3.js` and
`@solana/spl-token` libraries. The code in the example below will:

<WithMentions>

- [Create a connection](mention:connection)
- [Generate a keypair](mention:wallet) to pay for the transaction
- [Request an airdrop](mention:airdrop) to fund the keypair

```ts title="Connection & wallet setup"
// !mention connection
const connection = new Connection("http://localhost:8899", "confirmed");

// !mention wallet
const wallet = new Keypair();
// !mention(1:4) airdrop
const signature = await connection.requestAirdrop(
  wallet.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");
```

```rs title="Connection & wallet setup"
// !mention connection
let connection = RpcClient::new_with_commitment(
    "http://localhost:8899".to_string(),
    CommitmentConfig {
        commitment: CommitmentLevel::Confirmed,
    },
);

// !mention wallet
let wallet = Keypair::new();
// !mention(1:4) airdrop
let signature = connection
    .request_airdrop(&wallet.pubkey(), LAMPORTS_PER_SOL)
    .await?;
connection
    .confirm_transaction_with_commitment(
        &signature,
        CommitmentConfig {
            commitment: CommitmentLevel::Confirmed,
        },
    )
    .await?;
tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;
```

</WithMentions>

```ts !! title="Create mint account"
import {
  Connection,
  Keypair,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  MINT_SIZE,
  TOKEN_2022_PROGRAM_ID,
  createInitializeMint2Instruction,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

// !focus(1:8)
const connection = new Connection("http://localhost:8899", "confirmed");

const wallet = new Keypair();
const signature = await connection.requestAirdrop(
  wallet.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");
```

## !!steps

Generate a keypair for the mint account. The public key will be used as the mint
account's address.

```ts title="Mint keypair"
const mint = new Keypair();
```

```rs title="Mint keypair"
// !focus
let mint = Keypair::new();
```

```ts !! title="Create mint account"
import {
  Connection,
  Keypair,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  MINT_SIZE,
  TOKEN_2022_PROGRAM_ID,
  createInitializeMint2Instruction,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

const connection = new Connection("http://localhost:8899", "confirmed");

const wallet = new Keypair();
const signature = await connection.requestAirdrop(
  wallet.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

// !focus
const mint = new Keypair();
```

## !!steps

Calculate the minimum lamports required for a mint account. The
`getMinimumBalanceForRentExemptMint` function calculates how many lamport must
be allocated for the data on a mint account.

```ts title="Rent exemption"
const rentExemptionLamports =
  await getMinimumBalanceForRentExemptMint(connection);
```

```rs title="Rent exemption"
// !focus(1:2)
let rent_exemption_lamports = connection
    .get_minimum_balance_for_rent_exemption(MINT_SIZE)
    .await?;
```

```ts !! title="Create mint account"
import {
  Connection,
  Keypair,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  MINT_SIZE,
  TOKEN_2022_PROGRAM_ID,
  createInitializeMint2Instruction,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

const connection = new Connection("http://localhost:8899", "confirmed");

const wallet = new Keypair();
const signature = await connection.requestAirdrop(
  wallet.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const mint = new Keypair();

// !focus(1:2)
const rentExemptionLamports =
  await getMinimumBalanceForRentExemptMint(connection);
```

## !!steps

<WithMentions>

The first instruction invokes the System Program's `createAccount` instruction
to:

1. Allocate the [number of bytes](mention:space) needed to store the mint data.
2. [Transfer lamports](mention:lamports) from the wallet to fund the new
   account.
3. [Assign ownership](mention:programId) of the account to the
   [Token Extensions program](/docs/tokens/extensions).

```ts title="Create account instruction"
const createAccountInstruction = SystemProgram.createAccount({
  // !mention(1:2) lamports
  fromPubkey: wallet.publicKey,
  newAccountPubkey: mint.publicKey,
  // !mention space
  space: MINT_SIZE,
  // !mention lamports
  lamports: rentExemptionLamports,
  // !mention programId
  programId: TOKEN_2022_PROGRAM_ID
});
```

```rs title="Create account instruction"
let create_account_instruction = system_instruction::create_account(
    // !mention(1:2) lamports
    &wallet.pubkey(),
    &mint.pubkey(),
    // !mention lamports
    rent_exemption_lamports,
    // !mention space
    MINT_SIZE as u64,
    // !mention programId
    &spl_token_2022_interface::ID,
);
```

</WithMentions>

```ts !! title="Create mint account"
import {
  Connection,
  Keypair,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  MINT_SIZE,
  TOKEN_2022_PROGRAM_ID,
  createInitializeMint2Instruction,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

const connection = new Connection("http://localhost:8899", "confirmed");

const wallet = new Keypair();
const signature = await connection.requestAirdrop(
  wallet.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const mint = new Keypair();

const rentExemptionLamports =
  await getMinimumBalanceForRentExemptMint(connection);

// !focus(1:7)
const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: wallet.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: rentExemptionLamports,
  programId: TOKEN_2022_PROGRAM_ID
});
```

## !!steps

<WithMentions>

The second instruction invokes the
[Token Extensions Program](mention:programId)'s
`createInitializeMint2Instruction` instruction to initialize the mint account
with the following data:

- [2 decimals](mention:decimals)
- [Wallet](mention:authority) as both mint authority and freeze authority

```ts title="Initialize mint instruction"
const initializeMintInstruction = createInitializeMint2Instruction(
  mint.publicKey,
  // !mention decimals
  2,
  // !mention authority
  wallet.publicKey,
  // !mention authority
  wallet.publicKey,
  // !mention programId
  TOKEN_2022_PROGRAM_ID
);
```

```rs title="Initialize mint instruction"
let initialize_mint_instruction = token_instruction::initialize_mint2(
    &spl_token_2022_interface::ID,
    &mint.pubkey(),
    // !mention authority
    &wallet.pubkey(),
    // !mention authority
    Some(&wallet.pubkey()),
    // !mention decimals
    2,
)?;
```

</WithMentions>

```ts !! title="Create mint account"
import {
  Connection,
  Keypair,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  MINT_SIZE,
  TOKEN_2022_PROGRAM_ID,
  createInitializeMint2Instruction,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

const connection = new Connection("http://localhost:8899", "confirmed");

const wallet = new Keypair();
const signature = await connection.requestAirdrop(
  wallet.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const mint = new Keypair();

const rentExemptionLamports =
  await getMinimumBalanceForRentExemptMint(connection);

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: wallet.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: rentExemptionLamports,
  programId: TOKEN_2022_PROGRAM_ID
});

// !focus(1:6)
const initializeMintInstruction = createInitializeMint2Instruction(
  mint.publicKey,
  2, // decimals
  wallet.publicKey, // mint authority
  wallet.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);
```

## !!steps

Add both instructions to a single transaction. This ensures that account
creation and initialization happen atomically. (Either both instructions
succeed, or neither does.)

This approach is common when building complex Solana transactions, as it
guarantees that all instructions execute together.

```ts title="Transaction"
const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);
```

```rs title="Transaction"
// !focus(1:3)
let mut transaction = Transaction::new_with_payer(
    &[create_account_instruction, initialize_mint_instruction],
    Some(&wallet.pubkey()),
);
```

```ts !! title="Create mint account"
import {
  Connection,
  Keypair,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  MINT_SIZE,
  TOKEN_2022_PROGRAM_ID,
  createInitializeMint2Instruction,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

const connection = new Connection("http://localhost:8899", "confirmed");

const wallet = new Keypair();
const signature = await connection.requestAirdrop(
  wallet.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const mint = new Keypair();

const rentExemptionLamports =
  await getMinimumBalanceForRentExemptMint(connection);

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: wallet.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: rentExemptionLamports,
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMintInstruction = createInitializeMint2Instruction(
  mint.publicKey,
  2, // decimals
  wallet.publicKey, // mint authority
  wallet.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

// !focus(1:4)
const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);
```

## !!steps

<WithMentions>

Sign and send the transaction. Two signatures are required:

- The [wallet](mention:wallet) account signs as the payer for
  [transaction fees](/docs/core/fees) and account creation
- The [mint](mention:mint) account signs to authorize the use of its address for
  the new account

```ts title="Send transaction"
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [
    // !mention wallet
    wallet,
    // !mention mint
    mint
  ]
);
```

```rs title="Send transaction"
let recent_blockhash = connection.get_latest_blockhash().await?;
transaction.sign(&[&wallet, &mint], recent_blockhash);
let transaction_signature = connection
    .send_and_confirm_transaction(
        &transaction,
    )
    .await?;
```

The transaction signature returned can be used to inspect the transaction on
Solana Explorer.

</WithMentions>

```ts !! title="Create mint account"
import {
  Connection,
  Keypair,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  MINT_SIZE,
  TOKEN_2022_PROGRAM_ID,
  createInitializeMint2Instruction,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

const connection = new Connection("http://localhost:8899", "confirmed");

const wallet = new Keypair();
const signature = await connection.requestAirdrop(
  wallet.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const mint = new Keypair();

const rentExemptionLamports =
  await getMinimumBalanceForRentExemptMint(connection);

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: wallet.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: rentExemptionLamports,
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMintInstruction = createInitializeMint2Instruction(
  mint.publicKey,
  2, // decimals
  wallet.publicKey, // mint authority
  wallet.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);

// !focus(1:9)
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [
    wallet, // payer
    mint // mint address keypair
  ]
);

console.log("Transaction Signature:", `${transactionSignature}`);
```

</ScrollyCoding>
