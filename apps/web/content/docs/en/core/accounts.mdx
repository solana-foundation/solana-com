---
title: Solana Account Model
description:
  Learn about Solana's account model, including how accounts store data and
  programs, rent mechanics, account ownership, and the relationship between
  programs and data accounts. Understand the core concepts of Solana's key-value
  storage system.
---
## Overview
In the Solana network, all information is stored in **accounts**.

You can think of the Solana database as a big table of accounts. Each row in the table is an account with its own address.
Every account shares the same basic structure (see the struct on the right of the illustration), but stores unique information
 within that structure.

![Accounts](/assets/docs/core/accounts/accounts.png)

## Account address

In order to pull information from an account, you must be able to call its address. The account address acts as the unique ID 
for each entry in the "Accounts" table. Every account on Solana has a unique
32-byte address, often shown as a base58 encoded string (e.g. `14grJpemFaf88c8tiVb77W7TYg2W3ir6pfkKz3YjhhZ5`).

The relationship between the account and its address works like a key-value
pair (in which a key, or unique identifier, gives you access to a particular value, or information). In the Solana
account model, the "key" is the account address that gives you access to the "value"—the corresponding on-chain information
in the account. 

![Account Address](/assets/docs/core/accounts/account-address.svg)
{/*I personally think this illustration is kinda worthless*/}

Most Solana accounts use an [Ed25519](https://ed25519.cr.yp.to/) public key as
their address. This particular type of 32-byte key is fast and reliable.

{/*If these code snippets had the same margins as the rest of the text, they'd make the whole page look a lot less scary
and confusing.*/}

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner } from "@solana/kit";

// Kit does not enable extractable private keys
const keypairSigner = await generateKeyPairSigner();
console.log(keypairSigner);
```

```ts !! title="Legacy"
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);
console.log(`Secret Key: ${keypair.secretKey}`);
```

```rs !! title="Rust"
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() {
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());
    println!("Secret Key: {:?}", keypair.to_bytes());
}
```

</CodeTabs>

While public keys are commonly used as account addresses, Solana also supports a
feature called [Program Derived Addresses](/docs/core/pda) (PDAs). PDAs are
special addresses that you can deterministically derive from a program ID and one or more
optional inputs (seeds). This type of address is beneficial because it can be reliably 
regenerated without needing to store or protect a private key. 

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey; // macro
use solana_sdk::pubkey::Pubkey;

#[tokio::main]
async fn main() {
    let program_address = pubkey!("11111111111111111111111111111111");
    let seeds = [b"helloWorld".as_ref()];
    let (pda, bump) = Pubkey::find_program_address(&seeds, &program_address);
    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
}
```

</CodeTabs>

## Account structure

Every account on Solana shares the same base account structure.

Every account on Solana has a max size of 10MiB and contains the following fields: 

  - `lamports`
  - `data`
  - `owner`
  - `executable`
  - `rent_epoch`

Below is an example of a basic rust struct showing each of those fields:

### 

```rust title="Base account structure"
pub struct Account {
    /// lamports in the account
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    pub executable: bool,
    /// the epoch at which this account will next owe rent
    pub rent_epoch: Epoch,
}
```

<ScrollyCoding>

{/*For some reason, the sentence below doesn't show up on the local version of the site:*/}
To learn more about each field, click on the text on the left to see the relevant code highlighted on the right:

{/*It would be cool to be able to get each of these fields to show up on the Table of Contents, since they contain
important info. Another option would be to take the info out of this code-highlighting part and just leave the field name, and 
then put the info in a plain text section.*/}

## !!steps Lamports field

This field shows the account's balance in lamports. **Lamports** are the smallest unit of SOL (1 SOL = 1 billion
lamports). Balances are measured in lamports rather than SOL to avoid rounding errors. 

Accounts must have a minimum lamport balance, called "rent". The rent is charged proportionally to the
amount of data stored on the account (in bytes). Although this balance is called rent, it works more like a deposit
because you can recover the full lamport balance, including the rent, when you close an account. 

The term "rent" comes from—but should not be confused with—the now-deprecated `rent_epoch` field.

```rust !! title="Base account structure"
pub struct Account {
    // !focus(1:2)
    /// lamports in the account
    pub lamports: u64,
}

// Example token mint account
Account {
    // !focus
    lamports: 1461600,
}

// Example token program account
Account {
    // !focus
    lamports: 4513200894,
}
```

## !!steps Data field

Solana uses the term **data** to refer to any sequence of bytes. The data in the `data` field is considered "arbitrary", 
which means that the field could contain data for either executable accounts or non-executable accounts. 

- For executable accounts (program accounts), this field contains either the
  executable program code itself or the address of another account that stores
  the executable program code.
- For non-executable accounts, this field generally stores state that's meant to be read
  from.

The Solana runtime can't read the data field directly. Instead, the program that owns the account will read it.
Reading data from a Solana account involves two steps:

1. Fetch the account using its address (public key)
2. Deserialize the account's `data` field from raw bytes into the appropriate data
   structure, which is defined by the program that owns the account. Since program accounts contain executable code
   in their `data` field, we do not deserialize the data.

```rust !! title="Base account structure"
pub struct Account {
    /// lamports in the account
    pub lamports: u64,
    // !focus(1:3)
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    pub data: Vec<u8>,
}

// Example token mint account
Account {
    lamports: 1461600,
    // !focus(1:2)
    data.len: 82,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example token program account
Account {
    lamports: 4513200894,
    // !focus(1:2)
    data.len: 134080,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Owner field

The `owner` field lists the program ID (public key) of the program that owns this account.

Every Solana account has a designated [program](/docs/core/programs) as its owner. Only the program
that owns an account can change the account's `data` field or deduct lamports from its balance.

For executable accounts, the `owner` field contains the program ID of a loader
program. [Loader programs](https://solana.com/docs/core/programs#loader-programs) are built-in programs responsible for loading and
managing executable program accounts.

```rust !! title="Base account structure"
pub struct Account {
    /// lamports in the account
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    pub data: Vec<u8>,
    // !focus(1:2)
    /// the program that owns this account. If executable, the program that loads this account.
    pub owner: Pubkey,
}

// Example token mint account
Account {
    lamports: 1461600,
    data.len: 82,
    // !focus
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example token program account
Account {
    lamports: 4513200894,
    data.len: 134080,
    // !focus
    owner: BPFLoader2111111111111111111111111111111111,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Executable field

This field indicates whether an account is an executable program.

- If `true`, the account is executable (a program account).
- If `false`, the account is a non-executable (a state account).

```rust !! title="Base account structure"
pub struct Account {
    /// lamports in the account
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    pub owner: Pubkey,
    // !focus(1:2)
    /// this account's data contains a loaded program (and is now read-only)
    pub executable: bool,
}

// Example token mint account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    // !focus
    executable: false,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example token program account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    // !focus
    executable: true,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Rent_epoch field

The `rent_epoch` field is a legacy field that is no longer used.

Originally, this field tracked when an account would need to pay rent (in
lamports) to maintain its data on the network. However, this rent collection
mechanism has since been deprecated.

```rust !! title="Base account structure"
pub struct Account {
    /// lamports in the account
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    pub executable: bool,
    // !focus(1:2)
    /// the epoch at which this account will next owe rent
    pub rent_epoch: Epoch,
}

// Example token mint account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    // !focus
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example token program account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    // !focus
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```
</ScrollyCoding>

{/*I don't know why there's a space in the table of contents after this section, I couldn't figure out how to get rid of it*/}

## Account types

As mentioned in the overview, there are two basic types of accounts: those that contain executable code and those that do not.

Within these two categories, there are several types of accounts:

- Executable accounts:
  - Program accounts 

- Non-executable accounts:
  - State accounts
  - System accounts
  - Sysvar accounts
  - Program data accounts/buffer accounts

The following sections will elaborate on each of these account types.

### Program accounts
{/*These paragraphs don't flow together super great, but there was a lot of disparate information that all needed to be included.
Open to suggestions*/}

Some accounts contain executable code—this code can also be called a "program". Any account that contains executable code
is a program account. You can know that an account contains executable code if the `executable` field is set to `true`. (See the
[Account structure](http://solana.com/docs/core/accounts#account-structure) section to learn more about fields.)
 
Once a developer deploys a program on Solana, a program account will automatically be created to house the program.  

For simplicity, you can treat the program account as the program itself. Many developers use the term "program" and "program
account" interchangeably, since there is only one program for each program account. 

The following example fetches the Token Program account to show that in a program account, the `executable` field is set
to `true`. 

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const programId = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address;

const accountInfo = await rpc
  .getAccountInfo(programId, { encoding: "base64" })
  .send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Connection, PublicKey } from "@solana/web3.js";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const programId = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

const accountInfo = await connection.getAccountInfo(programId);
// !collapse(1:17) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let program_id = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let account_info = connection.get_account(&program_id).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

{/*The information in the callout seems important, so I took it out of the callout and put it in the main text.*/}

#### Program data accounts

All program accounts are owned by a [loader program](/docs/core/programs#loader-programs), which is the program that manages the account.
A loader is sometimes called a "BPF loader" because it loads and executes programs written in BPF (Berkeley Packet Filter) bytecode.
{/*I made the extra note about BPF because they wrote "BPF Loader" on the illustration*/}

![Program Account](/assets/docs/core/accounts/program-account-simple.svg)

There are several versions of the loader program. Earlier versions store
executable code directly in the `data` field of the program account. However, loader-v3 and later versions store the executable
code in a separate **program data account**. The `data` field of a program account using a more recent loader will only contain
the address of the program data account. 

When you deploy a new program, the Solana CLI uses the latest loader version by default.

![Program Data Account](/assets/docs/core/accounts/program-account-expanded.svg)

#### Buffer accounts
{/*Do we even need this section?*/} 
Loader-v3 has a special account type for temporarily staging the upload of a
program during deployment or upgrades.


### State accounts

In contrast to a program account, which contains executable code, a **state account** contains only
state. 

The executable code of a program is stored in a different account
than the program's state. This is like how operating systems typically have
separate files for programs and their data. To maintain state, programs define instructions to create separate state accounts that
they own. Each of these accounts has its own unique address and can store any
arbitrary data defined by the program.

![Data Account](/assets/docs/core/accounts/data-account.svg)

Note that only the [System Program](/docs/core/accounts#system-program) can
create new accounts. Once the System Program creates an account, it can then
assign ownership of the new account to another program.

In other words, creating a data account for a custom program takes two steps:

1. Invoke the System Program to create an account, then transfer ownership to
   the custom program
2. Invoke the custom program, which now owns the account, to initialize the
   account data. "Initialize" means to make sure 
   the data layout matches the structure defined by the program.

This account creation process is often abstracted as a single step, but it's
helpful to understand the underlying process.

The following example shows how to create and fetch a Token Mint account owned
by the Token 2022 program.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  fetchMint
} from "@solana-program/token-2022";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer
const feePayer = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Instruction to create new account for mint (token 2022 program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token 2022 program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address
});

const instructions = [createAccountInstruction, initializeMintInstruction];

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }), // Create transaction message
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx), // Set fee payer
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set transaction blockhash
  (tx) => appendTransactionMessageInstructions(instructions, tx) // Append instructions
);

// Sign transaction message with required signers (fee payer and mint keypair)
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Mint Address:", mint.address);
console.log("Transaction Signature:", transactionSignature);

const accountInfo = await rpc.getAccountInfo(mint.address).send();
console.log(accountInfo);

const mintAccount = await fetchMint(rpc, mint.address);
console.log(mintAccount);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  TOKEN_2022_PROGRAM_ID,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const recentBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: recentBlockhash.blockhash,
  lastValidBlockHeight: recentBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Generate keypair to use as address of mint
const mint = Keypair.generate();

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: await getMinimumBalanceForRentExemptMint(connection),
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);

const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint] // Signers
);

console.log("Mint Address: ", mint.publicKey.toBase58());
console.log("Transaction Signature: ", transactionSignature);

const accountInfo = await connection.getAccountInfo(mint.publicKey);

// !collapse(1:16) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);

const mintAccount = await getMint(
  connection,
  mint.publicKey,
  "confirmed",
  TOKEN_2022_PROGRAM_ID
);
console.log(mintAccount);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    program_pack::Pack,
    signature::{Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
};
use spl_token_2022::{id as token_2022_program_id, instruction::initialize_mint, state::Mint};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let recent_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    let space = Mint::LEN;
    let rent = client.get_minimum_balance_for_rent_exemption(space).await?;

    // Create account instruction
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),      // fee payer
        &mint.pubkey(),           // mint address
        rent,                     // rent
        space as u64,             // space
        &token_2022_program_id(), // program id
    );

    // Initialize mint instruction
    let initialize_mint_instruction = initialize_mint(
        &token_2022_program_id(),
        &mint.pubkey(),            // mint address
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        9,                         // decimals
    )?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        recent_blockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    let account_info = client.get_account(&mint.pubkey()).await?;
    println!("{:#?}", account_info);

    let mint_account = Mint::unpack(&account_info.data)?;
    println!("{:#?}", mint_account);

    Ok(())
}
```

</CodeTabs>

### System accounts

The System Program creates all accounts, then reassigns the ownership of the account to the propoer program owner. 
However, some accounts are not reassigned.

For example, all "wallet" accounts on Solana are "System Accounts" owned by the
System Program. The lamport balance in these accounts shows the amount of SOL
owned by the wallet. Only System Accounts can pay transaction fees.

![System Account](/assets/docs/core/accounts/system-account.svg)

When SOL is sent to a new address for the first time, an account is
automatically created at that address owned by the System Program.

In the example below, a new keypair is generated and funded with SOL. Run the
code to see the output. Note that the `owner` field of the account is the System
Program with the address `11111111111111111111111111111111`.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  generateKeyPairSigner,
  lamports
} from "@solana/kit";

// Create a connection to Solana cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate a new keypair
const keypair = await generateKeyPairSigner();
console.log(`Public Key: ${keypair.address}`);

// Funding an address with SOL automatically creates an account
const signature = await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: keypair.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

const accountInfo = await rpc.getAccountInfo(keypair.address).send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";

// Generate a new keypair
const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);

// Create a connection to the Solana cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Funding an address with SOL automatically creates an account
const signature = await connection.requestAirdrop(
  keypair.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const accountInfo = await connection.getAccountInfo(keypair.publicKey);
console.log(JSON.stringify(accountInfo, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    native_token::LAMPORTS_PER_SOL,
    signer::{keypair::Keypair, Signer},
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate a new keypair
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());

    // Create a connection to Solana cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Funding an address with SOL automatically creates an account
    let signature = connection
        .request_airdrop(&keypair.pubkey(), LAMPORTS_PER_SOL)
        .await?;
    connection.confirm_transaction(&signature).await?;

    let account_info = connection.get_account(&keypair.pubkey()).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

### Sysvar accounts

Sysvar accounts are special accounts at predefined addresses that provide access
to cluster state data. These accounts update dynamically with data about the
network cluster. You can find the full list of Sysvar Accounts
[here](https://docs.anza.xyz/runtime/sysvars).

The following example shows how to fetch and deserialize the data from the
Sysvar Clock account.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { createSolanaRpc } from "@solana/kit";
import { fetchSysvarClock, SYSVAR_CLOCK_ADDRESS } from "@solana/sysvars";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const accountInfo = await rpc
  .getAccountInfo(SYSVAR_CLOCK_ADDRESS, { encoding: "base64" })
  .send();
console.log(accountInfo);

// Automatically fetch and deserialize the account data
const clock = await fetchSysvarClock(rpc);
console.log(clock);
```

```ts !! title="Legacy"
import { Connection, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getSysvarClockCodec } from "@solana/sysvars";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const accountInfo = await connection.getAccountInfo(SYSVAR_CLOCK_PUBKEY);

// Deserialize the account data
const decodedClock = getSysvarClockCodec().decode(
  new Uint8Array(accountInfo?.data ?? [])
);
// !collapse(1:16) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
console.log(decodedClock);
```

```rs !! title="Rust"
use anyhow::Result;
use bincode::deserialize;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    sysvar::{self, clock::Clock},
};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let account = connection.get_account(&sysvar::clock::ID).await?;
    // Deserialize the account data
    let clock: Clock = deserialize(&account.data)?;

    println!("{:#?}", account);
    println!("{:#?}", clock);

    Ok(())
}
```

</CodeTabs>



{/*I don't love having the system program randomly here at the end. We could put a shortened blurb about it in the "Owner field"
section, and move the rest to a subsection of the "Core Programs" section on the Programs page. I already put some of it in a new
"System accounts" section.*/}

## System Program

By default, all new accounts are owned to the
[System Program](https://github.com/anza-xyz/agave/tree/v2.1.13/programs/system/src).
The System Program performs the following key functions:

| Function                                                                                                                | Description                                                                                                                                                                                                       |
| ----------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [New Account Creation](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L146)     | Only the System Program can create new accounts.                                                                                                                                                                  |
| [Space Allocation](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L71)          | Sets the byte capacity for the data field of each account.                                                                                                                                                        |
| [Assign Program Ownership](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L113) | Once the System Program creates an account, it can reassign the designated program owner to a different program account. That's how custom programs take ownership of new accounts created by the System Program. |
| [Transfer SOL](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L215)             | Transfers lamports (SOL) from System Accounts to other accounts.                                                                                                                                                  |






