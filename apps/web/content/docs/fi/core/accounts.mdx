---
title: Tilit
description:
  Opi Solanan tilimallista, mukaan lukien miten tilit tallentavat dataa ja
  ohjelmia, rent-mekaniikat, tilien omistajuus ja ohjelmien ja datatilien
  välinen suhde. Ymmärrä Solanan avain-arvo-tallennusjärjestelmän keskeiset
  käsitteet.
---

Kaikki data Solana-verkossa tallennetaan tileihin. Voit ajatella Solana-verkkoa
julkisena tietokantana, jossa on yksi Tilit-taulu. Tilin ja sen osoitteen
välinen suhde on samankaltainen kuin avain-arvo-parissa, jossa avain on osoite
ja arvo on tili.

Jokaisella tilillä on sama perus [rakenne](#account-structure) ja se voidaan
paikantaa sen [osoitteen](#account-address) avulla.

![Kaavio kolmesta tilistä ja niiden osoitteista. Sisältää tilin rakenteen määritelmän.](/assets/docs/core/accounts/accounts.png)

## Tilin osoite

Tilin osoite on 32-tavuinen yksilöllinen tunniste, jota käytetään tilin
paikantamiseen Solana-lohkoketjussa. Tilien osoitteet näytetään usein
base58-koodattuina merkkijonoina. Useimmat tilit käyttävät
[Ed25519](https://ed25519.cr.yp.to/) [julkista avainta](#public-key)
osoitteenaan, mutta tämä ei ole pakollista, sillä Solana tukee myös
[ohjelmasta johdettuja osoitteita](#program-derived-address).

![Tili ja sen base58-koodattu julkisen avaimen osoite](/assets/docs/core/accounts/account-address.svg)

### Julkinen avain

Alla oleva esimerkki näyttää, miten Solana SDK:ta käytetään keypair-parin
luomiseen.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner } from "@solana/kit";

// Kit does not enable extractable private keys
const keypairSigner = await generateKeyPairSigner();
console.log(keypairSigner);
```

```ts !! title="Legacy"
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);
console.log(`Secret Key: ${keypair.secretKey}`);
```

```rs !! title="Rust"
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() {
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());
    println!("Secret Key: {:?}", keypair.to_bytes());
}
```

</CodeTabs>

### Program Derived Address

[Program Derived Address](/docs/core/pda) (PDA) on osoite, joka johdetaan
deterministisesti käyttäen ohjelman tunnusta ja yhtä tai useampaa valinnaista
syötettä (siemeniä). Alla oleva esimerkki näyttää, miten Solana SDK:ta käytetään
Program Derived Address -osoitteen luomiseen.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey; // macro
use solana_sdk::pubkey::Pubkey;

#[tokio::main]
async fn main() {
    let program_address = pubkey!("11111111111111111111111111111111");
    let seeds = [b"helloWorld".as_ref()];
    let (pda, bump) = Pubkey::find_program_address(&seeds, &program_address);
    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
}
```

</CodeTabs>

## Tilin rakenne

Jokaisella
[`Account`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L48-L60)
on enimmäiskoko
[10MiB](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/system_instruction.rs#L85)
ja se sisältää seuraavat tiedot:

<WithMentions>

- [`lamports`](mention:lamports): [Lamports](#lamports)-yksiköiden määrä tilillä
- [`data`](mention:data): Tilin [data](#data)
- [`owner`](mention:owner): Sen ohjelman tunnus, joka [omistaa](#owner) tilin
- [`executable`](mention:executable): Ilmaisee, sisältääkö tili
  [suoritettavan](#executable) binäärin
- [`rent_epoch`](mention:rent_epoch): Vanhentunut [rent epoch](#rent-epoch)
  -kenttä

```rust title="Account"
pub struct Account {
    /// lamports in the account
    // !mention lamports
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    // !mention data
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    // !mention owner
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    // !mention executable
    pub executable: bool,
    /// the epoch at which this account will next owe rent
    // !mention rent_epoch
    pub rent_epoch: Epoch,
}
```

</WithMentions>

<ScrollyCoding>

## !!steps Lamport-yksiköt

Tilin saldo [lamport](/docs/references/terminology#lamport)-yksiköissä.

Jokaisella tilillä on oltava vähimmäismäärä lamport-yksiköitä, jota kutsutaan
[rent](/docs/references/terminology#rent)-maksuksi, joka mahdollistaa sen
tietojen tallentamisen lohkoketjuun. Rent on verrannollinen tilin kokoon.

<Callout type="info">
  Vaikka tätä saldoa kutsutaan rentiksi, se toimii enemmän talletuksen tavoin,
  sillä koko saldo voidaan palauttaa, kun tili suljetaan. (Nimi "rent" tulee nyt
  vanhentuneesta [rent epoch](#rent-epoch) -kentästä.)
</Callout>

(Katso
[vähimmäissaldon](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97)
kaava ja sovellettavat
[vakiot](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L47-L70).)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    // !focus
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    // !focus
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Data

Tähän kenttään viitataan yleisesti "tilin datana". Tämän kentän `data` katsotaan
mielivaltaiseksi, koska se voi sisältää mitä tahansa tavusarjoja. Jokainen
ohjelma määrittelee tähän kenttään tallennetun datan rakenteen.

- Program account -tilit: Tämä kenttä sisältää joko suoritettavan ohjelmakoodin
  tai [program data account](#program-data-accounts) -tilin osoitteen, joka
  tallentaa suoritettavan ohjelmakoodin.
- Datatilit: Tämä kenttä yleensä tallentaa tiladataa, joka on tarkoitettu
  luettavaksi.

Datan lukeminen Solana-tililtä sisältää kaksi vaihetta:

1. Tilin hakeminen sen [osoitteen](#account-address) avulla
2. Tilin `data` -kentän deserialisointi raakatavuista asianmukaiseen
   tietorakenteeseen, jonka määrittelee tiliä omistava ohjelma.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    // !focus
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    // !focus
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    // !focus
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    // !focus
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Omistaja

Tämä kenttä sisältää tilin omistajan ohjelmatunnuksen.

Jokaisella Solana-tilillä on [ohjelma](/docs/core/programs) määritetty sen
omistajaksi. Tilin omistaja on ainoa ohjelma, joka voi muuttaa tilin `data`
-kenttää tai vähentää lamport-yksiköitä ohjelman ohjeiden mukaisesti.

(Program account -tilin tapauksessa omistaja on sen
[loader program](https://solana.com/docs/core/programs#loader-programs).)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    // !focus
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    // !focus
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Suoritettava

Tämä kenttä ilmaisee, onko tili [program account](#program-accounts) vai
[datatili](#data-accounts)

- Jos `true`: Tili on program account
- Jos `false`: Tili on datatili

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    // !focus
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    // !focus
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Rent epoch

**`rent_epoch` -kenttä on vanhentunut.**

Aiemmin tämä kenttä seurasi, milloin tilin pitäisi maksaa rent-maksua. Tämä
rent-keräysmekanismi on kuitenkin sittemmin poistettu käytöstä.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    // !focus
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    // !focus
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

</ScrollyCoding>

## Tilityypit

Tilit jakautuvat kahteen peruskategoriaan:

- [Program account -tilit](#program-accounts): Tilit, jotka sisältävät
  suoritettavaa koodia
- [Datatilit](#data-accounts): Tilit, jotka eivät sisällä suoritettavaa koodia

Tämä erottelu tarkoittaa, että ohjelman suoritettava koodi ja sen tila
tallennetaan erillisiin tileihin. (Samankaltaisesti kuin käyttöjärjestelmissä,
joissa tyypillisesti on erilliset tiedostot ohjelmille ja niiden datalle.)

### Program account -tilit

Jokaisen ohjelman omistaa
[lataaja-ohjelma](/docs/core/programs#loader-programs), jota käytetään tilin
käyttöönottoon ja hallintaan. Kun uusi [ohjelma](/docs/core/programs) otetaan
käyttöön, luodaan tili sen [suoritettavan](#executable) koodin tallentamiseen.
Tätä kutsutaan program account -tiliksi. (Yksinkertaisuuden vuoksi voit ajatella
program account -tilin olevan itse ohjelma.)

Alla olevassa kaaviossa näet, kuinka lataaja-ohjelmaa käytetään program account
-tilin käyttöönottoon. Program account -tilin `data` sisältää suoritettavan
ohjelmakoodin.

![Kaavio program account -tilistä, sen 4 komponentista ja sen lataaja-ohjelmasta.](/assets/docs/core/accounts/program-account-simple.svg)

#### Program data account -tilit

Ohjelmat, jotka on otettu käyttöön loader-v3:lla, eivät sisällä ohjelmakoodia
`data` -kentässään. Sen sijaan niiden `data` osoittaa erilliseen **program data
account** -tiliin, joka sisältää ohjelmakoodin. (Katso alla oleva kaavio.)

![Program account datalla. Data osoittaa erilliseen program data account -tiliin](/assets/docs/core/accounts/program-account-expanded.svg)

<Callout>
  Ohjelman käyttöönoton tai päivitysten aikana puskuritilejä käytetään
  väliaikaisesti latauksen valmisteluun.
</Callout>

Alla oleva esimerkki hakee Token Program -tilin. Huomaa, että `executable`
-kenttä on asetettu arvoon `true`, mikä osoittaa tilin olevan ohjelma.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const programId = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address;

const accountInfo = await rpc
  .getAccountInfo(programId, { encoding: "base64" })
  .send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Connection, PublicKey } from "@solana/web3.js";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const programId = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

const accountInfo = await connection.getAccountInfo(programId);
// !collapse(1:17) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::pubkey;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let program_id = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let account_info = connection.get_account(&program_id).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

### Datatilit

Datatilit eivät sisällä suoritettavaa koodia. Sen sijaan ne tallentavat tietoa.

#### Ohjelman tilatilit

Ohjelmat käyttävät datatilejä tilansa ylläpitämiseen. Tätä varten niiden on
ensin luotava uusi datatili. Ohjelman tilatilien luomisprosessi on usein
abstrahoitu, mutta on hyödyllistä ymmärtää taustalla oleva prosessi.

Tilansa hallitsemiseksi uuden ohjelman täytyy:

1. Kutsua [System Program](/docs/core/programs#the-system-program) -ohjelmaa
   tilin luomiseksi. (System Program siirtää sitten omistajuuden uudelle
   ohjelmalle.)
2. Alustaa tilin data, kuten sen [ohjeet](/docs/core/instructions)
   määrittelevät.

![Kaavio datatiliistä, jonka omistaa program account](/assets/docs/core/accounts/data-account.svg)

Alla oleva esimerkki luo ja hakee Token Mint -tilin, jonka omistaa Token 2022
-ohjelma.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  fetchMint
} from "@solana-program/token-2022";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer
const feePayer = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Instruction to create new account for mint (token 2022 program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token 2022 program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address
});

const instructions = [createAccountInstruction, initializeMintInstruction];

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }), // Create transaction message
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx), // Set fee payer
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set transaction blockhash
  (tx) => appendTransactionMessageInstructions(instructions, tx) // Append instructions
);

// Sign transaction message with required signers (fee payer and mint keypair)
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Mint Address:", mint.address);
console.log("Transaction Signature:", transactionSignature);

const accountInfo = await rpc.getAccountInfo(mint.address).send();
console.log(accountInfo);

const mintAccount = await fetchMint(rpc, mint.address);
console.log(mintAccount);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  TOKEN_2022_PROGRAM_ID,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const recentBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: recentBlockhash.blockhash,
  lastValidBlockHeight: recentBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Generate keypair to use as address of mint
const mint = Keypair.generate();

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: await getMinimumBalanceForRentExemptMint(connection),
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);

const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint] // Signers
);

console.log("Mint Address: ", mint.publicKey.toBase58());
console.log("Transaction Signature: ", transactionSignature);

const accountInfo = await connection.getAccountInfo(mint.publicKey);

// !collapse(1:16) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);

const mintAccount = await getMint(
  connection,
  mint.publicKey,
  "confirmed",
  TOKEN_2022_PROGRAM_ID
);
console.log(mintAccount);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    program_pack::Pack,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_token_2022_interface::{
    id as token_2022_program_id, instruction::initialize_mint, state::Mint,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let recent_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    let space = Mint::LEN;
    let rent = client.get_minimum_balance_for_rent_exemption(space).await?;

    // Create account instruction
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),      // fee payer
        &mint.pubkey(),           // mint address
        rent,                     // rent
        space as u64,             // space
        &token_2022_program_id(), // program id
    );

    // Initialize mint instruction
    let initialize_mint_instruction = initialize_mint(
        &token_2022_program_id(),
        &mint.pubkey(),            // mint address
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        9,                         // decimals
    )?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        recent_blockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    let account_info = client.get_account(&mint.pubkey()).await?;
    println!("{:#?}", account_info);

    let mint_account = Mint::unpack(&account_info.data)?;
    println!("{:#?}", mint_account);

    Ok(())
}
```

</CodeTabs>

#### Järjestelmätilit

Kaikkia tilejä ei määritetä uudelle omistajalle sen jälkeen, kun System Program
on luonut ne. System Program -ohjelman omistamia tilejä kutsutaan
järjestelmätileiksi. Kaikki lompakkotilit ovat järjestelmätilejä, mikä
mahdollistaa niiden maksaa [transaktiomaksuja](docs/core/fees).

![System Program -ohjelman omistama lompakko, joka sisältää 1 000 000 lamportsia](/assets/docs/core/accounts/system-account.svg)

Kun SOL lähetetään ensimmäistä kertaa uuteen osoitteeseen, kyseiseen
osoitteeseen luodaan tili, jonka omistaa System Program.

Alla olevassa esimerkissä luodaan uusi keypair ja rahoitetaan se SOL:lla. Koodin
suorittamisen jälkeen näet, että tilin `owner` on
`11111111111111111111111111111111`
([System Program](/docs/core/programs#the-system-program)).

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  generateKeyPairSigner,
  lamports
} from "@solana/kit";

// Create a connection to Solana cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate a new keypair
const keypair = await generateKeyPairSigner();
console.log(`Public Key: ${keypair.address}`);

// Funding an address with SOL automatically creates an account
const signature = await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: keypair.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

const accountInfo = await rpc.getAccountInfo(keypair.address).send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";

// Generate a new keypair
const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);

// Create a connection to the Solana cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Funding an address with SOL automatically creates an account
const signature = await connection.requestAirdrop(
  keypair.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const accountInfo = await connection.getAccountInfo(keypair.publicKey);
console.log(JSON.stringify(accountInfo, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signer::{keypair::Keypair, Signer},
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate a new keypair
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());

    // Create a connection to Solana cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Funding an address with SOL automatically creates an account
    let signature = connection
        .request_airdrop(&keypair.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = connection.confirm_transaction(&signature).await?;
        if confirmed {
            break;
        }
    }

    let account_info = connection.get_account(&keypair.pubkey()).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

#### Sysvar-tilit

Sysvar-tilit ovat olemassa ennalta määritetyissä osoitteissa ja tarjoavat pääsyn
klusterin tilatietoihin. Ne päivittyvät dynaamisesti verkkoklusteria koskevilla
tiedoilla. Katso täydellinen luettelo
[Sysvar-tileistä](https://docs.anza.xyz/runtime/sysvars).

Alla oleva esimerkki hakee ja purkaa tietoja Sysvar Clock -tilistä.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { createSolanaRpc } from "@solana/kit";
import { fetchSysvarClock, SYSVAR_CLOCK_ADDRESS } from "@solana/sysvars";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const accountInfo = await rpc
  .getAccountInfo(SYSVAR_CLOCK_ADDRESS, { encoding: "base64" })
  .send();
console.log(accountInfo);

// Automatically fetch and deserialize the account data
const clock = await fetchSysvarClock(rpc);
console.log(clock);
```

```ts !! title="Legacy"
import { Connection, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getSysvarClockCodec } from "@solana/sysvars";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const accountInfo = await connection.getAccountInfo(SYSVAR_CLOCK_PUBKEY);

// Deserialize the account data
const decodedClock = getSysvarClockCodec().decode(
  new Uint8Array(accountInfo?.data ?? [])
);
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
console.log(decodedClock);
```

```rs !! title="Rust"
use anyhow::Result;
use bincode::deserialize;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::sysvar::{self, clock::Clock};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let account = connection.get_account(&sysvar::clock::ID).await?;
    // Deserialize the account data
    let clock: Clock = deserialize(&account.data)?;

    println!("{:#?}", account);
    println!("{:#?}", clock);

    Ok(())
}
```

</CodeTabs>
