---
title: Phí giao dịch
description:
  Tìm hiểu về phí giao dịch của Solana, bao gồm phí cơ bản và phí ưu tiên, cách
  áp dụng từng loại phí, và các phương pháp tốt nhất để quản lý đơn vị tính toán
  trong giao dịch của bạn.
---

Mỗi giao dịch Solana đều yêu cầu một khoản phí giao dịch, được thanh toán bằng
SOL. Phí giao dịch được chia thành hai phần: phí cơ bản và phí ưu tiên. Phí cơ
bản bồi thường cho validator khi xử lý giao dịch. Phí ưu tiên là một khoản phí
tùy chọn, để tăng cơ hội rằng leader hiện tại sẽ xử lý giao dịch của bạn.

## Phí cơ bản

Mỗi giao dịch có chi phí 5000 [lamports](/docs/references/terminology#lamport)
cho mỗi chữ ký được bao gồm. Khoản phí này được thanh toán bởi người ký đầu tiên
trong giao dịch và phải được thanh toán bởi một tài khoản thuộc sở hữu của
System Program. Phí cơ bản được chia như sau:

- **50% bị đốt:** Một nửa bị
  [đốt](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (lấy ra khỏi nguồn cung SOL đang lưu hành).
- **50% được phân phối:** Một nửa được
  [trả cho validator](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
  đã xử lý giao dịch.

## Phí ưu tiên

Một
[phí ưu tiên](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
là một khoản phí tùy chọn được sử dụng để tăng cơ hội rằng leader hiện tại
(validator) sẽ xử lý giao dịch của bạn. Validator nhận
[100% phí ưu tiên](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Phí ưu tiên có thể được thiết lập bằng cách điều chỉnh giá
[đơn vị tính toán](/docs/references/terminology#compute-units) (CU) và giới hạn
CU của giao dịch. (Xem
[Hướng dẫn sử dụng phí ưu tiên](/developers/guides/advanced/how-to-use-priority-fees)
để biết thêm chi tiết về phí ưu tiên.)

Phí ưu tiên được tính như sau:

**Phí ưu tiên = Giá đơn vị tính toán × Giới hạn đơn vị tính toán**

Phí ưu tiên được sử dụng để xác định
[độ ưu tiên của giao dịch](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646)
của bạn, so với các giao dịch khác. Nó được tính bằng công thức sau:

**Độ ưu tiên giao dịch = Phí ưu tiên / Giới hạn đơn vị tính toán**

#### Giới hạn đơn vị tính toán

Theo
[mặc định](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
mỗi lệnh được phân bổ
[200.000 CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
và mỗi giao dịch được phân bổ
[1,4 triệu CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14).
Bạn có thể thay đổi các giá trị mặc định này bằng cách bao gồm một lệnh
[ComputeBudgetInstruction::set_compute_unit_limit](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
trong giao dịch của bạn.

Để tính toán giới hạn đơn vị tính toán (CU) phù hợp cho giao dịch của bạn, chúng
tôi khuyến nghị các bước sau:

1. Ước tính số đơn vị CU cần thiết bằng cách
   [mô phỏng](/developers/guides/advanced/how-to-request-optimal-compute) giao
   dịch
2. Thêm 10% biên độ an toàn vào ước tính này

<Callout type="warn">
  Phí ưu tiên được xác định bởi giới hạn đơn vị tính toán được yêu cầu trong
  giao dịch, *không phải* số đơn vị tính toán thực tế được sử dụng. Nếu bạn đặt
  giới hạn đơn vị tính toán quá cao hoặc sử dụng số lượng mặc định, bạn có thể
  phải trả tiền cho các đơn vị tính toán không sử dụng.
</Callout>

#### Giá đơn vị tính toán

Giá đơn vị tính toán là một khoản tùy chọn tính bằng
[micro-lamports](/docs/references/terminology#micro-lamports) được trả cho mỗi
CU được yêu cầu. Bạn có thể xem giá CU như một khoản tiền boa để khuyến khích
validator ưu tiên giao dịch của bạn. Để đặt giá CU, hãy bao gồm lệnh
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
trong giao dịch của bạn.

<Callout>
  Giá CU mặc định là 0, nghĩa là phí ưu tiên mặc định cũng là 0.
</Callout>

Để được hỗ trợ xác định giá CU tốt nhất cho giao dịch của bạn, hãy xem khuyến
nghị giá CU thời gian thực được liệt kê trong bảng dưới đây.

| Nhà cung cấp                            | API Phí Ưu tiên                                                              |
| --------------------------------------- | ---------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [Tài liệu](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Tài liệu](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Tài liệu](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Ví dụ

Các ví dụ dưới đây cho thấy cách đặt giới hạn CU và giá CU cho một giao dịch sử
dụng các SDK của Solana.

| SDK                            | Tham khảo mã nguồn                                                                                                             |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
