---
title: İşlem ücretleri
description:
  Solana'nın işlem ücretleri hakkında bilgi edinin; temel ve öncelik ücretleri,
  her birinin nasıl uygulandığı ve işlemlerinizdeki hesaplama birimlerini
  yönetmek için en iyi uygulamalar dahil.
---

Her Solana işlemi, SOL olarak ödenen bir işlem ücreti gerektirir. İşlem
ücretleri iki kısma ayrılır: temel ücret ve önceliklendirme ücreti. Temel ücret,
doğrulayıcıları işlemi işledikleri için tazmin eder. Önceliklendirme ücreti,
mevcut liderin işleminizi işleme olasılığını artırmak için isteğe bağlı bir
ücrettir.

## Temel ücret

Her işlem, dahil edilen imza başına 5000
[lamport](/docs/references/terminology#lamport) maliyetindedir. Bu ücret,
işlemdeki ilk imzalayan tarafından ödenir ve System Program tarafından sahip
olunan bir hesap tarafından ödenmelidir. Temel ücret aşağıdaki şekilde bölünür:

- **%50'si yakılır:** Yarısı
  [yakılır](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (dolaşımdaki SOL arzından çıkarılır).
- **%50'si dağıtılır:** Yarısı
  [işlemi işleyen doğrulayıcıya ödenir](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62).

## Önceliklendirme ücreti

[Önceliklendirme ücreti](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48),
mevcut liderin (doğrulayıcının) işleminizi işleme olasılığını artırmak için
kullanılan isteğe bağlı bir ücrettir. Doğrulayıcı,
[öncelik ücretinin %100'ünü alır](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Önceliklendirme ücretleri, işlemin
[hesaplama birimi](/docs/references/terminology#compute-units) (CU) fiyatını ve
CU limitini ayarlayarak belirlenebilir. (Önceliklendirme ücretleri hakkında daha
fazla bilgi için
[Öncelik Ücretlerini Kullanma Kılavuzu'na](/developers/guides/advanced/how-to-use-priority-fees)
bakın.)

Önceliklendirme ücreti aşağıdaki şekilde hesaplanır:

```text title="Prioritization fee formula"
Prioritization fee = CU limit * CU price
```

Önceliklendirme ücreti, diğer işlemlere göre
[işleminizin önceliğini](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646)
belirlemek için kullanılır. Aşağıdaki formül kullanılarak hesaplanır:

```text title="Transaction priority formula"
Priority = (Prioritization fee + Base fee) / (1 + CU limit + Signature CUs + Write lock CUs)
```

#### Hesaplama birimi limiti

[Varsayılan olarak](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
her talimata
[200.000 CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
ve her işleme
[1,4 milyon CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14)
tahsis edilir. İşleminize bir
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
talimatı ekleyerek bu varsayılanları değiştirebilirsiniz.

İşleminiz için uygun Hesaplama Birimi sınırını hesaplamak için aşağıdaki
adımları öneririz:

1. İşlemi
   [simüle ederek](/developers/guides/advanced/how-to-request-optimal-compute)
   gerekli Hesaplama Birimi miktarını tahmin edin
2. Bu tahmine %10 güvenlik payı ekleyin

<Callout type="warn">
  Önceliklendirme ücreti, gerçekte kullanılan hesaplama birimi sayısına göre
  değil, talep edilen hesaplama birimi sınırına göre belirlenir. Eğer çok yüksek
  bir hesaplama birimi sınırı belirlerseniz veya varsayılan miktarı
  kullanırsanız, kullanılmayan hesaplama birimleri için ödeme yapabilirsiniz.
</Callout>

#### Hesaplama birimi fiyatı

Hesaplama birimi fiyatı, talep edilen her Hesaplama Birimi için ödenen isteğe
bağlı bir [mikro-lamport](/docs/references/terminology#micro-lamports)
miktarıdır. Hesaplama Birimi fiyatını, validator'ın işleminize öncelik vermesini
teşvik eden bir bahşiş olarak düşünebilirsiniz. Hesaplama Birimi fiyatını
ayarlamak için, işleminize bir
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
talimatı ekleyin.

<Callout>
  Varsayılan Hesaplama Birimi fiyatı 0'dır, yani varsayılan önceliklendirme
  ücreti de 0'dır.
</Callout>

İşleminiz için en iyi Hesaplama Birimi fiyatını belirlemek için yardım almak
isterseniz, aşağıdaki tabloda listelenen gerçek zamanlı Hesaplama Birimi fiyat
önerilerine bakabilirsiniz.

| Sağlayıcı                               | Öncelik Ücreti API                                                                |
| --------------------------------------- | --------------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [Dokümantasyon](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Dokümantasyon](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Dokümantasyon](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Örnek

Aşağıdaki örnekler, Solana SDK'larını kullanarak bir işlemde Hesaplama Birimi
sınırını ve Hesaplama Birimi fiyatını nasıl ayarlayacağınızı göstermektedir.

| SDK                            | Kaynak Kod Referansı                                                                                                           |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
