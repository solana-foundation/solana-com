---
title: İşlem Ücretleri
description:
  Solana'nın işlem ücretleri hakkında bilgi edinin, temel ve öncelik ücretleri
  dahil olmak üzere, her birinin nasıl uygulandığını ve işlemlerinizde hesaplama
  birimlerini yönetmek için en iyi uygulamaları öğrenin.
---

Her Solana işlemi, SOL cinsinden ödenen bir işlem ücreti gerektirir. İşlem
ücretleri iki kısma ayrılır: temel ücret ve önceliklendirme ücreti. Temel ücret,
doğrulayıcıları işlemi işledikleri için tazmin eder. Önceliklendirme ücreti,
mevcut liderin işleminizi işleme olasılığını artırmak için isteğe bağlı bir
ücrettir.

## Temel ücret

Her işlem, dahil edilen imza başına 5000
[lamport](/docs/references/terminology#lamport) maliyetindedir. Bu ücret,
işlemdeki ilk imzalayan tarafından ödenir ve System Program tarafından sahip
olunan bir hesap tarafından ödenmelidir. Temel ücret şu şekilde bölünür:

- **%50'si yakılır:** Yarısı
  [yakılır](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (dolaşımdaki SOL arzından çıkarılır).
- **%50'si dağıtılır:** Yarısı, işlemi işleyen
  [doğrulayıcıya ödenir](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62).

## Önceliklendirme ücreti

[Önceliklendirme ücreti](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48),
mevcut liderin (doğrulayıcının) işleminizi işleme olasılığını artırmak için
kullanılan isteğe bağlı bir ücrettir. Doğrulayıcı, öncelik ücretinin
[%100'ünü alır](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Önceliklendirme ücretleri, işlemin
[hesaplama birimi](/docs/references/terminology#compute-units) (CU) fiyatını ve
CU limitini ayarlayarak belirlenebilir. (Önceliklendirme ücretleri hakkında daha
fazla ayrıntı için
[Öncelik Ücretlerini Kullanma Kılavuzu](/developers/guides/advanced/how-to-use-priority-fees)'na
bakın.)

Önceliklendirme ücreti şu şekilde hesaplanır:

**Önceliklendirme Ücreti = Hesaplama Birimi Sınırı × Hesaplama Birimi Fiyatı**

Önceliklendirme ücreti,
[işleminizin önceliğini](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646)
diğer işlemlere göre belirlemek için kullanılır. Aşağıdaki formül kullanılarak
hesaplanır:

**İşlem Önceliği = Önceliklendirme Ücreti / Hesaplama Birimi Sınırı**

#### Hesaplama birimi limiti

[Varsayılan olarak](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
her talimata
[200.000 CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
ve her işleme
[1,4 milyon CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14)
tahsis edilir. İşleminize
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
talimatını ekleyerek bu varsayılanları değiştirebilirsiniz.

İşleminiz için uygun CU limitini hesaplamak için aşağıdaki adımları öneririz:

1. Gerekli CU birimlerini işlemi
   [simüle ederek](/developers/guides/advanced/how-to-request-optimal-compute)
   tahmin edin
2. Bu tahmine %10 güvenlik payı ekleyin

<Callout type="warn">
  Öncelik ücreti, işlemin gerçekte kullandığı hesaplama birimi sayısına değil,
  talep edilen hesaplama birimi limitine göre belirlenir. Eğer çok yüksek bir
  hesaplama birimi limiti belirlerseniz veya varsayılan miktarı kullanırsanız,
  kullanılmayan hesaplama birimleri için ödeme yapabilirsiniz.
</Callout>

#### Hesaplama birimi fiyatı

Hesaplama birimi fiyatı, talep edilen her CU için ödenen isteğe bağlı bir
[mikro-lamport](/docs/references/terminology#micro-lamports) miktarıdır. CU
fiyatını, validator'ın işleminize öncelik vermesini teşvik eden bir bahşiş
olarak düşünebilirsiniz. CU fiyatını ayarlamak için, işleminize bir
[ComputeBudgetInstruction::set_compute_unit_price](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
talimatı ekleyin.

<Callout>
  Varsayılan CU fiyatı 0'dır, yani varsayılan önceliklendirme ücreti de 0'dır.
</Callout>

İşleminiz için en iyi CU fiyatını belirlemek için yardıma ihtiyacınız varsa,
aşağıdaki tabloda listelenen gerçek zamanlı CU fiyat önerilerine bakın.

| Sağlayıcı                               | Öncelik Ücreti API                                                                |
| --------------------------------------- | --------------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [Dokümantasyon](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Dokümantasyon](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Dokümantasyon](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Örnek

Aşağıdaki örnekler, Solana SDK'larını kullanarak bir işlemde CU limitini ve CU
fiyatını nasıl ayarlayacağınızı göstermektedir.

| SDK                          | Kaynak Kod Referansı                                                                                                                             |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| @solana/web3.js (Typescript) | [ComputeBudgetProgram.setComputeUnitPrice](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| solana-sdk (Rust)            | [ComputeBudgetInstruction::set_compute_unit_limit](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)             |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    compute_budget::ComputeBudgetInstruction,
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    system_instruction,
    transaction::Transaction,
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction =
        system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
