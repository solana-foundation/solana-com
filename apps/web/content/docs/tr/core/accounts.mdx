---
title: Hesaplar
description:
  Solana'nın hesap modelini, hesapların verileri ve programları nasıl
  depoladığını, rent mekanizmalarını, hesap sahipliğini ve programlar ile veri
  hesapları arasındaki ilişkiyi öğrenin. Solana'nın anahtar-değer depolama
  sisteminin temel kavramlarını anlayın.
---

Solana ağındaki tüm veriler hesaplarda saklanır. Solana ağını, tek bir Hesaplar
tablosuna sahip genel bir veritabanı olarak düşünebilirsiniz. Bir hesap ile
adresi arasındaki ilişki, anahtarın adres ve değerin hesap olduğu bir
anahtar-değer çiftine benzer.

Her hesap aynı temel [yapıya](#account-structure) sahiptir ve
[adresi](#account-address) kullanılarak bulunabilir.

![Üç hesap ve adreslerini gösteren diyagram. Hesap yapısı tanımını içerir.](/assets/docs/core/accounts/accounts.png)

## Hesap adresi

Hesabın adresi, Solana blok zincirinde hesabı bulmak için kullanılan 32 baytlık
benzersiz bir kimliktir. Hesap adresleri genellikle base58 kodlanmış dizeler
olarak gösterilir. Çoğu hesap adres olarak bir
[Ed25519](https://ed25519.cr.yp.to/) [açık anahtar](#public-key) kullanır, ancak
Solana aynı zamanda [program derived address](#program-derived-address)
desteklediği için bu zorunlu değildir.

![Base58 kodlanmış açık anahtar adresine sahip bir hesap](/assets/docs/core/accounts/account-address.svg)

### Açık anahtar

Aşağıdaki örnek, bir keypair oluşturmak için Solana SDK'nın nasıl
kullanılacağını göstermektedir.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner } from "@solana/kit";

// Kit does not enable extractable private keys
const keypairSigner = await generateKeyPairSigner();
console.log(keypairSigner);
```

```ts !! title="Legacy"
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);
console.log(`Secret Key: ${keypair.secretKey}`);
```

```rs !! title="Rust"
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() {
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());
    println!("Secret Key: {:?}", keypair.to_bytes());
}
```

</CodeTabs>

### Program derived address

Bir [program derived address](/docs/core/pda) (PDA), bir program kimliği ve bir
veya daha fazla isteğe bağlı girdi (seed) kullanılarak deterministik olarak
türetilen bir adrestir. Aşağıdaki örnek, bir program derived address oluşturmak
için Solana SDK'nın nasıl kullanılacağını göstermektedir.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey; // macro
use solana_sdk::pubkey::Pubkey;

#[tokio::main]
async fn main() {
    let program_address = pubkey!("11111111111111111111111111111111");
    let seeds = [b"helloWorld".as_ref()];
    let (pda, bump) = Pubkey::find_program_address(&seeds, &program_address);
    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
}
```

</CodeTabs>

## Hesap yapısı

Her
[`Account`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L48-L60)
maksimum
[10MiB](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/system_instruction.rs#L85)
boyutundadır ve aşağıdaki bilgileri içerir:

<WithMentions>

- [`lamports`](mention:lamports): Hesaptaki [lamport](#lamports) sayısı
- [`data`](mention:data): Hesabın [verisi](#data)
- [`owner`](mention:owner): Hesabın [sahibi](#owner) olan programın kimliği
- [`executable`](mention:executable): Hesabın çalıştırılabilir ikili dosya
  [içerip içermediğini](#executable) gösterir
- [`rent_epoch`](mention:rent_epoch): Kullanımdan kaldırılmış
  [rent epoch](#rent-epoch) alanı

```rust title="Account"
pub struct Account {
    /// lamports in the account
    // !mention lamports
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    // !mention data
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    // !mention owner
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    // !mention executable
    pub executable: bool,
    /// the epoch at which this account will next owe rent
    // !mention rent_epoch
    pub rent_epoch: Epoch,
}
```

</WithMentions>

<ScrollyCoding>

## !!steps Lamport'lar

Hesabın [lamport](/docs/references/terminology#lamport) cinsinden bakiyesi.

Her hesabın, verilerinin zincir üzerinde saklanmasını sağlayan minimum bir
lamport bakiyesine, yani [rent](/docs/references/terminology#rent) adı verilen
bir bakiyeye sahip olması gerekir. Rent, hesabın boyutuyla orantılıdır.

<Callout type="info">
  Bu bakiye "rent" olarak adlandırılsa da, hesap kapatıldığında tüm bakiye geri
  alınabildiği için daha çok bir depozito gibi çalışır. ("Rent" adı, artık
  kullanımdan kaldırılmış olan [rent epoch](#rent-epoch) alanından gelmektedir.)
</Callout>

([Minimum bakiye](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97)
formülüne ve geçerli
[sabitlere](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L47-L70)
bakın.)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    // !focus
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    // !focus
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Veri

Bu alan genellikle "hesap verisi" olarak adlandırılır. Bu alandaki `data`
herhangi bir bayt dizisi içerebileceği için keyfi olarak kabul edilir. Her
program, bu alanda saklanan verilerin yapısını kendisi tanımlar.

- Program account'ları: Bu alan, ya çalıştırılabilir program kodunu ya da
  çalıştırılabilir program kodunu saklayan bir
  [program data account](#program-data-accounts) adresini içerir.
- Veri hesapları: Bu alan genellikle okunmak üzere durum verilerini saklar.

Bir Solana hesabından veri okumak iki adımdan oluşur:

1. Hesabı [adresi](#account-address) kullanarak getirmek
2. Hesabın `data` alanını ham baytlardan, hesabın sahibi olan program tarafından
   tanımlanan uygun veri yapısına dönüştürmek

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    // !focus
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    // !focus
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    // !focus
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    // !focus
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Sahip

Bu alan, hesabın sahibinin program ID'sini içerir.

Her Solana hesabının sahibi olarak belirlenmiş bir
[programı](/docs/core/programs) vardır. Hesabın sahibi, programın talimatlarında
belirtildiği gibi, hesabın `data` alanını değiştirebilen veya lamport'ları
düşebilen tek programdır.

(Bir program account söz konusu olduğunda, sahibi
[loader program](https://solana.com/docs/core/programs#loader-programs) olur.)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    // !focus
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    // !focus
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Çalıştırılabilir

Bu alan, bir hesabın [program account](#program-accounts) mı yoksa
[data account](#data-accounts) mı olduğunu belirtir

- Eğer `true`: Hesap bir program account'tır
- Eğer `false`: Hesap bir data account'tır

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    // !focus
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    // !focus
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Rent epoch

**`rent_epoch` alanı kullanımdan kaldırılmıştır.**

Geçmişte, bu alan bir hesabın ne zaman rent ödemesi gerektiğini takip ederdi.
Ancak, bu rent toplama mekanizması artık kullanımdan kaldırılmıştır.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    // !focus
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    // !focus
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

</ScrollyCoding>

## Hesap türleri

Hesaplar iki temel kategoriye ayrılır:

- [Program account'ları](#program-accounts): Çalıştırılabilir kod içeren
  hesaplar
- [Data account'ları](#data-accounts): Çalıştırılabilir kod içermeyen hesaplar

Bu ayrım, bir programın çalıştırılabilir kodu ve durumunun ayrı hesaplarda
saklandığı anlamına gelir. (İşletim sistemlerine benzer şekilde, genellikle
programlar ve verileri için ayrı dosyalara sahiptir.)

### Program account'ları

Her program, hesabı dağıtmak ve yönetmek için kullanılan bir
[loader program](/docs/core/programs#loader-programs) tarafından sahiplenilir.
Yeni bir [program](/docs/core/programs) dağıtıldığında,
[çalıştırılabilir](#executable) kodunu depolamak için bir hesap oluşturulur.
Buna program account denir. (Basitlik açısından, program account'ı programın
kendisi olarak düşünebilirsiniz.)

Aşağıdaki diyagramda, bir program account'ı dağıtmak için bir loader program'ın
kullanıldığını görebilirsiniz. Program account'ın `data` alanı, çalıştırılabilir
program kodunu içerir.

![Bir program account'ın, 4 bileşeninin ve loader program'ının diyagramı.](/assets/docs/core/accounts/program-account-simple.svg)

#### Program data account'ları

Loader-v3 kullanılarak dağıtılan programlar, `data` alanlarında program kodu
içermezler. Bunun yerine, `data` alanları, program kodunu içeren ayrı bir
**program data account**'a işaret eder. (Aşağıdaki diyagrama bakın.)

![Veriye sahip bir program hesabı. Veri, ayrı bir program veri hesabına işaret eder](/assets/docs/core/accounts/program-account-expanded.svg)

<Callout>
  Program dağıtımı veya güncellemeleri sırasında, buffer hesapları yüklemeyi
  geçici olarak hazırlamak için kullanılır.
</Callout>

Aşağıdaki örnek Token Program hesabını getirir. `executable` alanının `true`
olarak ayarlandığına dikkat edin, bu hesabın bir program olduğunu gösterir.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const programId = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address;

const accountInfo = await rpc
  .getAccountInfo(programId, { encoding: "base64" })
  .send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Connection, PublicKey } from "@solana/web3.js";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const programId = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

const accountInfo = await connection.getAccountInfo(programId);
// !collapse(1:17) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::pubkey;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let program_id = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let account_info = connection.get_account(&program_id).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

### Veri hesapları

Veri hesapları çalıştırılabilir kod içermez. Bunun yerine, bilgi depolarlar.

#### Program durum hesabı

Programlar, durumlarını korumak için veri hesaplarını kullanır. Bunu yapmak
için, önce yeni bir veri hesabı oluşturmaları gerekir. Program durum hesabı
oluşturma süreci genellikle soyutlanmıştır, ancak altta yatan süreci anlamak
faydalıdır.

Durumunu yönetmek için, yeni bir program şunları yapmalıdır:

1. Bir hesap oluşturmak için
   [System Program](/docs/core/programs#the-system-program)'ı çağırın. (System
   Program daha sonra sahipliği yeni programa aktarır.)
2. [Talimatlarında](/docs/core/instructions) tanımlandığı şekilde hesap
   verilerini başlatın.

![Bir program hesabı tarafından sahiplenilen bir veri hesabının diyagramı](/assets/docs/core/accounts/data-account.svg)

Aşağıdaki örnek, Token 2022 programı tarafından sahiplenilen bir Token Mint
hesabı oluşturur ve getirir.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  fetchMint
} from "@solana-program/token-2022";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer
const feePayer = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Instruction to create new account for mint (token 2022 program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token 2022 program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address
});

const instructions = [createAccountInstruction, initializeMintInstruction];

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }), // Create transaction message
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx), // Set fee payer
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set transaction blockhash
  (tx) => appendTransactionMessageInstructions(instructions, tx) // Append instructions
);

// Sign transaction message with required signers (fee payer and mint keypair)
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Mint Address:", mint.address);
console.log("Transaction Signature:", transactionSignature);

const accountInfo = await rpc.getAccountInfo(mint.address).send();
console.log(accountInfo);

const mintAccount = await fetchMint(rpc, mint.address);
console.log(mintAccount);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  TOKEN_2022_PROGRAM_ID,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const recentBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: recentBlockhash.blockhash,
  lastValidBlockHeight: recentBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Generate keypair to use as address of mint
const mint = Keypair.generate();

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: await getMinimumBalanceForRentExemptMint(connection),
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);

const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint] // Signers
);

console.log("Mint Address: ", mint.publicKey.toBase58());
console.log("Transaction Signature: ", transactionSignature);

const accountInfo = await connection.getAccountInfo(mint.publicKey);

// !collapse(1:16) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);

const mintAccount = await getMint(
  connection,
  mint.publicKey,
  "confirmed",
  TOKEN_2022_PROGRAM_ID
);
console.log(mintAccount);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    program_pack::Pack,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_token_2022_interface::{
    id as token_2022_program_id, instruction::initialize_mint, state::Mint,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let recent_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    let space = Mint::LEN;
    let rent = client.get_minimum_balance_for_rent_exemption(space).await?;

    // Create account instruction
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),      // fee payer
        &mint.pubkey(),           // mint address
        rent,                     // rent
        space as u64,             // space
        &token_2022_program_id(), // program id
    );

    // Initialize mint instruction
    let initialize_mint_instruction = initialize_mint(
        &token_2022_program_id(),
        &mint.pubkey(),            // mint address
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        9,                         // decimals
    )?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        recent_blockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    let account_info = client.get_account(&mint.pubkey()).await?;
    println!("{:#?}", account_info);

    let mint_account = Mint::unpack(&account_info.data)?;
    println!("{:#?}", mint_account);

    Ok(())
}
```

</CodeTabs>

#### System hesapları

System Program tarafından oluşturulduktan sonra tüm hesaplara yeni bir sahip
atanmaz. System Program tarafından sahiplenilen hesaplara system hesapları
denir. Tüm cüzdan hesapları system hesaplarıdır, bu da onların
[işlem ücretlerini](docs/core/fees) ödemelerine olanak tanır.

![System Program tarafından sahiplenilen ve 1.000.000 lamport içeren bir cüzdan](/assets/docs/core/accounts/system-account.svg)

SOL ilk kez yeni bir adrese gönderildiğinde, o adreste System Program tarafından
sahiplenilen bir hesap oluşturulur.

Aşağıdaki örnekte, yeni bir keypair oluşturulur ve SOL ile fonlanır. Kodu
çalıştırdıktan sonra, hesabın `owner` adresinin
`11111111111111111111111111111111`
([System Program](/docs/core/programs#the-system-program)) olduğunu
görebilirsiniz.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  generateKeyPairSigner,
  lamports
} from "@solana/kit";

// Create a connection to Solana cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate a new keypair
const keypair = await generateKeyPairSigner();
console.log(`Public Key: ${keypair.address}`);

// Funding an address with SOL automatically creates an account
const signature = await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: keypair.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

const accountInfo = await rpc.getAccountInfo(keypair.address).send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";

// Generate a new keypair
const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);

// Create a connection to the Solana cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Funding an address with SOL automatically creates an account
const signature = await connection.requestAirdrop(
  keypair.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const accountInfo = await connection.getAccountInfo(keypair.publicKey);
console.log(JSON.stringify(accountInfo, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signer::{keypair::Keypair, Signer},
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate a new keypair
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());

    // Create a connection to Solana cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Funding an address with SOL automatically creates an account
    let signature = connection
        .request_airdrop(&keypair.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = connection.confirm_transaction(&signature).await?;
        if confirmed {
            break;
        }
    }

    let account_info = connection.get_account(&keypair.pubkey()).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

#### Sysvar hesapları

Sysvar hesapları önceden tanımlanmış adreslerde bulunur ve küme durumu
verilerine erişim sağlar. Ağ kümesi hakkındaki verilerle dinamik olarak
güncellenir. [Sysvar Hesapları](https://docs.anza.xyz/runtime/sysvars) tam
listesine bakın.

Aşağıdaki örnek, Sysvar Clock hesabından veri alır ve deserialize eder.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { createSolanaRpc } from "@solana/kit";
import { fetchSysvarClock, SYSVAR_CLOCK_ADDRESS } from "@solana/sysvars";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");

const accountInfo = await rpc
  .getAccountInfo(SYSVAR_CLOCK_ADDRESS, { encoding: "base64" })
  .send();
console.log(accountInfo);

// Automatically fetch and deserialize the account data
const clock = await fetchSysvarClock(rpc);
console.log(clock);
```

```ts !! title="Legacy"
import { Connection, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getSysvarClockCodec } from "@solana/sysvars";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const accountInfo = await connection.getAccountInfo(SYSVAR_CLOCK_PUBKEY);

// Deserialize the account data
const decodedClock = getSysvarClockCodec().decode(
  new Uint8Array(accountInfo?.data ?? [])
);
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
console.log(decodedClock);
```

```rs !! title="Rust"
use anyhow::Result;
use bincode::deserialize;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::sysvar::{self, clock::Clock};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet-beta.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let account = connection.get_account(&sysvar::clock::ID).await?;
    // Deserialize the account data
    let clock: Clock = deserialize(&account.data)?;

    println!("{:#?}", account);
    println!("{:#?}", clock);

    Ok(())
}
```

</CodeTabs>
