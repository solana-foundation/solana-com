---
title: How to Get a Token Mint
description:
  "Learn how to retrieve Solana token mint information, including supply,
  authority, and decimals."
---

In order to get the current supply, authority, or decimals a token has, you will
need to get the account info for the token mint.

<CodeTabs storage="cookbook" flags="r">

```ts !! title="Kit"
import { Address, createSolanaRpc } from "@solana/kit";
import { fetchMint } from "@solana-program/token-2022";

const rpc = createSolanaRpc("https://api.mainnet-beta.solana.com");
const address = "2b1kV6DkPAnxd5ixfnxCpjxmKwqjjaYmCZfHsFu24GXo" as Address;

// !mark
const mint = await fetchMint(rpc, address);
console.log(mint);
```

```ts !! title="Legacy"
import { Connection, PublicKey } from "@solana/web3.js";
import { getMint, TOKEN_2022_PROGRAM_ID } from "@solana/spl-token";

const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  "confirmed"
);

const mintAddress = new PublicKey(
  "2b1kV6DkPAnxd5ixfnxCpjxmKwqjjaYmCZfHsFu24GXo"
);

// !mark(1:6)
let mintAccount = await getMint(
  connection,
  mintAddress,
  undefined,
  TOKEN_2022_PROGRAM_ID
);

// !collapse(1:10) collapsed
console.log(
  JSON.stringify(
    {
      ...mintAccount,
      supply: mintAccount.supply.toString()
    },
    null,
    2
  )
);
```

```rs !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::pubkey;
use spl_token_2022_interface::{
    extension::{
        confidential_transfer::ConfidentialTransferMint,
        confidential_transfer_fee::ConfidentialTransferFeeConfig,
        metadata_pointer::MetadataPointer, mint_close_authority::MintCloseAuthority,
        permanent_delegate::PermanentDelegate, transfer_fee::TransferFeeConfig,
        transfer_hook::TransferHook, BaseStateWithExtensions, ExtensionType, StateWithExtensions,
    },
    state::Mint,
};
use spl_token_metadata_interface::state::TokenMetadata;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.mainnet-beta.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let mint_address = pubkey!("2b1kV6DkPAnxd5ixfnxCpjxmKwqjjaYmCZfHsFu24GXo");
    let mint_data = client.get_account_data(&mint_address).await?;
    let mint = StateWithExtensions::<Mint>::unpack(&mint_data)?;

    println!("Mint address: {:#?}", mint_address);
    println!("{:#?}\n", mint.base);

    let extension_types = mint.get_extension_types()?;
    println!("Extensions enabled: {:#?}\n", extension_types);

    extension_types
        .iter()
        .for_each(|extension_type| match extension_type {
            ExtensionType::TransferFeeConfig => {
                if let Ok(ext) = mint.get_extension::<TransferFeeConfig>() {
                    println!("{:#?}\n", ext);
                }
            }
            ExtensionType::MintCloseAuthority => {
                if let Ok(ext) = mint.get_extension::<MintCloseAuthority>() {
                    println!("{:#?}\n", ext);
                }
            }
            ExtensionType::PermanentDelegate => {
                if let Ok(ext) = mint.get_extension::<PermanentDelegate>() {
                    println!("{:#?}\n", ext);
                }
            }
            ExtensionType::ConfidentialTransferMint => {
                if let Ok(ext) = mint.get_extension::<ConfidentialTransferMint>() {
                    println!("{:#?}\n", ext);
                }
            }
            ExtensionType::ConfidentialTransferFeeConfig => {
                if let Ok(ext) = mint.get_extension::<ConfidentialTransferFeeConfig>() {
                    println!("{:#?}\n", ext);
                }
            }
            ExtensionType::TransferHook => {
                if let Ok(ext) = mint.get_extension::<TransferHook>() {
                    println!("{:#?}\n", ext);
                }
            }
            ExtensionType::MetadataPointer => {
                if let Ok(ext) = mint.get_extension::<MetadataPointer>() {
                    println!("{:#?}\n", ext);
                }
            }
            ExtensionType::TokenMetadata => {
                if let Ok(metadata) = mint.get_variable_len_extension::<TokenMetadata>() {
                    println!("{:#?}\n", metadata);
                }
            }
            _ => {
                println!("{:?}: (not handled)\n", extension_type);
            }
        });

    Ok(())
}
```

```py !! title="Python"
#!/usr/bin/env python3
"""
Solana Cookbook - How to Get a Token Mint
"""

import asyncio
from solana.rpc.async_api import AsyncClient
from solders.pubkey import Pubkey
from spl.token._layouts import MINT_LAYOUT
from spl.token.core import MintInfo

async def main():
    rpc = AsyncClient("http://localhost:8899")

    mint_address = Pubkey.from_string("4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU")

    async with rpc:
        # Get account info
        account_info = await rpc.get_account_info(mint_address)

        # Parse mint data using layout
        mint_data = MINT_LAYOUT.parse(account_info.value.data)

        # Create MintInfo object
        mint_info = MintInfo(
            mint_authority=mint_data.mint_authority,
            supply=mint_data.supply,
            decimals=mint_data.decimals,
            is_initialized=mint_data.is_initialized,
            freeze_authority=mint_data.freeze_authority
        )

        print(f"Mint Address: {mint_address}")
        print(f"Decimals: {mint_info.decimals}")
        print(f"Supply: {mint_info.supply}")
        print(f"Is Initialized: {mint_info.is_initialized}")
        print(f"Freeze Authority: {mint_info.freeze_authority}")
        print(f"Mint Authority: {mint_info.mint_authority}")

if __name__ == "__main__":
    asyncio.run(main())
```

</CodeTabs>
