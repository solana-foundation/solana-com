---
date: 2025-01-22T00:00:00Z
difficulty: beginner
title: "Supabase Auth + Solana Deep Guide"
seoTitle: "Supabase Auth + Solana Deep Guide"
description:
  "A comprehensive guide to building Solana applications with wallet authentication
  using Supabase Web3 authentication. Learn how to set up Supabase, connect wallets,
  protect routes, and extend the template for your needs."
tags:
  - auth
  - supabase
  - wallet
  - nextjs
keywords:
  - authentication
  - supabase
  - wallet authentication
  - web3 auth
  - solana wallet
  - next.js
  - protected routes
---

# Supabase Auth + Solana Deep Guide

## Table of Contents

1. [Introduction](#1-introduction)
2. [What You'll Build](#2-what-youll-build)
3. [Why This Matters](#3-why-this-matters)
4. [Architecture Overview](#4-architecture-overview)
5. [Prerequisites](#5-prerequisites)
6. [Setting Up the Project](#6-setting-up-the-project)
   - [Clone the template](#clone-the-template)
   - [Install dependencies](#install-dependencies)
   - [Create your Supabase project](#create-your-supabase-project)
   - [Enable Web3 Authentication in Supabase](#enable-web3-authentication-in-supabase)
   - [Get your Supabase credentials](#get-your-supabase-credentials)
   - [Configure environment variables](#configure-environment-variables)
   - [Run the project](#run-the-project)
7. [Connecting Your Wallet](#7-connecting-your-wallet)
   - [Finding the wallet dropdown](#finding-the-wallet-dropdown)
   - [Connecting your wallet](#connecting-your-wallet)
   - [Verifying the connection](#verifying-the-connection)
   - [Understanding the network](#understanding-the-network)
   - [Requesting an airdrop (Devnet)](#requesting-an-airdrop-devnet)
   - [Disconnecting your wallet](#disconnecting-your-wallet)
   - [Common connection issues](#common-connection-issues)
8. [Signing In with Solana (Supabase Web3 Auth)](#8-signing-in-with-solana-supabase-web3-auth)
   - [Finding the sign-in card](#finding-the-sign-in-card)
   - [The authentication flow](#the-authentication-flow)
   - [Verifying authentication](#verifying-authentication)
   - [Session persistence](#session-persistence)
   - [Accessing protected routes](#accessing-protected-routes)
   - [Signing out](#signing-out)
   - [Common authentication errors](#common-authentication-errors)
   - [Understanding the authentication state](#understanding-the-authentication-state)
9. [Exploring Protected Routes](#9-exploring-protected-routes)
   - [Understanding the ProtectedRoute component](#understanding-the-protectedroute-component)
   - [The /account route](#the-account-route)
   - [The account page flow](#the-account-page-flow)
   - [What you'll see on the account page](#what-youll-see-on-the-account-page)
   - [Testing protected routes](#testing-protected-routes)
   - [Creating your own protected routes](#creating-your-own-protected-routes)
   - [Understanding the loading state](#understanding-the-loading-state)
   - [Common issues with protected routes](#common-issues-with-protected-routes)
   - [Why this pattern works](#why-this-pattern-works)
10. [Under the Hood (Deep Explanation)](#10-under-the-hood-deep-explanation)
    - [Environment Variable Validation with Zod](#environment-variable-validation-with-zod)
    - [Supabase Client Initialization](#supabase-client-initialization)
    - [Auth State Management with React Context](#auth-state-management-with-react-context)
    - [Session Storage and Persistence](#session-storage-and-persistence)
    - [Wallet Connection State Management](#wallet-connection-state-management)
    - [The Authentication Flow (Step by Step)](#the-authentication-flow-step-by-step)
    - [Provider Hierarchy and Order](#provider-hierarchy-and-order)
    - [How Protected Routes Work Internally](#how-protected-routes-work-internally)
    - [Error Handling and Edge Cases](#error-handling-and-edge-cases)
    - [Why This Architecture Works](#why-this-architecture-works)
11. [Extending the Template](#11-extending-the-template)
    - [Adding New Routes](#adding-new-routes)
    - [Creating Protected Routes](#creating-protected-routes)
    - [Adding Custom Hooks](#adding-custom-hooks)
    - [Extending the Auth Flow](#extending-the-auth-flow)
    - [Adding Features with Feature Folders](#adding-features-with-feature-folders)
    - [Working with Supabase Database](#working-with-supabase-database)
    - [Adding Environment Variables](#adding-environment-variables)
    - [Customizing the UI](#customizing-the-ui)
    - [Adding Mainnet Support](#adding-mainnet-support)
    - [Extending the useSolana Hook](#extending-the-usesolana-hook)
    - [Best Practices for Extension](#best-practices-for-extension)
12. [Troubleshooting](#12-troubleshooting)
13. [Best Practices](#13-best-practices)
    - [Environment Variables](#environment-variables)
    - [Security](#security)
    - [Code Organization](#code-organization)
    - [Testing](#testing)
    - [Deployment](#deployment)
    - [Error Handling](#error-handling)
    - [Performance](#performance)
    - [Type Safety](#type-safety)
    - [Wallet Integration](#wallet-integration)
    - [Supabase Integration](#supabase-integration)
    - [Code Maintenance](#code-maintenance)
    - [Common Mistakes to Avoid](#common-mistakes-to-avoid)
14. [Conclusion](#14-conclusion)

---

## 1. Introduction

This guide shows you how to build a [Solana](https://solana.org) app with wallet authentication using [Supabase](https://supabase.com). Users sign in with their Phantom or Solflare wallet. No email. No passwords. Just a wallet signature.

Traditional auth means managing user accounts, password resets, and email verification. With Solana wallet auth, users prove they control a wallet address. That's it. It's simpler for them. It's simpler for you.

The template uses Supabase's Web3 authentication. Supabase handles the cryptographic verification. You get a managed [PostgreSQL](https://www.postgresql.org/) database, session management, and protected routes. No local database setup. Everything runs through Supabase's hosted services.

This guide is based directly on the code in this repository. Every code snippet comes from the actual implementation. Every file path is real. If you see something here, you can find it in the codebase.

What you'll learn:

- How to set up Supabase Web3 authentication for Solana wallets
- How wallet connection works separately from Supabase authentication
- How to protect routes so only authenticated users can access them
- How environment variable validation works with [Zod](https://zod.dev)
- How the authentication flow works under the hood

By the end, you'll understand why each piece exists. You'll know how to extend it for your own needs. If you see an error message you don't recognize, don't stress. We'll cover the common ones and how to fix them.

## 2. What You'll Build

After following this guide, you'll have a working [Next.js](https://nextjs.org) app. Here's what it includes:

**Home Page (`/`)**

You'll see a dashboard with a "gm" greeting. The header has a wallet connection dropdown. It supports Phantom, Solflare, and other Solana wallets. After connecting, a "Sign in with Solana" card appears. There are also links to Solana docs and resources.

**Protected Account Page (`/account`)**

This route requires authentication. Unauthenticated users get redirected to the home page. Once authenticated, you'll see account details, balance, tokens, and transaction history. There's dynamic routing to `/account/[address]` for viewing specific wallet addresses.

**Authentication System**

Wallet connection happens via the Wallet UI library. This is separate from Supabase auth. Supabase Web3 authentication verifies wallet ownership. Sessions persist across page refreshes. Sign out clears both the Supabase session and wallet connection.

**Developer Experience Features**

The template includes several developer-friendly features:

- Environment variable validation with [Zod](https://zod.dev) - fails fast with clear errors if config is missing
- [TypeScript](https://www.typescriptlang.org/) throughout for type safety
- [TanStack Query](https://tanstack.com/query) for API state management and caching
- [Tailwind CSS](https://tailwindcss.com) and [Shadcn UI](https://ui.shadcn.com) for styling
- Protected route component you can wrap around any page

**Technical Stack**

- Next.js 15 with App Router
- Supabase client for authentication and database operations
- Wallet UI React components for Solana wallet interactions
- Gill SDK for Solana operations
- Devnet support for testing (with airdrop functionality)

The template structure is production-ready. You'll want to customize the UI and add your own features. When you're ready to deploy, configure it for mainnet. Everything is set up so you can focus on building your application logic. You won't spend time wiring up authentication.

## 3. Why This Matters

You could build your own Solana authentication system. You'd need to handle message signing, signature verification, session management, and database storage. You'd spend weeks on infrastructure instead of features.

This template uses Supabase's Web3 authentication. Supabase handles the cryptographic verification. You don't write signature verification code. You don't manage session tokens. You don't set up a database. You just call `supabase.auth.signInWithWeb3()` and it works.

**Wallet-based auth benefits**

Traditional auth requires users to create accounts. They need to remember passwords. You need to handle password resets, email verification, and OAuth providers. It's a lot of moving parts.

With Solana wallet auth, users already have their identity. Their wallet is their account. They sign a message to prove ownership. No passwords. No email verification. No account creation flow. It's one click.

**What Supabase provides**

You could use Supabase for just authentication. But you also get:

- A managed PostgreSQL database
- Real-time subscriptions
- Row-level security
- All from one service
- All with one client library

The template shows you how to use it. The `AuthProvider` component manages sessions. The `ProtectedRoute` component guards pages. The `wallet-login.tsx` component handles the auth flow. It's all there. You don't have to figure it out from scratch.

**Template benefits**

The code is production-ready with several built-in advantages:

- Environment variables validated with Zod - clear errors at startup if something is missing
- TypeScript catches type errors before runtime
- TanStack Query handles API state automatically
- Protected routes redirect unauthenticated users automatically

You'll spend less time debugging auth issues. You'll spend more time building features. If you hit a 422 error during sign-in, don't stress. It usually means Web3 auth isn't enabled in your Supabase project. We'll cover how to fix that.

## 4. Architecture Overview

The template uses a layered architecture. Each layer has a specific job. Understanding the layers helps you debug issues and extend the app.

**Provider Hierarchy**

Everything starts in `src/app/layout.tsx`. This is the root layout. It wraps your app with providers. The order matters.

```tsx
<AppProviders>
  <AppLayout links={links}>{children}</AppLayout>
</AppProviders>
```

`AppProviders` (`src/components/app-providers.tsx`) sets up the provider stack:

1. `ReactQueryProvider` - Handles API state and caching
2. `ThemeProvider` - Manages dark/light mode
3. `AuthProvider` - Manages Supabase authentication state
4. `SolanaProvider` - Manages wallet connection state

The `AuthProvider` wraps the `SolanaProvider`. This means authentication state is available to wallet components. Use `useAuth` for authentication state, `useSolana` for wallet state.

**Environment Validation**

Before anything runs, the app validates environment variables. This happens in `src/app/layout.tsx` when it imports `env` from `@/env`.

The `src/env.ts` file uses Zod to validate. It checks that `NEXT_PUBLIC_SUPABASE_URL` is a valid URL. It checks that `NEXT_PUBLIC_SUPABASE_ANON_KEY` exists. If validation fails, the app throws an error at startup.

If you see "Invalid environment variables" in your terminal, don't panic. It means your `.env.local` file is missing a key or has an invalid URL. Check the error message. It tells you exactly what's wrong.

**Supabase Client**

The Supabase client is created in `src/lib/supabase.ts`. It's simple:

```tsx
import { createClient } from '@supabase/supabase-js'
import { env } from '@/env'

export const supabase = createClient(
  env.NEXT_PUBLIC_SUPABASE_URL,
  env.NEXT_PUBLIC_SUPABASE_ANON_KEY
)
```

This client is used throughout the app. The `AuthProvider` uses it to check sessions. The `wallet-login.tsx` component uses it to sign in. Any component can import it and use it.

**Wallet Connection Flow**

Wallet connection happens separately from authentication. The `SolanaProvider` (`src/components/solana/solana-provider.tsx`) uses the Wallet UI library. It sets up Devnet and Localnet clusters. It provides wallet connection state to the app.

When a user clicks "Connect Wallet" in the header, the Wallet UI library handles it. It detects installed wallets. It prompts the user to connect. Once connected, `window.solana` is available. The `useSolana` hook exposes the connection state.

**Authentication Flow**

Authentication happens in `src/components/auth/wallet-login.tsx`. The flow is:

1. User connects wallet (handled by Wallet UI)
2. User clicks "Sign in with Solana"
3. Component calls `supabase.auth.signInWithWeb3()`
4. Supabase prompts wallet to sign a message
5. User approves signature in wallet
6. Supabase verifies signature and creates session
7. `AuthProvider` detects session change via `onAuthStateChange`
8. UI updates to show authenticated state

The `AuthProvider` (`src/components/auth/auth-provider.tsx`) listens for auth state changes. It calls `supabase.auth.getSession()` on mount. It subscribes to `onAuthStateChange`. When the session changes, it updates the context. Any component using `useAuth` gets the new state.

**Protected Routes**

Protected routes use the `ProtectedRoute` component (`src/components/auth/protected-route.tsx`). It checks if a user is authenticated. If not, it redirects to home.

The `/account` page (`src/app/account/page.tsx`) wraps its content:

```tsx
<ProtectedRoute>
  <AccountFeatureIndex />
</ProtectedRoute>
```

The `ProtectedRoute` component uses `useAuth` to check authentication. If `loading` is true, it shows a loading state. If `user` is null, it redirects. If authenticated, it renders the children.

**Separation of Concerns**

Wallet connection and authentication are separate. This is intentional. You might want to read wallet balances without authenticating. You might want to show wallet info in the header without requiring sign-in.

The `useSolana` hook gives you wallet connection state. The `useAuth` hook gives you authentication state. They're independent. Understanding this helps you build better UX.

If you're confused about why wallet connection doesn't automatically authenticate, don't stress. They're separate by design. Wallet connection is about reading blockchain data. Authentication is about creating a Supabase session. You need both for a full app, but they serve different purposes.

## 5. Prerequisites

Before you start, make sure you have these installed. If you're missing something, the app won't run. Don't worry, we'll check each one.

**Node.js 18 or higher**

The template uses Next.js 15.5.6. It requires Node.js 18 or higher. Check your version:

```bash
node --version
```

If you see v18.x.x or higher, you're good. If not, install [Node.js](https://nodejs.org) from nodejs.org. Use the LTS version. It's the most stable.

Next.js runs on Node.js. It handles server-side rendering, API routes, and the build process. Without it, `npm install` won't work.

**A Supabase account**

You need a Supabase account to use Web3 authentication. The free tier works fine for development. Sign up at [supabase.com](https://supabase.com). It takes about two minutes.

The template uses Supabase's Web3 authentication feature. You'll create a project and get credentials. Those credentials go in your `.env.local` file. Without them, authentication won't work.

You'll need two things from your Supabase project:

- Project URL (looks like `https://xxxxx.supabase.co`)
- Anon key (the public key, not the service role key)

You can find both in your Supabase dashboard under Settings → API. Don't stress if you don't have them yet. We'll get them during setup.

**A Solana wallet extension**

You need a Solana wallet installed in your browser. Phantom, Solflare, or Backpack all work. Install one from their official websites. Make sure it's the browser extension, not a mobile app.

Users sign in with their wallet. The template detects `window.solana` to connect. Without a wallet extension, the "Connect Wallet" button won't work. You can't test authentication without it.

**Git**

You need Git to clone the repository. Check if you have it:

```bash
git --version
```

If you see a version number, you're good. If not, install Git from [git-scm.com](https://git-scm.com).

The template is in a Git repository. You'll clone it to get the code locally. You don't need to know advanced Git. Just `git clone` is enough.

**Optional: A code editor**

Use VS Code, Cursor, or any editor you prefer. The template uses TypeScript, so an editor with [TypeScript](https://www.typescriptlang.org/) support helps. But it's not required. You can use any text editor.

That's it. If you have Node.js 18+, a Supabase account, a Solana wallet, and Git, you're ready. If you're missing something, install it now. We'll wait.

## 6. Setting Up the Project

Follow these steps in order. If you skip a step, something will break. Don't worry, we'll check each step as we go.

### Clone the template

First, clone the repository:

```bash
git clone https://github.com/solana-foundation/templates.git
cd templates/community/supabase-auth
```

This gets the template code on your machine. The `cd` command moves you into the project directory. You need to be in this directory for all the commands below.

If you see "command not found" for `git`, you don't have Git installed. Go back to the Prerequisites section and install it.

### Install dependencies

Next, install all the packages:

```bash
npm install
```

This reads `package.json` and installs everything listed. It installs Next.js, Supabase client, wallet libraries, and all other dependencies. It might take a minute or two.

You should see output like:

```text
added 500+ packages, and audited 501 packages in 30s
```

If you see errors, check that you're using Node.js 18 or higher. Run `node --version` to confirm. If you see permission errors, don't stress. Try running with `sudo` (on Mac/Linux) or run your terminal as administrator (on Windows).

### Create your Supabase project

You need a Supabase project before you can authenticate. Here's how to create one:

1. Go to [supabase.com](https://supabase.com) and sign in
2. Click "New Project"
3. Fill in your project details:
   - Name it something memorable (like "solana-auth-test")
   - Set a database password (save this somewhere safe)
   - Choose a region close to you
4. Wait for the project to finish provisioning (about 2 minutes)

Once your project is ready, you'll see the project dashboard. Don't close this tab. You'll need it for the next steps.

Supabase needs a project to store user sessions and handle authentication. Each project has its own database and API keys. The free tier gives you everything you need for development.

### Enable Web3 Authentication in Supabase

This step is critical. Without it, authentication will fail with a 422 error. Don't skip this.

1. In your Supabase dashboard, go to **Authentication** → **Providers**
2. Scroll down to find **Web3** (it may be under "Additional Providers" or "Additional")
3. Toggle **Web3** to enabled
4. Save the changes

![Supabase Web3 authentication toggle enabled](https://res.cloudinary.com/resourcefulmind-inc/image/upload/v1763204891/Screenshot_2025-11-15_at_8.06.58_AM_tnivte.png)

If you don't see Web3 as an option, your Supabase project might not support it yet. Web3 authentication is still in beta for some projects. Try creating a new project or check the Supabase documentation for the latest status.

The template uses `supabase.auth.signInWithWeb3()`. This method only works if Web3 authentication is enabled in your project. If it's disabled, you'll get a 422 error when trying to sign in. The error message will say "Web3 provider is disabled". If you see that, come back to this step.

### Get your Supabase credentials

You need two values from your Supabase project:

1. In your Supabase dashboard, go to **Settings** → **API**
2. Copy your **Project URL** (looks like `https://xxxxx.supabase.co`)
3. Copy your **anon/public key** (the `anon` key, not the `service_role` key)

Keep these handy. You'll paste them into a file in the next step.

The Project URL tells the Supabase client where to connect. The anon key is the public key that allows client-side access. The service role key is more powerful and should never be used in client-side code. That's why we use the anon key.

### Configure environment variables

Create a `.env.local` file from the example:

```bash
cp .env.example .env.local
```

Open `.env.local` in your editor. You'll see:

```env
NEXT_PUBLIC_SUPABASE_URL="https://your-project.supabase.co"
NEXT_PUBLIC_SUPABASE_ANON_KEY="your-anon-key-here"
```

Replace the placeholder values with your actual Supabase credentials:

```env
NEXT_PUBLIC_SUPABASE_URL="https://xxxxx.supabase.co"
NEXT_PUBLIC_SUPABASE_ANON_KEY="your-actual-anon-key-here"
```

Make sure the URL is in quotes. Make sure the key is in quotes. Don't add any extra spaces.

Next.js automatically loads `.env.local`. It ignores it in git, so your secrets stay local. Never commit `.env.local` to version control. The `.env.example` file is safe to commit because it has placeholder values.

The template uses Zod to validate these environment variables at build time. (See [Environment Variable Validation with Zod](#environment-variable-validation-with-zod) for details.) If you see an "Invalid environment variables" error when you start the dev server, don't panic. It means your `.env.local` file is missing a key or has an invalid URL format. Check that both keys are set and the URL starts with `https://`.

### Run the project

Start the development server:

```bash
npm run dev
```

This starts Next.js with Turbopack (faster than the default webpack). You should see output like:

```text
▲ Next.js 15.5.6
- Local:        http://localhost:3000
```

Open [http://localhost:3000](http://localhost:3000) in your browser. You should see a "gm" screen with a dashboard. That's how you know it's working.

If you see "Invalid environment variables" in your terminal, check your `.env.local` file. Make sure both keys are set correctly. If you see "Port 3000 is already in use", something else is running on that port. Kill that process or change the port with `npm run dev -- -p 3001`.

If the page loads but shows errors in the browser console, don't stress. We'll cover common errors in the Troubleshooting section. For now, if you see the "gm" screen, you're good to go.

## 7. Connecting Your Wallet

Wallet connection happens before authentication. You connect your wallet to read blockchain data. Then you authenticate with Supabase to create a session. They're separate steps.

**Separation of concerns** - You might want to show wallet balances without requiring sign-in. You might want to let users browse before they authenticate. The template gives you that flexibility.

### Finding the wallet dropdown

Look at the header of the page. You'll see a button that says "Select Wallet" or "Connect Wallet". That's the wallet dropdown. It's in `src/components/wallet-dropdown.tsx`.

![Wallet dropdown in the header](https://res.cloudinary.com/resourcefulmind-inc/image/upload/v1763205080/Screenshot_2025-11-15_at_8.11.08_AM_dyci3x.png)

If you don't see it, check that your wallet extension is installed. The Wallet UI library detects installed wallets automatically. If no wallets are detected, the dropdown shows a link to get a Solana wallet.

### Connecting your wallet

Click the "Select Wallet" button. A dropdown menu appears. It lists all detected wallets. You'll see options like:

- Phantom
- Solflare
- Backpack
- Other installed wallets

Click on your wallet. Your wallet extension will open a popup. It asks you to approve the connection. Click "Approve" or "Connect" in the popup.

Once connected, the button in the header changes. It shows your wallet address truncated (like `J4AJ...MAAP`). That's how you know it's connected.

![Connected wallet showing truncated address](https://res.cloudinary.com/resourcefulmind-inc/image/upload/v1763205189/Screenshot_2025-11-15_at_8.12.57_AM_afhpjb.png)

**What happens behind the scenes:** The Wallet UI library handles the connection internally. When you click a wallet in the dropdown, the library manages calling `window.solana.connect()` behind the scenes. You don't need to call it directly. The library manages the connection state. The `useSolana` hook exposes it to your components.

### Verifying the connection

After connecting, check the header. The button should show your wallet address. If you see "Select Wallet" still, the connection didn't work. Try clicking it again.

You can also check the browser console. Open DevTools (F12) and look for errors. If you see "wallet not found" or similar, your wallet extension might not be enabled. Make sure it's installed and active in your browser.

### Understanding the network

The template connects to Solana Devnet by default. Devnet is a test network. It has free test tokens. You can see the network in the header next to the wallet button. It should say "Devnet" or "Localnet".

Devnet is safe for testing. You can request airdrops without spending real money. Transactions are fast and free. When you're ready for production, you'll switch to Mainnet.

The network configuration is in `src/components/solana/solana-provider.tsx`. It sets up Devnet and Localnet clusters. You can add Mainnet later if you want.

### Requesting an airdrop (Devnet)

If you see a yellow banner saying "You are connected to Devnet but your account is not found on this cluster," your wallet has no SOL on Devnet. You can request an airdrop to get test tokens.

Click the **Request Airdrop** button in the banner. Wait a few seconds. The transaction confirms on Devnet. You'll get test SOL in your wallet.

**Important:** Devnet has rate limits. If you see a 429 error (Too Many Requests), you've hit the rate limit. Don't stress. Wait a few minutes and try again. Or use a different Devnet RPC endpoint if you need more airdrops.

The airdrop gives you test SOL. You can use it to test transactions. This step is optional. You only need it if you want to test sending SOL or interacting with programs.

### Disconnecting your wallet

To disconnect, click the wallet button in the header. You'll see a dropdown menu. Click "Disconnect" or "Sign Out & Disconnect" (if you're authenticated).

Disconnecting clears the wallet connection. It doesn't sign you out of Supabase. If you're authenticated, you'll stay signed in. If you want to sign out completely, use the "Sign Out" button in the authentication card.

### Common connection issues

- **Empty wallet dropdown** - No wallets detected. Install a Solana wallet extension (Phantom, Solflare, or Backpack) from their official websites.
- **Clicking wallet does nothing** - Check the browser console for errors. Make sure the extension is enabled in your browser settings.
- **Address doesn't show** - The Wallet UI library might still be initializing. Refresh the page and try again.
- **"Wallet not found" errors** - Your wallet extension might not be injecting `window.solana`. Check that the extension is active. Some browsers require you to enable extensions manually.

## 8. Signing In with Solana (Supabase Web3 Auth)

Once your wallet is connected, you can authenticate with Supabase. This creates a session that persists across page refreshes. You'll be able to access protected routes.

Authentication creates a Supabase session that lets you access protected routes and store user data. Without authentication, you can't access `/account` or other protected pages.

### Finding the sign-in card

Scroll down on the home page. You'll see a card titled "Sign in with Solana". It's in the dashboard section. The component is `src/components/auth/wallet-login.tsx`.

If you haven't connected your wallet yet, the card shows "Connect Wallet First" and the button is disabled. Connect your wallet first, then come back to this card.

![Sign in with Solana card](https://res.cloudinary.com/resourcefulmind-inc/image/upload/v1763205326/Screenshot_2025-11-15_at_8.15.12_AM_crhf6r.png)

### The authentication flow

Once your wallet is connected, the card shows "Wallet Connected: [your address]" in green text. Click the **Sign in with Solana** button.

Your wallet extension will open a popup. It asks you to sign a message. The message says "Please sign this message to authenticate with your wallet." This is the authentication challenge.

Click "Approve" or "Sign" in your wallet popup. The wallet signs the message cryptographically. This proves you control the wallet address.

**What happens behind the scenes:** The app calls `supabase.auth.signInWithWeb3()` with `chain: 'solana'`. Supabase generates a message for your wallet to sign. Your wallet signs it. Supabase verifies the signature matches your wallet address. If it matches, Supabase creates a session and stores it in localStorage.

The code is in `src/components/auth/wallet-login.tsx`. The `handleWalletAuth` function does the work:

```tsx
const { data, error } = await supabase.auth.signInWithWeb3({
  chain: 'solana',
  statement: 'Please sign this message to authenticate with your wallet.',
})
```
![Wallet popup asking to sign authentication message](https://res.cloudinary.com/resourcefulmind-inc/image/upload/v1763205749/Screenshot_2025-11-15_at_8.18.19_AM_dqjptf.png)

If authentication succeeds, you'll see "Wallet authenticated successfully!" in green text. The card updates automatically to show a welcome message with your wallet address and buttons to view account details or sign out. The UI updates via the `AuthProvider` state changes - no manual navigation is needed.

### Verifying authentication

After signing in, check the card. It should show "Welcome Back!" with your wallet address. You'll see two buttons: "View Account Details" and "Sign Out".

You can also check the browser console. Open DevTools (F12) and look for the Supabase session. You should see session data in localStorage under keys starting with `sb-`.

The `AuthProvider` component (`src/components/auth/auth-provider.tsx`) listens for auth state changes. It calls `supabase.auth.getSession()` on mount. It subscribes to `onAuthStateChange`. When you sign in, it updates the context. Any component using `useAuth` gets the new state.

### Session persistence

The session persists across page refreshes. Supabase stores it in localStorage. When you refresh the page, the `AuthProvider` checks for an existing session. If one exists, you stay signed in.

Users don't have to sign in every time they visit. The session lasts until they sign out or it expires. This is standard behavior for web apps.

### Accessing protected routes

Once authenticated, you can access protected routes. Try clicking "View Account Details" in the welcome card. It takes you to `/account`. Or navigate to `/account` directly in your browser.

If you're not authenticated and try to access `/account`, the `ProtectedRoute` component redirects you to the home page. It checks `useAuth()` for the user. If `user` is null, it redirects.

The protected route logic is in `src/components/auth/protected-route.tsx`. It wraps the `/account` page content. You can use it to protect any route you want.

### Signing out

To sign out, click the "Sign Out" button in the welcome card. This calls `handleSignOutAndDisconnect` which uses the `useCombinedSignOut` hook.

The hook does two things:

1. Signs out from Supabase (clears the session)
2. Disconnects the wallet (clears the wallet connection)

You might want to sign out but keep your wallet connected. Or you might want to disconnect but stay signed in. The combined sign out does both for a clean slate.

The sign out code is in `src/hooks/use-combined-signout.ts`. It calls `supabase.auth.signOut()` first, then disconnects the wallet. It also clears Supabase-related localStorage keys.

### Common authentication errors

**"Authentication failed: Web3 provider is disabled"**

This means Web3 authentication isn't enabled in your Supabase project. Don't stress. Go back to your Supabase dashboard. Navigate to **Authentication** → **Providers**. Find **Web3** and toggle it to enabled. Save the changes. Then try signing in again.

**"Authentication failed: [422 error]"**

A 422 error usually means one of these:

- Web3 authentication isn't enabled (see above)
- Your Supabase project doesn't support Web3 auth (check if you're on a supported plan)
- The `window.solana` provider isn't properly connected

If you see a 422 error, check the browser console. You might see more details about what went wrong. The error message from Supabase usually tells you what's missing.

**"Solana wallet not detected"**

This means `window.solana` is not available. Make sure you have a Solana wallet extension installed and enabled. Make sure you've connected your wallet before trying to authenticate. The wallet connection must happen first.

**"Please connect a wallet first"**

This message appears if you try to sign in without connecting your wallet. Connect your wallet using the dropdown in the header first. Then come back to the sign-in card.

**"Failed to authenticate with wallet. Please try again."**

This is a generic error. Check the browser console for more details. It might be a network issue or a problem with the Supabase connection. Make sure your `.env.local` file has the correct Supabase credentials.

### Understanding the authentication state

The `useAuth` hook gives you access to authentication state:

- `user` - The authenticated user object (null if not authenticated)
- `session` - The Supabase session object (null if not authenticated)
- `loading` - Boolean indicating if auth state is being checked
- `signOut` - Function to sign out

You can use this hook in any component to check authentication status. The `AuthProvider` wraps your app and provides this context.

## 9. Exploring Protected Routes

Protected routes require authentication. Unauthenticated users can't access them. The template includes a `ProtectedRoute` component that handles this. (See [Architecture Overview](#4-architecture-overview) for how it works.)

### Understanding the ProtectedRoute component

The `ProtectedRoute` component is in `src/components/auth/protected-route.tsx`. It wraps any content you want to protect. It checks authentication status and handles redirects.

Here's how it works:

1. It uses the `useAuth` hook to get the current user
2. If `loading` is true, it shows a loading spinner
3. If `user` is null (not authenticated), it redirects to home
4. If authenticated, it renders the children

The component uses `router.replace('/')` to redirect. This replaces the current URL in history. Users can't go back to the protected page after being redirected.

### The /account route

The `/account` route is protected. The page file is `src/app/account/page.tsx`. It wraps the account content with `ProtectedRoute`:

```tsx
<ProtectedRoute>
  <AccountFeatureIndex />
</ProtectedRoute>
```

If you're not authenticated and try to visit `/account`, you'll be redirected to the home page. The redirect happens automatically. You'll see a brief loading state, then the redirect.

Redirecting is better UX than showing an error. Users know they need to sign in. They're taken to a place where they can sign in. The redirect is instant, so it doesn't feel broken.

### The account page flow

The account page has two parts:

1. **Index page** (`/account`) - Redirects to the detail page if a wallet is connected
2. **Detail page** (`/account/[address]`) - Shows account details for a specific address

Both routes are protected. The `/account/[address]` route (`src/app/account/[address]/page.tsx`) is also wrapped with `ProtectedRoute`. You can navigate directly to `/account/[address]` if you know the address, but you must be authenticated first.

The index page (`src/features/account/account-feature-index.tsx`) checks if a wallet is connected. If `account` exists, it redirects to `/account/[address]`. If not, it shows a wallet dropdown so you can connect.

This flow ensures you always see account details for a connected wallet. If you're authenticated but don't have a wallet connected, you can still connect one.

### What you'll see on the account page

Once authenticated and on `/account/[address]`, you'll see:

- **Account balance** - Shows SOL balance for the address
- **Account buttons** - Actions like send, receive, request airdrop
- **Token list** - Shows SPL tokens held by the address
- **Transaction history** - Shows recent transactions for the address

![Account page showing balance, tokens, and transactions](https://res.cloudinary.com/resourcefulmind-inc/image/upload/v1763205913/Screenshot_2025-11-15_at_8.24.57_AM_cfgmwf.png)

The page uses TanStack Query to fetch data. It caches responses for better performance. If you refresh, it might show cached data while fetching fresh data.

The account detail component is in `src/features/account/account-feature-detail.tsx`. It extracts the address from the URL params. It validates the address using Gill's `assertIsAddress`. If the address is invalid, it shows an error.

### Testing protected routes

To test the protection, try this:

1. Sign out (if you're signed in)
2. Try to navigate to `/account` directly in your browser
3. You should be redirected to the home page

You can also check the browser console. You'll see a log message: "Protected route: User not authenticated, redirecting to home". This confirms the protection is working.

If you're authenticated and visit `/account`, you'll see the account page. The `ProtectedRoute` component checks authentication and renders the content.

### Creating your own protected routes

You can protect any route by wrapping it with `ProtectedRoute`. For example, to protect a `/dashboard` route:

```tsx
// src/app/dashboard/page.tsx
import { ProtectedRoute } from '@/components/auth/protected-route'

export default function DashboardPage() {
  return (
    <ProtectedRoute>
      <div>Your protected content here</div>
    </ProtectedRoute>
  )
}
```

The component handles all the authentication checks. You don't need to write redirect logic yourself.

You can also provide a custom fallback:

```tsx
<ProtectedRoute
  fallback={
    <div>Custom "please sign in" message</div>
  }
>
  <YourContent />
</ProtectedRoute>
```

The fallback renders instead of the default "Authentication Required" card. Use this if you want custom messaging or styling.

### Understanding the loading state

The `ProtectedRoute` component shows a loading state while checking authentication. This happens on the first render. The `AuthProvider` calls `supabase.auth.getSession()` on mount. Until that completes, `loading` is true.

Without a loading state, unauthenticated users might briefly see protected content. The loading state prevents that flash. It's a better UX.

The loading state is a spinner in a card. It says "Loading..." and "Checking authentication status". It's centered on the screen. Once authentication is checked, it either redirects or shows the content.

### Common issues with protected routes

**Redirect loop**

If you see a redirect loop, check that your home page doesn't redirect to a protected route. The home page should be accessible without authentication. If it's protected, you'll get stuck in a loop.

**Loading state never ends**

If the loading spinner never goes away, check the browser console. You might see an error from Supabase. Make sure your `.env.local` file has the correct Supabase credentials. The `AuthProvider` can't check sessions without valid credentials.

**Can't access protected route even when authenticated**

If you're signed in but still get redirected, check the browser console. You might see an error about the session. Try signing out and signing back in. The session might be invalid or expired.

**Protected route shows content but user is null**

This shouldn't happen, but if it does, there's a race condition. The `ProtectedRoute` checks `user` from `useAuth`. If the auth state updates after the check, you might see content briefly. This is rare, but if you see it, refresh the page.

### Why this pattern works

The `ProtectedRoute` pattern is simple and reusable. Wrap any content you want to protect. The component handles all the logic. It works with Next.js App Router as a client component that can use hooks. For larger apps, you might want middleware, but for most cases, this component is enough.

## 10. Under the Hood (Deep Explanation)

This section explains how everything works internally. Understanding the internals helps you debug issues and extend the template.

If you hit an error you don't understand, this section explains what's happening. If you want to customize the auth flow, this shows you where to look. If you're curious about how it all fits together, this is for you.

### Environment Variable Validation with Zod

The template validates environment variables at startup. This happens in `src/env.ts`. It uses Zod to define schemas and validate values.

Here's how it works:

```tsx
const client = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
})
```

The `client` schema validates client-side environment variables. It checks that `NEXT_PUBLIC_SUPABASE_URL` is a valid URL. It checks that `NEXT_PUBLIC_SUPABASE_ANON_KEY` exists and isn't empty.

If your environment variables are wrong, the app will fail later. Better to fail fast with a clear error. The validation happens when `src/app/layout.tsx` imports `env` from `@/env`. If validation fails, the app won't start.

The validation uses `safeParse` instead of `parse`. This means it doesn't throw. It returns a result object. If validation fails, it logs the error and throws a generic error. The error message includes formatted details about what's wrong.

The code wraps the validated environment in a Proxy. This prevents accessing server-side variables on the client. If you try to access `DATABASE_URL` on the client, it throws a descriptive error. Without the Proxy, it would just return `undefined`, which is harder to debug.

The Proxy checks if you're on the server (`typeof window === 'undefined'`). On the client, it only allows variables starting with `NEXT_PUBLIC_`. This is a [Next.js](https://nextjs.org) convention. Client-side code can only access public environment variables.

### Supabase Client Initialization

The Supabase client is created in `src/lib/supabase.ts`. It's simple:

```tsx
export const supabase = createClient(
  env.NEXT_PUBLIC_SUPABASE_URL,
  env.NEXT_PUBLIC_SUPABASE_ANON_KEY
)
```

The client is created once and exported. Any component that imports it gets the same instance. This is important for session management. Supabase stores the session in the client. If you create multiple clients, they won't share sessions.

The client uses the anon key, not the service role key. The anon key is safe for client-side use. It has limited permissions. The service role key has full access and should never be used in client code.

The Supabase client handles HTTP requests to your Supabase project. It manages authentication tokens. It stores sessions in localStorage (on the client). When you call `supabase.auth.signInWithWeb3()`, it makes a request to Supabase's auth endpoint. Supabase verifies the signature and returns a session.

### Auth State Management with React Context

The `AuthProvider` component manages authentication state. It's in `src/components/auth/auth-provider.tsx`. It uses [React](https://react.dev) Context to share state across components.

Here's the flow:

1. **Initial state** - `loading: true`, `user: null`, `session: null`
2. **Get initial session** - Calls `supabase.auth.getSession()` on mount
3. **Subscribe to changes** - Calls `supabase.auth.onAuthStateChange()` to listen for updates
4. **Update state** - When session changes, updates `user` and `session` state
5. **Set loading false** - Once initial check is done, sets `loading: false`

Any component can access auth state with `useAuth()`. You don't need to pass props down. The context is provided at the root level, so it's available everywhere.

When the page loads, there might be an existing session in localStorage. The `getSession()` call checks for it. If a session exists, the user is authenticated. If not, they're not.

When you sign in or sign out, the session changes. The subscription fires an event. The provider updates its state. All components using `useAuth()` get the new state automatically.

The subscription is cleaned up when the component unmounts. This prevents memory leaks. The `useEffect` returns a cleanup function that unsubscribes.

### Session Storage and Persistence

Supabase stores sessions in localStorage. The keys start with `sb-` followed by your project reference. You can see them in DevTools under Application → Local Storage.

localStorage persists across page refreshes. When you refresh, the session is still there. The `AuthProvider` checks for it on mount. If it exists, you stay signed in.

The `signOut` function in `AuthProvider` does two things:

1. Calls `supabase.auth.signOut()` - This clears the session on Supabase's side
2. Clears localStorage keys - This removes the session from the browser

The code loops through all localStorage keys. It removes any that start with `sb-` or contain `supabase`. This ensures a clean sign out.

Sometimes `supabase.auth.signOut()` might fail. If it does, the localStorage keys might still be there. The manual cleanup ensures they're removed. It's a safety net.

### Wallet Connection State Management

Wallet connection is managed by the Wallet UI library. The `SolanaProvider` wraps your app with `WalletUi` and `WalletUiGillProvider`. These provide wallet connection state through hooks.

The Wallet UI library detects installed wallet extensions. It provides hooks like `useWalletUi()` that give you connection state. The `useSolana` hook wraps these and adds the Gill client.

Wallet connection and authentication are different concerns. Wallet connection is about reading blockchain data. Authentication is about creating a Supabase session. They can be independent.

The wallet connection state is managed by the Wallet UI library. You don't need to manage it yourself. The library handles detecting wallets, connecting, and disconnecting.

### The Authentication Flow (Step by Step)

When you click "Sign in with Solana", here's what happens:

1. **Check wallet connection** - The `handleWalletAuth` function checks if a wallet is connected
2. **Check window.solana** - Verifies that `window.solana` is available
3. **Call signInWithWeb3** - Calls `supabase.auth.signInWithWeb3()` with `chain: 'solana'`
4. **Supabase generates message** - Supabase creates a message for your wallet to sign
5. **Wallet prompts for signature** - Your wallet extension shows a popup asking you to sign
6. **Wallet signs message** - Your wallet cryptographically signs the message
7. **Supabase verifies signature** - Supabase checks that the signature matches your wallet address
8. **Supabase creates session** - If verification succeeds, Supabase creates a session
9. **Session stored in localStorage** - The session is saved in the browser
10. **AuthProvider detects change** - The `onAuthStateChange` subscription fires
11. **State updates** - The `AuthProvider` updates `user` and `session` state
12. **UI updates** - Components using `useAuth()` get the new state and re-render

The signature proves you control the wallet address. Supabase can't fake it. Only someone with access to your wallet's private key can sign. This is cryptographic proof of ownership.

If verification fails, Supabase returns an error. The error message tells you what went wrong. Common issues are wrong wallet, network problems, or Supabase configuration issues.

### Provider Hierarchy and Order

The providers are nested in a specific order. This matters because inner providers can use outer providers, but not vice versa.

The order in `src/components/app-providers.tsx` is:

1. `ReactQueryProvider` - Outermost, provides query client
2. `ThemeProvider` - Provides theme context
3. `AuthProvider` - Provides auth context (can use query client)
4. `SolanaProvider` - Innermost, provides wallet context (can use auth context)

The `AuthProvider` wraps the `SolanaProvider`. This means wallet components can check auth state. But auth components don't need wallet state. The order reflects the dependencies.

If you put `SolanaProvider` outside `AuthProvider`, wallet components couldn't use `useAuth()`. They'd get an error about the context not being available.

### How Protected Routes Work Internally

The `ProtectedRoute` component is a client component. It uses hooks, so it must be client-side.

Here's what happens when you visit a protected route:

1. **Component mounts** - `ProtectedRoute` renders
2. **Check loading** - If `loading` is true, show loading spinner
3. **Check user** - If `loading` is false and `user` is null, redirect
4. **Render children** - If authenticated, render the protected content

The redirect happens in a `useEffect`. This runs after render. It checks `user` and `loading` from `useAuth()`. If not authenticated, it calls `router.replace('/')`.

`replace` replaces the current URL in history. Users can't go back to the protected page. `push` would add a new entry, allowing back navigation. For protected routes, `replace` is better UX.

### Error Handling and Edge Cases

The template handles several edge cases:

**Session expires** - If a session expires, Supabase's `getSession()` returns null. The `AuthProvider` updates state. Protected routes redirect. Users need to sign in again.

**Network errors** - If Supabase is unreachable, `getSession()` might fail. The error is logged to console. The `AuthProvider` sets `loading: false` and `user: null`. Users see the unauthenticated state.

**Invalid session** - If localStorage has a corrupted session, `getSession()` might fail. The error is caught and logged. The state is reset to unauthenticated.

**Race conditions** - If auth state changes while a component is rendering, React handles it. The state update triggers a re-render. Components always see the latest state.

### Why This Architecture Works

This architecture is simple and maintainable. Each piece has a clear responsibility:

- **Zod validation** - Ensures config is correct at startup
- **Supabase client** - Handles all Supabase API calls
- **AuthProvider** - Manages auth state and shares it via Context
- **ProtectedRoute** - Guards routes based on auth state
- **Wallet UI** - Manages wallet connection independently

The separation of concerns makes it easy to understand and modify. You can change one piece without affecting others. The patterns are standard React and Next.js patterns. They're well-tested and reliable.

If you're debugging an issue, start with the error message. Trace it back through these layers. Check the browser console for logs. Check localStorage for session data. Check the network tab for API calls. Understanding these internals helps you find the problem faster.

## 11. Extending the Template

The template is a starting point. You'll want to add your own features. This section shows you how to extend it without breaking what's already there.

The template gives you authentication and wallet connection. You'll add your own pages, features, and business logic. Understanding how to extend it helps you build faster.

### Adding New Routes

To add a new route, create a page file in `src/app/`. Next.js App Router uses the file system for routing.

For example, to add a `/settings` route:

```tsx
// src/app/settings/page.tsx
export default function SettingsPage() {
  return <div>Settings page</div>
}
```

The file path determines the URL. `src/app/settings/page.tsx` creates `/settings`. `src/app/dashboard/analytics/page.tsx` creates `/dashboard/analytics`.

Next.js App Router uses file-based routing. It's simple and intuitive. You don't need to configure routes manually. The file structure is the route structure.

### Creating Protected Routes

To protect a new route, wrap it with `ProtectedRoute`:

```tsx
// src/app/settings/page.tsx
import { ProtectedRoute } from '@/components/auth/protected-route'

export default function SettingsPage() {
  return (
    <ProtectedRoute>
      <div>Settings page - only authenticated users can see this</div>
    </ProtectedRoute>
  )
}
```

If you want a custom fallback, provide it:

```tsx
<ProtectedRoute
  fallback={
    <div className="text-center py-8">
      <p>Please sign in to access settings</p>
    </div>
  }
>
  <SettingsContent />
</ProtectedRoute>
```

`ProtectedRoute` handles authentication checks and redirects. You don't need to write that logic yourself. Just wrap your content and it works.

### Adding Custom Hooks

The template uses hooks for shared logic. You can add your own in `src/hooks/`.

For example, to create a hook that fetches user data:

```tsx
// src/hooks/use-user-data.ts
import { useAuth } from '@/components/auth/auth-provider'
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'

export function useUserData() {
  const { user } = useAuth()

  return useQuery({
    queryKey: ['user-data', user?.id],
    queryFn: async () => {
      if (!user) return null
      // Fetch user data from Supabase
      const { data, error } = await supabase
        .from('user_profiles')
        .select('*')
        .eq('id', user.id)
        .single()
      
      if (error) throw error
      return data
    },
    enabled: !!user,
  })
}
```

Then use it in components:

```tsx
import { useUserData } from '@/hooks/use-user-data'

export default function ProfilePage() {
  const { data, isLoading } = useUserData()
  
  if (isLoading) return <div>Loading...</div>
  return <div>{data?.name}</div>
}
```

Hooks encapsulate logic and state. Multiple components can use the same hook. TanStack Query handles caching and refetching. You don't need to manage that yourself.

### Extending the Auth Flow

You can extend the authentication flow by modifying `src/components/auth/wallet-login.tsx`. But be careful. Don't break the existing flow.

For example, to add custom user metadata after sign-in:

```tsx
const handleWalletAuth = async () => {
  // ... existing code ...
  
  if (data.user) {
    // Update user metadata
    await supabase.auth.updateUser({
      data: {
        wallet_address: account.address.toString(),
        connected_at: new Date().toISOString(),
      },
    })
    
    setMessage('Wallet authenticated successfully!')
    // Note: The UI updates automatically via AuthProvider state changes
    // No manual navigation needed - the welcome card appears automatically
  }
}
```

You might want to store additional user data. You might want to trigger other actions on sign-in. The template gives you the base flow. You can add to it.

**Note:** The example above shows how you COULD extend the flow. The actual template doesn't update user metadata after sign-in. It just sets the success message and lets the `AuthProvider` handle the UI update automatically.

### Adding Features with Feature Folders

The template uses a feature-based structure in `src/features/`. Each feature has its own folder with components, hooks, and utilities.

To add a new feature, create a folder:

```text
src/features/
  └── your-feature/
      ├── your-feature-index.tsx
      ├── data-access/
      │   └── use-your-feature-query.ts
      └── ui/
          └── your-feature-ui.tsx
```

This keeps related code together. It's easier to find and maintain.

Feature folders organize code by feature, not by type. All code for a feature is in one place. It's easier to understand and modify. The template uses this pattern for the account feature.

### Working with Supabase Database

The template uses Supabase for authentication. You can also use it for database operations. The Supabase client is already set up in `src/lib/supabase.ts`.

To query data:

```tsx
import { supabase } from '@/lib/supabase'

// Fetch data
const { data, error } = await supabase
  .from('your_table')
  .select('*')

// Insert data
const { data, error } = await supabase
  .from('your_table')
  .insert({ column: 'value' })

// Update data
const { data, error } = await supabase
  .from('your_table')
  .update({ column: 'new_value' })
  .eq('id', id)
```

Supabase database is already set up. You have the client. You have authentication. You can use Row Level Security to protect data. It's all in one service.

### Adding Environment Variables

To add new environment variables, update `src/env.ts`:

```tsx
const client = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
  NEXT_PUBLIC_YOUR_NEW_VAR: z.string().optional(), // Add your new variable
})
```

Then add it to `.env.local`:

```env
NEXT_PUBLIC_YOUR_NEW_VAR="your-value"
```

Access it with `env.NEXT_PUBLIC_YOUR_NEW_VAR`. The validation ensures it's set correctly.

Zod validation catches missing or invalid values at startup. Better to fail fast than fail later. The error messages tell you exactly what's wrong.

### Customizing the UI

The template uses [Shadcn UI](https://ui.shadcn.com) components. They're in `src/components/ui/`. You can customize them or add your own.

To customize a component, copy it from `src/components/ui/` and modify it. Shadcn UI components are meant to be customized.

To add a new component:

```tsx
// src/components/ui/your-component.tsx
export function YourComponent() {
  return <div>Your component</div>
}
```

Then use it anywhere:

```tsx
import { YourComponent } from '@/components/ui/your-component'
```

Shadcn UI components are copy-paste. You own the code. You can modify them however you want. They're built on [Radix UI](https://www.radix-ui.com) primitives. They're accessible and customizable.

### Adding Mainnet Support

The template uses Devnet by default. To add Mainnet, update `src/components/solana/solana-provider.tsx`:

```tsx
import { createSolanaMainnet } from '@wallet-ui/react'

const config = createWalletUiConfig({
  clusters: [
    createSolanaDevnet(),
    createSolanaLocalnet(),
    createSolanaMainnet(), // Add Mainnet
  ],
})
```

Users can then select Mainnet from the cluster dropdown. Make sure to warn users about using real money.

Devnet is for testing. [Mainnet](https://docs.solana.com/clusters#mainnet-beta) is for production. When you're ready to deploy, you'll need Mainnet support. The Wallet UI library makes it easy to add.

### Extending the useSolana Hook

The `useSolana` hook in `src/components/solana/use-solana.tsx` wraps Wallet UI hooks. You can extend it to add custom logic:

```tsx
export function useSolana() {
  const walletUi = useWalletUi()
  const client = useWalletUiGill()

  // Add your custom logic here
  const customFunction = () => {
    // Your code
  }

  return {
    ...walletUi,
    client,
    customFunction, // Export your custom function
  }
}
```

Then use it in components:

```tsx
const { customFunction } = useSolana()
```

Extending the hook creates a central place for Solana-related logic. All components using `useSolana()` get your custom functions. It keeps the API consistent.

### Best Practices for Extension

When extending the template, follow these practices:

**Don't modify core files directly** - Instead, create new files and import what you need. This makes updates easier.

**Use TypeScript** - The template is fully typed. Keep your extensions typed too. It catches errors early.

**Follow the existing patterns** - The template uses feature folders, hooks, and components. Follow the same patterns. It keeps the codebase consistent.

**Test your changes** - Make sure your extensions work. Test authentication flows. Test protected routes. Test wallet connections.

**Document your changes** - If you add complex logic, add comments. Future you will thank you.

If you're unsure how to extend something, look at how the template does it. The account feature is a good example. It shows how to structure features, use hooks, and work with data.

The template is designed to be extended. The patterns are clear. The code is organized. You can build on top of it without fighting against it.

## 12. Troubleshooting

Things go wrong. Don't stress. Most issues have simple fixes. This table covers common problems and how to solve them.

If you see an error you don't recognize, check the browser console (F12) and the terminal where `npm run dev` is running. Error messages usually point to the specific issue.

| Issue | Solution |
|-------|----------|
| "Invalid environment variables" error | Check that `.env.local` exists in the project root. Make sure it contains both `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY`. The URL must be a valid URL starting with `https://`. Check the error message for which variable is missing or invalid. |
| 422 error when signing in | Enable Web3 authentication in your Supabase dashboard. Go to **Authentication** → **Providers** → **Web3** and toggle it to enabled. Save the changes. This is the most common cause of 422 errors. |
| "Web3 provider is disabled" | Same as above. Web3 authentication must be enabled in Supabase. If you don't see Web3 as an option, your Supabase project might not support it yet. Try creating a new project or check Supabase documentation. |
| "Authentication failed: [422 error]" | This usually means Web3 auth isn't enabled. But it can also mean your Supabase project doesn't support Web3 auth, or `window.solana` isn't properly connected. Check the browser console for more details. |
| Wallet not connecting | Make sure a Solana wallet extension (Phantom, Solflare, or Backpack) is installed and enabled in your browser. Check browser extension settings. Some browsers require you to enable extensions manually. Refresh the page after enabling. |
| "Solana wallet not detected" | Your wallet extension isn't injecting `window.solana`. Make sure the extension is installed, enabled, and active. Try disconnecting and reconnecting. If it still doesn't work, try a different wallet. |
| "Please connect a wallet first" | You're trying to sign in without connecting your wallet. Use the wallet dropdown in the header to connect first. Then come back to the sign-in card. |
| Wallet dropdown is empty | No wallets are detected. Make sure you have a Solana wallet extension installed. The Wallet UI library detects installed wallets automatically. If none are found, it shows a link to get a wallet. |
| 429 errors on airdrop | You've hit Devnet rate limits. Devnet has rate limits to prevent abuse. Wait a few minutes and try again. Or use a different Devnet RPC endpoint. This is normal and expected. |
| Port 3000 already in use | Another process is using port 3000. Change the port: `npm run dev -- -p 3001`. Or find and kill the process using port 3000. On Mac/Linux, use: `lsof -ti:3000` to find the process ID, then `kill` it. On Windows, use Task Manager. |
| Build fails with type errors | Run `npm install` again to ensure all dependencies are installed correctly. Delete `node_modules` and `package-lock.json`, then run `npm install` fresh. Check that you're using Node.js 18 or higher. |
| "Module not found" errors | Dependencies might not be installed. Run `npm install`. If that doesn't work, delete `node_modules` and `package-lock.json`, then run `npm install` again. |
| Session doesn't persist after refresh | Check that localStorage is enabled in your browser. Some browsers or privacy modes disable it. Check the browser console for errors. Make sure Supabase credentials are correct. |
| Protected route redirects even when authenticated | Check the browser console for errors. The session might be invalid or expired. Try signing out and signing back in. Check that your `.env.local` file has the correct Supabase credentials. |
| Loading state never ends | The `AuthProvider` can't check the session. Check the browser console for Supabase errors. Make sure your `.env.local` file has the correct Supabase credentials. Check your network connection. |
| "Attempted to access server-side environment variable on the client" | You're trying to access a server-side environment variable in client code. Only variables starting with `NEXT_PUBLIC_` are available on the client. Move the variable to server-side code or prefix it with `NEXT_PUBLIC_`. |
| Redirect loop on protected route | Your home page might be redirecting to a protected route. Make sure the home page (`/`) is accessible without authentication. Check for redirects in your code. |
| Wallet connection works but address doesn't show | The Wallet UI library might still be initializing. Refresh the page. Check the browser console for errors. Make sure the wallet is actually connected (check the wallet extension). |
| Can't access `/account` even when authenticated | Check the browser console for errors. The session might be invalid. Try signing out and signing back in. Check that Web3 auth is enabled in Supabase. |
| "Failed to authenticate with wallet. Please try again." | This is a generic error. Check the browser console for more details. It might be a network issue or a problem with the Supabase connection. Make sure your `.env.local` file has the correct credentials. |
| TypeScript errors in IDE but code works | Your IDE might not be using the correct TypeScript version. Restart your IDE. Run `npm install` to ensure types are installed. Check that `tsconfig.json` is correct. |
| "Cannot find module" errors | Dependencies aren't installed or the path is wrong. Run `npm install`. Check that import paths use the `@/` alias correctly. Make sure files exist at the specified paths. |
| Supabase client errors | Check that your Supabase credentials are correct in `.env.local`. Make sure the URL is valid and the anon key is correct. Check the Supabase dashboard to verify your project is active. |
| TanStack Query errors | Make sure `ReactQueryProvider` is wrapping your app in `src/app/layout.tsx`. Check that TanStack Query is installed: `npm list @tanstack/react-query`. |
| Styling issues or Tailwind not working | Make sure Tailwind is configured correctly. Check `tailwind.config.js` or `tailwind.config.ts`. Run `npm install` to ensure all dependencies are installed. Restart the dev server. |
| "useAuth must be used within an AuthProvider" | The `useAuth` hook is being used outside the `AuthProvider`. Make sure `AuthProvider` wraps your app in `src/app/layout.tsx`. Check the provider hierarchy. |
| "useSolana must be used within SolanaProvider" | The `useSolana` hook is being used outside the `SolanaProvider`. Make sure `SolanaProvider` wraps your app. Check that it's inside `AuthProvider` in the provider hierarchy. |

If you're still stuck after trying these solutions, check:

1. **Browser console** - Open DevTools (F12) and look for errors. Red errors usually tell you what's wrong.
2. **Terminal output** - The terminal where `npm run dev` is running shows build errors and runtime errors.
3. **Network tab** - Check the Network tab in DevTools. Failed requests to Supabase will show there.
4. **LocalStorage** - Check Application → Local Storage in DevTools. Look for Supabase session keys (they start with `sb-`).
5. **Supabase dashboard** - Check your Supabase project dashboard. Make sure the project is active and Web3 auth is enabled.

Most issues are configuration problems. Double-check your `.env.local` file. Make sure Web3 auth is enabled in Supabase. Make sure your wallet extension is installed and enabled. These three things fix most problems.

If you've tried everything and it still doesn't work, don't stress. Check the error message carefully. It usually tells you exactly what's wrong. The template is well-tested. If something isn't working, it's usually a configuration issue, not a code issue.

## 13. Best Practices

These practices help you build better apps with the template. They're based on real experience and common pitfalls. Follow them to avoid headaches later.

Best practices prevent bugs. They make your code easier to maintain. They help your app scale. They save you time in the long run.

### Environment Variables

**Never commit `.env.local`** - Contains secrets. Add to `.gitignore`. `.env.example` is safe to commit.

**Use `NEXT_PUBLIC_` prefix for client variables** - Only these are available in client-side code. Prevents accidentally exposing secrets.

**Validate with Zod** - Catches errors at startup, not runtime. Add new variables to `src/env.ts` with validation.

**Use different projects for dev and prod** - Separate Supabase projects prevent accidentally affecting production data.

### Security

**Never use the service role key in client code** - Full access key. Only use in server-side code or backend services. Always use the anon key in client code.

**Enable Row Level Security in Supabase** - If using Supabase's database, enable RLS on tables. Protects data at the database level even if someone gets your anon key.

**Validate user input** - Don't trust client data. Validate on the server with Zod or similar libraries.

**Handle errors gracefully** - Don't expose sensitive error messages. Log detailed errors on the server. Show generic messages to users.

### Code Organization

**Follow the feature folder pattern** - Keep related code together in `src/features/`. Don't mix features in the same folder.

**Use hooks for shared logic** - Create hooks in `src/hooks/` for logic used by multiple components. Follow the template's pattern.

**Keep components small** - Break large components into smaller, focused ones. Easier to understand and test.

**Use TypeScript strictly** - Don't disable strict mode. Use proper types. Avoid `any` unless necessary.

### Testing

**Test authentication flows** - Test sign-in, sign-out, session persistence, protected routes, and error cases.

**Test wallet connection** - Test with different wallets. Test connection, disconnection, and error cases.

**Test environment validation** - Try missing variables and invalid URLs. Ensure validation catches them.

**Test protected routes** - Verify redirects when unauthenticated, access when authenticated, and loading states.

### Deployment

**Set environment variables in your hosting platform** - Use platform settings (Vercel, Netlify, etc.). Don't hardcode values.

**Use production Supabase project** - Separate from dev. Use production credentials. Keep them separate.

**Enable Web3 auth in production** - Easy to forget. Check before deploying.

**Test on production-like environment** - Use staging that matches production settings. Catch issues before production.

### Error Handling

**Handle async errors** - Use try-catch for async operations. Don't let errors crash your app.

**Show user-friendly messages** - Log technical details. Show generic messages to users.

**Validate before API calls** - Check required data exists. Follow the template's pattern (e.g., checking wallet connection before authentication).

**Handle loading states** - Show loading indicators during operations. Users need feedback.

### Performance

**Use TanStack Query for data fetching** - Handles caching, refetching, and state management. Don't fetch data directly in components.

**Cache when possible** - TanStack Query caches automatically. Use proper cache keys. Don't refetch unnecessarily.

**Lazy load heavy components** - Use Next.js dynamic imports to reduce initial bundle size.

**Optimize images** - Use Next.js Image component. It optimizes automatically.

### Type Safety

**Use proper types** - Avoid `any`. Keep additions typed like the template.

**Type environment variables** - Use Zod. Catches errors at compile time.

**Type API responses** - Use Supabase-generated types. Don't use `any`.

**Type component props** - Always type props with interfaces or types.

### Wallet Integration

**Don't assume wallet is connected** - Always check `connected` and `account` before using it.

**Handle wallet disconnection** - Users can disconnect at any time. Update your UI gracefully.

**Support multiple wallets** - Don't hardcode a specific wallet. Support any wallet that implements the standard.

**Test with different wallets** - Test with Phantom, Solflare, and Backpack. They may behave differently.

### Supabase Integration

**Use the existing client** - Don't create multiple clients. Use `src/lib/supabase.ts`. Multiple clients won't share sessions.

**Handle session expiration** - Sessions can expire. Handle it gracefully. `AuthProvider` checks sessions automatically.

**Use Row Level Security** - More secure than application-level checks. Enable RLS on tables if using Supabase database.

**Monitor Supabase usage** - Check dashboard regularly. Monitor API and database usage. Don't hit limits unexpectedly.

### Code Maintenance

**Keep dependencies updated** - Update regularly. Check for security vulnerabilities.

**Follow the existing patterns** - Don't invent new patterns unless necessary. Consistency helps.

**Document complex logic** - Add comments for complex code. Future you will thank you.

**Refactor when needed** - Don't let technical debt accumulate. Keep code clean.

### Common Mistakes to Avoid

**Don't skip environment validation** - Catches errors early. Add validation for new variables.

**Don't use service role key in client** - Security risk. Always use the anon key.

**Don't forget to enable Web3 auth** - Required for authentication. Check in both dev and production.

**Don't assume wallet stays connected** - Users can disconnect. Handle it gracefully.

**Don't create multiple Supabase clients** - Use the existing one. Multiple clients cause issues.

**Don't ignore TypeScript errors** - Fix them. Don't use `any` to silence them.

**Don't skip error handling** - Handle errors gracefully. Don't let them crash your app.

**Don't forget to test** - Test authentication, wallet connection, and protected routes.

Following these practices helps you build better apps. They're based on real experience. They prevent common mistakes. They save you time. The template follows these practices. You should too.

## 14. Conclusion

You've made it through the guide. You understand how the template works. You know how to set it up, use it, and extend it. You're ready to build.

**What you learned**

You learned how Supabase Web3 authentication works with Solana wallets. You learned how wallet connection is separate from authentication. You learned how to protect routes and manage sessions. You learned how the architecture fits together.

You learned why things are built the way they are. You learned how to debug issues. You learned best practices. You learned how to extend the template without breaking it.

**What to do next**

Start building. The template gives you a solid foundation. Add your features. Customize the UI. Build your app. The patterns are clear. The code is organized. You can build on top of it.

If you get stuck, don't stress. Check the Troubleshooting section. Check the browser console. Check the terminal output. Most issues are configuration problems. They're easy to fix.

If you want to learn more, explore the codebase. Read the components. See how they work. The template is well-structured. It's a good learning resource.

**Remember the basics**

Environment variables must be validated. Use Zod. It catches errors early. Don't skip validation.

Web3 authentication must be enabled in Supabase. Check it in both dev and production. It's easy to forget.

Protected routes use the `ProtectedRoute` component. Wrap your content. It handles authentication checks. It's simple and reusable.

**The template is your starting point**

The template isn't the end. It's the beginning. It gives you authentication and wallet connection. You add the rest. You build your features. You customize the UI. You make it yours.

The code is production-ready in structure. The patterns are solid. The architecture is sound. You can trust it. You can build on it.

**You're ready**

You have everything you need. You understand the concepts. You know how to use the tools. You know how to debug issues. You know best practices. You're ready to build.

Start small. Add one feature at a time. Test as you go. Don't try to build everything at once. Build incrementally. It's easier that way.

If you hit a problem, don't panic. Check the error message. Check the Troubleshooting section. Check the browser console. Most problems have simple solutions.

**Keep learning**

The Solana ecosystem is evolving. New tools appear. New patterns emerge. Keep learning. Stay curious. The template uses current best practices. As things change, adapt.

The Supabase ecosystem is growing. New features appear. New integrations emerge. Keep an eye on it. The template uses Supabase's Web3 authentication. As Supabase evolves, the template might too.

**You've got this**

Building with Solana and Supabase is exciting. Wallet-based authentication is powerful. The template makes it accessible. You can build great apps with it.

Don't be afraid to experiment. Try new things. Break things. Fix them. That's how you learn. The template is there to help. Use it. Extend it. Make it yours.

You understand how it works. You know how to use it. You know how to extend it. You're ready. Go build something great.

Good luck. You've got this.
