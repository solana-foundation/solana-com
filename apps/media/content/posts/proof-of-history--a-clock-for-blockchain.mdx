---
title: "Proof of History: A Clock for Blockchain"
description: |

  A high-level explanation of Solana’s core innovation
slug: proof-of-history--a-clock-for-blockchain
date: "2018-04-18"
category:
  - category: content/category/developers.mdx
  - category: content/category/finance.mdx
status: published
seo:
  title: "Proof of History: A Clock for Blockchain"
  description: |

    A high-level explanation of Solana’s core innovation
  noIndex: false
  noFollow: false
  openGraph:
    ogTitle: "Proof of History: A Clock for Blockchain"
    ogUrl: "https://www.solana.com/blog/proof-of-history--a-clock-for-blockchain"
    ogDescription: |

      A high-level explanation of Solana’s core innovation
    ogImage: null
    ogType:
      - article
  twitter:
    twitterTitle: "Proof of History: A Clock for Blockchain"
    twitterDescription: |

      A high-level explanation of Solana’s core innovation
    twitterImage: null
author: content/authors/solana-foundation.md
tags:
  - tag: content/tags/developer.mdx
  - tag: content/tags/distributed-systems.mdx
  - tag: content/tags/proof-of-history.mdx
---

### **A high-level explanation of** [**Solana**](https://solana.com/?utm_source=medium&utm_campaign=proof_of_history)**’s core innovation**

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-1.jpg)

Solana is the most performant permissionless blockchain in the world. On current iterations of the Solana Testnet, a network of 200 physically distinct nodes supports a sustained throughput of more than 50,000 transactions per second when running with GPUs. Achieving as such requires the implementation of several optimizations and new technologies, and the result is a breakthrough in network capacity that signals a new phase in blockchain development.

### **There are 8 key innovations that make the Solana network possible:**

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-2.jpg)

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-3.jpg)

One of the most difficult problems in distributed systems is agreement on time. In fact, some [argue](https://grisha.org/blog/2018/01/23/explaining-proof-of-work/?ref=solana.ghost.io) that Bitcoin’s Proof of Work algorithm’s most essential feature is functioning as a decentralized clock for the system. At [Solana](https://solana.com/?utm_source=medium&utm_campaign=proof_of_history), we believe **Proof of History** provides this solution and we’ve built a blockchain based on it.

Decentralized networks have solved this problem with trusted, centralized timing solutions. For example, [Google’s Spanner](https://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf?ref=solana.ghost.io) uses synchronized atomic clocks between its data centers. Google’s engineers synchronize these clocks to a very high precision and constantly maintain them.

This problem is even harder in adversarial systems like blockchain. Nodes in the network can’t trust an external source of time or any timestamp that appears in a message. [Hashgraph](https://www.hederahashgraph.com/?ref=solana.ghost.io) for example, solves this problem with a “median” timestamp. Each message that is seen by the network is signed and timestamped by a supermajority of the network. The median timestamp for the message is what Hashgraph calls “fair” ordering. Each message has to travel to the supermajority of the nodes in the system, then after the message collects enough signatures, the entire set needs to be propagated to the entire network. As you can imagine, this is really slow.

What if you could simply trust the timestamp that is encoded into the message? An enormous wealth of distributed systems optimizations would suddenly be at your disposal. E.g.

“Synchronized clocks are interesting because they can be used to improve the performance of distributed algorithms. They make it possible to replace communication with local computation.”— [Liskov, B. Practical uses of synchronized clocks in distributed systems](http://www.dainf.cefetpr.br/~tacla/SDII/PracticalUseOfClocks.pdf?ref=solana.ghost.io)

In our case this means a high throughput, high performance blockchain

## **Proof of History**

<video url="https://youtu.be/rywOYfGu4EA " />

What if instead of trusting the timestamp you could prove that the message occured sometime before and after an event? When you take a photograph with the cover of New York Times, you are creating a proof that your photograph was taken after that newspaper was published, or you have some way to influence what New York Times publishes. With Proof of History, you can create a historical record that proves that an event has occurred at a specific moment in time.

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-4.jpg)

Enter some text...

Proof of History Timestamps

The Proof of History is a high frequency [Verifiable Delay Function](https://www.youtube.com/watch?v=qUoagL7OZ1k&ref=solana.ghost.io). A Verifiable Delay Function requires a specific number of sequential steps to evaluate, yet produces a unique output that can be efficiently and publicly verified.

Our specific implementation uses a sequential pre-image resistant hash that runs over itself continuously with the previous output used as the next input. Periodically the count and the current output are recorded.

For a SHA256 hash function, this process is impossible to parallelize without a brute force attack using 2¹²⁸ cores.

We can then be certain that real time has passed between each counter as it was generated, and that the recorded order each counter is the same as it was in real time.

### **Upper bound on Time**

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-5.jpg)

Enter some text...

Recording messages into a Proof of History sequence

Data can be inserted into the sequence by appending the hash of the data to the previous generated state. The **state**, **input data**, and **count** are all published. Appending the input causes all future output to change unpredictably. It is still impossible to parallelize, and as long as hash function is pre-image and collision resistant, it is impossible to create an input that would generate a desired hash in the future, or create an alternative history with the same hashes. We can prove that time passed between any two append operations. We can prove that the data was created sometime before it was appended. Just like we know that the events published in the New York Times occurred before the newspaper was written.

### **Lower bound on Time**

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-6.jpg)

Enter some text...

Lower bound on time with Proof of History

Inputs into Proof of History can have references back to Proof of History itself. The back reference could be inserted as part of a signed message with the users signature, so it cannot be modified without the users private key. This is just like taking a photograph with the New York Times newspaper in the background. Because this message contains **0xdeadc0de** hash we know it was generated after count **510144806912** was created.

But since the message is also inserted back into Proof of History stream, it is as if you took a photo with the New York Times in the background, and the next day the New York Times published that photo. We know that the content of that photo existed before and after a specific day.

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-7.jpg)

### **Verification**

While the recorded sequence can only be generated on a single CPU core, the output can be verified in parallel.

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-8.jpg)

Enter some text...

Parallel Verification

Each recorded slice can be verified from start to finish on separate cores in 1/(number of cores) time it took to generate. So a modern day GPU with 4000 cores can verify a second in 0.25 milliseconds.

## **ASICS**

Isn’t every CPU different, and some much faster then others? How do you actually trust that “time” as it’s generated by our SHA256 loop is accurate?

This topic deserves its own article, but long story short is that we don’t much care if some CPUs are faster then others, and if an ASIC can be faster then the CPUs available to the network. The most important thing is that there is a finite bound on how much faster an ASIC can get.

We are using SHA256, and thanks to Bitcoin there has been significant research in making this cryptographic hash function fast. This function is impossible to speed up by using a larger die area, like a Look Up Table, or unrolling it without impact to clock speed. Both Intel and AMD are releasing consumer chips that can do a full round of SHA256 in 1.75 cycles.

Because of this, we have pretty good certainty that a custom ASIC will not be 100x faster, let alone 1000x, and most likey will be within 30% of what is available to the network. We can construct protocols that exploit this bound and only allow an attacker a very limited, easily detected and shortlived oportunity for a denial of service attack. More on that in the next article!

## **Code**

[**solana-labs/solana**](https://github.com/solana-labs/solana?ref=solana.ghost.io)

[solana — High Performance Blockchaingithub.com](https://github.com/solana-labs/solana?ref=solana.ghost.io)

If you like rust and cuda, and want to build the worlds fastest blockchain please reach out to us [hello@solana.com](http://hello@solana.com/?ref=solana.ghost.io)

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-9.jpg)

Solana’s implementation of Proof of History, alongside innovations like Tower BFT, Proof of Replication, and Gulf Stream combine to create the most performant blockchain in the world. Solana’s testnet is live today. You can see it at [https://testnet.solana.com](https://testnet.solana.com/?ref=solana.ghost.io). For cost purposes, we are only running a handful of nodes. However, we have spun it up on many instances to over 200 physically distinct nodes (not on shared hardware) across 23 data centers on AWS, GCE, and Azure for benchmarking.

The runtime is functioning today, and developers can deploy code on the testnow now. Developers can build smart contracts in C today, and we are aggressively working on the Rust toolchain. Rust will be the flagship language for Solana smart contract development. The [Rust toolchain is publicly available](https://github.com/solana-labs/solana-web3.js?ref=solana.ghost.io) as part of the Solana Javascript SDK, and we are further iterating on the Software Development Kit.

Solana will soon launch a public beta incentivizing validators to run nodes via [Tour de SOL](https://solana.ghost.io/solana-labs/solana-announces-tour-de-sol-an-incentivized-testnet-event-b26372a58a51) — analogous to Cosmos’s Game of Stakes — that challenges the public at large to test the limits of the Solana network while earning tokens for doing so.

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-10.jpg)

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-11.jpg)

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-12.jpg)

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-13.jpg)

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-14.jpg)

![](/uploads/builder/proof-of-history--a-clock-for-blockchain/image-15.jpg)
