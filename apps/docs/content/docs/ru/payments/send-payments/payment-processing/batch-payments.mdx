---
title: Пакетные платежи
description:
  Узнайте, как отправлять платежи нескольким получателям в одной транзакции.
---

Транзакция Solana — это контейнер, который содержит одну или несколько
инструкций. Каждая инструкция — это операция: перевод токенов, создание
аккаунта, вызов программы. Сеть выполняет все инструкции в транзакции
последовательно и атомарно: либо каждая инструкция выполняется успешно, либо вся
транзакция откатывается и считается неудачной.

Это означает, что вы можете объединить несколько переводов в одну транзакцию.
Вместо того чтобы отправлять три отдельные транзакции для оплаты трем
получателям, вы отправляете одну транзакцию с тремя инструкциями перевода. Это
быстрее (одно подтверждение вместо трёх) и дешевле (одна базовая комиссия вместо
трёх). Вот наглядный пример того, как платежи (на изображении они называются
«дропами») объединяются в одну транзакцию, а для обработки большого количества
платежей отправляется несколько транзакций.

![Диаграмма пакетных платежей](/assets/docs/payments/qn-bulk-send.png)

_Источник:
[QuickNode — Как отправлять массовые транзакции в Solana](https://www.quicknode.com/guides/solana-development/transactions/how-to-send-bulk-transactions-on-solana)_

Больше информации о транзакциях и инструкциях вы найдете в разделах
[Транзакции](/docs/core/transactions) и [Инструкции](/docs/core/instructions).

В этом пошаговом руководстве показано, как загрузить несколько инструкций
перевода в одну транзакцию для пакетных платежей.

## Объединение инструкций в одну транзакцию

Транзакция Solana может содержать несколько переводов разным получателям. Вы
подписываете один раз, платите одну комиссию за транзакцию, и все переводы
выполняются одновременно. Если какой-либо перевод не удастся, вся транзакция
будет отклонена.

<Callout>
  См. раздел [Как работают платежи в Solana](/docs/payments/how-payments-work)
  для ознакомления с основными понятиями.
</Callout>

Для объединения нескольких переводов необходимо создать каждую инструкцию
отдельно, а затем собрать их в одну транзакцию.

Далее приведены основные этапы процесса. Полный рабочий код смотрите в разделе
[Демо](#demo).

<ScrollyCoding>

## !!steps Получение адресов token account

Сначала получите адреса Associated Token Account (ATA) для отправителя и каждого
получателя. ATA — это детерминированные адреса, основанные на кошельке и mint.

<CodePlaceholder title="Batch Payments" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});
```

## !!steps Создание инструкций для перевода

Создайте отдельную инструкцию перевода для каждого получателя. В каждой
инструкции указываются:

- адрес исходного token account
- адрес целевого token account
- authority (адрес владельца исходного token account)
- сумма в базовых единицах (с учётом знаков после запятой у mint)

<CodePlaceholder title="Batch Payments" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !focus(1:12)
const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});
```

## !!steps Отправка одной транзакцией

Добавьте все инструкции перевода в одну транзакцию. Это позволит выполнить все
переводы атомарно: либо все переводы проходят успешно, либо вся транзакция
откатывается.

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});

// !focus(1:5)
const signature = await client.transaction.prepareAndSend({
  authority: sender,
  // !mark
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});
```

## !!steps Проверка балансов

После пакетного перевода проверьте балансы токенов для всех участников с помощью
`splToken` хелпера.

<CodePlaceholder title="Batch Payments" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});

const signature = await client.transaction.prepareAndSend({
  authority: sender,
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});

// !focus(1:8)
const splToken = client.splToken({
  mint: mint.address,
  tokenProgram: "auto"
});

const senderBalance = await splToken.fetchBalance(sender.address);
const recipient1Balance = await splToken.fetchBalance(recipient1.address);
const recipient2Balance = await splToken.fetchBalance(recipient2.address);
```

</ScrollyCoding>

### Демонстрация

<CodeTabs flags="r">

```ts !! title="Demo"
// !collapse(1:14) collapsed
// Click ">" icon on left to expand demo imports
import { createClient, lamports } from "@solana/client";
import { generateKeypair } from "@solana/client/server";
import type { ServerKeypair } from "@solana/client/server";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getCreateAssociatedTokenInstructionAsync,
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  findAssociatedTokenPda,
  getMintToInstruction,
  getTransferInstruction
} from "@solana-program/token-2022";

// Generate keypairs for sender and two recipients
const sender = (await generateKeypair()).signer;
const recipient1 = (await generateKeypair()).signer;
const recipient2 = (await generateKeypair()).signer;

console.log("Sender Address:", sender.address);
console.log("Recipient 1 Address:", recipient1.address);
console.log("Recipient 2 Address:", recipient2.address);

// Demo Setup: Create client, mint account, token accounts, and fund with initial tokens
const { client, mint } = await demoSetup(sender, recipient1, recipient2);

console.log("\nMint Address:", mint.address);

// Derive the Associated Token Accounts addresses (ATAs) for sender and recipients
// !mark(1:5)
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !mark(1:5)
const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !mark(1:5)
const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

console.log("Sender Token Account:", senderAta.toString());
console.log("Recipient 1 Token Account:", recipient1Ata.toString());
console.log("Recipient 2 Token Account:", recipient2Ata.toString());

// =============================================================================
// Batch Token Payment Demo
// =============================================================================

// Create instructions to transfer tokens from sender to both recipients
// Transferring 250,000 base units = 0.25 tokens (with 6 decimals) to each
// !mark(1:6)
const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n // 0.25 tokens
});

// !mark(1:6)
const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n // 0.25 tokens
});

// Prepare and send both transfers in a single transaction using @solana/client
const signature = await client.transaction.prepareAndSend({
  authority: sender,
  // !mark
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});

console.log("\n=== Batch Token Payment Complete ===");
console.log("Transaction Signature:", signature.toString());

// Fetch final token account balances using @solana/client SPL token helper
const splToken = client.splToken({
  mint: mint.address,
  tokenProgram: "auto"
});

const senderBalance = await splToken.fetchBalance(sender.address);
const recipient1Balance = await splToken.fetchBalance(recipient1.address);
const recipient2Balance = await splToken.fetchBalance(recipient2.address);

console.log("\nSender Token Account Balance:", senderBalance);
console.log("Recipient 1 Token Account Balance:", recipient1Balance);
console.log("Recipient 2 Token Account Balance:", recipient2Balance);

// =============================================================================
// Demo Setup Helper Function
// =============================================================================
// !collapse(1:1000) collapsed

/**
 * Sets up for a batch token transfer demo:
 * - Creates @solana/client instance
 * - Airdrops SOL to sender for transaction fees
 * - Generates mint keypair and creates/initializes mint account
 * - Creates associated token accounts for sender and both recipients
 * - Mints initial tokens to sender
 *
 * @param sender - The sender's keypair (will be funded and used as mint authority)
 * @param recipient1 - The first recipient's keypair
 * @param recipient2 - The second recipient's keypair
 * @returns Returns client instance and mint address
 */
async function demoSetup(
  sender: ServerKeypair["signer"],
  recipient1: ServerKeypair["signer"],
  recipient2: ServerKeypair["signer"]
) {
  // Create @solana/client instance pointing to local validator
  const client = createClient({
    endpoint: "http://localhost:8899",
    websocketEndpoint: "ws://localhost:8900",
    commitment: "confirmed",
    logger: () => {} // Disable all logs
  });

  // Fund sender with SOL for transaction fees using @solana/client actions
  await client.actions.requestAirdrop(sender.address, lamports(1_000_000_000n));

  // Generate keypair to use as address of mint
  const mint = (await generateKeypair()).signer;

  // Get default mint account size (in bytes), no extensions enabled
  const space = BigInt(getMintSize());

  // Get minimum balance for rent exemption
  const rent = await client.runtime.rpc
    .getMinimumBalanceForRentExemption(space)
    .send();

  // Instruction to create new account for mint (token program)
  // Invokes the system program
  const createAccountInstruction = getCreateAccountInstruction({
    payer: sender,
    newAccount: mint,
    lamports: rent,
    space,
    programAddress: TOKEN_2022_PROGRAM_ADDRESS
  });

  // Instruction to initialize mint account data
  // Invokes the token 2022 program
  const initializeMintInstruction = getInitializeMintInstruction({
    mint: mint.address,
    decimals: 6,
    mintAuthority: sender.address
  });

  // Derive sender's associated token account address (ATA)
  const [senderAta] = await findAssociatedTokenPda({
    mint: mint.address,
    owner: sender.address,
    tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
  });

  // Create instruction for sender's ATA
  const createSenderAtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: sender.address
    });

  // Create instruction for recipient 1's ATA
  const createRecipient1AtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: recipient1.address
    });

  // Create instruction for recipient 2's ATA
  const createRecipient2AtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: recipient2.address
    });

  // Create instruction to mint initial tokens to sender
  const mintToInstruction = getMintToInstruction({
    mint: mint.address,
    token: senderAta,
    mintAuthority: sender.address,
    amount: 1_000_000n // Mint 1.00 tokens (1,000,000 base units with 6 decimals)
  });

  // Combine all instructions and send using @solana/client transaction helper
  const setupInstructions = [
    createAccountInstruction, // Create mint account
    initializeMintInstruction, // Initialize mint
    createSenderAtaInstruction, // Create sender's ATA
    createRecipient1AtaInstruction, // Create recipient 1's ATA
    createRecipient2AtaInstruction, // Create recipient 2's ATA
    mintToInstruction // Mint tokens to sender
  ];

  // Prepare and send transaction using @solana/client
  await client.transaction.prepareAndSend({
    authority: sender,
    instructions: setupInstructions,
    version: 0
  });

  return {
    client,
    mint
  };
}
```

</CodeTabs>

## Масштабирование с помощью планирования транзакций

Одна транзакция имеет ограничения по размеру — примерно 1232 байта. Для крупных
пакетных операций (например, начисление зарплаты сотням сотрудников, массовые
airdrop) вы превысите этот лимит и потребуется разбивать работу на несколько
транзакций.

Хотя вы можете реализовать собственную логику распределения транзакций, пакет
[`@solana/instruction-plans`](https://www.solanakit.com/docs/concepts/instruction-plans)
(часть Solana Kit) решает эту задачу на двух уровнях:

**Планы инструкций** определяют ваши операции и ограничения по их порядку
выполнения:

- **Последовательные** — инструкции, которые должны выполняться по порядку
- **Параллельные** — инструкции, которые могут выполняться в любом порядке
- **Неделимые** — инструкции, которые должны оставаться вместе в одной
  транзакции

**Планы транзакций** формируются на основе планов инструкций. Планировщик
интеллектуально группирует инструкции в транзакции оптимального размера с учетом
ваших ограничений по порядку. Полученный план транзакций может быть:

- **Выполнен** — подписан и отправлен в сеть, при этом параллельные транзакции
  отправляются одновременно
- **Симулирован** — тестовый запуск в сети для проверки перед отправкой
- **Сериализован** — скомпилирован в base64 для внешних сервисов подписи или
  мультипользовательских сценариев

Такой двухуровневый подход позволяет вам мыслить в терминах операций ("перевести
Алисе, затем перевести Бобу"), а библиотека берет на себя механику определения
размера транзакций, их упаковки и параллельного выполнения.
