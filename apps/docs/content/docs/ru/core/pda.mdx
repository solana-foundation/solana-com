---
title: Адрес, производный от программы
description:
  Узнайте об адресах, производных от программ (PDA), в Solana —
  детерминированных адресах аккаунтов, которые обеспечивают безопасное
  подписание программ. Поймите процесс создания PDA, канонические смещения и как
  создавать аккаунты PDA.
---

[Адрес аккаунта](/docs/core/accounts#account-address) в Solana указывает на
местоположение аккаунта в блокчейне. Многие адреса аккаунтов являются открытым
ключом ключевой пары, в этом случае соответствующий закрытый ключ используется
для подписания транзакций, связанных с аккаунтом.

Полезной альтернативой адресу открытого ключа является адрес, производный от
программы (PDA). PDA предоставляет простой способ хранения, сопоставления и
извлечения состояния программы. PDA — это адрес, который создается
детерминированно с использованием идентификатора программы и комбинации
опциональных предопределенных входных данных. PDA выглядят как адреса открытых
ключей, но не имеют соответствующего закрытого ключа.

Среда выполнения Solana позволяет программам подписывать PDA без необходимости в
закрытом ключе. Использование PDA устраняет необходимость отслеживать адрес
аккаунта. Вместо этого вы можете вспомнить конкретные входные данные,
использованные для создания PDA. (Чтобы узнать, как программы используют PDA для
подписания, см. раздел [Вызовы между программами](/docs/core/cpi).)

## Основы

Ключевые пары Solana
([keypairs](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/keypair/src/lib.rs#L26))
являются точками на [кривой Ed25519](https://ed25519.cr.yp.to/) (эллиптическая
криптография). Они состоят из открытого ключа и закрытого ключа. Открытый ключ
становится адресом аккаунта, а закрытый ключ используется для создания
действительных [подписей](/docs/core/transactions#signatures) для аккаунта.

![Два аккаунта с адресами на кривой](/assets/docs/core/pda/address-on-curve.svg)

PDA намеренно создается так, чтобы находиться вне кривой Ed25519. Это означает,
что он не имеет действительного соответствующего закрытого ключа и не может
выполнять криптографические операции (например, предоставлять подпись). Однако
Solana позволяет программам подписывать PDA без необходимости в закрытом ключе.

![Адрес вне кривой](/assets/docs/core/pda/address-off-curve.svg)

Вы можете рассматривать PDAs как способ создания структур, похожих на
хэш-таблицы, в блокчейне с использованием заранее определённого набора входных
данных (например, строк, чисел и других адресов аккаунтов).

![Адрес, производный от программы](/assets/docs/core/pda/pda.svg)

## Получение PDA

Прежде чем создать аккаунт с PDA, сначала необходимо получить адрес. Получение
PDA _не_ создаёт автоматически аккаунт в блокчейне по этому адресу — аккаунт
должен быть явно создан через программу, использованную для получения PDA. Вы
можете представить PDA как адрес на карте: просто потому, что адрес существует,
это не означает, что там что-то построено.

SDK Solana поддерживают создание PDA с помощью функций, указанных в таблице
ниже. Каждая функция принимает следующие входные данные:

- **ID программы**: Адрес программы, используемой для получения PDA. Эта
  программа может подписывать от имени PDA.
- **Необязательные seeds**: Заранее определённые входные данные, такие как
  строки, числа или другие адреса аккаунтов.

| SDK                            | Функция                                                                                                                          |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `@solana/kit` (Typescript)     | [`getProgramDerivedAddress`](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L157) |
| `@solana/web3.js` (Typescript) | [`findProgramAddressSync`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/publickey.ts#L212)               |
| `solana_sdk` (Rust)            | [`find_program_address`](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/pubkey/src/lib.rs#L617)                        |

Функция использует ID программы и необязательные seeds, затем перебирает
значения bump, чтобы попытаться создать действительный адрес программы. Перебор
значений bump начинается с 255 и уменьшается на 1 до тех пор, пока не будет
найден действительный PDA. После нахождения действительного PDA функция
возвращает PDA и bump seed.

<Callout>
  Bump seed — это дополнительный байт, добавляемый к необязательным seeds, чтобы
  гарантировать генерацию действительного адреса вне кривой.
</Callout>

![Вывод PDA](/assets/docs/core/pda/pda-derivation.svg)

### Канонический bump

Bump seed — это дополнительный байт, добавляемый к необязательным seeds. Функция
вывода перебирает значения bump, начиная с 255 и уменьшая на 1, пока не будет
найдено значение, которое создаёт корректный off-curve адрес. Первое значение,
которое создаёт корректный off-curve адрес, называется "каноническим bump."

Следующие примеры показывают вывод PDA с использованием всех возможных bump seed
(от 255 до 0):

<Callout type="info">
  Пример с Kit не включён, так как функция
  [createProgramDerivedAddress](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L101)
  не экспортируется.
</Callout>

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const optionalSeed = "helloWorld";

// Loop through all bump seeds (255 down to 0)
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(optionalSeed), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed = b"helloWorld";

    // Loop through all bump seeds (255 down to 0)
    for bump in (0..=255).rev() {
        match Pubkey::create_program_address(&[optional_seed.as_ref(), &[bump]], &program_id) {
            Ok(pda) => println!("bump {}: {}", bump, pda),
            Err(err) => println!("bump {}: {}", bump, err),
        }
    }

    Ok(())
}
```

</CodeTabs>

<CodeTabs>

```sh !! title="Expected TS Output"
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// remaining bump outputs
```

```sh !! title="Expected Rust Output"
bump 255: Provided seeds do not result in a valid address
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Provided seeds do not result in a valid address
...
// remaining bump outputs
```

</CodeTabs>

В этом примере первый bump seed вызывает ошибку. Первый bump seed, который
выводит корректный PDA, — это 254. Bump seed с 253 по 251 также вычисляют
уникальные корректные PDA.

Это означает, что при одинаковых необязательных seed и `programId` bump seed с
разным значением всё равно может привести к валидному PDA.

<Callout type="warn">
  Всегда включайте проверки безопасности, чтобы убедиться, что PDA, переданный в
  программу, выведен из канонического bump. Отсутствие таких проверок может
  привести к уязвимостям, позволяющим использовать неожиданные аккаунты в
  инструкциях программы. Рекомендуется использовать только канонический bump при
  выводе PDA.
</Callout>

### Примеры

Примеры ниже показывают вывод PDA с использованием SDK Solana. Нажмите **&#9655;
Run**, чтобы выполнить код.

#### Вывод PDA с использованием строкового seed

Пример ниже выводит PDA с использованием ID программы и необязательного
строкового seed.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus
const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus
const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let seeds: &[&[u8]] = &[b"helloWorld"];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Вывод PDA с адресным seed

Пример ниже выводит PDA, используя идентификатор программы и необязательный
адресный seed.

<CodeTabs storage="pda-examples"flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:4)
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

// !focus(1:3)
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Вывод PDA с несколькими seeds

Пример ниже выводит PDA, используя идентификатор программы и несколько
необязательных seeds.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:5)
const optionalSeedString = "helloWorld";
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedString, optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus(1:4)
const optionalSeedString = "helloWorld";
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [Buffer.from(optionalSeedString), optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus(1:2)
    let optional_seed_bytes = b"helloWorld";
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

## Создание аккаунта PDA

<WithMentions>

В приведённом ниже примере используется
[фреймворк Anchor](https://www.anchor-lang.com/docs) для создания нового
аккаунта с адресом, производным от программы (PDA). Программа включает
единственную инструкцию [`initialize`](mention:initialize) для создания нового
аккаунта, который будет хранить [адрес пользователя](mention:user-address) и
[bump seed](mention:bump), использованные для получения PDA.

```rs title="Program"
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    // !mention initialize
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        // !mark
        // !mention user-address
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bumpd
        // !mark
        // !mention bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    // !mention user-address
    pub user: Signer<'info>,

    #[account(
        init,
        // define the seeds to derive the PDA
        // !mark
        // !mention user-address
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        // !mark
        // !mention bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(InitSpace)]
pub struct DataAccount {
    // !mark
    // !mention user-address
    pub user: Pubkey,
    // !mark
    // !mention bump
    pub bump: u8,
}
```

</WithMentions>

<WithMentions>

Ограничение [`init`](mention:init) сообщает Anchor, что нужно
[вызвать System Program](/docs/core/programs#the-system-program) для создания
нового аккаунта, используя PDA в качестве адреса. Для создания PDA используются
следующие seeds:

- Адрес аккаунта пользователя, предоставленный в инструкции
- Фиксированную строку: "data"
- Канонический [bump seed](mention:bump)

В этом примере ограничение bump не задано явно, поэтому Anchor использует
`find_program_address` для получения PDA и поиска bump.

```rust title="pda_account"
#[account(
    // !mention init
    init,
    // !mention seeds
    seeds = [b"data", user.key().as_ref()],
    // !mention bump
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

</WithMentions>

<WithMentions>

В тестовом файле ниже содержится транзакция, которая вызывает инструкцию
[`initialize`](mention:initialize) для создания нового аккаунта с адресом,
производным от программы (PDA). В файле также есть код для
[получения PDA](mention:pda).

Пример также показывает, как [получить](mention:fetch) новый аккаунт, который
будет создан.

```ts title="Test"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PdaAccount } from "../target/types/pda_account";
import { PublicKey } from "@solana/web3.js";

describe("pda-account", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.PdaAccount as Program<PdaAccount>;
  const user = provider.wallet as anchor.Wallet;

  // !mention(1:5) pda
  // Derive the PDA address using the seeds specified on the program
  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("data"), user.publicKey.toBuffer()],
    program.programId
  );

  it("Is initialized!", async () => {
    const transactionSignature = await program.methods
      // !mention initialize
      .initialize()
      .accounts({
        user: user.publicKey
      })
      .rpc();

    console.log("Transaction Signature:", transactionSignature);
  });

  it("Fetch Account", async () => {
    // !mention fetch
    const pdaAccount = await program.account.dataAccount.fetch(PDA);
    console.log(JSON.stringify(pdaAccount, null, 2));
  });
});
```

</WithMentions>

<Callout type="warn">
  Если вы снова вызовете инструкцию `initialize` с тем же seed адреса `user`,
  транзакция завершится с ошибкой. Это происходит потому, что по вычисленному
  адресу уже существует аккаунт.
</Callout>
