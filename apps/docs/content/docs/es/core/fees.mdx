---
title: Tarifas de transacción
description:
  Aprende sobre las tarifas de transacción de Solana, incluyendo las tarifas
  base y de prioridad, cómo se aplica cada una, y las mejores prácticas para
  gestionar unidades de cómputo en tus transacciones.
---

Cada transacción de Solana requiere una tarifa de transacción, pagada en SOL.
Las tarifas de transacción se dividen en dos partes: la tarifa base y la tarifa
de priorización. La tarifa base compensa a los validadores por procesar la
transacción. La tarifa de priorización es una tarifa opcional, para aumentar la
probabilidad de que el líder actual procese tu transacción.

## Tarifa base

Cada transacción cuesta 5000 [lamports](/docs/references/terminology#lamport)
por firma incluida. Esta tarifa es pagada por el primer firmante de la
transacción. Solo las cuentas propiedad del System Program pueden pagar tarifas
de transacción. La tarifa base se divide de la siguiente manera:

- **50% quemado:** La mitad se
  [quema](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (se retira del suministro circulante de SOL).
- **50% distribuido:** La mitad se
  [paga al validador](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
  que procesó la transacción.

## Tarifa de priorización

Una
[tarifa de priorización](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
es una tarifa opcional utilizada para aumentar la probabilidad de que el líder
actual (validador) procese tu transacción. El validador recibe el
[100% de la tarifa de prioridad](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Las tarifas de priorización se pueden establecer ajustando el precio de
[unidad de cómputo](/docs/references/terminology#compute-units) (CU) y el límite
de CU de la transacción. (Consulta la
[guía Cómo usar tarifas de prioridad](/developers/guides/advanced/how-to-use-priority-fees)
para más detalles sobre las tarifas de priorización.)

La tarifa de priorización se calcula de la siguiente manera:

```text title="Prioritization fee formula"
Prioritization fee = CU limit * CU price
```

La tarifa de priorización se utiliza para determinar la
[prioridad de tu transacción](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646),
en relación con otras transacciones. Se calcula utilizando la siguiente fórmula:

```text title="Transaction priority formula"
Priority = (Prioritization fee + Base fee) / (1 + CU limit + Signature CUs + Write lock CUs)
```

#### Límite de unidades de cómputo

Por
[defecto](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
a cada instrucción se le asignan
[200,000 CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
y a cada transacción se le asignan
[1.4 millones de CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14).
Puedes cambiar estos valores predeterminados incluyendo una instrucción
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
en tu transacción.

Para calcular el límite de CU apropiado para tu transacción, recomendamos los
siguientes pasos:

1. Estima las unidades de CU requeridas
   [simulando](/developers/guides/advanced/how-to-request-optimal-compute) la
   transacción
2. Añade un margen de seguridad del 10% a esta estimación

<Callout type="warn">
  La tarifa de prioridad está determinada por el límite de unidades de cómputo
  solicitado en la transacción, *no* por el número real de unidades de cómputo
  utilizadas. Si estableces un límite de unidades de cómputo demasiado alto o
  usas la cantidad predeterminada, podrías pagar por unidades de cómputo no
  utilizadas.
</Callout>

#### Precio de unidad de cómputo

El precio de unidad de cómputo es una cantidad opcional de
[micro-lamports](/docs/references/terminology#micro-lamports) pagados por cada
CU solicitada. Puedes pensar en el precio de CU como una propina para alentar al
validador a priorizar tu transacción. Para establecer el precio de CU, incluye
una instrucción
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
en tu transacción.

<Callout>
  El precio de CU predeterminado es 0, lo que significa que la tarifa de
  priorización predeterminada también es 0.
</Callout>

Para ayuda en determinar el mejor precio de CU para tu transacción, consulta la
recomendación de precio de CU en tiempo real proporcionada en la tabla a
continuación.

| Proveedor                               | API de tarifa de prioridad                                                        |
| --------------------------------------- | --------------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [Documentación](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Documentación](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Documentación](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Ejemplo

Los ejemplos a continuación muestran cómo establecer el límite de CU y el precio
de CU en una transacción usando los SDK de Solana.

| SDK                            | Referencia de código fuente                                                                                                    |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
