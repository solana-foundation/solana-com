---
title: Ejecución diferida
description:
  "Firma transacciones ahora, ejecútalas después: habilitando flujos de
  aprobación, operaciones de tesorería y firma segura"
---

Cada transacción de Solana incluye un blockhash reciente, una referencia a un
estado reciente de la red que demuestra que la transacción se creó "ahora". La
red rechaza cualquier transacción con un blockhash anterior a ~150 bloques
(~60-90 segundos), previniendo ataques de repetición y envíos obsoletos. Esto
funciona perfectamente para pagos en tiempo real. Pero rompe los flujos de
trabajo que necesitan un intervalo entre la firma y el envío, tales como:

| Escenario                        | Por qué fallan las transacciones estándar                                            |
| -------------------------------- | ------------------------------------------------------------------------------------ |
| **Operaciones de tesorería**     | El CFO en Tokio firma, el controlador en NYC aprueba: 90 segundos no son suficientes |
| **Flujos de cumplimiento**       | Las transacciones necesitan revisión legal/de cumplimiento antes de la ejecución     |
| **Firma en almacenamiento frío** | Las máquinas aisladas requieren transferencia manual de transacciones firmadas       |
| **Preparación por lotes**        | Preparar nómina o desembolsos en horario laboral, ejecutar durante la noche          |
| **Coordinación multi-firma**     | Múltiples aprobadores en diferentes zonas horarias                                   |
| **Pagos programados**            | Programar pagos para ejecutarse en una fecha futura                                  |

En las finanzas tradicionales, un cheque firmado no expira en 90 segundos.
Ciertas operaciones de blockchain tampoco deberían hacerlo. Los **nonces
duraderos** resuelven esto reemplazando el blockhash reciente con un valor
almacenado y persistente que solo avanza cuando lo usas, dándote transacciones
que permanecen válidas hasta que estés listo para enviarlas.

## Cómo funciona

En lugar de un blockhash reciente (válido ~150 bloques), usas una **cuenta
nonce**, una cuenta especial que almacena un valor _único_. Cada transacción que
usa este nonce debe "avanzarlo" como primera instrucción, previniendo ataques de
repetición.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  STANDARD BLOCKHASH                                                         │
│                                                                             │
│    ┌──────┐      ┌──────────┐                                               │
│    │ Sign │ ───▶ │  Submit  │     ⏱️ Must happen within ~90 seconds         │
│    └──────┘      └──────────┘                                               │
│       │                                                                     │
│       └─────────  Transaction expires if not submitted in time              │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  DURABLE NONCE                                                              │
│                                                                             │
│    ┌──────┐      ┌───────┐       ┌─────────┐      ┌──────────┐              │
│    │ Sign │ ───▶ │ Store │ ───▶  │ Approve │ ───▶ │  Submit  │              │
│    └──────┘      └───────┘       └─────────┘      └──────────┘              │
│                                                                             │
│    Transaction remains valid until you submit it                            │
└─────────────────────────────────────────────────────────────────────────────┘
```

<Callout type="info">
  La cuenta nonce cuesta ~0.0015 SOL para la exención de rent. Una cuenta nonce
  = una transacción pendiente a la vez. Para flujos de trabajo paralelos, crea
  múltiples cuentas nonce.
</Callout>

## Configuración: crear una cuenta nonce

Crear una cuenta nonce requiere dos instrucciones en una sola transacción:

1. **Crear la cuenta** usando `getCreateAccountInstruction` del System Program
2. **Inicializarla como nonce** usando `getInitializeNonceAccountInstruction`

```ts
import { generateKeyPairSigner } from "@solana/kit";
import {
  getNonceSize,
  getCreateAccountInstruction,
  getInitializeNonceAccountInstruction,
  SYSTEM_PROGRAM_ADDRESS
} from "@solana-program/system";

// Generate a keypair for the nonce account address
const nonceKeypair = await generateKeyPairSigner();

// Get required account size for rent calculation
const space = BigInt(getNonceSize());

// 1. Create the account (owned by System Program)
getCreateAccountInstruction({
  payer,
  newAccount: nonceKeypair,
  lamports: rent,
  space,
  programAddress: SYSTEM_PROGRAM_ADDRESS
});

// 2. Initialize as nonce account
getInitializeNonceAccountInstruction({
  nonceAccount: nonceKeypair.address,
  nonceAuthority: authorityAddress // Controls nonce advancement
});

// Assemble and send transaction to the network
```

## Construir una transacción diferida

En lugar de un blockhash reciente, usa el valor del nonce como el tiempo de vida
de la transacción. Para hacer esto, primero debemos obtener el valor del nonce
de la cuenta de nonce y luego usarlo para establecer el tiempo de vida de la
transacción.

### Obtener el valor del nonce

Primero, obtén el valor del nonce de la cuenta de nonce:

```ts
import { fetchNonce } from "@solana-program/system";

const nonceAccount = await fetchNonce(rpc, nonceAddress);
const nonceValue = nonceAccount.data.blockhash; // Use this as your "blockhash"
```

### Establecer el tiempo de vida de la transacción con nonce

En lugar de usar un blockhash reciente que expira, usa
`setTransactionMessageLifetimeUsingDurableNonce`. Esta función hace dos cosas:

1. Establece el valor del nonce como el "blockhash" de la transacción
2. Antepone automáticamente la instrucción `advanceNonceAccount` (requerida como
   la primera instrucción en todas las transacciones de nonce duradero)

```ts
import {
  setTransactionMessageLifetimeUsingDurableNonce,
  type Nonce
} from "@solana/kit";

setTransactionMessageLifetimeUsingDurableNonce(
  {
    nonce: nonceAccount.data.blockhash as Nonce,
    nonceAccountAddress: nonceAddress,
    nonceAuthorityAddress: authorityAddress
  },
  transactionMessage
);
```

## Firmar y almacenar

Después de construir, firma la transacción y serialízala para almacenarla:

```ts
import {
  signTransactionMessageWithSigners,
  getBase64EncodedWireTransaction
} from "@solana/kit";

// Sign the transaction
const signedTx = await signTransactionMessageWithSigners(transactionMessage);

// Serialize for storage (database, file, etc.)
const serialized = getBase64EncodedWireTransaction(signedTx);
```

Almacena la cadena serializada en tu base de datos: permanece válida hasta que
el nonce sea avanzado.

## Flujo de trabajo de aprobación multipartita

Deserializa la transacción para agregar firmas adicionales, luego serializa
nuevamente para almacenarla o enviarla:

```ts
import {
  getBase64Decoder,
  getTransactionDecoder,
  getBase64EncodedWireTransaction,
  partiallySignTransaction
} from "@solana/kit";

// Deserialize the stored transaction
const txBytes = getBase64Decoder().decode(serializedString);
const partiallySignedTx = getTransactionDecoder().decode(txBytes);

// Each approver adds their signature
const fullySignedTx = await partiallySignTransaction(
  [newSigner],
  partiallySignedTx
);

// Serialize again for storage or submission
const serialized = getBase64EncodedWireTransaction(fullySignedTx);
```

La transacción puede ser serializada, almacenada y pasada entre aprobadores. Una
vez que se recopilen todas las firmas requeridas, envíala a la red.

## Ejecutar cuando esté listo

Cuando las aprobaciones estén completas, envía la transacción serializada a la
red:

```ts
const signature = await rpc
  .sendTransaction(serializedTransaction, { encoding: "base64" })
  .send();
```

<Callout type="caution">
  Cada nonce solo puede usarse una vez. Si una transacción falla o decides no
  enviarla, debes avanzar el nonce antes de preparar otra transacción con la
  misma cuenta de nonce.
</Callout>

## Avanzar un nonce usado o abandonado

Para invalidar una transacción pendiente o preparar el nonce para reutilizarlo,
avánzalo manualmente:

```ts
import { getAdvanceNonceAccountInstruction } from "@solana-program/system";

// Submit this instruction (with a regular blockhash) to invalidate any pending transaction
getAdvanceNonceAccountInstruction({
  nonceAccount: nonceAddress,
  nonceAuthority
});
```

Esto genera un nuevo valor de nonce, haciendo que cualquier transacción firmada
con el valor antiguo sea permanentemente inválida.

## Consideraciones de producción

**Gestión de cuentas nonce:**

- Crea un grupo de cuentas nonce para la preparación paralela de transacciones
- Rastrea qué nonces están "en uso" (tienen transacciones firmadas pendientes)
- Implementa el reciclaje de nonces después de que las transacciones se envíen o
  abandonen

**Seguridad:**

- La autoridad del nonce controla si las transacciones pueden invalidarse.
  Considera separar la autoridad del nonce de los firmantes de transacciones
  para obtener control adicional y separación de funciones
- _Cualquiera_ con los bytes de transacción serializados puede enviarla a la red

## Recursos relacionados

- [Introducción a los nonces duraderos](https://solana.com/developers/guides/advanced/introduction-to-durable-nonces)
