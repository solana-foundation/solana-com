---
title: Preparaci√≥n para producci√≥n
description: Pasar de las pruebas en devnet al despliegue en mainnet
---

Construir localmente y probar en devnet son excelentes formas de comenzar con
los pagos en Solana. Sin embargo, cuando est√©s listo para desplegar en mainnet,
debes conocer los matices de mainnet. Devnet perdona los errores. Mainnet no.
Esta gu√≠a cubre las diferencias que importan para garantizar que tus usuarios
tengan una experiencia fluida.

| Devnet                                    | Mainnet                                                                                           |
| ----------------------------------------- | ------------------------------------------------------------------------------------------------- |
| SOL gratis desde faucets                  | [Adquiere SOL real](https://solana.com/ecosystem/explore?categories=exchange) para las comisiones |
| Baja competencia por espacio de bloque    | Las comisiones de prioridad importan                                                              |
| Las transacciones se confirman f√°cilmente | La configuraci√≥n de transacciones es cr√≠tica                                                      |
| El RPC p√∫blico est√° bien                  | Se requiere RPC de producci√≥n                                                                     |
| Keypairs y mints de devnet                | Claves y mints de tokens diferentes‚Äîactualiza tu configuraci√≥n                                    |

## Infraestructura RPC

Los
[endpoints p√∫blicos](https://solana.com/docs/references/clusters#solana-public-rpc-endpoints)
(`api.mainnet-beta.solana.com`) tienen l√≠mites de tasa sin SLA. Est√°n bien para
desarrollo pero fallar√°n en flujos de pago de producci√≥n‚Äîcomo intentar ejecutar
un procesador de pagos a trav√©s de una API compartida sin garant√≠a de tiempo de
actividad.

<Callout type="caution" title="Nunca uses RPC p√∫blico para producci√≥n">
  Usa un [proveedor de RPC privado](https://solana.com/rpc) para acceso
  confiable y de baja latencia.
</Callout>

Al elegir un proveedor de RPC, busca:

- **Confiabilidad**: SLAs con garant√≠as de tiempo de actividad (99.9%+)
- **Latencia**: Proximidad geogr√°fica a tus usuarios
- **Caracter√≠sticas**: Funciones de confirmaci√≥n de transacciones, indexaci√≥n,
  APIs de comisiones de prioridad

Para una lista completa de proveedores de RPC, consulta la gu√≠a de
[proveedores de infraestructura RPC](https://solana.com/rpc).

### Configuraci√≥n redundante de RPC

Como cualquier proveedor de servicios de red, los proveedores de RPC pueden
experimentar tiempo de inactividad o per√≠odos de rendimiento degradado. Para
garantizar que tu aplicaci√≥n sea resiliente, debes configurar tu aplicaci√≥n para
usar m√∫ltiples proveedores de RPC.

[Solana Kit](https://github.com/anza-xyz/kit/tree/main/packages/rpc-transport-http)
proporciona una biblioteca para personalizar transportes RPC que te permite
construir tu propio cliente RPC redundante. Aqu√≠ hay un ejemplo de c√≥mo podr√≠as
usarlo para construir un cliente RPC redundante:

```ts
import { RpcTransport } from "@solana/rpc-spec";
import { RpcResponse } from "@solana/rpc-spec-types";
import { createHttpTransport } from "@solana/rpc-transport-http";

// Create a transport for each RPC server
const transports = [
  createHttpTransport({ url: "https://mainnet-beta.my-server-1.com" }),
  createHttpTransport({ url: "https://mainnet-beta.my-server-2.com" }),
  createHttpTransport({ url: "https://mainnet-beta.my-server-3.com" })
];

// Create a wrapper transport that distributes requests to them
let nextTransport = 0;
async function roundRobinTransport<TResponse>(
  ...args: Parameters<RpcTransport>
): Promise<RpcResponse<TResponse>> {
  const transport = transports[nextTransport];
  nextTransport = (nextTransport + 1) % transports.length;
  return await transport(...args);
}
```

Si prefieres no construir tus propias herramientas de enrutamiento, puedes
aprovechar un servicio de terceros como
[Iron Forge](https://www.ironforge.sanctum.so/) para gestionar el enrutamiento
por ti.

## Aterrizaje de transacciones

En Devnet, las transacciones aterrizan con bastante facilidad. En Mainnet, est√°s
compitiendo por espacio de bloque. Para aumentar las posibilidades de que tu
transacci√≥n sea incluida en un bloque, debes asegurarte de haber ensamblado
correctamente tu transacci√≥n. Esto significa:

- incluir un blockhash reciente antes de enviar la transacci√≥n
- incluir una instrucci√≥n de tarifa de prioridad en la transacci√≥n con una
  tarifa de prioridad competitiva
- incluir una instrucci√≥n de l√≠mite de unidades de c√≥mputo en la transacci√≥n con
  un l√≠mite de unidades de c√≥mputo basado en las unidades de c√≥mputo estimadas
  requeridas para la transacci√≥n

Adem√°s, debes considerar otras herramientas como Jito Bundles para aumentar las
posibilidades de que tu transacci√≥n sea incluida en un bloque. Exploremos estas
herramientas con m√°s detalle.

### Configuraci√≥n de env√≠o de transacciones

Al enviar transacciones en Mainnet, configura estos par√°metros para tasas de
aterrizaje √≥ptimas:

**Gesti√≥n de blockhash:**

- Obt√©n con `confirmed` commitment
- Almacena el `lastValidBlockHeight` devuelto por `getLatestBlockhash`‚Äîesto te
  indica cu√°ndo expira tu transacci√≥n
- Los blockhashes expiran despu√©s de ~150 bloques (~60-90 segundos)

**Opciones de env√≠o:**

- `maxRetries: 0` ‚Äî Desactiva los reintentos autom√°ticos de RPC. Gestiona los
  reintentos t√∫ mismo para poder actualizar el blockhash cuando sea necesario.
- `skipPreflight: true` ‚Äî Omite la simulaci√≥n antes de enviar. Usa esto cuando
  ya hayas validado la transacci√≥n y quieras la menor latencia. Mantenlo en
  `false` durante el desarrollo para detectar errores temprano.

```typescript
import { createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc(process.env.RPC_URL!);

// 1. Get blockhash with confirmed commitment
const { value: latestBlockhash } = await rpc
  .getLatestBlockhash({ commitment: "confirmed" })
  .send();

// 2. Build and sign your transaction with the blockhash
// ... (transaction building code)

// 3. Send with production settings
const signature = await rpc
  .sendTransaction(encodedTransaction, {
    encoding: "base64",
    maxRetries: 0n, // Handle retries yourself
    skipPreflight: true, // Skip simulation for speed (use false during dev)
    preflightCommitment: "confirmed"
  })
  .send();

// 4. Track expiration using lastValidBlockHeight
const { lastValidBlockHeight } = latestBlockhash;
// Stop retrying when current block height exceeds lastValidBlockHeight
```

### Usa tarifas de prioridad

Cada transacci√≥n de Solana requiere una tarifa de transacci√≥n, pagada en SOL.
Las tarifas de transacci√≥n se dividen en dos partes: la tarifa base y la tarifa
de prioridad. La tarifa base compensa a los validadores por procesar la
transacci√≥n. La tarifa de prioridad es una tarifa opcional para aumentar la
probabilidad de que el l√≠der actual procese tu transacci√≥n. Piensa en ello como
env√≠o expr√©s: pagas m√°s por una entrega m√°s r√°pida y confiable.

**C√≥mo funcionan las tarifas:**

```
Total fee = Base fee (5,000 lamports per signature) + Priority fee
Priority fee = Compute units x Price per unit (micro-lamports per compute unit)
```

**Costos reales:**

- Transferencia simple de USDC: ~$0.001-0.005 durante condiciones normales
- Durante congesti√≥n: ~$0.01-0.05
- Congesti√≥n m√°xima: puede aumentar m√°s

**Implementaci√≥n de ejemplo:**

El paquete
[`@solana-program/compute-budget`](https://github.com/solana-program/compute-budget)
proporciona una funci√≥n auxiliar para actualizar o agregar f√°cilmente la
instrucci√≥n de precio de unidad de c√≥mputo (en micro-lamports) a una
transacci√≥n.

```typescript
import { updateOrAppendSetComputeUnitPriceInstruction } from "@solana-program/compute-budget";

const tx = pipe(
  createTransactionMessage({ version: 0 }),
  (m) => setTransactionMessageFeePayerSigner(payer, m),
  (m) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, m),
  (m) => appendTransactionMessageInstructions([myInstructions], m),
  (m) => updateOrAppendSetComputeUnitPriceInstruction(1000n as MicroLamports, m)
);
```

**Obtener estimaciones de tarifas:** la mayor√≠a de los proveedores de RPC
ofrecen APIs de tarifas de prioridad:

- [Helius Priority Fee API](https://docs.helius.dev/solana-apis/priority-fee-api)
- [QuickNode Priority Fee Add-on](https://marketplace.quicknode.com/add-on/solana-priority-fee)
- [Triton Priority Fees API](https://docs.triton.one/chains/solana/improved-priority-fees-api)

Para conocer la mec√°nica completa de las tarifas, consulta
[Tarifas de transacci√≥n](/docs/core/fees) y nuestra gu√≠a:
[C√≥mo agregar tarifas de prioridad a una transacci√≥n](https://solana.com/developers/cookbook/transactions/add-priority-fees).

### Optimiza las unidades de c√≥mputo

El c√≥mputo en Solana es efectivamente una medida de la cantidad de trabajo que
est√° realizando el programa. Hay un l√≠mite en la cantidad de c√≥mputo que se
puede usar en una transacci√≥n (actualmente 1.4 millones de unidades de c√≥mputo),
y un l√≠mite en la cantidad de c√≥mputo que se puede usar por cuenta por bloque
(actualmente 100 millones de unidades de c√≥mputo).

Cuando env√≠as una transacci√≥n, necesitas estimar la cantidad de c√≥mputo que se
utilizar√° y establecer el l√≠mite de unidades de c√≥mputo en consecuencia; esto es
efectivamente una solicitud de cu√°nta capacidad total debe reservarse para tu
transacci√≥n. En la pr√°ctica, esto significa que estimar correctamente las
unidades de c√≥mputo requeridas para tu transacci√≥n es fundamental para que tu
transacci√≥n se incluya en un bloque (e importante para gestionar tus tarifas de
prioridad).

La API JSON RPC de Solana tiene un m√©todo
[`simulatetransaction`](/docs/rpc/http/simulatetransaction) que se puede
utilizar para estimar las unidades de c√≥mputo requeridas para una transacci√≥n,
lo que incluye una estimaci√≥n de las unidades de c√≥mputo que se utilizar√°n. El
paquete
[`@solana-program/compute-budget`](https://github.com/solana-program/compute-budget)
proporciona una funci√≥n auxiliar para estimar f√°cilmente las unidades de c√≥mputo
requeridas para una transacci√≥n (que utiliza el m√©todo `simulatetransaction`
internamente).

```ts
import {
  estimateComputeUnitLimitFactory,
  updateOrAppendSetComputeUnitLimitInstruction
} from "@solana-program/compute-budget";

const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });
const computeUnitLimit = await estimateComputeUnitLimit(tx);
const txWithComputeUnitLimit = updateOrAppendSetComputeUnitLimitInstruction(
  computeUnitLimit,
  tx
);
```

En producci√≥n, si est√°s repitiendo el mismo tipo de transacci√≥n varias veces,
deber√≠as considerar almacenar en cach√© la estimaci√≥n de c√≥mputo para el tipo de
transacci√≥n para evitar la sobrecarga de estimar las unidades de c√≥mputo cada
vez.

### Bundles de Jito

Los bundles de Jito son una herramienta para gestionar la ejecuci√≥n at√≥mica de
m√∫ltiples transacciones. Esto se logra enviando m√∫ltiples transacciones a la red
Jito con una propina. Las propinas se pueden utilizar para incentivar a la red
Jito a incluir tus transacciones en un bloque.

**Recursos:**

- [Documentaci√≥n de Jito](https://docs.jito.wtf/lowlatencytxnsend/)
- [üé• Video: Bundles de Jito](https://www.youtube.com/watch?v=HZ1pK9i6zx4)
- [Gu√≠a de QuickNode sobre bundles de Jito](https://www.quicknode.com/guides/solana-development/transactions/jito-bundles)

### Estrategias de reintento

Las transacciones pueden fallar por muchas razones. A diferencia de las APIs de
pago tradicionales que devuelven √©xito/fallo inmediatamente, las transacciones
blockchain requieren seguimiento de confirmaci√≥n.

**Conceptos clave:**

- **Expiraci√≥n del blockhash**: las transacciones son v√°lidas durante ~150
  bloques (~60-90 segundos)
- **Idempotencia**: la misma transacci√≥n firmada siempre produce la misma
  firma‚Äîreenviarla es seguro
- **Retroceso exponencial**: evita saturar la red con reintentos r√°pidos

```typescript
import {
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  sendAndConfirmTransactionFactory,
  isSolanaError,
  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED
} from "@solana/kit";

const rpc = createSolanaRpc(process.env.RPC_URL!);
const rpcSubscriptions = createSolanaRpcSubscriptions(process.env.RPC_WSS_URL!);

const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({
  rpc,
  rpcSubscriptions
});

// Send with automatic confirmation tracking and block height monitoring
try {
  await sendAndConfirmTransaction(signedTransaction, {
    commitment: "confirmed",
    // Optional: abort after 75 seconds
    abortSignal: AbortSignal.timeout(75_000)
  });
} catch (e) {
  if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {
    // Blockhash expired‚Äîrebuild transaction with fresh blockhash and retry
    rebuildAndRetryTransaction(); // implement your own logic for rebuilding and retrying the transaction
  }
  throw e;
}
```

El `sendAndConfirmTransactionFactory` de `@solana/kit` maneja el sondeo de
confirmaci√≥n y el seguimiento de altura de bloque autom√°ticamente. Lanza
`SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED` cuando el blockhash de la transacci√≥n
expira, se√±alando que necesitas reconstruir la transacci√≥n con un blockhash
nuevo.

### Recursos adicionales

- [Gu√≠a: Confirmaci√≥n y expiraci√≥n de transacciones](https://solana.com/developers/guides/advanced/confirmation)
- [Helius: C√≥mo ejecutar transacciones en Solana](https://www.helius.dev/blog/how-to-land-transactions-on-solana)
- [QuickNode: Estrategias para optimizar transacciones en Solana](https://www.quicknode.com/docs/solana/transactions)

## Comprender los niveles de confirmaci√≥n

Solana ofrece tres niveles de confirmaci√≥n. En t√©rminos de finanzas
tradicionales:

| Nivel       | Definici√≥n en Solana        | Equivalente tradicional | Caso de uso                          |
| ----------- | --------------------------- | ----------------------- | ------------------------------------ |
| `processed` | En un bloque, a√∫n sin votar | Autorizaci√≥n pendiente  | Actualizaciones de UI en tiempo real |
| `confirmed` | Votado por supermayor√≠a     | Fondos compensados      | **La mayor√≠a de pagos**              |
| `finalized` | Enraizado, irreversible     | Fondos liquidados       | Alto valor, cumplimiento normativo   |

**Cu√°ndo usar cada uno:**

- **Actualizaciones de UI**: Mostrar `processed` para retroalimentaci√≥n
  inmediata ("Pago enviado")
- **Acreditar cuenta de usuario**: Esperar `confirmed` (seguro para la mayor√≠a
  de transacciones)
- **Enviar bienes f√≠sicos**: Esperar `finalized`
- **Retiros grandes**: Esperar `finalized`
- **Cumplimiento normativo/auditor√≠a**: Siempre registrar el estado `finalized`

Para m√°s informaci√≥n sobre c√≥mo verificar el estado de las transacciones,
consulta [Interactuar con Solana](/docs/payments/interacting-with-solana).

## Manejo de errores

Solana Kit proporciona errores tipados mediante `isSolanaError()`. Usa c√≥digos
de error espec√≠ficos en lugar de coincidencia de cadenas:

```typescript
import {
  isSolanaError,
  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,
  SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,
  SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,
  SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS
} from "@solana/kit";

function handlePaymentError(error: unknown): {
  message: string;
  retryable: boolean;
} {
  // Blockhash expired‚Äîrebuild and retry
  if (
    isSolanaError(error, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED) ||
    isSolanaError(error, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND)
  ) {
    return { message: "Transaction expired‚Äîrebuilding", retryable: true };
  }

  // Insufficient SOL for fees
  if (
    isSolanaError(
      error,
      SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE
    )
  ) {
    return { message: "Not enough SOL for fees", retryable: false };
  }

  // Insufficient token balance
  if (
    isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS)
  ) {
    return { message: "Insufficient balance", retryable: false };
  }

  // Unknown error
  console.error("Payment error:", error);
  return { message: "Payment failed‚Äîplease retry", retryable: true };
}
```

**C√≥digos de error comunes:**

| C√≥digo de error              | Causa                    | Recuperaci√≥n                                                                                                                        |
| ---------------------------- | ------------------------ | ----------------------------------------------------------------------------------------------------------------------------------- |
| `BLOCK_HEIGHT_EXCEEDED`      | Blockhash expirado       | Reconstruir con blockhash actualizado                                                                                               |
| `BLOCKHASH_NOT_FOUND`        | Blockhash no encontrado  | Reconstruir con blockhash actualizado                                                                                               |
| `INSUFFICIENT_FUNDS_FOR_FEE` | SOL insuficiente         | Financiar pagador de comisiones o usar [abstracci√≥n de comisiones](/docs/payments/send-payments/payment-processing/fee-abstraction) |
| `INSUFFICIENT_FUNDS`         | Tokens insuficientes     | El usuario necesita m√°s saldo                                                                                                       |
| `ACCOUNT_NOT_FOUND`          | Cuenta de token faltante | Crear ATA en la transacci√≥n                                                                                                         |

## Transacciones sin comisiones

Los usuarios esperan pagar en stablecoins, no adquirir SOL para las comisiones
de red. Las transacciones sin comisiones resuelven esto, similar a c√≥mo los
usuarios de Venmo no piensan en las comisiones ACH. Consulta
[Abstracci√≥n de comisiones](/docs/payments/send-payments/payment-processing/fee-abstraction)
para la implementaci√≥n completa.

## Seguridad

### Gesti√≥n de claves

- **Nunca expongas claves privadas en el c√≥digo frontend.** Usa firma en
  backend, wallets de hardware, wallets multifirma o servicios de gesti√≥n de
  claves.
- **Separa wallets calientes y fr√≠as.** Wallet caliente para operaciones, fr√≠a
  para tesorer√≠a.
- **Haz copias de seguridad de todas las claves de producci√≥n.** Almacena copias
  de seguridad cifradas en m√∫ltiples ubicaciones seguras. Perder una clave
  significa perder el acceso permanentemente.
- **Usa claves diferentes para devnet y mainnet.** Tus claves de devnet no
  deber√≠an ser tus claves de mainnet. Usa configuraci√≥n basada en entorno para
  asegurar que se carguen las claves correctas para cada red.

### Seguridad de RPC

Trata los endpoints de RPC como claves de API: no los expongas en el c√≥digo
frontend donde pueden ser extra√≠dos y abusados. Usa un proxy de backend o
variables de entorno que no se incluyan en el c√≥digo del cliente.

- [QuickNode: pr√°cticas recomendadas de seguridad de endpoints](https://www.quicknode.com/guides/quicknode-products/endpoint-security/endpoint-security-best-practices)
- [Helius: protege tus claves de API de Solana: pr√°cticas recomendadas de seguridad](https://www.helius.dev/docs/rpc/protect-your-keys)

### Monitoreo

Rastrea estas m√©tricas en producci√≥n:

| M√©trica                        | Por qu√©                     |
| ------------------------------ | --------------------------- |
| Tasa de √©xito de transacciones | Detectar problemas temprano |
| Latencia de confirmaci√≥n       | Monitorear salud de la red  |
| Gasto en comisi√≥n prioritaria  | Gesti√≥n de costos           |
| Tasa de error de RPC           | Salud del proveedor         |

Configura alertas para:

- Transferencias por encima del umbral desde tesorer√≠a
- Picos en la tasa de transacciones fallidas
- Patrones inusuales de destinatarios
- Aumentos en la tasa de error de RPC

Para monitoreo de transacciones en tiempo real a escala, consulta nuestra
[gu√≠a de indexaci√≥n](/docs/payments/accept-payments/indexing).

### Verificar direcciones

Cada token y programa tiene exactamente una direcci√≥n correcta en mainnet. Los
tokens falsificados que imitan USDC u otras stablecoins son comunes: tendr√°n el
mismo nombre y s√≠mbolo pero un mint diferente. Tu aplicaci√≥n debe codificar de
forma fija o incluir en una lista de permitidos las direcciones de mint (seg√∫n
tus requisitos), nunca aceptarlas din√°micamente de fuentes no confiables.

**Configuraci√≥n basada en entorno:** Devnet y Mainnet a menudo usan mints de
tokens completamente diferentes. Configura tu aplicaci√≥n para cargar las
direcciones correctas por entorno: no codifiques de forma fija las direcciones
de mainnet y olvides cambiarlas durante las pruebas, o peor a√∫n, env√≠es
direcciones de devnet a producci√≥n.

Algunos mints de stablecoins comunes son:

| Token | Emisor | Direcci√≥n de mint                              |
| ----- | ------ | ---------------------------------------------- |
| USDC  | Circle | `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v` |
| USDT  | Tether | `Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB` |
| PYUSD | PayPal | `2b1kV6DkPAnxd5ixfnxCpjxmKwqjjaYmCZfHsFu24GXo` |
| USDG  | Paxos  | `2u1tszSeqZ3qBWF3uNGPFc8TzMk2tdiwknnRMWGWjGWH` |

Las direcciones de programas tambi√©n importan. Enviar instrucciones al programa
incorrecto fallar√°, o peor a√∫n, resultar√° en p√©rdida irreversible de fondos. Las
direcciones del Token Program son:

| Programa           | Direcci√≥n                                     |
| ------------------ | --------------------------------------------- |
| Token Program      | `TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA` |
| Token-2022 Program | `TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb` |

## Lista de verificaci√≥n previa al lanzamiento

- [ ] SOL de mainnet adquirido para comisiones y rent
- [ ] RPC de producci√≥n configurado (no endpoint p√∫blico)
- [ ] Endpoint RPC de respaldo configurado
- [ ] Comisiones de prioridad implementadas con precios din√°micos
- [ ] L√≥gica de reintentos maneja expiraci√≥n de blockhash
- [ ] Nivel de confirmaci√≥n apropiado para el caso de uso
- [ ] Todos los errores comunes manejados correctamente
- [ ] Gasless configurado (si aplica)
- [ ] Direcciones de tokens de mainnet verificadas (no mints de devnet)
- [ ] Todas las claves respaldadas de forma segura
- [ ] Gesti√≥n de claves revisada (sin claves en frontend)
- [ ] Monitoreo de transacciones y alertas activos
- [ ] Pruebas de carga realizadas al volumen esperado

## Despliegue de programas

Si est√°s desplegando un programa personalizado de Solana como parte de tu
infraestructura de pagos, hay consideraciones adicionales.

### Pre-despliegue

- **Versi√≥n de Solana CLI:** Aseg√∫rate de estar usando la √∫ltima versi√≥n de
  [Solana CLI](https://solana.com/docs/intro/installation).
- **Keypair del programa:** Tu programa tendr√° una direcci√≥n diferente en
  mainnet que en devnet (a menos que est√©s reutilizando el mismo keypair).
  Actualiza todas las referencias en la configuraci√≥n de tu aplicaci√≥n. Almacena
  tu keypair del programa en una ubicaci√≥n segura (ten en cuenta que ejecutar
  `cargo clean` probablemente eliminar√° tu keypair del programa).
- **Inicializar cuentas:** Si tu programa requiere cuentas de administrador,
  PDAs u otras cuentas de estado, aseg√∫rate de que est√©n creadas en mainnet
  antes de que los usuarios interact√∫en con tu aplicaci√≥n. Lo mismo para
  cualquier cuenta de token asociada (ATA) que tu programa necesite.

### Proceso de despliegue

- **Cuentas buffer:** Los programas grandes se despliegan mediante cuentas
  buffer. El comando `solana program deploy` maneja esto autom√°ticamente, pero
  entiende que el despliegue no es at√≥mico: si se interrumpe, es posible que
  necesites recuperar o cerrar cuentas buffer. Consulta
  [Deploying Programs](https://solana.com/docs/programs/deploying).
- **Autoridad de actualizaci√≥n:** Decide si tu programa debe ser actualizable
  despu√©s del lanzamiento. Para inmutabilidad, revoca la autoridad de
  actualizaci√≥n despu√©s del despliegue. Para flexibilidad, asegura la clave de
  autoridad de actualizaci√≥n apropiadamente.
- **Renta:** Aseg√∫rate de que tu billetera de despliegue tenga suficiente SOL
  para cubrir los m√≠nimos exentos de renta para todas las cuentas del programa.
- **Verificaci√≥n:** [Verifica](https://solana.com/docs/programs/verified-builds)
  tu programa para asegurar que el programa ejecutable que despliegas en la red
  de Solana coincida con el c√≥digo fuente en tu repositorio

Para una gu√≠a completa sobre el despliegue de programas, consulta
[Deploying Programs](https://solana.com/docs/programs/deploying).
