---
title: "@solana/client"
description:
  Construa frontends Solana enxutos com o runtime de cliente Solana headless.
---

`@solana/client` mantém a superfície do runtime enxuta. Uma store, uma pilha RPC
e um registro de carteiras alimentam os diferentes auxiliares para que a mesma
instância possa suportar CLIs, scripts ou UIs completas. Actions, watchers e
helpers compartilham cache, subscrições e sessões de carteira através desse
único cliente.

<Callout type="info">
  Quando você está construindo uma experiência puramente React, geralmente é
  mais rápido começar com [`@solana/react-hooks`](/docs/frontend/react-hooks). O
  pacote de hooks envolve este mesmo runtime de cliente e expõe hooks prontos
  para que você só precise recorrer ao cliente headless quando precisar de
  controle extra.
</Callout>

## Instalar

```terminal
$ npm install @solana/client
```

Use qualquer gerenciador de pacotes; o cliente executa em navegadores, workers,
React, Svelte ou runtimes do lado do servidor.

## Criar um cliente uma vez

Escolha conectores Wallet Standard (descoberta automática é a forma mais rápida
de começar), depois crie o cliente. Este único objeto expõe a store, actions,
watchers e helpers.

```ts
import { autoDiscover, createClient } from "@solana/client";

const client = createClient({
  endpoint: "https://api.devnet.solana.com",
  websocketEndpoint: "wss://api.devnet.solana.com",
  walletConnectors: autoDiscover()
});

await client.actions.connectWallet("wallet-standard:phantom");
const balance = await client.actions.fetchBalance("Fke...address");
console.log(balance.lamports?.toString());
```

A store do cliente rastreia configuração de cluster, subscrições, transações
pendentes e sessões de carteira. Você pode fornecer sua própria store Zustand se
precisar de persistência ou coordenação multi-abas.

## Orquestração de carteiras

Conectores encapsulam metadados do Wallet Standard além da lógica de
conectar/desconectar. Registre os helpers integrados `phantom()`, `solflare()`,
`backpack()` ou `autoDiscover()`, ou envolva provedores personalizados com
`createWalletStandardConnector`. Todas as ações de carteira (conectar,
desconectar, assinar, enviar) fluem através do registro do cliente para que
todos os consumidores permaneçam sincronizados.

## Actions, watchers e helpers

- **Actions** envolvem leituras e escritas RPC comuns enquanto atualizam a store
  (por exemplo, `fetchAccount`, `requestAirdrop`, `setCluster`).
- **Watchers** multiplexam subscrições websocket, transmitem atualizações para a
  store e fornecem handles de abort para limpeza.
- **Helpers** expõem fluxos de nível superior, como transferências SOL, helpers
  de token SPL, polling de assinatura e pools de transação.

```ts
const abortWatcher = client.watchers.watchBalance(
  { address: "Fke...address" },
  (lamports) => {
    console.log("live balance", lamports.toString());
  }
);

// Later when the component unmounts or the flow ends
abortWatcher.abort();
```

## Padrão de auxiliar de transação

O auxiliar de transação gerencia a atualização do blockhash, resolução do
pagador de taxas e assinatura. Você pode preparar, inspecionar e enviar com a
experiência de usuário que preferir.

```ts
const prepared = await client.helpers.transaction.prepare({
  authority: client.store.getState().wallet.session!,
  instructions: [instructionA, instructionB]
});

await client.helpers.transaction.simulate(prepared, {
  commitment: "processed"
});
const signature = await client.helpers.transaction.send(prepared);
console.log("submitted", signature.toString());
```

Use `prepareAndSend` para um fluxo pré-construído (simulação mais registro) ou
chame `sign` / `toWire` para coletar assinaturas manualmente antes de
retransmitir o formato de transmissão você mesmo.

## Padrões comuns para desenvolvedores Solana

- **Máquinas de estado headless**: Execute o cliente dentro de rotas de API,
  scripts ou workers para reutilizar a mesma lógica de orquestração de
  carteira + RPC que alimenta sua interface.
- **Painéis em tempo real**: Combine observadores (saldos, contas, assinaturas)
  com sua biblioteca de interface preferida; o cliente gerencia a distribuição
  de websocket e invalidação de cache.
- **Stores personalizadas**: Injete sua própria store Zustand para hidratar a
  partir de IndexedDB/localStorage, espelhar estado para sessões de servidor ou
  coordenar entre abas do navegador.
- **Ponte para hooks React**: Passe uma instância de cliente configurada para
  `@solana/react-hooks` quando quiser hooks ergonómicos sobre o mesmo runtime.
- **Testabilidade**: A interface única do cliente pode ser simulada em testes
  unitários, facilitando a simulação de respostas RPC ou sessões de carteira sem
  uma carteira de navegador presente.
