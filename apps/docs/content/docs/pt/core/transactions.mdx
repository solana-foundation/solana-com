---
title: Transações
description:
  Aprenda sobre as transações da Solana—os blocos fundamentais para interagir
  com a blockchain Solana. Entenda a estrutura das transações e a composição de
  instruções com exemplos práticos.
---

Para interagir com a rede Solana, você deve enviar uma transação. Você pode
pensar em uma transação como um envelope que contém vários formulários. Cada
formulário é uma instrução que diz à rede o que fazer. Enviar a transação é como
enviar o envelope pelo correio para que os formulários possam ser processados.

O exemplo abaixo mostra uma versão simplificada de duas transações. Quando a
primeira transação é processada, ela executará uma única instrução. Quando a
segunda transação é processada, ela executará três instruções **em ordem
sequencial**: primeiro a instrução 1, seguida pela instrução 2, seguida pela
instrução 3.

<Callout type="warn">
  As transações são **atômicas**: Se uma única instrução falhar, toda a
  transação falhará e nenhuma alteração ocorrerá.
</Callout>

![Um diagrama simplificado mostrando duas transações](/assets/docs/core/transactions/transaction-simple.svg)

Uma
[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
consiste nas seguintes informações:

<WithMentions>

- [`signatures`](mention:signatures): um array de [assinaturas](#signatures)
- [`message`](mention:message): informações da transação, incluindo a lista de
  instruções a serem processadas

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![Diagrama mostrando as duas partes de uma transação](/assets/docs/core/transactions/tx_format.png)

As transações têm um limite de tamanho total de
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
bytes. Este limite inclui tanto o array [`signatures`](#signatures) quanto a
estrutura [`message`](#message).

<Callout>
  Este limite foi projetado para evitar a fragmentação de pacotes na
  infraestrutura típica da internet. Embora o IPv6 suporte MTUs maiores que 9000
  bytes, a maioria dos roteadores de internet usa um MTU padrão de 1500 bytes
  (Ethernet padrão). Para garantir que as transações caibam em um único pacote
  sem fragmentação, a Solana usa 1280 bytes (o MTU mínimo exigido para IPv6)
  menos 48 bytes para cabeçalhos de rede (40 bytes IPv6 + 8 bytes de cabeçalho
  de fragmento/UDP), resultando no limite de tamanho de transação de 1232 bytes.
</Callout>

![Diagrama mostrando o formato da transação e limites de tamanho](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## Assinaturas

O array `signatures` da transação contém estruturas `Signature`. Cada
[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
tem 64 bytes e é criada ao assinar o `Message` da transação com a chave privada
da conta. Uma assinatura deve ser fornecida para cada
[conta signatária](#account-addresses) incluída em qualquer uma das instruções
da transação.

A primeira assinatura pertence à conta que pagará a
[taxa base](docs/core/fees#base-fee) da transação e é a assinatura da transação.
A assinatura da transação pode ser usada para consultar os detalhes da transação
na rede.

## Mensagem

O `message` da transação é uma estrutura
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)
que contém as seguintes informações:

<WithMentions>

- [`header`](mention:message-header): o [cabeçalho](#header) da mensagem
- [`account_keys`](mention:account-addresses): um array de
  [endereços de contas](#account-addresses) necessários para as instruções da
  transação
- [`recent_blockhash`](mention:recent-blockhash): um
  [blockhash](#recent-blockhash) que funciona como um carimbo de data/hora para
  a transação
- [`instructions`](mention:instructions): um array de
  [instruções](#instructions)

<Callout>
  Para economizar espaço, a transação não armazena permissões para cada conta
  individualmente. Em vez disso, as permissões das contas são determinadas
  usando o `header` e `account_keys`.
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### Cabeçalho

<WithMentions>

O `header` da mensagem é uma estrutura
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97).
Ela contém as seguintes informações:

- [`num_required_signatures`](mention:num_required_signatures): o número total
  de assinaturas necessárias para a transação
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts): o
  número total de contas somente leitura que requerem assinaturas
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts): o
  número total de contas somente leitura que não requerem assinaturas

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![Diagrama mostrando as três partes do cabeçalho da mensagem](/assets/docs/core/transactions/message_header.png)

### Endereços de contas

O
[`account_keys`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
da mensagem é um array de endereços de contas, enviado em
[formato de array compacto](/docs/references/terminology#compact-array-format).
O prefixo do array indica o seu comprimento. Cada item no array é uma chave
pública, apontando para uma conta utilizada pelas suas instruções. O array
`accounts_keys` deve estar completo e estritamente ordenado, da seguinte forma:

1. Assinante + Gravável
2. Assinante + Somente leitura
3. Não assinante + Gravável
4. Não assinante + Somente leitura

<Callout>
  A ordenação estrita permite que o array `account_keys` seja combinado com a
  informação no [`header`](#header) da mensagem para determinar as permissões de
  cada conta.
</Callout>

![Diagrama mostrando a ordem do array de endereços de contas](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Blockhash recente

O `recent_blockhash` da mensagem é um valor hash que funciona como um carimbo
temporal da transação e previne transações duplicadas. Um blockhash expira após
[150 blocos](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134).
(Equivalente a um minuto—assumindo que cada bloco tem 400ms.) Após o bloco
expirar, a transação expira e não pode ser processada.

<Callout>
  O método RPC [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) permite
  obter o blockhash atual e a última altura de bloco na qual o blockhash será
  válido.
</Callout>

### Instruções

O
[`instructions`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
da mensagem é um array de todas as instruções a serem processadas, enviado em
[formato de array compacto](/docs/references/terminology#compact-array-format).
O prefixo do array indica o seu comprimento. Cada item no array é uma estrutura
[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
e inclui as seguintes informações:

<WithMentions>

1. [`program_id_index`](mention:program-id-index): Um índice que aponta para um
   endereço no array [`account_keys`](#account-addresses). Este valor indica o
   endereço do programa que processa a instrução.
2. [`accounts`](mention:account-indexes): Um array de índices que apontam para
   endereços no array `account_keys`. Cada índice aponta para o endereço de uma
   conta necessária para esta instrução.
3. [`data`](mention:instruction-data): Um array de bytes que especifica qual
   instrução invocar no programa. Também inclui quaisquer dados adicionais
   necessários pela instrução. (Por exemplo, argumentos de função)

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Array compacto de Instruções](/assets/docs/core/transactions/compact_array_of_ixs.png)

## Exemplo de estrutura de transação

O exemplo a seguir mostra a estrutura de uma transação que contém uma única
instrução de transferência de SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
O código abaixo mostra a saída dos snippets de código anteriores.
O formato difere entre SDKs,
mas observe que cada instrução contém as mesmas informações necessárias.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

Depois que uma transação é enviada, você pode recuperar seus detalhes usando a
assinatura da transação e o método RPC
[getTransaction](/docs/rpc/http/gettransaction). A resposta terá uma estrutura
semelhante ao trecho a seguir.

<Callout>
  Você também pode encontrar a transação usando o [Solana
  Explorer](https://explorer.solana.com).
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
