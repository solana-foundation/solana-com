---
title: Endereço Derivado de Programa
description:
  Aprenda sobre os Endereços Derivados de Programa (PDAs) da Solana — endereços
  de conta determinísticos que permitem assinatura segura de programas. Entenda
  a derivação de PDAs, bumps canônicos e como criar contas PDA.
---

Um [endereço de conta](/docs/core/accounts#account-address) da Solana aponta
para a localização da conta no blockchain. Muitos endereços de contas são a
chave pública de um keypair, caso em que a chave privada correspondente é usada
para assinar transações envolvendo a conta.

Uma alternativa útil a um endereço de chave pública é um endereço derivado de
programa (PDA). Os PDAs fornecem um método fácil para armazenar, mapear e buscar
o estado do programa. Um PDA é um endereço que é criado deterministicamente
usando um ID de programa e uma combinação de entradas predefinidas opcionais. Os
PDAs parecem semelhantes aos endereços de chave pública, mas não têm uma chave
privada correspondente.

O runtime da Solana permite que programas assinem PDAs sem precisar de uma chave
privada. Usar um PDA elimina a necessidade de rastrear o endereço da conta. Em
vez disso, você pode recuperar as entradas específicas usadas para a derivação
do PDA. (Para aprender como os programas usam PDAs para assinatura, consulte a
seção [Invocações Entre Programas](/docs/core/cpi).)

## Contexto

Os
[keypairs](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/keypair/src/lib.rs#L26)
da Solana são pontos na [curva Ed25519](https://ed25519.cr.yp.to/) (criptografia
de curva elíptica). Eles consistem em uma chave pública e uma chave privada. A
chave pública torna-se o endereço da conta, e a chave privada é usada para gerar
[assinaturas](/docs/core/transactions#signatures) válidas para a conta.

![Duas contas com endereços na curva](/assets/docs/core/pda/address-on-curve.svg)

Um PDA é intencionalmente derivado para ficar fora da curva Ed25519. Isso
significa que ele não tem uma chave privada correspondente válida e não pode
realizar operações criptográficas. (Como fornecer uma assinatura.) No entanto, a
Solana permite que programas assinem PDAs sem precisar de uma chave privada.

![Endereço Fora da Curva](/assets/docs/core/pda/address-off-curve.svg)

Você pode pensar nos PDAs como uma forma de criar estruturas semelhantes a
hashmaps na blockchain usando um conjunto predefinido de entradas. (Por exemplo,
strings, números e outros endereços de conta.)

![Program Derived Address](/assets/docs/core/pda/pda.svg)

## Derivar um PDA

Antes de criar uma conta com um PDA, você deve primeiro derivar o endereço.
Derivar um PDA _não_ cria automaticamente uma conta na blockchain nesse endereço
— a conta deve ser explicitamente criada através do programa usado para derivar
o PDA. Você pode pensar em um PDA como um endereço em um mapa: só porque um
endereço existe não significa que há algo construído lá.

Os SDKs da Solana suportam a criação de PDA com as funções mostradas na tabela
abaixo. Cada função recebe as seguintes entradas:

- **Program ID**: O endereço do programa sendo usado para derivar o PDA. Este
  programa pode assinar em nome do PDA.
- **Seeds opcionais**: Entradas predefinidas, como strings, números ou outros
  endereços de conta.

| SDK                            | Função                                                                                                                           |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `@solana/kit` (Typescript)     | [`getProgramDerivedAddress`](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L157) |
| `@solana/web3.js` (Typescript) | [`findProgramAddressSync`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/publickey.ts#L212)               |
| `solana_sdk` (Rust)            | [`find_program_address`](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/pubkey/src/lib.rs#L617)                        |

A função usa o Program ID e os seeds opcionais, depois itera através dos valores
de bump para tentar criar um endereço de programa válido. A iteração dos valores
de bump começa em 255 e diminui em 1 até que um PDA válido seja encontrado.
Depois que um PDA válido é encontrado, a função retorna o PDA e o bump seed.

<Callout>
  O bump seed é um byte extra anexado aos seeds opcionais para garantir que um
  endereço fora da curva válido seja gerado.
</Callout>

![Derivação de PDA](/assets/docs/core/pda/pda-derivation.svg)

### Bump canônico

Um bump seed é um byte extra anexado aos seeds opcionais. A função de derivação
itera pelos valores de bump, começando em 255 e decrementando em 1, até que um
valor produza um endereço válido fora da curva. O primeiro valor que produz um
endereço válido fora da curva é chamado de "bump canônico".

Os exemplos a seguir mostram a derivação de PDA usando todos os possíveis bump
seeds (255 a 0):

<Callout type="info">
  Exemplo do Kit não incluído porque a função
  [createProgramDerivedAddress](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L101)
  não é exportada.
</Callout>

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const optionalSeed = "helloWorld";

// Loop through all bump seeds (255 down to 0)
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(optionalSeed), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed = b"helloWorld";

    // Loop through all bump seeds (255 down to 0)
    for bump in (0..=255).rev() {
        match Pubkey::create_program_address(&[optional_seed.as_ref(), &[bump]], &program_id) {
            Ok(pda) => println!("bump {}: {}", bump, pda),
            Err(err) => println!("bump {}: {}", bump, err),
        }
    }

    Ok(())
}
```

</CodeTabs>

<CodeTabs>

```sh !! title="Expected TS Output"
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// remaining bump outputs
```

```sh !! title="Expected Rust Output"
bump 255: Provided seeds do not result in a valid address
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Provided seeds do not result in a valid address
...
// remaining bump outputs
```

</CodeTabs>

Neste exemplo, o primeiro bump seed gera um erro. O primeiro bump seed a derivar
um PDA válido é 254. Os bump seeds 253-251 também derivam PDAs válidos e únicos.

Isto significa que, dados os mesmos seeds opcionais e `programId`, um bump seed
com um valor diferente ainda pode derivar um PDA válido.

<Callout type="warn">
  Sempre inclua verificações de segurança para garantir que um PDA passado para
  o programa seja derivado do bump canônico. Não fazer isso pode introduzir
  vulnerabilidades que permitem que contas inesperadas sejam usadas nas
  instruções do programa. É uma boa prática usar apenas o bump canônico ao
  derivar PDAs.
</Callout>

### Exemplos

Os exemplos abaixo derivam um PDA usando os SDKs da Solana. Clique em **&#9655;
Executar** para executar o código.

#### Derivar um PDA com um seed de string

O exemplo abaixo deriva um PDA usando um ID de programa e um seed opcional de
string.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus
const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus
const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let seeds: &[&[u8]] = &[b"helloWorld"];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Derivar um PDA com um seed de endereço

O exemplo abaixo deriva um PDA usando um ID de programa e um seed de endereço
opcional.

<CodeTabs storage="pda-examples"flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:4)
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

// !focus(1:3)
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Derivar um PDA com múltiplos seeds

O exemplo abaixo deriva um PDA usando um ID de programa e múltiplos seeds
opcionais.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:5)
const optionalSeedString = "helloWorld";
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedString, optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus(1:4)
const optionalSeedString = "helloWorld";
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [Buffer.from(optionalSeedString), optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus(1:2)
    let optional_seed_bytes = b"helloWorld";
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

## Criar uma conta PDA

<WithMentions>

O exemplo abaixo utiliza o [framework Anchor](https://www.anchor-lang.com/docs)
para criar uma nova conta com um endereço derivado de programa. O programa
inclui uma única instrução [`initialize`](mention:initialize) para criar a nova
conta, que armazenará o [endereço do utilizador](mention:user-address) e o
[bump seed](mention:bump) utilizados para derivar o PDA.

```rs title="Program"
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    // !mention initialize
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        // !mark
        // !mention user-address
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bumpd
        // !mark
        // !mention bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    // !mention user-address
    pub user: Signer<'info>,

    #[account(
        init,
        // define the seeds to derive the PDA
        // !mark
        // !mention user-address
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        // !mark
        // !mention bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(InitSpace)]
pub struct DataAccount {
    // !mark
    // !mention user-address
    pub user: Pubkey,
    // !mark
    // !mention bump
    pub bump: u8,
}
```

</WithMentions>

<WithMentions>

A restrição [`init`](mention:init) indica ao Anchor para
[invocar o System Program](/docs/core/programs#the-system-program) para criar
uma nova conta utilizando o PDA como endereço. Os [seeds](mention:seeds)
utilizados para criar o PDA são:

- O endereço da conta do usuário fornecido na instrução
- A string fixa: "data"
- O [bump seed](mention:bump) canônico

Neste exemplo, a restrição bump não tem um valor atribuído, pelo que o Anchor
utilizará `find_program_address` para derivar o PDA e encontrar o bump.

```rust title="pda_account"
#[account(
    // !mention init
    init,
    // !mention seeds
    seeds = [b"data", user.key().as_ref()],
    // !mention bump
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

</WithMentions>

<WithMentions>

O ficheiro de teste abaixo contém uma transação que invoca a instrução
[`initialize`](mention:initialize) para criar uma nova conta com um endereço
derivado de programa. O ficheiro contém código para
[derivar o PDA](mention:pda).

O exemplo também mostra como [buscar](mention:fetch) a nova conta que será
criada.

```ts title="Test"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PdaAccount } from "../target/types/pda_account";
import { PublicKey } from "@solana/web3.js";

describe("pda-account", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.PdaAccount as Program<PdaAccount>;
  const user = provider.wallet as anchor.Wallet;

  // !mention(1:5) pda
  // Derive the PDA address using the seeds specified on the program
  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("data"), user.publicKey.toBuffer()],
    program.programId
  );

  it("Is initialized!", async () => {
    const transactionSignature = await program.methods
      // !mention initialize
      .initialize()
      .accounts({
        user: user.publicKey
      })
      .rpc();

    console.log("Transaction Signature:", transactionSignature);
  });

  it("Fetch Account", async () => {
    // !mention fetch
    const pdaAccount = await program.account.dataAccount.fetch(PDA);
    console.log(JSON.stringify(pdaAccount, null, 2));
  });
});
```

</WithMentions>

<Callout type="warn">
  Se invocar a instrução `initialize` novamente com o mesmo seed de endereço
  `user`, a transação falhará. Isto acontece porque já existe uma conta no
  endereço derivado.
</Callout>
