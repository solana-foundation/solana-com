---
title: Prepara√ß√£o para produ√ß√£o
description: Passando de testes na devnet para implanta√ß√£o na mainnet
---

Construir localmente e testar na devnet s√£o √≥timas formas de come√ßar com
pagamentos na Solana. No entanto, quando estiver pronto para implantar na
Mainnet, voc√™ precisa estar ciente das nuances da mainnet. A Devnet perdoa
erros. A Mainnet n√£o. Este guia aborda as diferen√ßas que importam para garantir
que seus usu√°rios tenham uma experi√™ncia tranquila.

| Devnet                                | Mainnet                                                                                 |
| ------------------------------------- | --------------------------------------------------------------------------------------- |
| SOL gratuito de faucets               | [Adquira SOL real](https://solana.com/ecosystem/explore?categories=exchange) para taxas |
| Baixa competi√ß√£o por espa√ßo de bloco  | Taxas de prioridade importam                                                            |
| Transa√ß√µes s√£o confirmadas facilmente | Configura√ß√£o de transa√ß√£o √© cr√≠tica                                                     |
| RPC p√∫blico √© suficiente              | RPC de produ√ß√£o necess√°rio                                                              |
| Keypairs e mints da devnet            | Chaves e token mints diferentes‚Äîatualize sua configura√ß√£o                               |

## Infraestrutura RPC

[Endpoints p√∫blicos](https://solana.com/docs/references/clusters#solana-public-rpc-endpoints)
(`api.mainnet-beta.solana.com`) t√™m limite de taxa sem SLA. S√£o adequados para
desenvolvimento, mas falhar√£o em fluxos de pagamento de produ√ß√£o‚Äîcomo tentar
executar um processador de pagamentos atrav√©s de uma API compartilhada sem
garantia de tempo de atividade.

<Callout type="caution" title="Nunca use RPC p√∫blico para produ√ß√£o">
  Use um [provedor de RPC privado](https://solana.com/rpc) para acesso confi√°vel
  e de baixa lat√™ncia.
</Callout>

Ao escolher um provedor de RPC, procure por:

- **Confiabilidade**: SLAs com garantias de tempo de atividade (99,9%+)
- **Lat√™ncia**: Proximidade geogr√°fica com seus usu√°rios
- **Recursos**: Recursos de confirma√ß√£o de transa√ß√µes, indexa√ß√£o, APIs de taxa
  de prioridade

Para uma lista completa de provedores de RPC, consulte o guia
[Provedores de infraestrutura RPC](https://solana.com/rpc).

### Configura√ß√£o de RPC redundante

Como qualquer provedor de servi√ßos de rede, os provedores de RPC podem
experimentar tempo de inatividade ou per√≠odos de desempenho degradado. Para
garantir que sua aplica√ß√£o seja resiliente, voc√™ deve configurar sua aplica√ß√£o
para usar m√∫ltiplos provedores de RPC.

O
[Solana Kit](https://github.com/anza-xyz/kit/tree/main/packages/rpc-transport-http)
fornece uma biblioteca para personalizar transportes RPC que permite construir o
seu pr√≥prio cliente RPC redundante. Aqui est√° um exemplo de como voc√™ pode
us√°-lo para construir um cliente RPC redundante:

```ts
import { RpcTransport } from "@solana/rpc-spec";
import { RpcResponse } from "@solana/rpc-spec-types";
import { createHttpTransport } from "@solana/rpc-transport-http";

// Create a transport for each RPC server
const transports = [
  createHttpTransport({ url: "https://mainnet-beta.my-server-1.com" }),
  createHttpTransport({ url: "https://mainnet-beta.my-server-2.com" }),
  createHttpTransport({ url: "https://mainnet-beta.my-server-3.com" })
];

// Create a wrapper transport that distributes requests to them
let nextTransport = 0;
async function roundRobinTransport<TResponse>(
  ...args: Parameters<RpcTransport>
): Promise<RpcResponse<TResponse>> {
  const transport = transports[nextTransport];
  nextTransport = (nextTransport + 1) % transports.length;
  return await transport(...args);
}
```

Se preferir n√£o construir as suas pr√≥prias ferramentas de roteamento, pode
aproveitar um servi√ßo de terceiros como o
[Iron Forge](https://www.ironforge.sanctum.so/) para lidar com o roteamento por
si.

## Confirma√ß√£o de transa√ß√£o

Na Devnet, as transa√ß√µes s√£o confirmadas facilmente. Na Mainnet, voc√™ est√° a
competir por espa√ßo no bloco. Para aumentar as hip√≥teses de ter a sua transa√ß√£o
inclu√≠da num bloco, deve garantir que montou corretamente a sua transa√ß√£o. Isto
significa:

- incluir um blockhash recente antes de enviar a transa√ß√£o
- incluir uma instru√ß√£o de taxa de prioridade na transa√ß√£o com uma taxa de
  prioridade competitiva
- incluir uma instru√ß√£o de limite de unidades de computa√ß√£o na transa√ß√£o com um
  limite de unidades de computa√ß√£o baseado nas unidades de computa√ß√£o estimadas
  necess√°rias para a transa√ß√£o

Al√©m disso, deve considerar outras ferramentas como Jito Bundles para aumentar
as hip√≥teses da sua transa√ß√£o ser inclu√≠da num bloco. Vamos explorar estas
ferramentas com mais detalhe.

### Configura√ß√£o de envio de transa√ß√£o

Ao enviar transa√ß√µes na Mainnet, configure estes par√¢metros para taxas de
confirma√ß√£o √≥timas:

**Gest√£o de blockhash:**

- Obtenha com compromisso `confirmed`
- Armazene o `lastValidBlockHeight` retornado por `getLatestBlockhash`‚Äîisto
  indica quando a sua transa√ß√£o expira
- Os blockhashes expiram ap√≥s ~150 blocos (~60-90 segundos)

**Op√ß√µes de envio:**

- `maxRetries: 0` ‚Äî Desative as tentativas autom√°ticas de RPC. Gira as
  tentativas voc√™ mesmo para poder atualizar o blockhash quando necess√°rio.
- `skipPreflight: true` ‚Äî Ignore a simula√ß√£o antes de enviar. Use isto quando j√°
  validou a transa√ß√£o e quer a menor lat√™ncia. Mantenha como `false` durante o
  desenvolvimento para detetar erros mais cedo.

```typescript
import { createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc(process.env.RPC_URL!);

// 1. Get blockhash with confirmed commitment
const { value: latestBlockhash } = await rpc
  .getLatestBlockhash({ commitment: "confirmed" })
  .send();

// 2. Build and sign your transaction with the blockhash
// ... (transaction building code)

// 3. Send with production settings
const signature = await rpc
  .sendTransaction(encodedTransaction, {
    encoding: "base64",
    maxRetries: 0n, // Handle retries yourself
    skipPreflight: true, // Skip simulation for speed (use false during dev)
    preflightCommitment: "confirmed"
  })
  .send();

// 4. Track expiration using lastValidBlockHeight
const { lastValidBlockHeight } = latestBlockhash;
// Stop retrying when current block height exceeds lastValidBlockHeight
```

### Use taxas de prioridade

Toda transa√ß√£o Solana requer uma taxa de transa√ß√£o, paga em SOL. As taxas de
transa√ß√£o s√£o divididas em duas partes: a taxa base e a taxa de prioridade. A
taxa base compensa os validadores pelo processamento da transa√ß√£o. A taxa de
prioridade √© uma taxa opcional, para aumentar a chance de o l√≠der atual
processar sua transa√ß√£o. Pense nisso como envio expresso: voc√™ paga mais por uma
entrega mais r√°pida e confi√°vel.

**Como as taxas funcionam:**

```
Total fee = Base fee (5,000 lamports per signature) + Priority fee
Priority fee = Compute units x Price per unit (micro-lamports per compute unit)
```

**Custos reais:**

- Transfer√™ncia simples de USDC: ~$0.001-0.005 durante condi√ß√µes normais
- Durante congestionamento: ~$0.01-0.05
- Pico de congestionamento: pode aumentar ainda mais

**Exemplo de implementa√ß√£o:**

O pacote
[`@solana-program/compute-budget`](https://github.com/solana-program/compute-budget)
fornece uma fun√ß√£o auxiliar para atualizar ou anexar facilmente a instru√ß√£o de
pre√ßo de unidade de computa√ß√£o (em micro-lamports) a uma transa√ß√£o.

```typescript
import { updateOrAppendSetComputeUnitPriceInstruction } from "@solana-program/compute-budget";

const tx = pipe(
  createTransactionMessage({ version: 0 }),
  (m) => setTransactionMessageFeePayerSigner(payer, m),
  (m) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, m),
  (m) => appendTransactionMessageInstructions([myInstructions], m),
  (m) => updateOrAppendSetComputeUnitPriceInstruction(1000n as MicroLamports, m)
);
```

**Obtendo estimativas de taxas:** a maioria dos provedores RPC oferece APIs de
taxa de prioridade:

- [Helius Priority Fee API](https://docs.helius.dev/solana-apis/priority-fee-api)
- [QuickNode Priority Fee Add-on](https://marketplace.quicknode.com/add-on/solana-priority-fee)
- [Triton Priority Fees API](https://docs.triton.one/chains/solana/improved-priority-fees-api)

Para a mec√¢nica completa de taxas, consulte
[Taxas de transa√ß√£o](/docs/core/fees) e nosso guia:
[Como adicionar taxas de prioridade a uma transa√ß√£o](https://solana.com/developers/cookbook/transactions/add-priority-fees).

### Otimize unidades de computa√ß√£o

A computa√ß√£o na Solana √© efetivamente uma medida da quantidade de trabalho que o
programa est√° realizando. H√° um limite na quantidade de computa√ß√£o que pode ser
usada em uma transa√ß√£o (atualmente 1,4 milh√£o de unidades de computa√ß√£o) e um
limite na quantidade de computa√ß√£o que pode ser usada por conta por bloco
(atualmente 100 milh√µes de unidades de computa√ß√£o).

Quando voc√™ envia uma transa√ß√£o, precisa estimar a quantidade de computa√ß√£o que
ser√° usada e definir o limite de unidade de computa√ß√£o adequadamente - isso √©
efetivamente uma solicita√ß√£o de quanto da capacidade total deve ser reservada
para sua transa√ß√£o. Na pr√°tica, isso significa que estimar adequadamente as
unidades de computa√ß√£o necess√°rias para sua transa√ß√£o √© fundamental para que sua
transa√ß√£o seja inclu√≠da em um bloco (e importante para gerenciar suas taxas de
prioridade).

A API JSON RPC da Solana possui um m√©todo
[`simulatetransaction`](/docs/rpc/http/simulatetransaction) que pode ser
utilizado para estimar as unidades de computa√ß√£o necess√°rias para uma transa√ß√£o,
o que inclui uma estimativa das unidades de computa√ß√£o que ser√£o utilizadas. O
pacote
[`@solana-program/compute-budget`](https://github.com/solana-program/compute-budget)
fornece uma fun√ß√£o auxiliar para estimar facilmente as unidades de computa√ß√£o
necess√°rias para uma transa√ß√£o (que utiliza o m√©todo `simulatetransaction`
internamente).

```ts
import {
  estimateComputeUnitLimitFactory,
  updateOrAppendSetComputeUnitLimitInstruction
} from "@solana-program/compute-budget";

const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });
const computeUnitLimit = await estimateComputeUnitLimit(tx);
const txWithComputeUnitLimit = updateOrAppendSetComputeUnitLimitInstruction(
  computeUnitLimit,
  tx
);
```

Em produ√ß√£o, se estiver a repetir o mesmo tipo de transa√ß√£o v√°rias vezes, deve
considerar armazenar em cache a estimativa de computa√ß√£o para o tipo de
transa√ß√£o para evitar a sobrecarga de estimar as unidades de computa√ß√£o sempre.

### Pacotes Jito

Os pacotes Jito s√£o uma ferramenta para gerir a execu√ß√£o at√≥mica de m√∫ltiplas
transa√ß√µes. Isto √© alcan√ßado atrav√©s do envio de m√∫ltiplas transa√ß√µes para a
rede Jito com uma gorjeta. As gorjetas podem ser utilizadas para incentivar a
rede Jito a incluir as suas transa√ß√µes num bloco.

**Recursos:**

- [Documenta√ß√£o Jito](https://docs.jito.wtf/lowlatencytxnsend/)
- [üé• V√≠deo: Pacotes Jito](https://www.youtube.com/watch?v=HZ1pK9i6zx4)
- [Guia QuickNode sobre pacotes Jito](https://www.quicknode.com/guides/solana-development/transactions/jito-bundles)

### Estrat√©gias de repeti√ß√£o

As transa√ß√µes podem falhar por diversos motivos. Ao contr√°rio das APIs de
pagamento tradicionais que retornam sucesso/falha imediatamente, as transa√ß√µes
blockchain requerem rastreamento de confirma√ß√£o.

**Conceitos-chave:**

- **Expira√ß√£o do blockhash**: as transa√ß√µes s√£o v√°lidas por ~150 blocos (~60-90
  segundos)
- **Idempot√™ncia**: a mesma transa√ß√£o assinada produz sempre a mesma
  assinatura‚Äîreenviar √© seguro
- **Recuo exponencial**: evite sobrecarregar a rede com repeti√ß√µes r√°pidas

```typescript
import {
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  sendAndConfirmTransactionFactory,
  isSolanaError,
  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED
} from "@solana/kit";

const rpc = createSolanaRpc(process.env.RPC_URL!);
const rpcSubscriptions = createSolanaRpcSubscriptions(process.env.RPC_WSS_URL!);

const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({
  rpc,
  rpcSubscriptions
});

// Send with automatic confirmation tracking and block height monitoring
try {
  await sendAndConfirmTransaction(signedTransaction, {
    commitment: "confirmed",
    // Optional: abort after 75 seconds
    abortSignal: AbortSignal.timeout(75_000)
  });
} catch (e) {
  if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {
    // Blockhash expired‚Äîrebuild transaction with fresh blockhash and retry
    rebuildAndRetryTransaction(); // implement your own logic for rebuilding and retrying the transaction
  }
  throw e;
}
```

O `sendAndConfirmTransactionFactory` do `@solana/kit` gere automaticamente a
verifica√ß√£o de confirma√ß√£o e o rastreamento da altura do bloco. Lan√ßa
`SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED` quando o blockhash da transa√ß√£o expira,
sinalizando que precisa de reconstruir a transa√ß√£o com um blockhash novo.

### Recursos adicionais

- [Guia: Confirma√ß√£o e expira√ß√£o de transa√ß√µes](https://solana.com/developers/guides/advanced/confirmation)
- [Helius: Como concluir transa√ß√µes na Solana](https://www.helius.dev/blog/how-to-land-transactions-on-solana)
- [QuickNode: Estrat√©gias para otimizar transa√ß√µes na Solana](https://www.quicknode.com/docs/solana/transactions)

## Compreender os n√≠veis de confirma√ß√£o

A Solana oferece tr√™s n√≠veis de confirma√ß√£o. Em termos de finan√ßas tradicionais:

| N√≠vel       | Defini√ß√£o Solana            | Equivalente tradicional | Caso de uso                             |
| ----------- | --------------------------- | ----------------------- | --------------------------------------- |
| `processed` | Num bloco, ainda n√£o votado | Autoriza√ß√£o pendente    | Atualiza√ß√µes de interface em tempo real |
| `confirmed` | Votado por supermaioria     | Fundos compensados      | **Maioria dos pagamentos**              |
| `finalized` | Enraizado, irrevers√≠vel     | Fundos liquidados       | Alto valor, conformidade                |

**Quando usar cada um:**

- **Atualiza√ß√µes de interface**: Mostrar `processed` para feedback imediato
  ("Pagamento enviado")
- **Creditar conta do utilizador**: Aguardar `confirmed` (seguro para a maioria
  das transa√ß√µes)
- **Enviar bens f√≠sicos**: Aguardar `finalized`
- **Levantamentos grandes**: Aguardar `finalized`
- **Conformidade/auditoria**: Registar sempre o estado `finalized`

Para mais informa√ß√µes sobre como verificar o estado da transa√ß√£o, consulte
[Interagir com a Solana](/docs/payments/interacting-with-solana).

## Tratamento de erros

O Solana Kit fornece erros tipados atrav√©s de `isSolanaError()`. Use c√≥digos de
erro espec√≠ficos em vez de correspond√™ncia de strings:

```typescript
import {
  isSolanaError,
  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,
  SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,
  SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,
  SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS
} from "@solana/kit";

function handlePaymentError(error: unknown): {
  message: string;
  retryable: boolean;
} {
  // Blockhash expired‚Äîrebuild and retry
  if (
    isSolanaError(error, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED) ||
    isSolanaError(error, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND)
  ) {
    return { message: "Transaction expired‚Äîrebuilding", retryable: true };
  }

  // Insufficient SOL for fees
  if (
    isSolanaError(
      error,
      SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE
    )
  ) {
    return { message: "Not enough SOL for fees", retryable: false };
  }

  // Insufficient token balance
  if (
    isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS)
  ) {
    return { message: "Insufficient balance", retryable: false };
  }

  // Unknown error
  console.error("Payment error:", error);
  return { message: "Payment failed‚Äîplease retry", retryable: true };
}
```

**C√≥digos de erro comuns:**

| C√≥digo de erro               | Causa                    | Recupera√ß√£o                                                                                                                |
| ---------------------------- | ------------------------ | -------------------------------------------------------------------------------------------------------------------------- |
| `BLOCK_HEIGHT_EXCEEDED`      | Blockhash expirado       | Reconstruir com blockhash atualizado                                                                                       |
| `BLOCKHASH_NOT_FOUND`        | Blockhash n√£o encontrado | Reconstruir com blockhash atualizado                                                                                       |
| `INSUFFICIENT_FUNDS_FOR_FEE` | SOL insuficiente         | Financiar o pagador de taxas ou usar [abstra√ß√£o de taxas](/docs/payments/send-payments/payment-processing/fee-abstraction) |
| `INSUFFICIENT_FUNDS`         | Tokens insuficientes     | O utilizador precisa de mais saldo                                                                                         |
| `ACCOUNT_NOT_FOUND`          | Conta de token em falta  | Criar ATA na transa√ß√£o                                                                                                     |

## Transa√ß√µes sem taxas

Os utilizadores esperam pagar em stablecoins, n√£o adquirir SOL para taxas de
rede. As transa√ß√µes sem taxas resolvem isto‚Äîsemelhante a como os utilizadores do
Venmo n√£o pensam nas taxas ACH. Consulte
[Abstra√ß√£o de taxas](/docs/payments/send-payments/payment-processing/fee-abstraction)
para implementa√ß√£o completa.

## Seguran√ßa

### Gest√£o de chaves

- **Nunca exponha chaves privadas no c√≥digo frontend.** Use assinatura backend,
  carteiras de hardware, carteiras multisignature ou servi√ßos de gest√£o de
  chaves.
- **Separe carteiras quentes e frias.** Carteira quente para opera√ß√µes, fria
  para tesouraria.
- **Fa√ßa backup de todas as chaves de produ√ß√£o.** Armazene backups encriptados
  em m√∫ltiplas localiza√ß√µes seguras. Perder uma chave significa perder o acesso
  permanentemente.
- **Use chaves diferentes para devnet e mainnet.** As suas chaves de devnet n√£o
  devem ser as suas chaves de mainnet. Use configura√ß√£o baseada em ambiente para
  garantir que as chaves corretas s√£o carregadas para cada rede.

### Seguran√ßa RPC

Trate os endpoints RPC como chaves de API‚Äîn√£o os exponha no c√≥digo frontend onde
podem ser extra√≠dos e abusados. Use um proxy backend ou vari√°veis de ambiente
que n√£o sejam inclu√≠das no c√≥digo do cliente.

- [QuickNode: Pr√°ticas recomendadas de seguran√ßa de endpoint](https://www.quicknode.com/guides/quicknode-products/endpoint-security/endpoint-security-best-practices)
- [Helius: Proteja as suas chaves de API Solana: Pr√°ticas recomendadas de seguran√ßa](https://www.helius.dev/docs/rpc/protect-your-keys)

### Monitoriza√ß√£o

Acompanhe estas m√©tricas em produ√ß√£o:

| M√©trica                       | Porqu√™                    |
| ----------------------------- | ------------------------- |
| Taxa de sucesso de transa√ß√µes | Detetar problemas cedo    |
| Lat√™ncia de confirma√ß√£o       | Monitorizar sa√∫de da rede |
| Gasto de taxa priorit√°ria     | Gest√£o de custos          |
| Taxa de erro RPC              | Sa√∫de do fornecedor       |

Configure alertas para:

- Transfer√™ncias acima do limite da tesouraria
- Picos na taxa de transa√ß√µes falhadas
- Padr√µes de destinat√°rios incomuns
- Aumentos na taxa de erro RPC

Para monitoriza√ß√£o de transa√ß√µes em tempo real em escala, consulte o nosso
[Guia de indexa√ß√£o](/docs/payments/accept-payments/indexing).

### Verificar endere√ßos

Cada token e programa tem exatamente um endere√ßo correto na mainnet. Tokens
falsificados que imitam USDC ou outras stablecoins s√£o comuns‚Äîeles ter√£o o mesmo
nome e s√≠mbolo, mas um mint diferente. A sua aplica√ß√£o deve codificar de forma
fixa ou criar uma lista de permiss√µes para os endere√ßos de mint (com base nos
seus requisitos), nunca os aceite dinamicamente de fontes n√£o confi√°veis.

**Configura√ß√£o baseada em ambiente:** Devnet e Mainnet frequentemente usam mints
de tokens completamente diferentes. Configure a sua aplica√ß√£o para carregar os
endere√ßos corretos por ambiente‚Äîn√£o codifique endere√ßos da mainnet de forma fixa
e se esque√ßa de troc√°-los durante os testes, ou pior, envie endere√ßos da devnet
para produ√ß√£o.

Alguns mints de stablecoins comuns s√£o:

| Token | Emissor | Endere√ßo do mint                               |
| ----- | ------- | ---------------------------------------------- |
| USDC  | Circle  | `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v` |
| USDT  | Tether  | `Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB` |
| PYUSD | PayPal  | `2b1kV6DkPAnxd5ixfnxCpjxmKwqjjaYmCZfHsFu24GXo` |
| USDG  | Paxos   | `2u1tszSeqZ3qBWF3uNGPFc8TzMk2tdiwknnRMWGWjGWH` |

Os endere√ßos de programas tamb√©m s√£o importantes. Enviar instru√ß√µes para o
programa errado falhar√°‚Äîou pior, resultar√° em perda irrevers√≠vel de fundos. Os
endere√ßos do Token Program s√£o:

| Programa           | Endere√ßo                                      |
| ------------------ | --------------------------------------------- |
| Token Program      | `TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA` |
| Token-2022 Program | `TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb` |

## Lista de verifica√ß√£o pr√©-lan√ßamento

- [ ] SOL da mainnet adquirido para taxas e rent
- [ ] RPC de produ√ß√£o configurado (n√£o endpoint p√∫blico)
- [ ] Endpoint RPC de fallback configurado
- [ ] Taxas de prioridade implementadas com pre√ßos din√¢micos
- [ ] L√≥gica de retry trata expira√ß√£o de blockhash
- [ ] N√≠vel de confirma√ß√£o apropriado para o caso de uso
- [ ] Todos os erros comuns tratados de forma elegante
- [ ] Gasless configurado (se aplic√°vel)
- [ ] Endere√ßos de tokens da mainnet verificados (n√£o mints da devnet)
- [ ] Todas as chaves guardadas de forma segura
- [ ] Gest√£o de chaves revista (sem chaves no frontend)
- [ ] Monitoriza√ß√£o e alertas de transa√ß√µes ativos
- [ ] Teste de carga realizado no volume esperado

## Implementa√ß√£o de programas

Se est√° a implementar um programa Solana personalizado como parte da sua
infraestrutura de pagamento, existem considera√ß√µes adicionais.

### Pr√©-implementa√ß√£o

- **Vers√£o da CLI Solana:** Certifique-se de que est√° a usar a vers√£o mais
  recente da [CLI Solana](https://solana.com/docs/intro/installation).
- **Keypair do programa:** O seu programa ter√° um endere√ßo diferente na mainnet
  em rela√ß√£o √† devnet (a menos que esteja a reutilizar o mesmo keypair).
  Atualize todas as refer√™ncias na configura√ß√£o da sua aplica√ß√£o. Armazene o
  keypair do seu programa num local seguro (note que executar `cargo clean`
  provavelmente eliminar√° o keypair do seu programa).
- **Inicializar contas:** Se o seu programa requer contas de administrador, PDAs
  ou outras contas de estado, certifique-se de que estas s√£o criadas na mainnet
  antes dos utilizadores interagirem com a sua aplica√ß√£o. O mesmo se aplica a
  quaisquer contas de token associadas (ATAs) que o seu programa necessite.

### Processo de implementa√ß√£o

- **Contas de buffer:** Programas grandes s√£o implementados atrav√©s de contas de
  buffer. O comando `solana program deploy` trata disto automaticamente, mas
  compreenda que a implementa√ß√£o n√£o √© at√≥mica‚Äîse for interrompida, poder√°
  precisar de recuperar ou fechar contas de buffer. Consulte
  [Implementa√ß√£o de programas](https://solana.com/docs/programs/deploying).
- **Autoridade de atualiza√ß√£o:** Decida se o seu programa deve ser atualiz√°vel
  ap√≥s o lan√ßamento. Para imutabilidade, revogue a autoridade de atualiza√ß√£o
  ap√≥s a implementa√ß√£o. Para flexibilidade, proteja adequadamente a chave de
  autoridade de atualiza√ß√£o.
- **Renda:** Certifique-se de que a sua carteira de implementa√ß√£o tem SOL
  suficiente para cobrir os m√≠nimos isentos de renda para todas as contas do
  programa.
- **Verifica√ß√£o:** [Verifique](https://solana.com/docs/programs/verified-builds)
  o seu programa para garantir que o programa execut√°vel que implementa na rede
  Solana corresponde ao c√≥digo-fonte no seu reposit√≥rio

Para orienta√ß√£o completa sobre implementa√ß√£o de programas, consulte
[Implementa√ß√£o de programas](https://solana.com/docs/programs/deploying).
