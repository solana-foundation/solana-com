---
title: Transazioni
description:
  Scopri le transazioni di Solana—i blocchi fondamentali per interagire con la
  blockchain Solana. Comprendi la struttura delle transazioni e la composizione
  delle istruzioni con esempi pratici.
---

Per interagire con la rete Solana, devi inviare una transazione. Puoi pensare a
una transazione come a una busta che contiene diversi moduli. Ogni modulo è
un'istruzione che dice alla rete cosa fare. Inviare la transazione è come
spedire la busta affinché i moduli possano essere elaborati.

L'esempio seguente mostra una versione semplificata di due transazioni. Quando
la prima transazione viene elaborata, eseguirà una singola istruzione. Quando la
seconda transazione viene elaborata, eseguirà tre istruzioni **in ordine
sequenziale**: prima l'istruzione 1, seguita dall'istruzione 2, seguita
dall'istruzione 3.

<Callout type="warn">
  Le transazioni sono **atomiche**: se una singola istruzione fallisce, l'intera
  transazione fallirà e non avverrà alcuna modifica.
</Callout>

![Un diagramma semplificato che mostra due transazioni](/assets/docs/core/transactions/transaction-simple.svg)

Una
[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
consiste delle seguenti informazioni:

<WithMentions>

- [`signatures`](mention:signatures): un array di [firme](#signatures)
- [`message`](mention:message): informazioni sulla transazione, inclusa la lista
  delle istruzioni da elaborare

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![Diagramma che mostra le due parti di una transazione](/assets/docs/core/transactions/tx_format.png)

Le transazioni hanno un limite di dimensione totale di
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
byte. Questo limite include sia l'array [`signatures`](#signatures) che la
struttura [`message`](#message).

<Callout>
  Questo limite è progettato per evitare la frammentazione dei pacchetti
  nell'infrastruttura internet tipica. Mentre IPv6 supporta MTU superiori a 9000
  byte, la maggior parte dei router internet utilizza un MTU predefinito di 1500
  byte (Ethernet standard). Per garantire che le transazioni si adattino a un
  singolo pacchetto senza frammentazione, Solana utilizza 1280 byte (l'MTU
  minimo richiesto per IPv6) meno 48 byte per le intestazioni di rete (40 byte
  IPv6 + 8 byte per l'intestazione di frammentazione/UDP), risultando nel limite
  di dimensione della transazione di 1232 byte.
</Callout>

![Diagramma che mostra il formato della transazione e i limiti di dimensione](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## Firme

L'array `signatures` della transazione contiene strutture `Signature`. Ogni
[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
è di 64 byte e viene creata firmando il `Message` della transazione con la
chiave privata dell'account. Una firma deve essere fornita per ogni
[account firmatario](#account-addresses) incluso in una qualsiasi delle
istruzioni della transazione.

La prima firma appartiene all'account che pagherà la
[commissione base](docs/core/fees#base-fee) della transazione ed è la firma
della transazione. La firma della transazione può essere utilizzata per cercare
i dettagli della transazione sulla rete.

## Messaggio

Il `message` della transazione è una struttura
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)
che contiene le seguenti informazioni:

<WithMentions>

- [`header`](mention:message-header): l'[header](#header) del messaggio
- [`account_keys`](mention:account-addresses): un array di
  [indirizzi account](#account-addresses) richiesti dalle istruzioni della
  transazione
- [`recent_blockhash`](mention:recent-blockhash): un
  [blockhash](#recent-blockhash) che funge da timestamp per la transazione
- [`instructions`](mention:instructions): un array di
  [istruzioni](#instructions)

<Callout>
  Per risparmiare spazio, la transazione non memorizza i permessi per ogni
  account individualmente. Invece, i permessi degli account vengono determinati
  utilizzando `header` e `account_keys`.
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### Intestazione

<WithMentions>

L'`header` del messaggio è una struttura
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97).
Contiene le seguenti informazioni:

- [`num_required_signatures`](mention:num_required_signatures): il numero totale
  di firme richieste dalla transazione
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts): il
  numero totale di account in sola lettura che richiedono firme
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts): il
  numero totale di account in sola lettura che non richiedono firme

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![Diagramma che mostra le tre parti dell'intestazione del messaggio](/assets/docs/core/transactions/message_header.png)

### Indirizzi degli account

L'array
[`account_keys`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
del messaggio è un array di indirizzi di account, inviato in
[formato compact array](/docs/references/terminology#compact-array-format). Il
prefisso dell'array indica la sua lunghezza. Ogni elemento nell'array è una
chiave pubblica, che punta a un account utilizzato dalle sue istruzioni. L'array
`accounts_keys` deve essere completo e rigorosamente ordinato, come segue:

1. Firmatario + Scrivibile
2. Firmatario + Sola lettura
3. Non firmatario + Scrivibile
4. Non firmatario + Sola lettura

<Callout>
  L'ordinamento rigoroso consente di combinare l'array `account_keys` con le
  informazioni nell'[`header`](#header) del messaggio per determinare i permessi
  per ciascun account.
</Callout>

![Diagramma che mostra l'ordine dell'array degli indirizzi degli account](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Blockhash recente

Il `recent_blockhash` del messaggio è un valore hash che funge da timestamp
della transazione e previene transazioni duplicate. Un blockhash scade dopo
[150 blocchi](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134).
(Equivalente a un minuto—assumendo che ogni blocco sia di 400ms.) Dopo la
scadenza del blocco, la transazione è scaduta e non può essere elaborata.

<Callout>
  Il metodo RPC [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash)
  consente di ottenere il blockhash corrente e l'ultima altezza del blocco alla
  quale il blockhash sarà valido.
</Callout>

### Istruzioni

L'array
[`instructions`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
del messaggio è un array di tutte le istruzioni da elaborare, inviato in
[formato compact array](/docs/references/terminology#compact-array-format). Il
prefisso dell'array indica la sua lunghezza. Ogni elemento nell'array è una
struttura
[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
e include le seguenti informazioni:

<WithMentions>

1. [`program_id_index`](mention:program-id-index): un indice che punta a un
   indirizzo nell'array [`account_keys`](#account-addresses). Questo valore
   indica l'indirizzo del programma che elabora l'istruzione.
2. [`accounts`](mention:account-indexes): un array di indici che puntano a
   indirizzi nell'array `account_keys`. Ogni indice punta all'indirizzo di un
   account richiesto per questa istruzione.
3. [`data`](mention:instruction-data): un array di byte che specifica quale
   istruzione invocare sul programma. Include anche eventuali dati aggiuntivi
   richiesti dall'istruzione. (Ad esempio, argomenti di funzione)

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Array compatto di istruzioni](/assets/docs/core/transactions/compact_array_of_ixs.png)

## Struttura di esempio della transazione

Il seguente esempio mostra la struttura di una transazione che contiene una
singola istruzione di trasferimento SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
Il codice seguente mostra l'output degli snippet di codice precedenti.
Il formato differisce tra gli SDK,
ma nota che ogni istruzione contiene le stesse informazioni richieste.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

Dopo che una transazione è stata inviata, puoi recuperare i suoi dettagli
utilizzando la firma della transazione e il metodo RPC
[getTransaction](/docs/rpc/http/gettransaction). La risposta avrà una struttura
simile al seguente snippet.

<Callout>
  Puoi anche trovare la transazione utilizzando [Solana
  Explorer](https://explorer.solana.com).
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
