---
title: Verifica dei programmi
description:
  Le build verificate sono un modo per collegare il tuo programma al suo codice
  sorgente e permettere a tutti di verificare in modo indipendente che il
  programma sia stato effettivamente costruito dal codice sorgente fornito.
---

Questa guida è pensata come riferimento per gli sviluppatori che vogliono
implementare build verificate per i loro programmi su Solana. Tratteremo cosa
sono le build verificate, come utilizzarle, considerazioni speciali e best
practice per garantire l'autenticità del tuo programma sulla blockchain.

# Cosa sono le build verificate?

Le build verificate assicurano che il programma eseguibile che distribuisci
sulla rete di Solana corrisponda al codice sorgente nel tuo repository. Grazie a
questo, sviluppatori e utenti possono avere la certezza che il programma in
esecuzione sulla blockchain corrisponda esattamente alla base di codice
pubblica, promuovendo trasparenza e sicurezza.

Il processo di verifica prevede il confronto dell'hash del programma sulla
blockchain con l'hash del programma compilato localmente dal codice sorgente.
Questo garantisce che non ci siano discrepanze tra le due versioni.

> Sebbene una build verificata non debba essere considerata più sicura di una
> build non verificata, la build permette agli sviluppatori di verificare
> autonomamente che il codice sorgente corrisponda a ciò che è distribuito sulla
> blockchain. Utilizzando il codice sorgente, uno sviluppatore può quindi
> validare cosa esegue il codice quando invia una transazione.

La pipeline di build verificate è stata ideata e viene mantenuta da
[Ellipsis Labs](https://ellipsislabs.xyz/) e [OtterSec](https://osec.io/). Per
maggiori dettagli, segui la guida nel
[repository originale delle build verificate](https://github.com/Ellipsis-Labs/solana-verifiable-build)
e il processo di verifica della build direttamente nella suite di strumenti
[Anza](https://www.anza.xyz/), una volta supportato.

# Come funziona?

Il processo di verifica viene effettuato confrontando l'hash del programma
onchain con l'hash del programma compilato localmente dal codice sorgente.
Compili il tuo programma in un ambiente controllato utilizzando Solana Verify
CLI e Docker. Questo garantisce che il processo di compilazione sia
deterministico e coerente su diversi sistemi. Una volta ottenuto l'eseguibile,
puoi distribuirlo sulla rete Solana. Durante il processo di compilazione verrà
creato un
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)
del [programma verify](https://github.com/otter-sec/otter-verify). Questo PDA
contiene tutti i dati necessari per verificare il programma. Il PDA contiene
l'indirizzo del programma, l'URL git, l'hash del commit e gli argomenti
utilizzati per compilare il programma.

Utilizzando i dati nel PDA, chiunque può eseguire localmente il comando del
programma verify e controllare se il programma è stato compilato dal codice
sorgente fornito. Quindi tutti possono verificare autonomamente in modo
completamente trustless o possono eseguire la propria
[API di verifica](https://github.com/otter-sec/solana-verified-programs-api)
mantenuta da [OtterSec](https://github.com/otter-sec) per fornire un punto di
accesso facile agli utenti per controllare la verifica. Puoi già vedere queste
[chiamate API](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
utilizzate in
[Solana Explorer](https://explorer.solana.com/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/verified-build)
e
[SolanaFM](https://solana.fm/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/transactions?cluster=mainnet-alpha),
tra gli altri.

# Perché dovrei usare build verificate?

L'utilizzo di build verificate offre i seguenti vantaggi:

- Sicurezza: garantisce che il programma in esecuzione onchain corrisponda al
  codice sorgente, prevenendo alterazioni dannose.

- Trasparenza: permette ad altri utenti e sviluppatori di convalidare che il
  programma onchain sia affidabile confrontandolo con il codebase pubblico.

- Fiducia: aumenta la fiducia degli utenti, poiché le build verificate
  dimostrano che il comportamento onchain del tuo programma è allineato con il
  tuo codice pubblico. Quando costruisci programmi verificabili, riduci al
  minimo i rischi associati all'esecuzione di codice non autorizzato o dannoso.
  Garantisce inoltre che tu rispetti le migliori pratiche e offri ai ricercatori
  di sicurezza un modo semplice per contattarti. Anche i wallet e altri
  strumenti possono consentire più facilmente le transazioni dal tuo programma
  finché è verificato.

- Individuabilità: quando fornisci una build verificata del tuo programma, tutti
  possono trovare il tuo codice sorgente, la documentazione, l'SDK o l'IDL del
  programma e possono anche contattarti facilmente tramite GitHub in caso di
  problemi.

# Come creo build verificate?

Per creare build verificate, dovrai seguire questi passaggi:

Riepilogo:

- Effettua il commit del tuo codice in un repository pubblico
- Crea una build verificata in Docker
- Distribuisci la build verificata
- Verifica il programma distribuito tramite API pubblica

Se verifichi il tuo programma che non è stato compilato in un container Docker,
molto probabilmente fallirà perché le build dei programmi Solana non sono
deterministiche su sistemi diversi.

<Steps>
<Step>

### Installa Docker e Cargo

Installa gli strumenti necessari assicurandoti di avere Docker e Cargo
installati. Docker fornisce un ambiente di build controllato per garantire la
coerenza, e Cargo viene utilizzato per gestire i pacchetti Rust.

- Docker: segui i passaggi sul
  [sito web di Docker](https://docs.docker.com/engine/install/) per installare
  Docker per la tua piattaforma. Una volta installato, assicurati che il
  servizio Docker sia in esecuzione seguendo questa guida.
- Cargo: se non hai già Cargo installato, puoi installarlo eseguendo il seguente
  comando:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

</Step>
<Step>

### Installa la CLI Solana Verify

La CLI Solana Verify è lo strumento principale utilizzato per verificare le
build. La CLI Solana Verify è attualmente mantenuta da
[Ellipsis Labs](https://ellipsislabs.xyz/) e può essere installata utilizzando
Cargo.

Puoi installarla eseguendo:

```bash
cargo install solana-verify
```

Se hai bisogno di una versione specifica della CLI, puoi fissare la versione
con:

```bash
cargo install solana-verify --version $VERSION
```

Se lo desideri, puoi installare una versione direttamente da un commit
specifico:

```bash
cargo install solana-verify --git https://github.com/Ellipsis-Labs/solana-verifiable-build --rev 13a1db2
```

</Step>
<Step>

### Preparare il progetto

Per verificare un repository, è necessario avere un file `Cargo.lock` nella
directory principale del repository. Se hai un solo programma nel tuo repository
e un file `cargo.lock` nella root, puoi passare direttamente al passaggio
successivo e compilare il tuo programma.

Se il tuo programma si trova in una sottocartella e hai un workspace Rust, devi
creare un file `Cargo.toml` del workspace nella directory principale del tuo
repository.

Puoi utilizzare questo esempio di `Cargo.toml` come modello:

```toml title="Cargo.toml"
[workspace]
members = ["program/programs/*"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1

[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
```

Assicurati che il tuo programma sia nell'array `workspace/members` e che il file
`Cargo.toml` del tuo programma abbia configurato correttamente il nome `lib`.

> È importante il `lib name`, non il nome del pacchetto!

Qualcosa come questo:

```toml title="waffle/Cargo.toml"
[package]
name = "waffle"
version = "0.1.0"
edition = "2021"

[lib]
name = "waffle"
crate-type = ["cdylib", "lib"]

[dependencies]
solana-program = "2.1.0"
```

In questo [repository](https://github.com/solana-developers/verified-program)
puoi vedere un esempio di workspace con un programma in una sottocartella. Nota
anche che quando il programma si trova in una sottocartella, dovrai
successivamente aggiungere questa cartella come `--mount-path` al comando
`verify-from-repo`.

In questo [repository](https://github.com/solana-developers/solana-game-preset)
puoi trovare un esempio di Anchor. In questo
[repository](https://github.com/solana-developers/verified-program-root) puoi
trovare un esempio di Rust nativo.

Con questo file `Cargo.toml` in posizione, puoi quindi eseguire
`cargo generate-lockfile` per creare un file di lock e continuare con la
compilazione del tuo programma.

</Step>
<Step>

### Compilazione di programmi verificabili

Per compilare in modo verificabile il tuo programma Solana, naviga nella
directory contenente il file `Cargo.toml` del tuo workspace ed esegui:

```bash
solana-verify build
```

Questo copierà il tuo ambiente in un container Docker e lo compilerà in modo
deterministico.

> Assicurati di distribuire effettivamente la build verificata e di non
> sovrascriverla accidentalmente con `anchor build` o `cargo build-sbf`, poiché
> questi molto probabilmente non produrranno lo stesso hash e quindi la tua
> verifica fallirà.

Per progetti con più programmi, puoi compilare un programma specifico
utilizzando il nome della libreria (non il nome del pacchetto):

```bash
solana-verify build --library-name $PROGRAM_LIB_NAME
```

Questo processo garantisce build deterministiche e può richiedere del tempo,
specialmente su certi sistemi (ad es., MacBook M1) perché viene eseguito
all'interno di un container docker. Per build più veloci, si consiglia
l'utilizzo di una macchina Linux con architettura x86.

Una volta completata la build, puoi recuperare l'hash dell'eseguibile
utilizzando il seguente comando:

```bash
solana-verify get-executable-hash target/deploy/$PROGRAM_LIB_NAME.so
```

</Step>
<Step>

### Distribuzione di programmi verificabili

Una volta che hai compilato il tuo programma e recuperato il suo hash, puoi
distribuirlo sulla rete Solana. Si consiglia di utilizzare una soluzione
multi-firma o di governance come [Squads Protocol](https://squads.so/protocol)
per distribuzioni sicure, ma puoi anche distribuire direttamente con:

```bash
solana program deploy -u $NETWORK_URL target/deploy/$PROGRAM_LIB_NAME.so --program-id $PROGRAM_ID --with-compute-unit-price 50000 --max-sign-attempts 100 --use-rpc
```

Una commissione a bassa priorità attualmente adeguata può essere richiesta dal
tuo provider rpc, ad esempio
[Quicknode](https://www.quicknode.com/gas-tracker/solana).

Per verificare che il programma distribuito corrisponda all'eseguibile
compilato, esegui:

```bash
solana-verify get-program-hash -u $NETWORK_URL $PROGRAM_ID
```

> Potresti avere versioni diverse distribuite su diversi
> [cluster Solana](/docs/references/clusters) (ad es. devnet, testnet, mainnet).
> Assicurati di utilizzare l'URL di rete corretto per il cluster Solana
> desiderato su cui vuoi verificare un programma. La verifica remota funzionerà
> solo su mainnet.

</Step>
<Step>

### Verifica rispetto ai repository

Per verificare un programma rispetto al suo repository pubblico, utilizza:

```bash
solana-verify verify-from-repo -u $NETWORK_URL --program-id $PROGRAM_ID https://github.com/$REPO_PATH --commit-hash $COMMIT_HASH --library-name $PROGRAM_LIB_NAME --mount-path $MOUNT_PATH
```

> Mentre esegui la build verificata nella directory del tuo programma, quando
> esegui `verify-from-repo` devi aggiungere il flag `--mount-path`. Questo sarà
> il percorso alla cartella contenente il `Cargo.toml` che contiene il nome
> della libreria del tuo programma.

Questo comando confronta l'hash del programma onchain con l'hash eseguibile
costruito dal codice sorgente al commit hash specificato.

Alla fine il comando ti chiederà se vuoi caricare i tuoi dati di verifica
onchain. Se lo fai, Solana Explorer mostrerà immediatamente i dati di verifica
del tuo programma. Finché non sarà verificato da una build remota, apparirà come
non verificato. Scopri come puoi verificare il tuo programma tramite un'API
pubblica nel prossimo passaggio.

Se vuoi bloccare la verifica a una determinata release, puoi aggiungere il flag
`--commit-hash` al comando.

</Step>
<Step>

### Verifica tramite API pubblica

Infine puoi anche verificare direttamente il programma con chiunque stia
eseguendo l'API di verifica:

```bash
solana-verify verify-from-repo --remote -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

> Si consiglia di utilizzare un URL RPC a pagamento perché altrimenti potresti
> incorrere in limiti di frequenza degli RPC gratuiti. Quindi invece di `-um`
> dovresti usare `--url yourRpcUrl` per una verifica più affidabile.

Il flag `--remote` invia una richiesta di build all'API di OtterSec, che attiva
una build remota del tuo programma. Una volta completata la build, il sistema
verifica che l'hash onchain del tuo programma corrisponda all'hash
dell'artefatto di build generato dal tuo repository.

L'impostazione predefinita è
[API OtterSec](https://github.com/otter-sec/solana-verified-programs-api).

Assicurati di scegliere sì quando ti viene chiesto di caricare i dati di
verifica onchain. Questo viene utilizzato dall'API per verificare che hai
caricato i dati di verifica.

Puoi anche attivare manualmente un job remoto utilizzando:

```bash
solana-verify remote submit-job --program-id <program-id> --uploader <address>
```

Dove l'uploader è l'indirizzo che ha l'autorità di scrivere nel PDA. Questo
dovrebbe essere l'autorità del programma nella maggior parte dei casi. Se il tuo
programma è controllato da un multisig, continua nella parte
[verifica multisig](#how-to-verify-your-program-when-its-controlled-by-a-multisig-like-squads)
di questa guida qui sotto.

Questo invierà un job all'API di OtterSec e potrai quindi verificare lo stato
del job con:

```bash
solana-verify remote get-job-status --job-id <job-id>
```

Una volta completata con successo la verifica, che potrebbe richiedere del
tempo, potrai vedere il tuo programma come verificato nell'
[API OtterSec per programmi singoli](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
e in
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY/verified-build),
[SolanaFM](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY?cluster=mainnet-alpha),
[SolScan](https://solscan.io/account/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY#programVerification)
e infine anche sul sito web gestito dalla community
[SolanaVerify.org](https://www.solanaverify.org/) mantenuto da
[0xDeep](https://x.com/0xDeep) e l'
[API dei programmi verificati di OtterSec](https://verify.osec.io/verified-programs)
e infine nella
[Dashboard Dune dei Programmi Verificati](https://dune.com/jonashahn/verified-programs/dedf21e1-9b71-42c8-89f9-02ed94628657)
contribuendo a un ecosistema Solana più sano.

</Step>
</Steps>

## Come verificare il tuo programma quando è controllato da un Multisig come Squads

Affinché la verifica remota funzioni, devi scrivere i dati di verifica in un PDA
firmato dall'autorità del programma. Se il tuo programma è controllato da un
multisig, puoi esportare questa transazione di scrittura PDA e inviarla tramite
[Squads Protocol](https://squads.so/protocol) o un'altra soluzione multisig di
tua scelta.

<Steps>
<Step>

### 1. Costruire il programma verificabile

Prima costruisci il programma:

```bash
solana-verify build
```

Questo costruirà una build verificabile utilizzando un container docker con la
versione solana specificata nel file `Cargo.lock`.

</Step>
<Step>

### 2. Distribuire il programma

```bash
solana config set --url "PayedMainnetRPCAddress" // the public endpoint will be rate limited too much
solana program deploy target/deploy/verify_squads.so
```

Per il resto di questa guida multisig, useremo un ID programma di esempio
`6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`.

</Step>
<Step>

### 3. Commit e verifica rispetto al repository

Una volta fatto, facciamo il commit del progetto su github. Ecco un esempio:
https://github.com/solana-developers/verify-squads

Opzionale: Verifica se puoi verificare localmente prima (questo comando usa un
ID programma di esempio `6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`):

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
```

Solo per assicurarti che i tuoi parametri siano corretti.

</Step>
<Step>

### 4. Trasferisci l'autorità del programma al multisig

Se non hai ancora trasferito l'autorità del tuo programma al multisig e copiato
l'autorità multisig, devi farlo. Ti servirà nel passaggio successivo.

</Step>
<Step>

### 5. Esporta la transazione PDA

Quando hai l'autorità del programma localmente, ti viene richiesto di caricare i
dati di build onchain quando usi il comando `solana-verify verify-from-repo`.

Poiché non puoi farlo quando stai usando un multisig, devi esportare la
transazione PDA manualmente e poi attivare la transazione tramite Squads.

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader <your program authority> --encoding base58 --compute-unit-price 0
```

Questo ti restituirà una transazione in formato base58. Se desideri una
transazione codificata in base64 da utilizzare in un ispettore di transazioni,
puoi usare `--encoding base64`.

```bash
P6vBfcPaaXb8fZoT3NBAYEcdtEj7tubA1k2gBxmFKZ3UWF5YyrmDMFTvLKALCJoUuRsPAjMckudYruCu3eeWQtuDrFbEMLxLFutnKXac974fnkMivcwUdY66VLjbxQT6ATmcy7F4hBtz1G4P1h6iBJLhb8WtrtgY3i4qq45MUEb7RjuMEfUFXKrNgPdGxkz5xvMHq3dxKRcpmEK5k2DkeW6SUQYBVe19Ga3B9GyhTX8k3CMt9JCEah13WyRnQd8GjoK6sTEvGJym6xDNvmd8yiJYSNcaYwEJsjHEUf4Yh6kAC7ki2KRvVAr3NVe1gjqK9McrwSQjtUatvydTG8Zovcr7PPUEMf3yPMgKXjZLB2QpkH63yTTYdNAnWFuv9E6b6nYRqye5XcNi436yKw5U14fXh65yK34bgYLi9328UT1huJELsJU9BRGnGUmb6GWp6c2WL5BhnzgNTSnt9TXFfEgUMzhvKzpVBxLP44hwqqBdyUhHFysCF37531PnmiESq8x1xou23xJ6FcQbc199754MkqQd7tX9CUznGzAEqHGkzn3VBoJnojsKtgYmiTYbdRsT1CU18MbYEE7WvGAvXyxxbpNzbAcc94HrnM6cqRGmwhEBroPfFghTdmzg9D
```

</Step>
<Step>

### 6. Invia la transazione tramite Squads

Vai al builder di transazioni di Squads e importa la transazione codificata in
base58. Assicurati che nella simulazione la transazione abbia solo una chiamata
al programma di verifica osec e al programma di budget del computer e
nient'altro!

</Step>
<Step>

### 7. Invia il job di verifica remota

Una volta che la transazione su Squads è andata a buon fine, puoi inviare il job
remoto:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
--uploader <your program authority>
```

Ecco fatto! Hai verificato il tuo programma rispetto a un repository pubblico e
inviato un job remoto all'API di OtterSec. Ora dovresti essere in grado di
vederlo riflesso nell'explorer di Solana e in altri luoghi.

</Step>
<Step>

### 8. Aggiornamento del programma (Opzionale)

Quando aggiorni il tuo programma devi esportare una nuova transazione PDA e
inviarla nuovamente tramite Squads.

Come fare un aggiornamento al programma:

```bash
solana-verify build
solana program write-buffer target/deploy/verify_squads.so --with-compute-unit-price 50000 --max-sign-attempts 50
```

Poi trasferisci l'autorità del buffer al multisig o crea direttamente il buffer
con l'autorità del multisig.

```bash
solana program set-buffer-authority Fu3k79g53ZozAj47uq1tXrFy4QbQYh7y745DDsxjtyLR --new-buffer-authority 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

</Step>
<Step>

### 9. Esportazione e invio della nuova transazione PDA

Non dimenticare di fare commit delle tue modifiche su github. Esporta nuovamente
la transazione di aggiornamento PDA:

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

Invia nuovamente la transazione tramite Squads.

Puoi vedere un esempio di transazione
[qui](https://solana.fm/tx/4zJ1vK2KToAwxuEYzTMLqPkcebjoi9rdeeyxtEEx9L5Q4vWDA8h6Rr4kPRuRxcV7ZLKMr6qx1LTWb6x3ZpUJaFUW?cluster=mainnet-alpha).

Poi invia per un'altra build remota:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

Dovrebbe risultare qualcosa del genere:

```shell
Verification request sent with request id: b63339d2-163e-49ac-b55d-3454c1c2b5b3
Verification in progress... ⏳ [00:18:02] ✅ Process completed. (Done in 18
minutes) Program 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD has been verified.
✅ The provided GitHub build matches the on-chain hash. On Chain Hash:
96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Executable
Hash: 96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Repo URL:
https://github.com/Woody4618/verify-squads/tree/0fb0a2e30c15c51732c0ad5e837975a6f7bbc7ed
Check the verification status at:
https://verify.osec.io/status/6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD Job
url: https://verify.osec.io/job/b63339d2-163e-49ac-b55d-3454c1c2b5b3
```

Congratulazioni, hai verificato il tuo programma dopo un aggiornamento multisig!

</Step>
</Steps>

## Verifica da immagine docker

Puoi anche verificare il tuo programma con un'immagine docker eseguendo il
seguente comando:

```bash
solana-verify verify-from-image -e
examples/hello_world/target/deploy/hello_world.so -i
ellipsislabs/hello_world_verifiable_build:latest -p
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn
```

Questo comando carica l'immagine memorizzata in
`ellipsislabs/hello_world_verifiable_build:latest`, e verifica che l'hash del
percorso eseguibile nel container sia lo stesso dell'hash del programma on-chain
fornito al comando. Poiché la build è già stata caricata su un'immagine, non è
necessaria una ricostruzione completa dell'eseguibile, che potrebbe richiedere
molto tempo.

Il Dockerfile che crea l'immagine
`ellipsislabs/hello_world_verifiable_build:latest` può essere trovato nel
repository di ellipsis labs
[/examples/hello_world](https://github.com/Ellipsis-Labs/solana-verifiable-build/tree/master/examples/hello_world).

Di seguito è riportato l'output previsto:

```bash
Verifying image: "ellipsislabs/hello_world_verifiable_build:latest", on network
"https://api.mainnet.solana.com" against program ID
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn Executable path in container:
"examples/hello_world/target/deploy/hello_world.so"

Executable hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Program hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Executable
matches on-chain program data ✅
```

## Esempio di build verificata

Ecco un esempio di verifica di un programma di esempio con ID
`FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv` utilizzando il codice sorgente da
questo [repository](https://github.com/solana-developers/verified-program):

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

Per impostazione predefinita, il comando `verify-from-repo` prende l'ultimo
commit sul ramo main. Puoi anche definire un commit specifico nel caso in cui
desideri continuare a lavorare sul repository utilizzando il parametro
`commit-hash`: `--commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e`

Infine, puoi anche verificare direttamente il programma tramite l'API di
OtterSec:

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --remote --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

Il comando `--remote` invia una richiesta di build all'API di OtterSec, che
attiva una build remota del tuo programma. Una volta completata la build, il
sistema verifica che l'hash on-chain del tuo programma corrisponda all'hash
dell'artefatto di build generato dal tuo repository.

## Programmi popolari già verificati

### Phoenix

```shell
solana-verify verify-from-repo -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

Output finale:

```shell
Executable Program Hash from repo: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
On-chain Program Hash: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
Program hash matches ✅
```

### Squads V3

```shell
solana-verify verify-from-repo https://github.com/Squads-Protocol/squads-mpl --commit-hash c95b7673d616c377a349ca424261872dfcf8b19d --program-id SMPLecH534NA9acpos4G6x7uf3LWbCAwZQE9e8ZekMu -um --library-name squads_mpl --bpf
```

> Nota che abbiamo dovuto specificare `library-name` perché il repository di
> Squads include più programmi. Utilizziamo il flag `--bpf` perché `squads_mpl`
> è stato precedentemente verificato con Anchor.

Output finale:

```shell
Executable Program Hash from repo: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
On-chain Program Hash: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
Program hash matches ✅
```

### Drift V2

```shell
solana-verify verify-from-repo -um --program-id dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH https://github.com/drift-labs/protocol-v2 --commit-hash 110d3ff4f8ba07c178d69f9bfc7b30194fac56d6 --library-name drift
```

Output finale:

```shell
Executable Program Hash from repo: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
On-chain Program Hash: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
Program hash matches ✅
```

### Marginfi V2

```shell
solana-verify verify-from-repo -um --program-id MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA https://github.com/mrgnlabs/marginfi-v2 --commit-hash d33e649e415c354cc2a1e3c49131725552d69ba0 --library-name marginfi -- --features mainnet-beta
```

Output finale:

```shell
Executable Program Hash from repo: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
On-chain Program Hash: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
Program hash matches ✅
```

# Conclusione

L'utilizzo di
[build verificate su Solana](/developers/guides/advanced/verified-builds)
garantisce l'integrità e l'affidabilità dei tuoi programmi sulla rete e permette
agli sviluppatori di trovare i tuoi SDK direttamente da Solana Explorer.
Sfruttando strumenti come Solana Verify CLI e Docker, puoi mantenere build
verificabili e sicure che si allineano con il tuo codice sorgente. Prendi sempre
le precauzioni necessarie per utilizzare ambienti coerenti e considera soluzioni
di governance per aggiornamenti e implementazioni sicure.

## Sicurezza + Disclaimer

Sebbene le build verificate siano uno strumento potente per garantire
l'integrità dei tuoi programmi Solana, nella configurazione predefinita non sono
completamente trustless. Le immagini docker sono create e ospitate dalla Solana
Foundation.

Tieni presente che stai costruendo il tuo progetto in un'immagine docker
scaricata e che l'intera configurazione viene copiata in quell'immagine docker
per la compilazione, incluse eventuali informazioni sensibili.

Se desideri una configurazione completamente trustless, puoi creare le immagini
docker tu stesso e ospitarle sulla tua infrastruttura. In questo modo puoi
essere sicuro che le immagini docker non siano state manomesse. Puoi trovare gli
script per creare le tue immagini docker nel
[repository Verified builds](https://github.com/Ellipsis-Labs/solana-verifiable-build)
e puoi effettuare un fork ed eseguire le github actions tu stesso o verificare
che siano corrette.

Inoltre, per la verifica remota ti stai affidando all'API OtterSec e a
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
fino a un certo punto.

L'API o Solana Explorer potrebbero potenzialmente visualizzare informazioni
errate se compromessi.

Se desideri una configurazione completamente trustless, puoi eseguire
[Verify API](https://github.com/otter-sec/solana-verified-programs-api)
autonomamente o eseguire la verifica del programma localmente utilizzando il
comando `verify-from-repo` utilizzando i dati di verifica on-chain che sono
salvati in un
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)
derivato dall'autorità di distribuzione dei programmi e dal
[programma verify](https://explorer.solana.com/address/verifycLy8mB96wd9wqq3WDXQwM4oU6r42Th37Db9fC).

Il programma di verifica è distribuito dal [team OtterSec](https://osec.io/) e
non è ancora congelato, quindi può essere aggiornato in qualsiasi momento.

La Solana Foundation, OtterSec e il team di Ellipsis Labs non sono responsabili
per eventuali perdite o danni che potrebbero verificarsi utilizzando la pipeline
di build verificate.

# Security.txt per i programmi Solana

Oltre alle build verificate, puoi anche aggiungere un file `security.txt` al tuo
programma. In futuro, una volta implementato, il `security.txt` conterrà la
chiave pubblica del verificatore per un facile accesso ai dati di verifica
memorizzati nel PDA di verifica. Il PDA contenente tutte le informazioni
necessarie per compilare e verificare un programma è derivato dall'indirizzo del
programma e dalla pubkey del verificatore. Per impostazione predefinita, questa
è la stessa pubkey che ha compilato e distribuito il programma. Ma può anche
essere un'altra pubkey che può essere specificata nel `security.txt`.

La funzionalità `security.txt` consente agli sviluppatori di incorporare
informazioni di contatto e sicurezza direttamente nei loro smart contract
Solana. Ispirato a [securitytxt.org](https://securitytxt.org), questo approccio
fornisce un modo standardizzato per i ricercatori di sicurezza di contattare i
responsabili del progetto, anche se conoscono solo l'indirizzo del contratto.

## Perché utilizzare security.txt?

Per molti progetti, specialmente quelli più piccoli o privati, identificare gli
sviluppatori partendo solo dall'indirizzo del contratto può essere difficile e
richiedere tempo. Incorporare un file `security.txt` all'interno del programma
garantisce che i ricercatori di sicurezza possano facilmente contattare le
persone giuste, potenzialmente prevenendo exploit e assicurando segnalazioni
tempestive di bug.

## Come implementare security.txt

Per aggiungere un `security.txt` al tuo programma Solana, includi i seguenti
passaggi:

Aggiungi la dipendenza `solana-security-txt` al tuo `Cargo.toml`:

```toml title="Cargo.toml"
[dependencies]
solana-security-txt = "1.1.1"
```

Utilizza la macro `security_txt!` nel tuo contratto per definire le tue
informazioni di sicurezza. Puoi includere dettagli di contatto, URL del progetto
e persino una politica di sicurezza. Ecco un esempio:

```rust
#[cfg(not(feature = "no-entrypoint"))]
use {default_env::default_env, solana_security_txt::security_txt};

#[cfg(not(feature = "no-entrypoint"))]
security_txt! {
    name: "MyProject",
    project_url: "https://myproject.com",
    contacts: "email:security@myproject.com,discord:security#1234",
    policy: "https://myproject.com/security-policy",

    // Optional Fields
    preferred_languages: "en,de",
    source_code: "https://github.com/solana-developers/solana-game-preset",
    source_revision: "5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    source_release: "",
    encryption: "",
    auditors: "Verifier pubkey: 5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    acknowledgements: "Thank you to our bug bounty hunters!"
}
```

Una volta che le informazioni `security.txt` sono incorporate nel tuo programma,
possono essere facilmente consultate tramite strumenti come Solana Explorer,
assicurando che i tuoi contatti e i dettagli di sicurezza siano disponibili a
chiunque voglia segnalare potenziali problemi.

## Best practices

- Usa i link: per informazioni che potrebbero cambiare (ad esempio, i dettagli
  di contatto), è consigliabile linkare a una pagina web piuttosto che
  codificarle direttamente nel contratto. Questo evita la necessità di frequenti
  aggiornamenti del programma.

- Verifica: prima di distribuire, verifica il formato e il contenuto utilizzando
  lo strumento `query-security-txt`, che può validare sia i programmi onchain
  che i binari locali:

```bash
query-security-txt target/bpfel-unknown-unknown/release/my_contract.so
```

Incorporando le informazioni di contatto per la sicurezza direttamente nel tuo
contratto, rendi più facile per i ricercatori raggiungerti, favorendo una
migliore sicurezza e comunicazione all'interno dell'ecosistema Solana.

Questo è
[un esempio di come security.txt appare in Solana Explorer](https://explorer.solana.com/address/HPxKXnBN4vJ8RjpdqDCU7gvNQHeeyGnSviYTJ4fBrDt4/security?cluster=devnet)

Il progetto `security.txt` è mantenuto da
[Neodyme Labs](https://github.com/neodyme-labs)
