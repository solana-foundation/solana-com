---
title: 验证程序
description: 验证构建是一种将程序与其源代码关联起来的方法，使每个人都可以独立验证该程序确实是从提供的源代码构建而来的。
---

本指南旨在为希望在 Solana 上为其程序实现验证构建的开发者提供参考。我们将介绍什么是验证构建、如何使用它们、需要注意的特殊事项以及确保程序链上真实性的最佳实践。

# 什么是验证构建？

验证构建确保您部署到 Solana 网络的可执行程序与您代码库中的源代码相匹配。通过这样做，开发者和用户可以确信链上运行的程序与公共代码库完全一致，从而促进透明性和安全性。

验证过程包括将链上程序的哈希值与从源代码本地构建的程序的哈希值进行比较。这确保了两者之间没有差异。

> 虽然验证构建不应被认为比未验证构建更安全，但它使开发者能够自行验证源代码与链上部署的内容相匹配。使用源代码，开发者可以验证代码在发送交易时执行的内容。

验证构建流程由 [Ellipsis Labs](https://ellipsislabs.xyz/) 和
[OtterSec](https://osec.io/) 设计并维护。有关更多详细信息，请参阅
[原始验证构建](https://github.com/Ellipsis-Labs/solana-verifiable-build)
库中的指南，以及在 [Anza](https://www.anza.xyz/)
工具套件中直接支持的验证构建流程（支持后）。

# 它是如何工作的？

验证过程是通过比较链上程序的哈希值与从源代码本地构建的程序的哈希值来完成的。您可以使用 Solana
Verify
CLI 和 Docker 在受控环境中构建您的程序。这确保了构建过程在不同系统之间是确定性和一致的。一旦您获得了可执行文件，您就可以将其部署到 Solana 网络。在构建过程中，会创建一个
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)（程序派生地址）用于
[verify program](https://github.com/otter-sec/otter-verify)。这个 PDA 包含验证程序所需的所有数据。PDA 包括程序地址、Git
URL、提交哈希值以及用于构建程序的参数。

通过 PDA 中的数据，任何人都可以在本地运行 verify
program 命令，检查程序是否是从提供的源代码构建的。然后，任何人都可以完全无需信任地自行验证，或者运行由
[OtterSec](https://github.com/otter-sec) 维护的
[verify API](https://github.com/otter-sec/solana-verified-programs-api)，为用户提供一个便捷的验证访问点。您已经可以在
[Solana Explorer](https://explorer.solana.com/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/verified-build)
和
[SolanaFM](https://solana.fm/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/transactions?cluster=mainnet-alpha)
等平台上看到这些
[API 调用](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
的使用。

# 为什么我应该使用已验证的构建？

使用已验证的构建可以带来以下好处：

- 安全性：保证链上运行的程序与源代码一致，防止恶意篡改。

- 透明性：允许其他用户和开发者通过与公共代码库进行比较来验证链上程序的可信度。

- 信任：提高用户信心，因为已验证的构建表明您的程序链上行为与您的公共代码一致。在构建可验证程序时，您可以最大限度地减少运行未经授权或恶意代码的风险。这也确保您遵循最佳实践，并为安全研究人员提供一种简单的联系方式。此外，只要程序经过验证，钱包和其他工具也可以更轻松地允许来自您的程序的交易。

- 可发现性：当您提供经过验证的程序构建版本时，所有人都可以找到您的源代码、文档、程序 SDK 或 IDL，并且如果出现问题，他们还可以通过 GitHub 轻松联系您。

# 如何创建经过验证的构建？

要创建经过验证的构建，您需要按照以下步骤操作：

摘要：

- 将您的代码提交到公共代码库
- 在 Docker 中构建一个经过验证的构建
- 部署经过验证的构建
- 根据公共 API 验证已部署的程序

如果您验证的程序不是在 Docker 容器中构建的，很可能会失败，因为 Solana 程序构建在不同系统之间并非确定性一致。

<Steps>
<Step>

### 安装 Docker 和 Cargo

安装必要的工具，确保您已安装 Docker 和 Cargo。Docker 提供了一个受控的构建环境以确保一致性，而 Cargo 用于管理 Rust 包。

- Docker：按照 [Docker 网站](https://docs.docker.com/engine/install/)
  上的步骤为您的平台安装 Docker。安装完成后，确保 Docker 服务正在运行，并继续按照本指南操作。
- Cargo：如果您尚未安装 Cargo，可以通过运行以下命令进行安装：

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

</Step>
<Step>

### 安装 Solana Verify CLI

Solana Verify CLI 是用于验证构建的主要工具。Solana Verify CLI 目前由
[Ellipsis Labs](https://ellipsislabs.xyz/) 维护，可以通过 Cargo 安装。

您可以通过运行以下命令安装：

```bash
cargo install solana-verify
```

如果您需要特定版本的 CLI，可以通过以下方式固定版本：

```bash
cargo install solana-verify --version $VERSION
```

如果需要，您还可以直接从特定提交中安装一个版本：

```bash
cargo install solana-verify --git https://github.com/Ellipsis-Labs/solana-verifiable-build --rev 13a1db2
```

</Step>
<Step>

### 准备项目

要验证存储库，需要在存储库的根目录中包含一个 `Cargo.lock`
文件。如果您的存储库中只有一个程序，并且根目录中有一个 `cargo.lock`
文件，您可以直接进入下一步并构建您的程序。

如果您的程序位于子文件夹中，并且您有一个 Rust 工作区，则需要在存储库的根目录中创建一个工作区
`Cargo.toml` 文件。

您可以使用此 `Cargo.toml` 示例作为预设：

```toml title="Cargo.toml"
[workspace]
members = ["program/programs/*"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1

[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
```

确保您的程序在 `workspace/members` 数组中，并且您的程序的 `Cargo.toml`
文件已配置正确的 `lib` 名称。

> 重要的是 `lib name`，而不是包名！

类似于以下内容：

```toml title="waffle/Cargo.toml"
[package]
name = "waffle"
version = "0.1.0"
edition = "2021"

[lib]
name = "waffle"
crate-type = ["cdylib", "lib"]

[dependencies]
solana-program = "2.1.0"
```

在这个 [存储库](https://github.com/solana-developers/verified-program)
中，您可以看到一个包含子文件夹中程序的工作区示例。还请注意，当程序位于子文件夹中时，稍后需要将此文件夹添加为
`--mount-path` 到 `verify-from-repo` 命令中。

在这个 [存储库](https://github.com/solana-developers/solana-game-preset)
中，您可以找到一个 Anchor 示例。在这个
[存储库](https://github.com/solana-developers/verified-program-root)
中，您可以找到一个原生 Rust 示例。

有了这个 `Cargo.toml` 文件后，您可以运行 `cargo generate-lockfile`
来创建一个锁定文件，然后继续构建您的程序。

</Step>
<Step>

### 构建可验证程序

要可验证地构建您的 Solana 程序，请导航到包含工作区 `Cargo.toml`
文件的目录并运行：

```bash
solana-verify build
```

这将把您的环境复制到一个 Docker 容器中，并以确定性的方式构建它。

> 确保您实际部署的是已验证的构建，而不是意外地用 `anchor build` 或
> `cargo build-sbf`
> 覆盖它，因为这些很可能不会生成相同的哈希值，因此您的验证将失败。

对于包含多个程序的项目，可以使用库名称（而不是包名称）来构建特定的程序：

```bash
solana-verify build --library-name $PROGRAM_LIB_NAME
```

此过程可确保构建的确定性，但可能需要一些时间，尤其是在某些系统（例如 M1
MacBook）上，因为它是在 docker 容器中运行的。为了加快构建速度，建议使用运行 x86 架构的 Linux 机器。

构建完成后，可以使用以下命令检索可执行文件的哈希值：

```bash
solana-verify get-executable-hash target/deploy/$PROGRAM_LIB_NAME.so
```

</Step>
<Step>

### 部署可验证程序

在构建程序并检索其哈希值后，可以将其部署到 Solana 网络。建议使用多签名或治理解决方案（例如
[Squads Protocol](https://squads.so/protocol)）进行安全部署，但也可以直接部署：

```bash
solana program deploy -u $NETWORK_URL target/deploy/$PROGRAM_LIB_NAME.so --program-id $PROGRAM_ID --with-compute-unit-price 50000 --max-sign-attempts 100 --use-rpc
```

您可以从 rpc 提供商（例如
[Quicknode](https://www.quicknode.com/gas-tracker/solana)）请求当前适合的低优先级费用。

要验证已部署的程序与构建的可执行文件是否匹配，请运行：

```bash
solana-verify get-program-hash -u $NETWORK_URL $PROGRAM_ID
```

> 您可能在不同的
> [Solana 集群](/docs/references/clusters)（例如 devnet、testnet、mainnet）上部署了不同的版本。确保使用正确的网络 URL 来验证目标 Solana 集群上的程序。远程验证仅适用于 mainnet。

</Step>
<Step>

### 与存储库进行验证

要将程序与其公共存储库进行验证，请使用：

```bash
solana-verify verify-from-repo -u $NETWORK_URL --program-id $PROGRAM_ID https://github.com/$REPO_PATH --commit-hash $COMMIT_HASH --library-name $PROGRAM_LIB_NAME --mount-path $MOUNT_PATH
```

> 当您在程序目录中运行已验证的构建时，运行 `verify-from-repo` 时需要添加
> `--mount-path` 标志。这将是包含 `Cargo.toml`
> 的文件夹路径，其中包含程序的库名称。

此命令将链上程序的哈希值与从指定提交哈希的源代码构建的可执行文件哈希值进行比较。

最后，命令会询问您是否希望将验证数据上传到链上。如果您选择上传，Solana
Explorer 将立即显示您程序的验证数据。在通过远程构建验证之前，它将显示为未验证。了解如何在下一步中通过公共 API 验证您的程序。

如果您希望将验证锁定到某个特定版本，可以在命令中添加 `--commit-hash` 标志。

</Step>
<Step>

### 通过公共 API 验证

最后，您还可以直接通过运行验证 API 的任何人验证程序：

```bash
solana-verify verify-from-repo --remote -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

> 建议使用付费的 RPC URL，否则可能会遇到免费 RPC 的速率限制。因此，与其使用
> `-um`，您应该使用 `--url yourRpcUrl` 以获得更可靠的验证。

`--remote` 标志会向 OtterSec
API 发送一个构建请求，从而触发程序的远程构建。一旦构建完成，系统会验证程序的链上哈希值是否与从您的代码库生成的构建工件的哈希值匹配。

默认使用
[OtterSec API](https://github.com/otter-sec/solana-verified-programs-api)。

当被询问是否将验证数据上传到链上时，请确保选择“是”。API 会使用此数据验证您已上传的验证数据。

您还可以通过以下方式手动触发远程任务：

```bash
solana-verify remote submit-job --program-id <program-id> --uploader <address>
```

上传者是具有写入 PDA 权限的地址。在大多数情况下，这应该是程序权限。如果您的程序由多签控制，请继续阅读本指南下方的
[多签验证](#how-to-verify-your-program-when-its-controlled-by-a-multisig-like-squads)
部分。

这将向 OtterSec API 提交一个任务，您可以通过以下方式验证任务状态：

```bash
solana-verify remote get-job-status --job-id <job-id>
```

一旦验证成功完成（可能需要一些时间），您将能够在以下位置看到您的程序已被验证：
[单个程序的 OtterSec API](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)、
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY/verified-build)、
[SolanaFM](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY?cluster=mainnet-alpha)、
[SolScan](https://solscan.io/account/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY#programVerification)，以及最终在社区运营的网站
[SolanaVerify.org](https://www.solanaverify.org/)（由
[0xDeep](https://x.com/0xDeep) 维护）和
[OtterSec 验证程序 API](https://verify.osec.io/verified-programs)，最后在
[Verified Programs Dune Dashboard](https://dune.com/jonashahn/verified-programs/dedf21e1-9b71-42c8-89f9-02ed94628657)
上显示，为更健康的 Solana 生态系统做出贡献。

</Step>
</Steps>

## 如何验证由 Squads 等多签控制的程序

为了使远程验证生效，您需要将验证数据写入由程序权限签名的 PDA。如果您的程序由多签控制，您可以导出此写入 PDA 的交易，并通过
[Squads Protocol](https://squads.so/protocol) 或您选择的其他多签解决方案提交。

<Steps>
<Step>

### 1. 构建可验证的程序

首先构建程序：

```bash
solana-verify build
```

这将使用 docker 容器构建一个可验证的版本，使用 `Cargo.lock`
文件中指定的 Solana 版本。

</Step>
<Step>

### 2. 部署程序

```bash
solana config set --url "PayedMainnetRPCAddress" // the public endpoint will be rate limited too much
solana program deploy target/deploy/verify_squads.so
```

在本多签指南的其余部分中，我们将使用一个示例程序 ID：
`6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`。

</Step>
<Step>

### 3. 提交并验证到存储库

完成后，我们将项目提交到 GitHub。以下是一个示例：
https://github.com/solana-developers/verify-squads

可选：先尝试在本地验证（此命令使用示例程序ID
`6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`）：

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
```

确保您的参数是正确的。

</Step>
<Step>

### 4. 将程序权限转移到多签账户

如果您尚未将程序权限转移到多签账户，请执行此操作并复制多签账户的权限。在下一步中您将需要它。

</Step>
<Step>

### 5. 导出 PDA 交易

当您在本地拥有程序权限时，系统会提示您在使用命令
`solana-verify verify-from-repo` 时将构建数据上传到链上。

由于使用多签账户时无法直接执行此操作，您需要手动导出 PDA 交易，然后通过 Squads 触发交易。

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader <your program authority> --encoding base58 --compute-unit-price 0
```

这将返回一个 base58 格式的交易。如果您需要一个 base64 编码的交易以便在交易检查器中使用，可以使用
`--encoding base64`。

```bash
P6vBfcPaaXb8fZoT3NBAYEcdtEj7tubA1k2gBxmFKZ3UWF5YyrmDMFTvLKALCJoUuRsPAjMckudYruCu3eeWQtuDrFbEMLxLFutnKXac974fnkMivcwUdY66VLjbxQT6ATmcy7F4hBtz1G4P1h6iBJLhb8WtrtgY3i4qq45MUEb7RjuMEfUFXKrNgPdGxkz5xvMHq3dxKRcpmEK5k2DkeW6SUQYBVe19Ga3B9GyhTX8k3CMt9JCEah13WyRnQd8GjoK6sTEvGJym6xDNvmd8yiJYSNcaYwEJsjHEUf4Yh6kAC7ki2KRvVAr3NVe1gjqK9McrwSQjtUatvydTG8Zovcr7PPUEMf3yPMgKXjZLB2QpkH63yTTYdNAnWFuv9E6b6nYRqye5XcNi436yKw5U14fXh65yK34bgYLi9328UT1huJELsJU9BRGnGUmb6GWp6c2WL5BhnzgNTSnt9TXFfEgUMzhvKzpVBxLP44hwqqBdyUhHFysCF37531PnmiESq8x1xou23xJ6FcQbc199754MkqQd7tX9CUznGzAEqHGkzn3VBoJnojsKtgYmiTYbdRsT1CU18MbYEE7WvGAvXyxxbpNzbAcc94HrnM6cqRGmwhEBroPfFghTdmzg9D
```

</Step>
<Step>

### 6. 通过 Squads 提交交易

前往 Squads 交易构建器并导入 base58 编码的交易。确保在模拟中，交易仅调用 osec 验证程序和计算预算程序，且没有其他内容！

</Step>
<Step>

### 7. 提交远程验证任务

当交易成功提交到 Squads 后，您可以提交远程任务：

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
--uploader <your program authority>
```

就是这样！您已成功将程序验证到公共存储库，并向 OtterSec
API 提交了远程任务。现在，您应该可以在 Solana Explorer 和其他地方看到它的反映。

</Step>
<Step>

### 8. 更新程序（可选）

当您更新程序时，需要导出一个新的 PDA 交易，并再次通过 Squads 提交。

更新程序的步骤：

```bash
solana-verify build
solana program write-buffer target/deploy/verify_squads.so --with-compute-unit-price 50000 --max-sign-attempts 50
```

然后将该缓冲区的权限转移到多签名账户，或者直接创建一个具有多签名账户权限的缓冲区。

```bash
solana program set-buffer-authority Fu3k79g53ZozAj47uq1tXrFy4QbQYh7y745DDsxjtyLR --new-buffer-authority 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

</Step>
<Step>

### 9. 导出并提交新的 PDA 交易

别忘了将您的更改提交到 GitHub。再次导出 PDA 升级交易：

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

再次通过 Squads 提交交易。

您可以在[这里](https://solana.fm/tx/4zJ1vK2KToAwxuEYzTMLqPkcebjoi9rdeeyxtEEx9L5Q4vWDA8h6Rr4kPRuRxcV7ZLKMr6qx1LTWb6x3ZpUJaFUW?cluster=mainnet-alpha)查看一个示例交易。

然后提交另一个远程构建：

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

结果应类似于以下内容：

```shell
Verification request sent with request id: b63339d2-163e-49ac-b55d-3454c1c2b5b3
Verification in progress... ⏳ [00:18:02] ✅ Process completed. (Done in 18
minutes) Program 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD has been verified.
✅ The provided GitHub build matches the on-chain hash. On Chain Hash:
96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Executable
Hash: 96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Repo URL:
https://github.com/Woody4618/verify-squads/tree/0fb0a2e30c15c51732c0ad5e837975a6f7bbc7ed
Check the verification status at:
https://verify.osec.io/status/6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD Job
url: https://verify.osec.io/job/b63339d2-163e-49ac-b55d-3454c1c2b5b3
```

恭喜您，在多签名升级后成功验证了您的程序！

</Step>
</Steps>

## 从 Docker 镜像验证

您还可以通过运行以下命令，使用 Docker 镜像验证您的程序：

```bash
solana-verify verify-from-image -e
examples/hello_world/target/deploy/hello_world.so -i
ellipsislabs/hello_world_verifiable_build:latest -p
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn
```

此命令会加载存储在 `ellipsislabs/hello_world_verifiable_build:latest`
的镜像，并验证容器中可执行路径的哈希值是否与提供给命令的链上程序的哈希值相同。由于构建已经上传到镜像中，因此无需重新完整构建可执行文件，这可以节省大量时间。

创建该镜像的 Dockerfile 可以在 ellipsis labs 的
[/examples/hello_world](https://github.com/Ellipsis-Labs/solana-verifiable-build/tree/master/examples/hello_world)
仓库中找到。

以下是预期的输出结果：

```bash
Verifying image: "ellipsislabs/hello_world_verifiable_build:latest", on network
"https://api.mainnet.solana.com" against program ID
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn Executable path in container:
"examples/hello_world/target/deploy/hello_world.so"

Executable hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Program hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Executable
matches on-chain program data ✅
```

## 示例已验证构建

以下是一个使用此[代码库](https://github.com/solana-developers/verified-program)中的源代码，通过 ID
`FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv` 验证示例程序的示例：

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

默认情况下，`verify-from-repo`
命令会使用主分支上的最后一次提交。如果您希望在继续处理代码库时指定某个特定的提交，可以使用
`commit-hash` 参数： `--commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e`

最后，您还可以直接通过 OtterSec API 验证程序：

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --remote --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

`--remote` 命令会向 OtterSec
API 发送一个构建请求，从而触发程序的远程构建。构建完成后，系统会验证您的程序的链上哈希是否与代码库中生成的构建工件的哈希匹配。

## 已验证的热门程序

### Phoenix

```shell
solana-verify verify-from-repo -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

最终输出：

```shell
Executable Program Hash from repo: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
On-chain Program Hash: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
Program hash matches ✅
```

### Squads V3

```shell
solana-verify verify-from-repo https://github.com/Squads-Protocol/squads-mpl --commit-hash c95b7673d616c377a349ca424261872dfcf8b19d --program-id SMPLecH534NA9acpos4G6x7uf3LWbCAwZQE9e8ZekMu -um --library-name squads_mpl --bpf
```

> 注意，我们需要指定 `library-name`，因为 Squads 代码库包含多个程序。我们使用
> `--bpf` 标志，因为 `squads_mpl` 之前已通过 Anchor 验证。

最终输出：

```shell
Executable Program Hash from repo: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
On-chain Program Hash: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
Program hash matches ✅
```

### Drift V2

```shell
solana-verify verify-from-repo -um --program-id dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH https://github.com/drift-labs/protocol-v2 --commit-hash 110d3ff4f8ba07c178d69f9bfc7b30194fac56d6 --library-name drift
```

最终输出：

```shell
Executable Program Hash from repo: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
On-chain Program Hash: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
Program hash matches ✅
```

### Marginfi V2

```shell
solana-verify verify-from-repo -um --program-id MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA https://github.com/mrgnlabs/marginfi-v2 --commit-hash d33e649e415c354cc2a1e3c49131725552d69ba0 --library-name marginfi -- --features mainnet-beta
```

最终输出：

```shell
Executable Program Hash from repo: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
On-chain Program Hash: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
Program hash matches ✅
```

# 结论

使用 [Solana 的已验证构建](/developers/guides/advanced/verified-builds)
可确保网络上程序的完整性和可信度，并允许开发者直接从 Solana
Explorer 找到您的 SDK。通过利用 Solana Verify
CLI 和 Docker 等工具，您可以维护与源代码一致的可验证且安全的构建。始终采取必要的预防措施以使用一致的环境，并考虑使用治理解决方案来实现安全的升级和部署。

## 安全性与免责声明

虽然已验证构建是确保 Solana 程序完整性的强大工具，但在默认设置下，它并非完全无需信任。这些 Docker 镜像由 Solana 基金会构建和托管。

请注意，您是在下载的 Docker 镜像中构建项目，您的整个设置会被复制到该 Docker 镜像中进行构建，包括可能包含敏感信息的内容。

如果您希望拥有完全无需信任的设置，可以自行构建 Docker 镜像并将其托管在自己的基础设施上。这样，您可以确保 Docker 镜像未被篡改。您可以在
[已验证构建存储库](https://github.com/Ellipsis-Labs/solana-verifiable-build)
中找到创建 Docker 镜像的脚本，并可以将其分叉并自行运行 GitHub
Actions，或者验证它们的正确性。

此外，对于远程验证，您需要在一定程度上信任 OtterSec API 和
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)。

如果 API 或 Solana Explorer 被攻破，可能会显示不正确的信息。

如果您希望拥有完全无需信任的设置，可以自行运行
[Verify API](https://github.com/otter-sec/solana-verified-programs-api)，或者使用
`verify-from-repo` 命令在本地运行程序验证，利用保存在
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)
中的链上验证数据，该 PDA 是从程序部署权限和
[验证程序](https://explorer.solana.com/address/verifycLy8mB96wd9wqq3WDXQwM4oU6r42Th37Db9fC)
派生的。

验证程序由 [OtterSec 团队](https://osec.io/)
部署，目前尚未冻结，因此可以随时升级。

Solana 基金会、OtterSec 和 Ellipsis
Labs 团队对使用验证构建管道可能导致的任何损失或损害不承担责任。

# Solana 程序的 Security.txt

除了验证构建之外，您还可以向您的程序添加一个 `security.txt`
文件。未来在实现后，`security.txt`
将包含验证者公钥，以便轻松访问存储在验证 PDA 中的验证数据。包含构建和验证程序所需的所有信息的 PDA 是从程序地址和验证者 pubkey 派生的。默认情况下，这与构建和部署程序的 pubkey 相同。但也可以是另一个 pubkey，可以在
`security.txt` 中指定。

`security.txt`
功能允许开发者将联系和安全信息直接嵌入到他们的 Solana 智能合约中。受
[securitytxt.org](https://securitytxt.org)
启发，这种方法为安全研究人员提供了一种标准化的方式与项目维护者联系，即使他们只知道合约地址。

## 为什么使用 security.txt？

对于许多项目，尤其是较小或私有的项目，仅通过合约地址识别开发者可能既困难又耗时。在程序中嵌入一个
`security.txt`
文件可以确保安全研究人员能够轻松联系到正确的人，从而可能防止漏洞利用并确保及时的错误报告。

## 如何实现 security.txt

要向您的 Solana 程序添加一个 `security.txt`，请按照以下步骤操作：

将 `solana-security-txt` 依赖项添加到您的 `Cargo.toml`：

```toml title="Cargo.toml"
[dependencies]
solana-security-txt = "1.1.1"
```

在您的合约中使用 `security_txt!`
宏来定义您的安全信息。您可以包括联系方式、项目 URL，甚至是安全策略。以下是一个示例：

```rust
#[cfg(not(feature = "no-entrypoint"))]
use {default_env::default_env, solana_security_txt::security_txt};

#[cfg(not(feature = "no-entrypoint"))]
security_txt! {
    name: "MyProject",
    project_url: "https://myproject.com",
    contacts: "email:security@myproject.com,discord:security#1234",
    policy: "https://myproject.com/security-policy",

    // Optional Fields
    preferred_languages: "en,de",
    source_code: "https://github.com/solana-developers/solana-game-preset",
    source_revision: "5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    source_release: "",
    encryption: "",
    auditors: "Verifier pubkey: 5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    acknowledgements: "Thank you to our bug bounty hunters!"
}
```

一旦将 `security.txt` 信息嵌入到您的程序中，就可以通过 Solana
Explorer 等工具轻松查询，确保任何希望报告潜在问题的人都能获取您的联系和安全信息。

## 最佳实践

- 使用链接：对于可能会更改的信息（例如联系方式），建议链接到网页，而不是将其硬编码到合约中。这可以避免频繁的程序升级。

- 验证：在部署之前，使用 `query-security-txt`
  工具验证格式和内容，该工具可以验证链上程序和本地二进制文件：

```bash
query-security-txt target/bpfel-unknown-unknown/release/my_contract.so
```

通过将安全联系信息直接嵌入到您的合约中，您可以让研究人员更容易联系到您，从而促进 Solana 生态系统内更好的安全性和沟通。

这是
[在 Solana Explorer 中 security.txt 的示例](https://explorer.solana.com/address/HPxKXnBN4vJ8RjpdqDCU7gvNQHeeyGnSviYTJ4fBrDt4/security?cluster=devnet)

`security.txt` 项目由 [Neodyme Labs](https://github.com/neodyme-labs) 维护
