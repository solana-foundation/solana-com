---
title: Token 组和成员
description: 了解如何启用 GroupPointerExtension 和 GroupMemberPointerExtension。
---

## 如何启用 GroupPointerExtension 和 GroupMemberPointerExtension

[`GroupPointerExtension`](https://github.com/solana-program/token-2022/blob/6f2473344d70271f632c3e9b7e945be00186c536/interface/src/instruction.rs#L718)
用于将某个 mint 指定为 group mint（如 Collection
NFT），方法是指向一个包含[group 配置](https://github.com/solana-program/token-group/blob/3b4ff305452fa35754206fc1ad4addb2e2bff511/interface/src/state.rs#L16)（如 update
authority 和最大数量）的账户。

[`GroupMemberPointerExtension`](https://github.com/solana-program/token-2022/blob/6f2473344d70271f632c3e9b7e945be00186c536/interface/src/instruction.rs#L725)
用于将某个 mint 指定为 member
mint（如集合中的 NFT），方法是指向一个包含[membership 数据](https://github.com/solana-program/token-group/blob/3b4ff305452fa35754206fc1ad4addb2e2bff511/interface/src/state.rs#L67)（如 group
address 和成员编号）的账户。

Token Extensions Program 直接实现了
[Token Group Interface](https://github.com/solana-program/token-group)，允许组和成员数据都存储在 mint 账户本身。当指针扩展指向 mint 本身时，
[TokenGroup](https://github.com/solana-program/token-2022/blob/6f2473344d70271f632c3e9b7e945be00186c536/interface/src/extension/token_group/mod.rs#L7)
和
[TokenGroupMember](https://github.com/solana-program/token-2022/blob/6f2473344d70271f632c3e9b7e945be00186c536/interface/src/extension/token_group/mod.rs#L11)
扩展可以用于将所有集合和成员数据存储在 mint 账户中。

### Typescript

<CodeTabs storage="token-ts" flags="r">

```ts !! title="Kit"
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  extension,
  getInitializeAccountInstruction,
  getInitializeMintInstruction,
  getInitializeGroupPointerInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  getInitializeTokenGroupInstruction,
  getInitializeGroupMemberPointerInstruction,
  getInitializeTokenGroupMemberInstruction
} from "@solana-program/token-2022";
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners,
  some
} from "@solana/kit";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate the authority for the mint (also acts as fee payer)
const authority = await generateKeyPairSigner();

// Fund authority/fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: authority.address,
  lamports: lamports(5_000_000_000n), // 5 SOL
  commitment: "confirmed"
});

// ===== GROUP MINT CREATION =====

// Generate keypair to use as address of group mint
const groupMint = await generateKeyPairSigner();

// Group pointer extension (points to external group account)
const groupPointerExtension = extension("GroupPointer", {
  authority: authority.address,
  groupAddress: groupMint.address // Points to the group mint itself
});

// Group extension (stores group data directly on mint)
const groupExtension = extension("TokenGroup", {
  updateAuthority: some(authority.address),
  mint: groupMint.address,
  size: 1, // Will be incremented when members are added
  maxSize: 10
});

// Get mint account size with group pointer extension
const spaceWithGroupPointerExtensions = BigInt(
  getMintSize([groupPointerExtension])
);

// Get mint account size with group pointer and group extension
const spaceWithGroupAndGroupPointerExtensions = BigInt(
  getMintSize([groupPointerExtension, groupExtension])
);

// Get rent exempt balance for group mint
const groupMintRent = await rpc
  .getMinimumBalanceForRentExemption(spaceWithGroupAndGroupPointerExtensions)
  .send();

// Get latest blockhash
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// GROUP MINT INSTRUCTIONS
const createGroupMintAccountInstruction = getCreateAccountInstruction({
  payer: authority,
  newAccount: groupMint,
  lamports: groupMintRent,
  space: spaceWithGroupPointerExtensions,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

const initializeGroupPointerInstruction = getInitializeGroupPointerInstruction({
  mint: groupMint.address,
  authority: authority.address,
  groupAddress: groupMint.address
});

const initializeGroupMintInstruction = getInitializeMintInstruction({
  mint: groupMint.address,
  decimals: 0, // NFT-style
  mintAuthority: authority.address,
  freezeAuthority: authority.address
});

const initializeGroupInstruction = getInitializeTokenGroupInstruction({
  group: groupMint.address,
  mint: groupMint.address,
  mintAuthority: authority,
  updateAuthority: authority.address,
  maxSize: 10
});

// Build group mint transaction
const groupInstructions = [
  createGroupMintAccountInstruction,
  initializeGroupPointerInstruction,
  initializeGroupMintInstruction,
  initializeGroupInstruction
];

const groupTransactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(authority, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions(groupInstructions, tx)
);

const signedGroupTransaction = await signTransactionMessageWithSigners(
  groupTransactionMessage
);

await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedGroupTransaction,
  { commitment: "confirmed", skipPreflight: true }
);

const groupTransactionSignature = getSignatureFromTransaction(
  signedGroupTransaction
);
console.log("Group Mint Address:", groupMint.address.toString());
console.log("Group Transaction Signature:", groupTransactionSignature);

// ===== MEMBER MINT CREATION =====

// Generate keypair for member mint
const memberMint = await generateKeyPairSigner();

// Member pointer extension (points to external member account)
const memberPointerExtension = extension("GroupMemberPointer", {
  authority: authority.address,
  memberAddress: memberMint.address // Points to the member mint itself
});

// Member extension (stores membership data directly on mint)
const memberExtension = extension("TokenGroupMember", {
  mint: memberMint.address,
  group: groupMint.address, // References the group mint we created above
  memberNumber: 1 // First member of the group
});

// Get mint account size with group pointer extension
const spaceWithMemberPointerExtension = BigInt(
  getMintSize([groupPointerExtension])
);

// Get mint account size with group pointer and group extension
const spaceWithMemberAndMemberPointerExtensions = BigInt(
  getMintSize([groupPointerExtension, groupExtension])
);

// Get rent exempt balance for member mint
const memberMintRent = await rpc
  .getMinimumBalanceForRentExemption(spaceWithMemberAndMemberPointerExtensions)
  .send();

// Get fresh blockhash for member mint transaction
const { value: memberLatestBlockhash } = await rpc.getLatestBlockhash().send();

// MEMBER MINT INSTRUCTIONS
const createMemberMintAccountInstruction = getCreateAccountInstruction({
  payer: authority,
  newAccount: memberMint,
  lamports: memberMintRent,
  space: spaceWithMemberPointerExtension, // Only pointer extension space for account creation
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

const initializeMemberPointerInstruction =
  getInitializeGroupMemberPointerInstruction({
    mint: memberMint.address,
    authority: authority.address,
    memberAddress: memberMint.address
  });

const initializeMemberMintInstruction = getInitializeMintInstruction({
  mint: memberMint.address,
  decimals: 0, // NFT-style
  mintAuthority: authority.address,
  freezeAuthority: authority.address
});

// Initialize member extension (added post-mint initialization)
const initializeMemberInstruction = getInitializeTokenGroupMemberInstruction({
  member: memberMint.address,
  memberMint: memberMint.address,
  memberMintAuthority: authority,
  group: groupMint.address, // References the group mint
  groupUpdateAuthority: authority
});

// Build member mint transaction
const memberInstructions = [
  createMemberMintAccountInstruction,
  initializeMemberPointerInstruction,
  initializeMemberMintInstruction,
  initializeMemberInstruction
];

const memberTransactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(authority, tx),
  (tx) =>
    setTransactionMessageLifetimeUsingBlockhash(memberLatestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions(memberInstructions, tx)
);

const signedMemberTransaction = await signTransactionMessageWithSigners(
  memberTransactionMessage
);

await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedMemberTransaction,
  { commitment: "confirmed", skipPreflight: true }
);

const memberTransactionSignature = getSignatureFromTransaction(
  signedMemberTransaction
);
console.log("Member Mint Address:", memberMint.address.toString());
console.log("Member Transaction Signature:", memberTransactionSignature);

console.log("\n===== SUMMARY =====");
console.log("Group Mint:", groupMint.address.toString());
console.log("Member Mint:", memberMint.address.toString());
console.log("Member belongs to Group:", groupMint.address.toString());
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  Transaction,
  SystemProgram,
  LAMPORTS_PER_SOL,
  sendAndConfirmTransaction
} from "@solana/web3.js";
import {
  TOKEN_2022_PROGRAM_ID,
  ExtensionType,
  getMintLen,
  createInitializeMintInstruction,
  createInitializeGroupPointerInstruction,
  createInitializeGroupInstruction,
  createInitializeGroupMemberPointerInstruction,
  createInitializeMemberInstruction
} from "@solana/spl-token";

// Create Connection, local validator in this example
const connection = new Connection("http://localhost:8899", "confirmed");

// Generate the authority for the mint (also acts as fee payer)
const authority = Keypair.generate();

// Fund authority/fee payer
const airdropSignature = await connection.requestAirdrop(
  authority.publicKey,
  5 * LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// ===== GROUP MINT CREATION =====

// Generate keypair to use as address of group mint
const groupMint = Keypair.generate();

// Get mint account size with group pointer extension only
const groupPointerExtensions = [ExtensionType.GroupPointer];
const spaceWithGroupPointerExtensions = getMintLen(groupPointerExtensions);

// Get mint account size with group pointer and group extension
const groupAndGroupPointerExtensions = [
  ExtensionType.GroupPointer,
  ExtensionType.TokenGroup
];
const spaceWithGroupAndGroupPointerExtensions = getMintLen(
  groupAndGroupPointerExtensions
);

// Get rent exempt balance for group mint (full space)
const groupMintRent = await connection.getMinimumBalanceForRentExemption(
  spaceWithGroupAndGroupPointerExtensions
);

// Get latest blockhash
const { blockhash: latestBlockhash } = await connection.getLatestBlockhash();

// GROUP MINT INSTRUCTIONS
const createGroupMintAccountInstruction = SystemProgram.createAccount({
  fromPubkey: authority.publicKey,
  newAccountPubkey: groupMint.publicKey,
  lamports: groupMintRent,
  space: spaceWithGroupPointerExtensions, // Only pointer extension space for account creation
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeGroupPointerInstruction =
  createInitializeGroupPointerInstruction(
    groupMint.publicKey, // mint
    authority.publicKey, // authority
    groupMint.publicKey, // group address (points to itself)
    TOKEN_2022_PROGRAM_ID
  );

const initializeGroupMintInstruction = createInitializeMintInstruction(
  groupMint.publicKey, // mint
  0, // decimals (NFT-style)
  authority.publicKey, // mint authority
  authority.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

const initializeGroupInstruction = createInitializeGroupInstruction({
  programId: TOKEN_2022_PROGRAM_ID,
  group: groupMint.publicKey,
  mint: groupMint.publicKey,
  mintAuthority: authority.publicKey,
  updateAuthority: authority.publicKey,
  maxSize: 10n
});

// Build group mint transaction
const groupTransaction = new Transaction({
  feePayer: authority.publicKey,
  recentBlockhash: latestBlockhash
}).add(
  createGroupMintAccountInstruction,
  initializeGroupPointerInstruction,
  initializeGroupMintInstruction,
  initializeGroupInstruction
);

const groupTransactionSignature = await sendAndConfirmTransaction(
  connection,
  groupTransaction,
  [authority, groupMint],
  { commitment: "confirmed", skipPreflight: true }
);

console.log("Group Mint Address:", groupMint.publicKey.toString());
console.log("Group Transaction Signature:", groupTransactionSignature);

// ===== MEMBER MINT CREATION =====

// Generate keypair for member mint
const memberMint = Keypair.generate();

// Get mint account size with member pointer extension only
const memberPointerExtensions = [ExtensionType.GroupMemberPointer];
const spaceWithMemberPointerExtension = getMintLen(memberPointerExtensions);

// Get mint account size with member pointer and member extension
const memberAndMemberPointerExtensions = [
  ExtensionType.GroupMemberPointer,
  ExtensionType.TokenGroupMember
];
const spaceWithMemberAndMemberPointerExtensions = getMintLen(
  memberAndMemberPointerExtensions
);

// Get rent exempt balance for member mint (full space)
const memberMintRent = await connection.getMinimumBalanceForRentExemption(
  spaceWithMemberAndMemberPointerExtensions
);

// Get fresh blockhash for member mint transaction
const { blockhash: memberLatestBlockhash } =
  await connection.getLatestBlockhash();

// MEMBER MINT INSTRUCTIONS
const createMemberMintAccountInstruction = SystemProgram.createAccount({
  fromPubkey: authority.publicKey,
  newAccountPubkey: memberMint.publicKey,
  lamports: memberMintRent,
  space: spaceWithMemberPointerExtension, // Only pointer extension space for account creation
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMemberPointerInstruction =
  createInitializeGroupMemberPointerInstruction(
    memberMint.publicKey, // mint
    authority.publicKey, // authority
    memberMint.publicKey, // member address (points to itself)
    TOKEN_2022_PROGRAM_ID
  );

const initializeMemberMintInstruction = createInitializeMintInstruction(
  memberMint.publicKey, // mint
  0, // decimals (NFT-style)
  authority.publicKey, // mint authority
  authority.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

// Initialize member extension (added post-mint initialization)
const initializeMemberInstruction = createInitializeMemberInstruction({
  programId: TOKEN_2022_PROGRAM_ID,
  member: memberMint.publicKey,
  memberMint: memberMint.publicKey,
  memberMintAuthority: authority.publicKey,
  group: groupMint.publicKey,
  groupUpdateAuthority: authority.publicKey
});

// Build member mint transaction
const memberTransaction = new Transaction({
  feePayer: authority.publicKey,
  recentBlockhash: memberLatestBlockhash
}).add(
  createMemberMintAccountInstruction,
  initializeMemberPointerInstruction,
  initializeMemberMintInstruction,
  initializeMemberInstruction
);

const memberTransactionSignature = await sendAndConfirmTransaction(
  connection,
  memberTransaction,
  [authority, memberMint],
  { commitment: "confirmed", skipPreflight: true }
);

console.log("Member Mint Address:", memberMint.publicKey.toString());
console.log("Member Transaction Signature:", memberTransactionSignature);

console.log("\n===== SUMMARY =====");
console.log("Group Mint:", groupMint.publicKey.toString());
console.log("Member Mint:", memberMint.publicKey.toString());
console.log("Member belongs to Group:", groupMint.publicKey.toString());
```

</CodeTabs>

### Rust

<CodeTabs storage="token-rs" flags="r">

```rust !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_token_2022_interface::{
    extension::{
        group_member_pointer::{
            instruction::initialize as initialize_group_member_pointer, GroupMemberPointer,
        },
        group_pointer::{instruction::initialize as initialize_group_pointer, GroupPointer},
        BaseStateWithExtensions, ExtensionType, StateWithExtensions,
    },
    instruction::initialize_mint,
    state::Mint,
    ID as TOKEN_2022_PROGRAM_ID,
};
use spl_token_group_interface::{
    instruction::{initialize_group, initialize_member},
    state::{TokenGroup, TokenGroupMember},
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let latest_blockhash = client.get_latest_blockhash().await?;

    // Generate the authority for the mint (also acts as fee payer)
    let authority = Keypair::new();

    // Airdrop 5 SOL to authority/fee payer
    let airdrop_signature = client
        .request_airdrop(&authority.pubkey(), 5_000_000_000)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create group mint
    // Generate keypair to use as address of group mint
    let group_mint = Keypair::new();

    // Calculate space for mint with group pointer extension only (for account creation)
    let group_mint_space =
        ExtensionType::try_calculate_account_len::<Mint>(&[ExtensionType::GroupPointer])?;

    // Calculate space for mint with group pointer and group extension (for rent calculation)
    let group_mint_space_with_data = ExtensionType::try_calculate_account_len::<Mint>(&[
        ExtensionType::GroupPointer,
        ExtensionType::TokenGroup,
    ])?;

    // Get rent exempt balance for full space (including data extension)
    let group_mint_rent = client
        .get_minimum_balance_for_rent_exemption(group_mint_space_with_data)
        .await?;

    let create_group_mint_account_instruction = create_account(
        &authority.pubkey(),     // payer
        &group_mint.pubkey(),    // new account (mint)
        group_mint_rent,         // lamports
        group_mint_space as u64, // space (pointer only for account creation)
        &TOKEN_2022_PROGRAM_ID,  // program id
    );

    let initialize_group_pointer_instruction = initialize_group_pointer(
        &TOKEN_2022_PROGRAM_ID,
        &group_mint.pubkey(),      // mint
        Some(authority.pubkey()),  // authority
        Some(group_mint.pubkey()), // group address (points to itself)
    )?;

    let initialize_group_mint_instruction = initialize_mint(
        &TOKEN_2022_PROGRAM_ID,    // program id
        &group_mint.pubkey(),      // mint
        &authority.pubkey(),       // mint authority
        Some(&authority.pubkey()), // freeze authority
        0,                         // decimals (NFT-style)
    )?;

    // Initialize group extension (added post-mint initialization)
    let initialize_group_instruction = initialize_group(
        &TOKEN_2022_PROGRAM_ID,   // program id
        &group_mint.pubkey(),     // group
        &group_mint.pubkey(),     // mint
        &authority.pubkey(),      // mint authority
        Some(authority.pubkey()), // update authority
        10,                       // max size
    );

    // Build group mint transaction
    let group_transaction = Transaction::new_signed_with_payer(
        &[
            create_group_mint_account_instruction,
            initialize_group_pointer_instruction,
            initialize_group_mint_instruction,
            initialize_group_instruction,
        ],
        Some(&authority.pubkey()),
        &[&authority, &group_mint],
        latest_blockhash,
    );

    client
        .send_and_confirm_transaction(&group_transaction)
        .await?;

    // Generate keypair for member mint
    let member_mint = Keypair::new();

    // Calculate space for mint with member pointer extension only (for account creation)
    let member_mint_space =
        ExtensionType::try_calculate_account_len::<Mint>(&[ExtensionType::GroupMemberPointer])?;

    // Calculate space for mint with member pointer and member extension (for rent calculation)
    let member_mint_space_with_data = ExtensionType::try_calculate_account_len::<Mint>(&[
        ExtensionType::GroupMemberPointer,
        ExtensionType::TokenGroupMember,
    ])?;

    // Get rent exempt balance for full space (including data extension)
    let member_mint_rent = client
        .get_minimum_balance_for_rent_exemption(member_mint_space_with_data)
        .await?;

    let create_member_mint_account_instruction = create_account(
        &authority.pubkey(),      // payer
        &member_mint.pubkey(),    // new account (mint)
        member_mint_rent,         // lamports
        member_mint_space as u64, // space (pointer only for account creation)
        &TOKEN_2022_PROGRAM_ID,   // program id
    );

    let initialize_member_pointer_instruction = initialize_group_member_pointer(
        &TOKEN_2022_PROGRAM_ID,
        &member_mint.pubkey(),      // mint
        Some(authority.pubkey()),   // authority
        Some(member_mint.pubkey()), // member address (points to itself)
    )?;

    let initialize_member_mint_instruction = initialize_mint(
        &TOKEN_2022_PROGRAM_ID,    // program id
        &member_mint.pubkey(),     // mint
        &authority.pubkey(),       // mint authority
        Some(&authority.pubkey()), // freeze authority
        0,                         // decimals (NFT-style)
    )?;

    // Initialize member extension (added post-mint initialization)
    let initialize_member_instruction = initialize_member(
        &TOKEN_2022_PROGRAM_ID, // program id
        &member_mint.pubkey(),  // member
        &member_mint.pubkey(),  // member mint
        &authority.pubkey(),    // member mint authority
        &group_mint.pubkey(),   // group (references the group mint)
        &authority.pubkey(),    // group update authority
    );

    // Build member mint transaction
    let member_transaction = Transaction::new_signed_with_payer(
        &[
            create_member_mint_account_instruction,
            initialize_member_pointer_instruction,
            initialize_member_mint_instruction,
            initialize_member_instruction,
        ],
        Some(&authority.pubkey()),
        &[&authority, &member_mint],
        latest_blockhash,
    );

    // Send and confirm member transaction
    client
        .send_and_confirm_transaction(&member_transaction)
        .await?;

    println!("Group Mint: {}", group_mint.pubkey());
    // Fetch and deserialize group mint
    let group_mint_account = client.get_account(&group_mint.pubkey()).await?;
    let group_mint_state = StateWithExtensions::<Mint>::unpack(&group_mint_account.data)?;

    let group_extension_types = group_mint_state.get_extension_types()?;
    println!("Extensions enabled: {:?}", group_extension_types);

    let group_pointer = group_mint_state.get_extension::<GroupPointer>()?;
    println!("\n{:#?}", group_pointer);
    let token_group = group_mint_state.get_extension::<TokenGroup>()?;
    println!("\n{:#?}", token_group);

    println!("\nMember Mint: {}", member_mint.pubkey());
    // Fetch and deserialize member mint
    let member_mint_account = client.get_account(&member_mint.pubkey()).await?;
    let member_mint_state = StateWithExtensions::<Mint>::unpack(&member_mint_account.data)?;

    let member_extension_types = member_mint_state.get_extension_types()?;
    println!("Extensions enabled: {:?}", member_extension_types);

    let member_pointer = member_mint_state.get_extension::<GroupMemberPointer>()?;
    println!("\n{:#?}", member_pointer);
    let token_group_member = member_mint_state.get_extension::<TokenGroupMember>()?;
    println!("\n{:#?}", token_group_member);

    Ok(())
}
```

</CodeTabs>
