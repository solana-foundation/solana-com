---
title: Programme verifizieren
description:
  Verifizierte Builds sind eine Möglichkeit, Ihr Programm mit seinem Quellcode
  zu verknüpfen und jedem zu ermöglichen, unabhängig zu überprüfen, dass das
  Programm tatsächlich aus diesem bereitgestellten Quellcode erstellt wurde.
---

Dieser Leitfaden dient als Referenz für Entwickler, die verifizierte Builds für
ihre Programme auf Solana implementieren möchten. Wir behandeln, was
verifizierte Builds sind, wie man sie verwendet, besondere Überlegungen und Best
Practices, um die Authentizität Ihres Programms onchain sicherzustellen.

# Was sind verifizierte Builds?

Verifizierte Builds stellen sicher, dass das ausführbare Programm, das Sie im
Solana-Netzwerk bereitstellen, mit dem Quellcode in Ihrem Repository
übereinstimmt. Dadurch können Entwickler und Benutzer darauf vertrauen, dass das
onchain ausgeführte Programm genau der öffentlichen Codebasis entspricht, was
Transparenz und Sicherheit fördert.

Der Verifizierungsprozess umfasst den Vergleich des Hashs des Onchain-Programms
mit dem Hash des lokal aus dem Quellcode erstellten Programms. Dies stellt
sicher, dass keine Diskrepanzen zwischen den beiden Versionen bestehen.

> Obwohl ein verifizierter Build nicht als sicherer als ein nicht verifizierter
> Build betrachtet werden sollte, ermöglicht der Build Entwicklern, selbst zu
> überprüfen, ob der Quellcode mit dem übereinstimmt, was onchain bereitgestellt
> wurde. Mithilfe des Quellcodes kann ein Entwickler dann validieren, was der
> Code beim Senden einer Transaktion ausführt.

Die Pipeline für verifizierte Builds wurde von
[Ellipsis Labs](https://ellipsislabs.xyz/) und [OtterSec](https://osec.io/)
konzipiert und wird von diesen gepflegt. Weitere Details finden Sie im Leitfaden
im
[ursprünglichen Repository für verifizierte Builds](https://github.com/Ellipsis-Labs/solana-verifiable-build)
sowie den Verifizierungsprozess direkt in der
[Anza](https://www.anza.xyz/)-Toolsuite, sobald dies dort unterstützt wird.

# Wie funktioniert es?

Der Verifizierungsprozess erfolgt durch den Vergleich des Hashs des
Onchain-Programms mit dem Hash des lokal aus dem Quellcode erstellten Programms.
Du erstellst dein Programm in einer kontrollierten Umgebung mithilfe der Solana
Verify CLI und Docker. Dies stellt sicher, dass der Build-Prozess
deterministisch und über verschiedene Systeme hinweg konsistent ist. Sobald du
die ausführbare Datei hast, kannst du sie im Solana-Netzwerk deployen. Während
des Build-Prozesses wird ein
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)
des [Verify-Programms](https://github.com/otter-sec/otter-verify) erstellt.
Dieser PDA enthält alle Daten, die zur Verifizierung des Programms erforderlich
sind. Der PDA enthält die Programmadresse, die Git-URL, den Commit-Hash und die
Argumente, die zum Erstellen des Programms verwendet wurden.

Mithilfe der Daten im PDA kann jeder den Verify-Programmbefehl lokal ausführen
und überprüfen, ob das Programm aus dem bereitgestellten Quellcode erstellt
wurde. Dann kann jeder vollständig vertrauenslos selbst verifizieren oder eine
eigene [Verify-API](https://github.com/otter-sec/solana-verified-programs-api)
betreiben, die von [OtterSec](https://github.com/otter-sec) gepflegt wird, um
Nutzern einen einfachen Zugangspunkt zur Überprüfung der Verifizierung zu
bieten. Du kannst diese
[API-Aufrufe](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
bereits im
[Solana Explorer](https://explorer.solana.com/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/verified-build)
und auf
[SolanaFM](https://solana.fm/address/E1fcPKuV1UJEsTJPpab2Jr8y87ZN73i4CHTPLbWQE6CA/transactions?cluster=mainnet-alpha)
sowie an anderen Stellen in Verwendung sehen.

# Warum sollte ich verifizierte Builds verwenden?

Die Verwendung verifizierter Builds bietet folgende Vorteile:

- Sicherheit: Garantiert, dass das Onchain laufende Programm mit dem Quellcode
  übereinstimmt und verhindert böswillige Änderungen.

- Transparenz: Ermöglicht es anderen Nutzern und Entwicklern zu validieren, dass
  das Onchain-Programm vertrauenswürdig ist, indem sie es mit der öffentlichen
  Codebasis vergleichen.

- Vertrauen: Erhöht das Nutzervertrauen, da verifizierte Builds demonstrieren,
  dass das Onchain-Verhalten deines Programms mit deinem öffentlichen Code
  übereinstimmt. Beim Erstellen verifizierbarer Programme minimierst du Risiken,
  die mit der Ausführung nicht autorisierter oder bösartiger Programme verbunden
  sind. Es stellt außerdem sicher, dass du Best Practices einhältst und
  Sicherheitsforschern eine einfache Möglichkeit gibst, dich zu kontaktieren.
  Auch Wallets und andere Tools können Transaktionen von deinem Programm
  leichter zulassen, solange es verifiziert ist.

- Auffindbarkeit: Wenn Sie einen verifizierten Build Ihres Programms
  bereitstellen, kann jeder Ihren Quellcode, Ihre Dokumentation, Ihr
  Programm-SDK oder IDL finden und Sie können auch einfach über GitHub
  kontaktiert werden, falls es ein Problem gibt.

# Wie erstelle ich verifizierte Builds?

Um verifizierte Builds zu erstellen, müssen Sie diese Schritte befolgen:

Zusammenfassung:

- Committen Sie Ihren Code in ein öffentliches Repository
- Erstellen Sie einen verifizierten Build in Docker
- Deployen Sie den verifizierten Build
- Verifizieren Sie das deployete Programm gegen die öffentliche API

Wenn Sie Ihr Programm verifizieren, das nicht in einem Docker-Container erstellt
wurde, wird es höchstwahrscheinlich fehlschlagen, da Solana-Programm-Builds
nicht deterministisch über verschiedene Systeme hinweg sind.

<Steps>
<Step>

### Docker und Cargo installieren

Installieren Sie die notwendigen Tools und stellen Sie sicher, dass Docker und
Cargo installiert sind. Docker bietet eine kontrollierte Build-Umgebung, um
Konsistenz zu gewährleisten, und Cargo wird für die Verwaltung von Rust-Paketen
verwendet.

- Docker: Folgen Sie den Schritten auf der
  [Docker-Website](https://docs.docker.com/engine/install/), um Docker für Ihre
  Plattform zu installieren. Stellen Sie nach der Installation sicher, dass der
  Docker-Dienst läuft, indem Sie dieser Anleitung weiter folgen.
- Cargo: Wenn Sie Cargo noch nicht installiert haben, können Sie es
  installieren, indem Sie folgenden Befehl ausführen:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

</Step>
<Step>

### Solana Verify CLI installieren

Die Solana Verify CLI ist das primäre Tool zur Verifizierung von Builds. Solana
Verify CLI wird derzeit von [Ellipsis Labs](https://ellipsislabs.xyz/) gepflegt
und kann mit Cargo installiert werden.

Sie können es installieren, indem Sie Folgendes ausführen:

```bash
cargo install solana-verify
```

Wenn Sie eine bestimmte Version der CLI benötigen, können Sie die Version
festlegen mit:

```bash
cargo install solana-verify --version $VERSION
```

Falls gewünscht, können Sie eine Version direkt von einem bestimmten Commit
installieren:

```bash
cargo install solana-verify --git https://github.com/Ellipsis-Labs/solana-verifiable-build --rev 13a1db2
```

</Step>
<Step>

### Projekt vorbereiten

Um gegen ein Repository zu verifizieren, muss es eine `Cargo.lock`-Datei im
Stammverzeichnis Ihres Repositories haben. Wenn Sie nur ein Programm in Ihrem
Repository haben und eine `cargo.lock`-Datei in Ihrem Stammverzeichnis vorhanden
ist, können Sie direkt zum nächsten Schritt übergehen und Ihr Programm
erstellen.

Wenn sich Ihr Programm in einem Unterordner befindet und Sie einen
Rust-Workspace haben, müssen Sie eine Workspace-`Cargo.toml`-Datei im
Stammverzeichnis Ihres Repositories erstellen.

Sie können dieses `Cargo.toml`-Beispiel als Vorlage verwenden:

```toml title="Cargo.toml"
[workspace]
members = ["program/programs/*"]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1

[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1
```

Stellen Sie sicher, dass sich Ihr Programm im `workspace/members`-Array befindet
und dass die `Cargo.toml` Ihres Programms den korrekten `lib`-Namen konfiguriert
hat.

> Wichtig ist der `lib name`, nicht der Paketname!

Etwa so:

```toml title="waffle/Cargo.toml"
[package]
name = "waffle"
version = "0.1.0"
edition = "2021"

[lib]
name = "waffle"
crate-type = ["cdylib", "lib"]

[dependencies]
solana-program = "2.1.0"
```

In diesem [Repository](https://github.com/solana-developers/verified-program)
sehen Sie ein Beispiel für einen Workspace mit einem Programm in einem
Unterordner. Beachten Sie auch, dass Sie, wenn sich das Programm in einem
Unterordner befindet, diesen Ordner später als `--mount-path` zum
`verify-from-repo`-Befehl hinzufügen müssen.

In diesem [Repository](https://github.com/solana-developers/solana-game-preset)
finden Sie ein Anchor-Beispiel. In diesem
[Repository](https://github.com/solana-developers/verified-program-root) finden
Sie ein natives Rust-Beispiel.

Mit dieser `Cargo.toml`-Datei können Sie dann `cargo generate-lockfile`
ausführen, um eine Lock-Datei zu erstellen und mit dem Erstellen Ihres Programms
fortzufahren.

</Step>
<Step>

### Verifizierbare Programme erstellen

Um Ihr Solana-Programm verifizierbar zu erstellen, navigieren Sie zum
Verzeichnis, das die `Cargo.toml`-Datei Ihres Workspace enthält, und führen Sie
aus:

```bash
solana-verify build
```

Dadurch wird Ihre Umgebung in einen Docker-Container kopiert und auf
deterministische Weise erstellt.

> Stellen Sie sicher, dass Sie tatsächlich den verifizierten Build deployen und
> ihn nicht versehentlich mit `anchor build` oder `cargo build-sbf`
> überschreiben, da diese höchstwahrscheinlich nicht zum gleichen Hash führen
> und Ihre Verifizierung daher fehlschlagen wird.

Bei Projekten mit mehreren Programmen können Sie ein bestimmtes Programm
erstellen, indem Sie den Library-Namen (nicht den Package-Namen) verwenden:

```bash
solana-verify build --library-name $PROGRAM_LIB_NAME
```

Dieser Prozess gewährleistet deterministische Builds und kann einige Zeit in
Anspruch nehmen, insbesondere auf bestimmten Systemen (z. B. M1 MacBook), da er
innerhalb eines Docker-Containers ausgeführt wird. Für schnellere Builds wird
die Verwendung einer Linux-Maschine mit x86-Architektur empfohlen.

Sobald der Build abgeschlossen ist, können Sie den Hash der ausführbaren Datei
mit folgendem Befehl abrufen:

```bash
solana-verify get-executable-hash target/deploy/$PROGRAM_LIB_NAME.so
```

</Step>
<Step>

### Verifizierbare Programme deployen

Sobald Sie Ihr Programm erstellt und dessen Hash abgerufen haben, können Sie es
im Solana-Netzwerk deployen. Es wird empfohlen, eine Multi-Signatur- oder
Governance-Lösung wie [Squads Protocol](https://squads.so/protocol) für sichere
Deployments zu verwenden, aber Sie können auch direkt deployen mit:

```bash
solana program deploy -u $NETWORK_URL target/deploy/$PROGRAM_LIB_NAME.so --program-id $PROGRAM_ID --with-compute-unit-price 50000 --max-sign-attempts 100 --use-rpc
```

Eine aktuell passende niedrige Priority Fee können Sie beispielsweise von Ihrem
RPC-Provider wie [Quicknode](https://www.quicknode.com/gas-tracker/solana)
anfordern.

Um zu verifizieren, dass das deployete Programm mit der erstellten ausführbaren
Datei übereinstimmt, führen Sie aus:

```bash
solana-verify get-program-hash -u $NETWORK_URL $PROGRAM_ID
```

> Möglicherweise haben Sie verschiedene Versionen auf verschiedenen
> [Solana-Clustern](/docs/references/clusters) (d. h. devnet, testnet, mainnet)
> deployed. Stellen Sie sicher, dass Sie die korrekte Netzwerk-URL für den
> gewünschten Solana-Cluster verwenden, gegen den Sie ein Programm verifizieren
> möchten. Remote-Verifizierung funktioniert nur auf Mainnet.

</Step>
<Step>

### Verifizierung gegen Repositories

Um ein Programm gegen sein öffentliches Repository zu verifizieren, verwende:

```bash
solana-verify verify-from-repo -u $NETWORK_URL --program-id $PROGRAM_ID https://github.com/$REPO_PATH --commit-hash $COMMIT_HASH --library-name $PROGRAM_LIB_NAME --mount-path $MOUNT_PATH
```

> Während du den verifizierten Build in deinem Programmverzeichnis ausführst,
> musst du beim Ausführen von `verify-from-repo` das Flag `--mount-path`
> hinzufügen. Dies ist der Pfad zum Ordner, der die Datei `Cargo.toml` enthält,
> die den Bibliotheksnamen deines Programms beinhaltet.

Dieser Befehl vergleicht den Onchain-Programm-Hash mit dem Hash der ausführbaren
Datei, die aus dem Quellcode beim angegebenen Commit-Hash erstellt wurde.

Am Ende fragt der Befehl, ob du deine Verifizierungsdaten onchain hochladen
möchtest. Wenn du das tust, zeigt der Solana Explorer sofort die
Verifizierungsdaten deines Programms an. Bis es durch einen Remote-Build
verifiziert wurde, wird es als unverifiziert angezeigt. Erfahre im nächsten
Schritt, wie du dein Programm gegen eine öffentliche API verifizieren kannst.

Wenn du die Verifizierung auf eine bestimmte Version festlegen möchtest, kannst
du das Flag `--commit-hash` an den Befehl anhängen.

</Step>
<Step>

### Verifizierung gegen öffentliche API

Schließlich kannst du das Programm auch direkt gegen jeden verifizieren, der die
Verify-API betreibt:

```bash
solana-verify verify-from-repo --remote -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

> Es wird empfohlen, eine kostenpflichtige RPC-URL zu verwenden, da du sonst
> möglicherweise auf Ratenlimits der kostenlosen RPCs stößt. Anstelle von `-um`
> solltest du also `--url yourRpcUrl` für eine zuverlässigere Verifizierung
> verwenden.

Das Flag `--remote` sendet eine Build-Anfrage an die OtterSec API, die einen
Remote-Build deines Programms auslöst. Sobald der Build abgeschlossen ist,
überprüft das System, dass der Onchain-Hash deines Programms mit dem Hash des
generierten Build-Artefakts aus deinem Repository übereinstimmt.

Die Standardeinstellung ist die
[OtterSec API](https://github.com/otter-sec/solana-verified-programs-api).

Stellen Sie sicher, dass Sie „Ja" auswählen, wenn Sie gefragt werden, ob Sie die
Verifizierungsdaten onchain hochladen möchten. Diese werden von der API
verwendet, um zu überprüfen, dass Sie die Verifizierungsdaten hochgeladen haben.

Sie können einen Remote-Job auch manuell auslösen, indem Sie Folgendes
verwenden:

```bash
solana-verify remote submit-job --program-id <program-id> --uploader <address>
```

Dabei ist der Uploader die Adresse, die die Berechtigung hat, in die PDA zu
schreiben. Das sollte in den meisten Fällen die Programmberechtigung sein. Wenn
Ihr Programm von einer Multisig kontrolliert wird, fahren Sie bitte im Abschnitt
[Multisig-Verifizierung](#how-to-verify-your-program-when-its-controlled-by-a-multisig-like-squads)
dieses Leitfadens unten fort.

Dadurch wird ein Job an die OtterSec API übermittelt und Sie können dann den
Job-Status überprüfen mit:

```bash
solana-verify remote get-job-status --job-id <job-id>
```

Sobald die Verifizierung erfolgreich abgeschlossen wurde, was eine Weile dauern
kann, können Sie Ihr Programm als verifiziert in der
[OtterSec API für einzelne Programme](https://verify.osec.io/status/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY)
und im
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY/verified-build),
[SolanaFM](https://solana.fm/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY?cluster=mainnet-alpha),
[SolScan](https://solscan.io/account/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY#programVerification)
und schließlich auch auf der von der Community betriebenen Website
[SolanaVerify.org](https://www.solanaverify.org/), die von
[0xDeep](https://x.com/0xDeep) gepflegt wird, sowie in der
[OtterSec verified programs API](https://verify.osec.io/verified-programs) und
zuletzt im
[Verified Programs Dune Dashboard](https://dune.com/jonashahn/verified-programs/dedf21e1-9b71-42c8-89f9-02ed94628657)
sehen, was zu einem gesünderen Solana-Ökosystem beiträgt.

</Step>
</Steps>

## So verifizieren Sie Ihr Programm, wenn es von einer Multisig wie Squads kontrolliert wird

Damit die Remote-Verifizierung funktioniert, müssen Sie die Verifizierungsdaten
in eine PDA schreiben, die von der Programmberechtigung signiert ist. Wenn Ihr
Programm von einer Multisig kontrolliert wird, können Sie diese
Write-PDA-Transaktion exportieren und über
[Squads Protocol](https://squads.so/protocol) oder eine andere Multisig-Lösung
Ihrer Wahl einreichen.

<Steps>
<Step>

### 1. Bauen Sie das verifizierbare Programm

Erstellen Sie zunächst das Programm:

```bash
solana-verify build
```

Dies erstellt einen verifizierbaren Build mithilfe eines Docker-Containers unter
Verwendung der Solana-Version, die in der Datei `Cargo.lock` angegeben ist.

</Step>
<Step>

### 2. Programm bereitstellen

```bash
solana config set --url "PayedMainnetRPCAddress" // the public endpoint will be rate limited too much
solana program deploy target/deploy/verify_squads.so
```

Für den Rest dieser Multisig-Anleitung verwenden wir eine Beispiel-Programm-ID
von `6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`.

</Step>
<Step>

### 3. Committen und gegen Repository verifizieren

Sobald das erledigt ist, committen wir das Projekt auf GitHub. Hier ist ein
Beispiel: https://github.com/solana-developers/verify-squads

Optional: Prüfen Sie, ob Sie zunächst lokal verifizieren können (dieser Befehl
verwendet die Beispiel-Programm-ID
`6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD`):

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
```

Nur um sicherzustellen, dass Ihre Parameter korrekt sind.

</Step>
<Step>

### 4. Programmberechtigung auf Multisig übertragen

Falls Sie die Berechtigung Ihres Programms noch nicht auf das Multisig
übertragen haben, tun Sie dies und kopieren Sie die Multisig-Berechtigung. Sie
benötigen sie im nächsten Schritt.

</Step>
<Step>

### 5. PDA-Transaktion exportieren

Wenn Sie die Programmberechtigung lokal haben, werden Sie aufgefordert, die
Build-Daten onchain hochzuladen, wenn Sie den Befehl
`solana-verify verify-from-repo` verwenden.

Da Sie dies bei Verwendung eines Multisigs nicht tun können, müssen Sie die
PDA-Transaktion manuell exportieren und dann die Transaktion über Squads
auslösen.

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader <your program authority> --encoding base58 --compute-unit-price 0
```

Dies gibt Ihnen eine base58-Transaktion zurück. Wenn Sie eine base64-kodierte
Transaktion zur Verwendung in einem Transaktionsinspektor wünschen, können Sie
`--encoding base64` verwenden.

```bash
P6vBfcPaaXb8fZoT3NBAYEcdtEj7tubA1k2gBxmFKZ3UWF5YyrmDMFTvLKALCJoUuRsPAjMckudYruCu3eeWQtuDrFbEMLxLFutnKXac974fnkMivcwUdY66VLjbxQT6ATmcy7F4hBtz1G4P1h6iBJLhb8WtrtgY3i4qq45MUEb7RjuMEfUFXKrNgPdGxkz5xvMHq3dxKRcpmEK5k2DkeW6SUQYBVe19Ga3B9GyhTX8k3CMt9JCEah13WyRnQd8GjoK6sTEvGJym6xDNvmd8yiJYSNcaYwEJsjHEUf4Yh6kAC7ki2KRvVAr3NVe1gjqK9McrwSQjtUatvydTG8Zovcr7PPUEMf3yPMgKXjZLB2QpkH63yTTYdNAnWFuv9E6b6nYRqye5XcNi436yKw5U14fXh65yK34bgYLi9328UT1huJELsJU9BRGnGUmb6GWp6c2WL5BhnzgNTSnt9TXFfEgUMzhvKzpVBxLP44hwqqBdyUhHFysCF37531PnmiESq8x1xou23xJ6FcQbc199754MkqQd7tX9CUznGzAEqHGkzn3VBoJnojsKtgYmiTYbdRsT1CU18MbYEE7WvGAvXyxxbpNzbAcc94HrnM6cqRGmwhEBroPfFghTdmzg9D
```

</Step>
<Step>

### 6. Transaktion über Squads einreichen

Gehen Sie zum Squads Transaction Builder und importieren Sie die base58-kodierte
Transaktion. Stellen Sie sicher, dass die Transaktion in der Simulation nur
einen Aufruf an das osec-Verify-Programm und das Computer-Budget-Programm
enthält und sonst nichts!

</Step>
<Step>

### 7. Remote-Verifizierungsjob einreichen

Sobald die Transaktion an Squads erfolgreich war, können Sie den Remote-Job
einreichen:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD
--uploader <your program authority>
```

Das war's! Sie haben Ihr Programm gegen ein öffentliches Repository verifiziert
und einen Remote-Job an die OtterSec-API übermittelt. Sie sollten es nun im
Solana Explorer und an anderen Stellen sehen können.

</Step>
<Step>

### 8. Programm aktualisieren (optional)

Wenn Sie Ihr Programm aktualisieren, müssen Sie eine neue PDA-Transaktion
exportieren und diese erneut über Squads einreichen.

So führen Sie ein Update des Programms durch:

```bash
solana-verify build
solana program write-buffer target/deploy/verify_squads.so --with-compute-unit-price 50000 --max-sign-attempts 50
```

Übertragen Sie dann diese Buffer-Berechtigung an die Multisig oder erstellen Sie
den Buffer direkt mit der Berechtigung der Multisig.

```bash
solana program set-buffer-authority Fu3k79g53ZozAj47uq1tXrFy4QbQYh7y745DDsxjtyLR --new-buffer-authority 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

</Step>
<Step>

### 9. Neue PDA-Transaktion exportieren und einreichen

Vergessen Sie nicht, Ihre Änderungen auf GitHub zu committen. Exportieren Sie
die PDA-Upgrade-Transaktion erneut:

```bash
solana-verify export-pda-tx https://github.com/solana-developers/verify-squads --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

Reichen Sie die Transaktion erneut über Squads ein.

Sie können eine Beispieltransaktion
[hier](https://solana.fm/tx/4zJ1vK2KToAwxuEYzTMLqPkcebjoi9rdeeyxtEEx9L5Q4vWDA8h6Rr4kPRuRxcV7ZLKMr6qx1LTWb6x3ZpUJaFUW?cluster=mainnet-alpha)
sehen.

Reichen Sie dann einen weiteren Remote-Build ein:

```bash
solana-verify remote submit-job --program-id 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD --uploader 3JG6ULvZVCrkKtSSskKNJGe8RNZGFe8Ruev9KUhxzK5K
```

Das Ergebnis sollte in etwa so aussehen:

```shell
Verification request sent with request id: b63339d2-163e-49ac-b55d-3454c1c2b5b3
Verification in progress... ⏳ [00:18:02] ✅ Process completed. (Done in 18
minutes) Program 6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD has been verified.
✅ The provided GitHub build matches the on-chain hash. On Chain Hash:
96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Executable
Hash: 96f8c3d9400258f7759408d1f6f8435b4a24d9b52f5a0340d97907e567cb8773 Repo URL:
https://github.com/Woody4618/verify-squads/tree/0fb0a2e30c15c51732c0ad5e837975a6f7bbc7ed
Check the verification status at:
https://verify.osec.io/status/6XBGfP17P3KQAKoJb2s5M5fR4aFTXzPeuC1af2GYkvhD Job
url: https://verify.osec.io/job/b63339d2-163e-49ac-b55d-3454c1c2b5b3
```

Herzlichen Glückwunsch, Sie haben Ihr Programm nach einem Multisig-Upgrade
verifiziert!

</Step>
</Steps>

## Verifizierung aus Docker-Image

Du kannst dein Programm auch gegen ein Docker-Image verifizieren, indem du den
folgenden Befehl ausführst:

```bash
solana-verify verify-from-image -e
examples/hello_world/target/deploy/hello_world.so -i
ellipsislabs/hello_world_verifiable_build:latest -p
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn
```

Dieser Befehl lädt das unter `ellipsislabs/hello_world_verifiable_build:latest`
gespeicherte Image und überprüft, ob der Hash des ausführbaren Pfads im
Container mit dem Hash des Onchain-Programms übereinstimmt, das dem Befehl
übergeben wurde. Da der Build bereits in ein Image hochgeladen wurde, ist kein
vollständiger Rebuild der ausführbaren Datei erforderlich, was viel Zeit in
Anspruch nehmen kann.

Das Dockerfile, das das Image `ellipsislabs/hello_world_verifiable_build:latest`
erstellt, findest du im Repository von Ellipsis Labs unter
[/examples/hello_world](https://github.com/Ellipsis-Labs/solana-verifiable-build/tree/master/examples/hello_world).

Nachfolgend die erwartete Ausgabe:

```bash
Verifying image: "ellipsislabs/hello_world_verifiable_build:latest", on network
"https://api.mainnet.solana.com" against program ID
2ZrriTQSVekoj414Ynysd48jyn4AX6ZF4TTJRqHfbJfn Executable path in container:
"examples/hello_world/target/deploy/hello_world.so"

Executable hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Program hash:
08d91368d349c2b56c712422f6d274a1e8f1946ff2ecd1dc3efc3ebace52a760 Executable
matches on-chain program data ✅
```

## Beispiel für einen verifizierten Build

Hier ist ein Beispiel für die Verifizierung eines Beispielprogramms mit der ID
`FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv` unter Verwendung des Quellcodes
aus diesem [Repository](https://github.com/solana-developers/verified-program):

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

Standardmäßig verwendet der Befehl `verify-from-repo` den letzten Commit auf dem
Main-Branch. Du kannst auch einen bestimmten Commit definieren, falls du am
Repository weiterarbeiten möchtest, indem du den Parameter `commit-hash`
verwendest: `--commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e`

Schließlich kannst du das Programm auch direkt gegen die OtterSec-API
verifizieren:

```bash
solana-verify verify-from-repo https://github.com/solana-developers/verified-program --url YOUR-RPC-URL --remote --program-id FWEYpBAf9WsemQiNbAewhyESfR38GBBHLrCaU3MpEKWv --mount-path waffle --library-name waffle --commit-hash 5b82b86f02afbde330dff3e1847bed2d42069f4e
```

Der Befehl `--remote` sendet eine Build-Anfrage an die OtterSec-API, die einen
Remote-Build deines Programms auslöst. Sobald der Build abgeschlossen ist,
überprüft das System, ob der Onchain-Hash deines Programms mit dem Hash des
generierten Build-Artefakts aus deinem Repository übereinstimmt.

## Beliebte Programme, die bereits verifiziert sind

### Phoenix

```shell
solana-verify verify-from-repo -um --program-id PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY https://github.com/Ellipsis-Labs/phoenix-v1
```

Endgültige Ausgabe:

```shell
Executable Program Hash from repo: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
On-chain Program Hash: 6877a5b732b3494b828a324ec846d526d962223959534dbaf4209e0da3b2d6a9
Program hash matches ✅
```

### Squads V3

```shell
solana-verify verify-from-repo https://github.com/Squads-Protocol/squads-mpl --commit-hash c95b7673d616c377a349ca424261872dfcf8b19d --program-id SMPLecH534NA9acpos4G6x7uf3LWbCAwZQE9e8ZekMu -um --library-name squads_mpl --bpf
```

> Beachten Sie, dass wir `library-name` angeben mussten, da das
> Squads-Repository mehrere Programme enthält. Wir verwenden das Flag `--bpf`,
> weil `squads_mpl` zuvor mit Anchor verifiziert wurde.

Endgültige Ausgabe:

```shell
Executable Program Hash from repo: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
On-chain Program Hash: 72da599d9ee14b2a03a23ccfa6f06d53eea4a00825ad2191929cbd78fb69205c
Program hash matches ✅
```

### Drift V2

```shell
solana-verify verify-from-repo -um --program-id dRiftyHA39MWEi3m9aunc5MzRF1JYuBsbn6VPcn33UH https://github.com/drift-labs/protocol-v2 --commit-hash 110d3ff4f8ba07c178d69f9bfc7b30194fac56d6 --library-name drift
```

Endgültige Ausgabe:

```shell
Executable Program Hash from repo: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
On-chain Program Hash: e31d58edeabc3c30bf6f2aa60bfaa5e492b41ec203e9006404b463e5adee5828
Program hash matches ✅
```

### Marginfi V2

```shell
solana-verify verify-from-repo -um --program-id MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA https://github.com/mrgnlabs/marginfi-v2 --commit-hash d33e649e415c354cc2a1e3c49131725552d69ba0 --library-name marginfi -- --features mainnet-beta
```

Endgültige Ausgabe:

```shell
Executable Program Hash from repo: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
On-chain Program Hash: 890d68f48f96991016222b1fcbc2cc81b8ef2dcbf280c44fe378c523c108fad5
Program hash matches ✅
```

# Fazit

Die Verwendung von
[verifizierten Builds auf Solana](/developers/guides/advanced/verified-builds)
gewährleistet die Integrität und Vertrauenswürdigkeit Ihrer Programme im
Netzwerk und ermöglicht es Entwicklern, Ihre SDKs direkt über einen Solana
Explorer zu finden. Durch den Einsatz von Tools wie der Solana Verify CLI und
Docker können Sie verifizierbare und sichere Builds pflegen, die mit Ihrem
Quellcode übereinstimmen. Treffen Sie stets die notwendigen Vorsichtsmaßnahmen,
um konsistente Umgebungen zu verwenden, und ziehen Sie Governance-Lösungen für
sichere Upgrades und Deployments in Betracht.

## Sicherheit + Haftungsausschluss

Obwohl verifizierte Builds ein leistungsstarkes Werkzeug zur Gewährleistung der
Integrität Ihrer Solana-Programme sind, sind sie in der Standardkonfiguration
nicht vollständig vertrauenslos. Die Docker-Images werden von der Solana
Foundation erstellt und gehostet.

Beachten Sie, dass Sie Ihr Projekt in einem heruntergeladenen Docker-Image
erstellen und dass Ihr gesamtes Setup einschließlich potenziell sensibler
Informationen zum Erstellen in dieses Docker-Image kopiert wird.

Wenn Sie ein vollständig vertrauensloses Setup wünschen, können Sie die
Docker-Images selbst erstellen und auf Ihrer eigenen Infrastruktur hosten. Auf
diese Weise können Sie sicherstellen, dass die Docker-Images nicht manipuliert
wurden. Sie finden die Skripte zum Erstellen Ihrer eigenen Docker-Images im
[Verified-Builds-Repository](https://github.com/Ellipsis-Labs/solana-verifiable-build)
und können es forken und die GitHub-Actions selbst ausführen oder validieren,
dass sie korrekt sind.

Darüber hinaus vertraust du bei der Remote-Verifizierung bis zu einem gewissen
Grad der OtterSec-API und dem
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY).

Die API oder der Solana Explorer können möglicherweise falsche Informationen
anzeigen, wenn sie kompromittiert wurden.

Wenn du ein vollständig vertrauensloses Setup haben möchtest, kannst du die
[Verify-API](https://github.com/otter-sec/solana-verified-programs-api) selbst
betreiben oder die Programmverifizierung lokal selbst mit dem `verify-from-repo`
Befehl durchführen, indem du die Onchain-Verifizierungsdaten verwendest, die in
einem
[PDA](https://explorer.solana.com/address/63XDCHrwZu3mXsw2RUFb4tbNpChuUHx4eA5aJMnHkpQQ/anchor-account)
gespeichert sind, der von der Deploy-Authority des Programms und dem
[Verify-Programm](https://explorer.solana.com/address/verifycLy8mB96wd9wqq3WDXQwM4oU6r42Th37Db9fC)
abgeleitet wird.

Das Verify-Programm wird vom [OtterSec-Team](https://osec.io/) bereitgestellt
und ist noch nicht eingefroren, sodass es jederzeit aktualisiert werden kann.

Die Solana Foundation, OtterSec und das Ellipsis Labs Team sind nicht
verantwortlich für Verluste oder Schäden, die durch die Verwendung der
Verified-Builds-Pipeline entstehen können.

# Security.txt für Solana-Programme

Zusätzlich zu verifizierten Builds kannst du auch eine `security.txt`-Datei zu
deinem Programm hinzufügen. In Zukunft, sobald implementiert, wird die
`security.txt` den Verifier-Public-Key für einfachen Zugriff auf die im
Verifizierungs-PDA gespeicherten Verifizierungsdaten enthalten. Der PDA, der
alle Informationen enthält, die zum Erstellen und Verifizieren eines Programms
benötigt werden, wird vom Programm-Adresse und dem Verifier-Pubkey abgeleitet.
Standardmäßig ist dies derselbe Pubkey, der das Programm erstellt und
bereitgestellt hat. Es kann aber auch ein anderer Pubkey sein, der in der
`security.txt` angegeben werden kann.

Die `security.txt`-Funktion ermöglicht es Entwicklern, Kontakt- und
Sicherheitsinformationen direkt in ihre Solana-Smart-Contracts einzubetten.
Inspiriert von [securitytxt.org](https://securitytxt.org) bietet dieser Ansatz
eine standardisierte Möglichkeit für Sicherheitsforscher, Projekt-Maintainer zu
kontaktieren, selbst wenn sie nur die Adresse des Contracts kennen.

## Warum security.txt verwenden?

Bei vielen Projekten, insbesondere kleineren oder privaten, kann es schwierig
und zeitaufwändig sein, die Entwickler allein anhand der Vertragsadresse zu
identifizieren. Das Einbetten einer `security.txt`-Datei im Programm stellt
sicher, dass Sicherheitsforscher die richtigen Personen leicht kontaktieren
können, wodurch potenzielle Exploits verhindert und zeitnahe Fehlerberichte
gewährleistet werden.

## So implementieren Sie security.txt

Um eine `security.txt` zu Ihrem Solana-Programm hinzuzufügen, führen Sie die
folgenden Schritte aus:

Fügen Sie die `solana-security-txt`-Abhängigkeit zu Ihrer `Cargo.toml` hinzu:

```toml title="Cargo.toml"
[dependencies]
solana-security-txt = "1.1.1"
```

Verwenden Sie das `security_txt!`-Makro in Ihrem Vertrag, um Ihre
Sicherheitsinformationen zu definieren. Sie können Kontaktdaten, Projekt-URLs
und sogar eine Sicherheitsrichtlinie einschließen. Hier ist ein Beispiel:

```rust
#[cfg(not(feature = "no-entrypoint"))]
use {default_env::default_env, solana_security_txt::security_txt};

#[cfg(not(feature = "no-entrypoint"))]
security_txt! {
    name: "MyProject",
    project_url: "https://myproject.com",
    contacts: "email:security@myproject.com,discord:security#1234",
    policy: "https://myproject.com/security-policy",

    // Optional Fields
    preferred_languages: "en,de",
    source_code: "https://github.com/solana-developers/solana-game-preset",
    source_revision: "5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    source_release: "",
    encryption: "",
    auditors: "Verifier pubkey: 5vJwnLeyjV8uNJSp1zn7VLW8GwiQbcsQbGaVSwRmkE4r",
    acknowledgements: "Thank you to our bug bounty hunters!"
}
```

Sobald die `security.txt`-Informationen in Ihr Programm eingebettet sind, können
sie einfach über Tools wie den Solana Explorer abgefragt werden, wodurch
sichergestellt wird, dass Ihre Kontakt- und Sicherheitsdetails für jeden
verfügbar sind, der potenzielle Probleme melden möchte.

## Best Practices

- Links verwenden: Für Informationen, die sich wahrscheinlich ändern (z. B.
  Kontaktdaten), wird empfohlen, auf eine Webseite zu verlinken, anstatt sie
  fest in den Vertrag zu codieren. Dies vermeidet die Notwendigkeit häufiger
  Programm-Upgrades.

- Verifizierung: Überprüfen Sie vor der Bereitstellung das Format und den Inhalt
  mit dem `query-security-txt`-Tool, das sowohl Onchain-Programme als auch
  lokale Binärdateien validieren kann:

```bash
query-security-txt target/bpfel-unknown-unknown/release/my_contract.so
```

Durch das Einbetten von Sicherheitskontaktinformationen direkt in Ihren Vertrag
erleichtern Sie es Forschern, Sie zu erreichen, und fördern so bessere
Sicherheit und Kommunikation innerhalb des Solana-Ökosystems.

Dies ist
[ein Beispiel dafür, wie security.txt im Solana Explorer aussieht](https://explorer.solana.com/address/HPxKXnBN4vJ8RjpdqDCU7gvNQHeeyGnSviYTJ4fBrDt4/security?cluster=devnet)

Das `security.txt`-Projekt wird von
[Neodyme Labs](https://github.com/neodyme-labs) betreut
