---
title: Programmstruktur
description:
  Erfahren Sie, wie Sie Solana-Programme in Rust strukturieren, einschließlich
  Einstiegspunkten, Zustandsverwaltung, Anweisungsverarbeitung und Tests.
h1: Rust-Programmstruktur
---

In Rust geschriebene Solana-Programme haben minimale strukturelle Anforderungen,
was Flexibilität bei der Organisation des Codes ermöglicht. Die einzige
Anforderung ist, dass ein Programm einen `entrypoint` haben muss, der definiert,
wo die Ausführung eines Programms beginnt.

## Programmstruktur

Obwohl es keine strengen Regeln für die Dateistruktur gibt, folgen
Solana-Programme typischerweise einem gemeinsamen Muster:

- `entrypoint.rs`: Definiert den Einstiegspunkt, der eingehende Anweisungen
  weiterleitet.
- `state.rs`: Definiert den Programmzustand (Kontodaten).
- `instructions.rs`: Definiert die Anweisungen, die das Programm ausführen kann.
- `processor.rs`: Definiert die Anweisungshandler (Funktionen), die die
  Geschäftslogik für jede Anweisung implementieren.
- `error.rs`: Definiert benutzerdefinierte Fehler, die das Programm zurückgeben
  kann.

Siehe zum Beispiel das
[Token-Programm](https://github.com/solana-program/token/tree/main/program/src).

## Beispielprogramm

Um zu demonstrieren, wie man ein natives Rust-Programm mit mehreren Anweisungen
erstellt, gehen wir ein einfaches Zählerprogramm durch, das zwei Anweisungen
implementiert:

1. `InitializeCounter`: Erstellt und initialisiert ein neues Konto mit einem
   Anfangswert.
2. `IncrementCounter`: Erhöht den in einem bestehenden Konto gespeicherten Wert.

Der Einfachheit halber wird das Programm in einer einzigen `lib.rs`-Datei
implementiert, obwohl Sie in der Praxis größere Programme möglicherweise in
mehrere Dateien aufteilen möchten.

<Accordions>
<Accordion title="Vollständiger Programmcode">

<CodeTabs>

```rs !! title="src/lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

// Program entrypoint
entrypoint!(process_instruction);

// Function to route instructions to the correct handler
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Unpack instruction data
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    // Match instruction type
    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => process_increment_counter(program_id, accounts)?,
    };
    Ok(())
}

// Instructions that our program can execute
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 }, // variant 0
    IncrementCounter,                         // variant 1
}

// Initialize a new counter account
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // u64 requires 8 bytes

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for the new account
            counter_account.key,  // Account to be created
            required_lamports,    // Amount of lamports to transfer to the new account
            account_space as u64, // Size in bytes to allocate for the data field
            program_id,           // Set program owner to our program
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Create a new CounterAccount struct with the initial value
    let counter_data = CounterAccount {
        count: initial_value,
    };

    // Get a mutable reference to the counter account's data
    let mut account_data = &mut counter_account.data.borrow_mut()[..];

    // Serialize the CounterAccount struct into the account's data
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}

// Update an existing counter's value
fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify account ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Mutable borrow the account data
    let mut data = counter_account.data.borrow_mut();

    // Deserialize the account data into our CounterAccount struct
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    // Increment the counter value
    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    // Serialize the updated counter data back into the account
    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);
    Ok(())
}

// Struct representing our counter account's data
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    count: u64,
}

#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        // Create a new LiteSVM instance
        let mut svm = LiteSVM::new();

        // Create a keypair for the transaction payer
        let payer = Keypair::new();

        // Airdrop some lamports to the payer
        svm.airdrop(&payer.pubkey(), 1_000_000_000).unwrap();

        // Load our program
        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();
        svm.add_program_from_file(program_id, "target/deploy/counter_program.so")
            .unwrap();

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Use Borsh serialization for the instruction
        let init_instruction_data =
            borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
                .expect("Failed to serialize instruction");

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Create transaction
        let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(&[&payer, &counter_keypair], message, svm.latest_blockhash());

        // Send transaction
        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Initialize transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);

        // Check account data
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");
        assert_eq!(counter.count, 42);
        println!(
            "Counter initialized successfully with value: {}",
            counter.count
        );

        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Use Borsh serialization for increment instruction
        let increment_data = borsh::to_vec(&CounterInstruction::IncrementCounter)
            .expect("Failed to serialize instruction");

        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &increment_data,
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Create transaction
        let message = Message::new(&[increment_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(&[&payer, &counter_keypair], message, svm.latest_blockhash());

        // Send transaction
        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Increment transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);

        // Check account data
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");
        assert_eq!(counter.count, 43);
        println!("Counter incremented successfully to: {}", counter.count);
    }
}
```

```rs !! title="examples/client.rs"
use counter_program::CounterInstruction;
use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    system_program,
    transaction::Transaction,
};
use std::str::FromStr;

#[tokio::main]
async fn main() {
    // Replace with your actual program ID from deployment
    let program_id = Pubkey::from_str("AUia4JuToXDAB4gR2ZXWqJ6kDyCqn7WqunGAgw1KxdKU")
        .expect("Invalid program ID");

    // Connect to local cluster
    let rpc_url = String::from("http://localhost:8899");
    let client = RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed());

    // Generate a new keypair for paying fees
    let payer = Keypair::new();

    // Request airdrop of 1 SOL for transaction fees
    println!("Requesting airdrop...");
    let airdrop_signature = client
        .request_airdrop(&payer.pubkey(), 1_000_000_000)
        .expect("Failed to request airdrop");

    // Wait for airdrop confirmation
    loop {
        if client
            .confirm_transaction(&airdrop_signature)
            .unwrap_or(false)
        {
            break;
        }
        std::thread::sleep(std::time::Duration::from_millis(500));
    }
    println!("Airdrop confirmed");

    println!("\nInitializing counter...");
    let counter_keypair = Keypair::new();
    let initial_value = 100u64;

    // Serialize the initialize instruction data
    let instruction_data = borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
        .expect("Failed to serialize instruction");

    let initialize_instruction = Instruction::new_with_bytes(
        program_id,
        &instruction_data,
        vec![
            AccountMeta::new(counter_keypair.pubkey(), true),
            AccountMeta::new(payer.pubkey(), true),
            AccountMeta::new_readonly(system_program::id(), false),
        ],
    );

    let mut transaction =
        Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));

    let blockhash = client
        .get_latest_blockhash()
        .expect("Failed to get blockhash");
    transaction.sign(&[&payer, &counter_keypair], blockhash);

    match client.send_and_confirm_transaction(&transaction) {
        Ok(signature) => {
            println!("Counter initialized!");
            println!("Transaction: {}", signature);
            println!("Counter address: {}", counter_keypair.pubkey());
        }
        Err(err) => {
            eprintln!("Failed to initialize counter: {}", err);
            return;
        }
    }

    println!("\nIncrementing counter...");
    // Serialize the increment instruction data
    let increment_data = borsh::to_vec(&CounterInstruction::IncrementCounter)
        .expect("Failed to serialize instruction");

    let increment_instruction = Instruction::new_with_bytes(
        program_id,
        &increment_data,
        vec![AccountMeta::new(counter_keypair.pubkey(), true)],
    );

    let mut transaction =
        Transaction::new_with_payer(&[increment_instruction], Some(&payer.pubkey()));

    transaction.sign(&[&payer, &counter_keypair], blockhash);

    match client.send_and_confirm_transaction(&transaction) {
        Ok(signature) => {
            println!("Counter incremented!");
            println!("Transaction: {}", signature);
        }
        Err(err) => {
            eprintln!("Failed to increment counter: {}", err);
        }
    }
}
```

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
borsh = "1.5.7"
solana-program = "2.2.0"

[dev-dependencies]
litesvm = "0.6.1"
solana-client = "2.2.0"
solana-sdk = "2.2.0"
tokio = "1.47.1"

[[example]]
name = "client"
path = "examples/client.rs"
```

</CodeTabs>

</Accordion>
</Accordions>

## Teil 1: Schreiben des Programms

Beginnen wir mit dem Erstellen des Zählerprogramms. Wir erstellen ein Programm,
das einen Zähler mit einem Startwert initialisieren und ihn erhöhen kann.

<ScrollyCoding>

## !!steps Erstelle ein neues Programm

Erstellen wir zunächst ein neues Rust-Projekt für unser Solana-Programm.

```terminal
$ cargo new counter_program --lib
$ cd counter_program
```

Sie sollten die Standard-Dateien `src/lib.rs` und `Cargo.toml` sehen.

<Callout type="warn">
  Aktualisieren Sie das Feld `edition` in `Cargo.toml` auf 2021. Andernfalls
  kann beim Erstellen des Programms ein Fehler auftreten.
</Callout>

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
# !mark
edition = "2021"

[dependencies]
```

```rs !! title="lib.rs"
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
```

## !!steps Füge Abhängigkeiten hinzu

Fügen wir nun die notwendigen Abhängigkeiten für die Erstellung eines
Solana-Programms hinzu. Wir benötigen `solana-program` für das Core-SDK und
`borsh` für die Serialisierung.

```terminal
$ cargo add solana-program@2.2.0
$ cargo add borsh
```

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[dependencies]
# !focus(1:4)
# Borsh is used for serializing/deserializing
borsh = "1.5.7"
# The core Solana program SDK
solana-program = "2.2.0"
```

<Callout type="info">
  Es besteht keine Verpflichtung, Borsh zu verwenden. Es ist jedoch eine häufig
  verwendete Serialisierungsbibliothek für Solana-Programme.
</Callout>

## !!steps Konfiguriere crate-type

Solana-Programme müssen als dynamische Bibliotheken kompiliert werden. Fügen Sie
den Abschnitt `[lib]` hinzu, um zu konfigurieren, wie Cargo das Programm
erstellt.

```toml title="Cargo.toml"
[lib]
crate-type = ["cdylib", "lib"]
```

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

# !focus(1:2)
[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
borsh = "1.5.7"
solana-program = "2.2.0"
```

<Callout type="warn">
  Wenn Sie diese Konfiguration nicht einschließen, wird das Verzeichnis
  target/deploy beim Erstellen des Programms nicht generiert.
</Callout>

## !!steps Richte den Programm-Entrypoint ein

Jedes Solana-Programm hat einen Entrypoint, die Funktion, die aufgerufen wird,
wenn das Programm ausgeführt wird. Beginnen wir damit, die benötigten Imports
für das Programm hinzuzufügen und den Entrypoint einzurichten.

Fügen Sie den folgenden Code zu `lib.rs` hinzu:

```rs title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    Ok(())
}
```

Das
[entrypoint](https://github.com/anza-xyz/solana-sdk/blob/449d97c0ed164611dae538e2ee91ca0caaaec515/program-entrypoint/src/lib.rs#L126-L140)
Makro übernimmt die Deserialisierung der `input` Daten in die Parameter der
`process_instruction` Funktion.

Ein Solana-Programm `entrypoint` hat die folgende Funktionssignatur. Entwickler
können ihre eigene Implementierung der `entrypoint` Funktion erstellen.

```rs
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64;
```

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

// This macro defines the program's entrypoint
// !mark
entrypoint!(process_instruction);

// The main function that processes all incoming instructions
pub fn process_instruction(
    program_id: &Pubkey,      // This program's public key
    accounts: &[AccountInfo],  // Accounts passed to the instruction
    instruction_data: &[u8],   // Raw instruction data as bytes
) -> ProgramResult {
    // Program logic will go here
    Ok(())
}
```

## !!steps Definiere den Programmzustand

Jetzt definieren wir die Datenstruktur, die in unseren Counter-Konten
gespeichert wird. Dies sind die Daten, die im Feld `data` des Kontos gespeichert
werden.

Füge den folgenden Code zu `lib.rs` hinzu:

```rs title="lib.rs"
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    Ok(())
}

// !focus(1:7)
// Define the data structure for our counter account
// The derive macros enable automatic serialization/deserialization
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    // Store the counter value
    pub count: u64,
}
```

## !!steps Definiere das Anweisungs-Enum

Definieren wir die Anweisungen, die unser Programm ausführen kann. Wir verwenden
ein Enum, bei dem jede Variante eine andere Anweisung darstellt.

Füge den folgenden Code zu `lib.rs` hinzu:

```rs title="lib.rs"
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 },
    IncrementCounter,
}
```

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    Ok(())
}

// !focus(1:8)
// Define the instructions our program can execute
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    // Variant 0: Initialize a counter with a starting value
    InitializeCounter { initial_value: u64 },
    // Variant 1: Increment an existing counter by 1
    IncrementCounter,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

## !!steps Implementiere die Deserialisierung von Anweisungen

Jetzt müssen wir die `instruction_data` (rohe Bytes) in eine unserer
`CounterInstruction`-Enum-Varianten deserialisieren. Die Borsh-Methode
`try_from_slice` übernimmt diese Konvertierung automatisch.

Aktualisiere die Funktion `process_instruction`, um die Borsh-Deserialisierung
zu verwenden:

```rs title="lib.rs"
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    Ok(())
}
```

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

// !focus(1:10)
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Deserialize instruction data using Borsh
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    Ok(())
}

// !focus(1:8)
// Instructions are automatically serialized/deserialized by Borsh
// The enum variants are numbered 0, 1, etc. in order of declaration
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 },  // Variant 0
    IncrementCounter,                          // Variant 1
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

## !!steps Leite Anweisungen an Handler weiter

Aktualisieren wir nun die Hauptfunktion `process_instruction`, um Anweisungen an
die entsprechenden Handler-Funktionen weiterzuleiten.

Dieses Routing-Muster ist in Solana-Programmen üblich. Die `instruction_data`
wird in eine Variante eines Enums deserialisiert, das die Anweisung
repräsentiert, dann wird die entsprechende Handler-Funktion aufgerufen. Jede
Handler-Funktion enthält die Implementierung für diese Anweisung.

Füge den folgenden Code zu `lib.rs` hinzu, aktualisiere die Funktion
`process_instruction` und füge die Handler für die Anweisungen
`InitializeCounter` und `IncrementCounter` hinzu:

```rs title="lib.rs"
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => {
            process_increment_counter(program_id, accounts)?
        }
    };
    Ok(())
}

fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    Ok(())
}

fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    Ok(())
}
```

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

// !focus(1:40)
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Deserialize the instruction using Borsh
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    // Route to the appropriate handler based on the instruction
    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => {
            process_increment_counter(program_id, accounts)?
        }
    };

    Ok(())
}

// Handler function for initializing a counter
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    // Implementation coming next
    Ok(())
}

// Handler function for incrementing a counter
fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    // Implementation coming next
    Ok(())
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 },
    IncrementCounter,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

## !!steps Implementiere den Initialize-Handler

Implementieren wir den Handler zum Erstellen und Initialisieren eines neuen
Counter-Kontos. Da nur das System Program Konten auf Solana erstellen kann,
verwenden wir einen Cross Program Invocation (CPI), also den Aufruf eines
anderen Programms aus unserem Programm heraus.

Unser Programm führt einen CPI aus, um die Anweisung `create_account` des System
Program aufzurufen. Das neue Konto wird mit unserem Programm als Eigentümer
erstellt, wodurch unser Programm die Möglichkeit erhält, in das Konto zu
schreiben und die Daten zu initialisieren.

Fügen Sie den folgenden Code zu `lib.rs` hinzu und aktualisieren Sie die
Funktion `process_initialize_counter`:

```rs title="lib.rs"
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    let account_space = 8;

    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    invoke(
        &system_instruction::create_account(
            payer_account.key,
            counter_account.key,
            required_lamports,
            account_space as u64,
            program_id,
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    let counter_data = CounterAccount {
        count: initial_value,
    };

    let mut account_data = &mut counter_account.data.borrow_mut()[..];
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}
```

<Callout type="warn">
  Diese Anweisung dient nur zu Demonstrationszwecken. Sie enthält keine
  Sicherheits- und Validierungsprüfungen, die für Produktionsprogramme
  erforderlich sind.
</Callout>

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,                      // For logging messages
    program::invoke,          // For Cross Program Invocations
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,       // System Program instructions
    sysvar::{rent::Rent, Sysvar},  // For rent calculations
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => {
            process_increment_counter(program_id, accounts)?
        }
    };

    Ok(())
}

// !focus(1:50)
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    // Create an iterator over the accounts
    let accounts_iter = &mut accounts.iter();

    // Extract the required accounts in order
    let counter_account = next_account_info(accounts_iter)?;  // The new counter account
    let payer_account = next_account_info(accounts_iter)?;    // Who pays for the account
    let system_program = next_account_info(accounts_iter)?;   // System Program for CPI

    // Calculate the space needed for our counter data
    let account_space = 8; // 8 bytes for a u64

    // Get the minimum balance required for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account via CPI to the System Program
    // !focus(1:15)
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for creation
            counter_account.key,  // New account being created
            required_lamports,    // Lamports to transfer
            account_space as u64, // Space to allocate in bytes
            program_id,          // Program that will own this account (our program)
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Initialize the counter data
    let counter_data = CounterAccount {
        count: initial_value,
    };

    // Serialize and write the data to the account
    let mut account_data = &mut counter_account.data.borrow_mut()[..];
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}

fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    Ok(())
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 },
    IncrementCounter,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

## !!steps Inkrement-Handler implementieren

Implementieren wir nun den Handler, der einen bestehenden Zähler erhöht. Diese
Anweisung:

- Liest das Feld `data` des Kontos für `counter_account`
- Deserialisiert es in eine `CounterAccount`-Struktur
- Erhöht das Feld `count` um 1
- Serialisiert die `CounterAccount`-Struktur zurück in das Feld `data` des
  Kontos

Fügen Sie den folgenden Code zu `lib.rs` hinzu und aktualisieren Sie die
Funktion `process_increment_counter`:

```rs title="lib.rs"
fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;

    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    let mut data = counter_account.data.borrow_mut();

    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);

    Ok(())
}
```

<Callout type="warn">
  Diese Anweisung dient nur zu Demonstrationszwecken. Sie enthält keine
  Sicherheits- und Validierungsprüfungen, die für Produktionsprogramme
  erforderlich sind.
</Callout>

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => {
            process_increment_counter(program_id, accounts)?
        }
    };

    Ok(())
}

fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    let account_space = 8;

    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    invoke(
        &system_instruction::create_account(
            payer_account.key,
            counter_account.key,
            required_lamports,
            account_space as u64,
            program_id,
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    let counter_data = CounterAccount {
        count: initial_value,
    };

    let mut account_data = &mut counter_account.data.borrow_mut()[..];
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}

// !focus(1:33)
fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    // Get the counter account to increment
    let counter_account = next_account_info(accounts_iter)?;

    // Security check: Verify this program owns the account
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Get a mutable reference to the account's data
    let mut data = counter_account.data.borrow_mut();

    // Deserialize the current counter value
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    // Increment the counter value
    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    // Serialize the updated data back to the account
    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);

    Ok(())
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 },
    IncrementCounter,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

## !!steps Vollständiges Programm

Herzlichen Glückwunsch! Sie haben ein vollständiges Solana-Programm erstellt,
das die grundlegende Struktur demonstriert, die alle Solana-Programme gemeinsam
haben:

- **Entrypoint**: Definiert, wo die Programmausführung beginnt, und leitet alle
  eingehenden Anfragen an die entsprechenden Anweisungs-Handler weiter
- **Anweisungsverarbeitung**: Definiert Anweisungen und ihre zugehörigen
  Handler-Funktionen
- **Zustandsverwaltung**: Definiert Kontodatenstrukturen und verwaltet deren
  Zustand in programmeigenen Konten
- **Cross Program Invocation (CPI)**: Ruft das System Program auf, um neue
  programmeigene Konten zu erstellen

Der nächste Schritt besteht darin, das Programm zu testen, um sicherzustellen,
dass alles korrekt funktioniert.

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

// Program entrypoint - this is where execution starts
entrypoint!(process_instruction);

/// Main instruction processing function
/// Routes incoming instructions to appropriate handlers
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Parse instruction data
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    // Route to appropriate handler
    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            msg!("Instruction: Initialize Counter");
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => {
            msg!("Instruction: Increment Counter");
            process_increment_counter(program_id, accounts)?
        }
    };

    Ok(())
}

/// Instructions supported by the counter program
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    /// Initialize a new counter with the given value
    InitializeCounter { initial_value: u64 },

    /// Increment an existing counter by 1
    IncrementCounter,
}

/// Initialize a new counter account
///
/// Accounts expected:
/// 1. `[signer, writable]` Counter account to create
/// 2. `[signer, writable]` Payer account
/// 3. `[]` System Program
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    let account_space = 8;
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create account via CPI to System Program
    invoke(
        &system_instruction::create_account(
            payer_account.key,
            counter_account.key,
            required_lamports,
            account_space as u64,
            program_id,
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Initialize counter data
    let counter_data = CounterAccount {
        count: initial_value,
    };

    let mut account_data = &mut counter_account.data.borrow_mut()[..];
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}

/// Increment an existing counter
///
/// Accounts expected:
/// 1. `[writable]` Counter account to increment
fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Read, update, write
    let mut data = counter_account.data.borrow_mut();
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);

    Ok(())
}

/// Counter account data structure
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    /// Current counter value
    pub count: u64,
}
```

</ScrollyCoding>

## Teil 2: Testen des Programms

Jetzt testen wir unser Counter-Programm. Wir verwenden
[LiteSVM](https://github.com/LiteSVM/litesvm), ein Test-Framework, mit dem wir
Programme testen können, ohne sie auf einem Cluster bereitzustellen.

<ScrollyCoding>

## !!steps Test-Abhängigkeiten hinzufügen

Zunächst fügen wir die für das Testen benötigten Abhängigkeiten hinzu. Wir
verwenden `litesvm` zum Testen und `solana-sdk`.

```terminal
$ cargo add litesvm@0.6.1 --dev
$ cargo add solana-sdk@2.2.0 --dev
```

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
borsh = "1.5.7"
solana-program = "2.2.0"

# !focus(1:3)
[dev-dependencies]
litesvm = "0.6.1"
solana-sdk = "2.2.0"
```

## !!steps Test-Modul erstellen

Jetzt fügen wir unserem Programm ein Test-Modul hinzu. Wir beginnen mit dem
grundlegenden Gerüst und den Imports.

Fügen Sie den folgenden Code zu `lib.rs` direkt unterhalb des Programmcodes
hinzu:

```rs title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        // Test implementation will go here
    }
}
```

```rs !! title="lib.rs"
// ... (program code above) ...

// !focus(1:22)
// Test module - only compiled when running tests
#[cfg(test)]
mod test {
    use super::*;  // Import everything from the parent module
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        // Test implementation will go here
    }
}
```

Das Attribut `#[cfg(test)]` stellt sicher, dass dieser Code nur beim Ausführen
von Tests kompiliert wird.

## !!steps Test-Umgebung initialisieren

Richten wir die Test-Umgebung mit LiteSVM ein und finanzieren ein Payer-Konto.

LiteSVM simuliert die Solana-Laufzeitumgebung und ermöglicht es uns, unser
Programm zu testen, ohne es auf einem echten Cluster bereitzustellen.

Fügen Sie den folgenden Code zu `lib.rs` hinzu, um die Funktion
`test_counter_program` zu aktualisieren:

```rs title="lib.rs"
let mut svm = LiteSVM::new();

let payer = Keypair::new();

svm.airdrop(&payer.pubkey(), 1_000_000_000)
    .expect("Failed to airdrop");
```

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        // !focus(1:12)
        // Create a new instance of the Solana VM for testing
        let mut svm = LiteSVM::new();

        // Create a keypair for the transaction payer
        let payer = Keypair::new();

        // Fund the payer account with 1 SOL (1 billion lamports)
        // This is needed to pay for transaction fees and account creation
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");
    }
}
```

## !!steps Programm laden

Jetzt müssen wir unser Programm erstellen und in die Test-Umgebung laden. Führen
Sie den Befehl `cargo build-sbf` aus, um das Programm zu erstellen. Dadurch wird
die Datei `counter_program.so` im Verzeichnis `target/deploy` generiert.

```terminal
$ cargo build-sbf
```

<Callout type="warn">
  Stellen Sie sicher, dass `edition` in `Cargo.toml` auf `2021` gesetzt ist.
</Callout>

Nach dem Build können wir das Programm laden.

Aktualisieren Sie die Funktion `test_counter_program`, um das Programm in die
Testumgebung zu laden.

```rs title="lib.rs"
let program_keypair = Keypair::new();
let program_id = program_keypair.pubkey();

svm.add_program_from_file(
    program_id,
    "target/deploy/counter_program.so"
).expect("Failed to load program");
```

<Callout type="warn">
  Sie müssen `cargo build-sbf` ausführen, bevor Sie Tests durchführen, um die
  Datei `.so` zu generieren. Der Test lädt das kompilierte Programm.
</Callout>

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        let mut svm = LiteSVM::new();

        let payer = Keypair::new();
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");

        // !focus(1:11)
        // Load our compiled program into the test environment
        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();

        // Load the compiled program
        svm.add_program_from_file(
            program_id,
            "target/deploy/counter_program.so"
        ).expect("Failed to load program");
    }
}
```

## !!steps Initialisierungsanweisung testen

Testen wir die Initialisierungsanweisung, indem wir ein neues Counter-Konto mit
einem Startwert erstellen.

Fügen Sie den folgenden Code zu `lib.rs` hinzu und aktualisieren Sie die
Funktion `test_counter_program`:

```rs title="lib.rs"
let counter_keypair = Keypair::new();
let initial_value: u64 = 42;

println!("Testing counter initialization...");

let init_instruction_data =
    borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
        .expect("Failed to serialize instruction");

let initialize_instruction = Instruction::new_with_bytes(
    program_id,
    &init_instruction_data,
    vec![
        AccountMeta::new(counter_keypair.pubkey(), true),
        AccountMeta::new(payer.pubkey(), true),
        AccountMeta::new_readonly(system_program::id(), false),
    ],
);

let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
let transaction = Transaction::new(
    &[&payer, &counter_keypair],
    message,
    svm.latest_blockhash()
);

let result = svm.send_transaction(transaction);
assert!(result.is_ok(), "Initialize transaction should succeed");

let logs = result.unwrap().logs;
println!("Transaction logs:\n{:#?}", logs);
```

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        let mut svm = LiteSVM::new();

        let payer = Keypair::new();
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");

        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();
        svm.add_program_from_file(
            program_id,
            "target/deploy/counter_program.so"
        ).expect("Failed to load program");

        // !focus(1:38)
        // Step 1: Initialize the counter
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        println!("Testing counter initialization...");

        // Use Borsh serialization for the instruction
        let init_instruction_data =
            borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
                .expect("Failed to serialize instruction");

        // Create the initialization instruction
        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                // Account 1: Counter account (signer, writable)
                AccountMeta::new(counter_keypair.pubkey(), true),
                // Account 2: Payer (signer, writable)
                AccountMeta::new(payer.pubkey(), true),
                // Account 3: System Program (not signer, not writable)
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Build and send the transaction
        let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],  // Signers
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Initialize transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);
    }
}
```

## !!steps Initialisierung überprüfen

Nach der Initialisierung überprüfen wir, ob das Counter-Konto korrekt mit dem
erwarteten Wert erstellt wurde.

Fügen Sie den folgenden Code zu `lib.rs` hinzu und aktualisieren Sie die
Funktion `test_counter_program`:

```rs title="lib.rs"
let account = svm
    .get_account(&counter_keypair.pubkey())
    .expect("Failed to get counter account");

let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
    .expect("Failed to deserialize counter data");

assert_eq!(counter.count, 42);
println!("Counter initialized successfully with value: {}", counter.count);
```

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        let mut svm = LiteSVM::new();

        let payer = Keypair::new();
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");

        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();
        svm.add_program_from_file(program_id, "target/deploy/counter_program.so")
            .unwrap();

        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        println!("Testing counter initialization...");

        // Use Borsh serialization for the instruction
        let init_instruction_data =
            borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
                .expect("Failed to serialize instruction");

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Initialize transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);

        // !focus(1:14)
        // Check account data after initialization
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        // Deserialize and verify the counter data
        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");

        assert_eq!(counter.count, 42);
        println!("Counter initialized successfully with value: {}", counter.count);
    }
}
```

## !!steps Increment-Anweisung testen

Testen wir nun die Increment-Anweisung, um sicherzustellen, dass sie den
Counter-Wert korrekt aktualisiert.

Fügen Sie den folgenden Code zu `lib.rs` hinzu und aktualisieren Sie die
Funktion `test_counter_program`:

```rs title="lib.rs"
println!("Testing counter increment...");

let increment_instruction_data =
    borsh::to_vec(&CounterInstruction::IncrementCounter)
        .expect("Failed to serialize instruction");

let increment_instruction = Instruction::new_with_bytes(
    program_id,
    &increment_instruction_data,
    vec![AccountMeta::new(counter_keypair.pubkey(), true)],
);

let message = Message::new(&[increment_instruction], Some(&payer.pubkey()));
let transaction = Transaction::new(
    &[&payer, &counter_keypair],
    message,
    svm.latest_blockhash()
);

let result = svm.send_transaction(transaction);
assert!(result.is_ok(), "Increment transaction should succeed");

let logs = result.unwrap().logs;
println!("Transaction logs:\n{:#?}", logs);
```

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        let mut svm = LiteSVM::new();

        let payer = Keypair::new();
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");

        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();
        svm.add_program_from_file(program_id, "target/deploy/counter_program.so")
            .unwrap();

        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Use Borsh serialization for the instruction
        let init_instruction_data =
            borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
                .expect("Failed to serialize instruction");

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Initialize transaction should succeed");

        // Check account data
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");
        assert_eq!(counter.count, 42);
        println!("Counter initialized successfully with value: {}", counter.count);

        // !focus(1:26)
        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Use Borsh serialization for increment instruction
        let increment_data = borsh::to_vec(&CounterInstruction::IncrementCounter)
            .expect("Failed to serialize instruction");

        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &increment_data,
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Build and send increment transaction
        let message = Message::new(&[increment_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Increment transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);
    }
}
```

## !!steps Endergebnisse überprüfen

Abschließend überprüfen wir, ob das Increment korrekt funktioniert hat, indem
wir den aktualisierten Counter-Wert prüfen.

Fügen Sie den folgenden Code zu `lib.rs` hinzu und aktualisieren Sie die
Funktion `test_counter_program`:

```rs title="lib.rs"
let account = svm
    .get_account(&counter_keypair.pubkey())
    .expect("Failed to get counter account");

let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
    .expect("Failed to deserialize counter data");
assert_eq!(counter.count, 43);
println!("Counter incremented successfully to: {}", counter.count);
```

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        let mut svm = LiteSVM::new();

        let payer = Keypair::new();
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");

        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();
        svm.add_program_from_file(program_id, "target/deploy/counter_program.so")
            .unwrap();

        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Use Borsh serialization for the instruction
        let init_instruction_data =
            borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
                .expect("Failed to serialize instruction");

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Initialize transaction should succeed");

        // Check account data
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");
        assert_eq!(counter.count, 42);
        println!("Counter initialized successfully with value: {}", counter.count);

        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Use Borsh serialization for increment instruction
        let increment_data = borsh::to_vec(&CounterInstruction::IncrementCounter)
            .expect("Failed to serialize instruction");

        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &increment_data,
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Build and send increment transaction
        let message = Message::new(&[increment_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Increment transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);

        // !focus(1:11)
        // Check account data
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");
        assert_eq!(counter.count, 43);
        println!("Counter incremented successfully to: {}", counter.count);
    }
}
```

Führe die Tests mit dem folgenden Befehl aus. Das Flag `--nocapture` gibt die
Ausgabe des Tests aus.

```terminal
$ cargo test -- --nocapture
```

Erwartete Ausgabe:

```
Testing counter initialization...
Transaction logs:
[
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq invoke [1]",
    "Program 11111111111111111111111111111111 invoke [2]",
    "Program 11111111111111111111111111111111 success",
    "Program log: Counter initialized with value: 42",
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq consumed 3803 of 200000 compute units",
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq success",
]
Counter initialized successfully with value: 42
Testing counter increment...
Transaction logs:
[
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq invoke [1]",
    "Program log: Counter incremented to: 43",
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq consumed 762 of 200000 compute units",
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq success",
]
Counter incremented successfully to: 43
```

</ScrollyCoding>

## Teil 3: Aufruf des Programms

Fügen wir nun ein Client-Skript hinzu, um das Programm aufzurufen.

<ScrollyCoding>

## !!steps Client-Beispiel erstellen

Erstellen wir einen Rust-Client, um mit unserem bereitgestellten Programm zu
interagieren.

```terminal
$ mkdir examples
$ touch examples/client.rs
```

Füge die folgende Konfiguration zu `Cargo.toml` hinzu:

```toml title="Cargo.toml"
[[example]]
name = "client"
path = "examples/client.rs"
```

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
borsh = "1.5.7"
solana-program = "2.2.0"

[dev-dependencies]
litesvm = "0.6.1"
solana-sdk = "2.2.0"
# !focus(1:2)
solana-client = "2.2.0"
tokio = "1.47.1"

# !focus(1:3)
[[example]]
name = "client"
path = "examples/client.rs"
```

Installiere die Client-Abhängigkeiten:

```terminal
$ cargo add solana-client@2.2.0 --dev
$ cargo add tokio --dev
```

## !!steps Client-Code implementieren

Implementieren wir nun den Client, der unser bereitgestelltes Programm aufruft.

Führe den folgenden Befehl aus, um deine Programm-ID aus der Keypair-Datei zu
erhalten:

```terminal
$ solana address -k ./target/deploy/counter_program-keypair.json
```

Füge den Client-Code zu `examples/client.rs` hinzu und ersetze die `program_id`
durch die Ausgabe des vorherigen Befehls:

```rs title="examples/client.rs"
// !mark
let program_id = Pubkey::from_str("BDLLezrtFEXVGYqG3aS7eAC7GVeojJ4JHhKJM6pAFCDH")
    .expect("Invalid program ID");
```

<CodePlaceholder title="examples/client.rs" />

```rs !! title="examples/client.rs"
use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    system_program,
    transaction::Transaction,
};
use std::str::FromStr;
use counter_program::CounterInstruction;

#[tokio::main]
async fn main() {
    // Replace with your actual program ID from deployment
    // !mark
    let program_id = Pubkey::from_str("BDLLezrtFEXVGYqG3aS7eAC7GVeojJ4JHhKJM6pAFCDH")
        .expect("Invalid program ID");

    // Connect to local cluster
    let rpc_url = String::from("http://localhost:8899");
    let client = RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed());

    // Generate a new keypair for paying fees
    let payer = Keypair::new();

    // Request airdrop of 1 SOL for transaction fees
    println!("Requesting airdrop...");
    let airdrop_signature = client
        .request_airdrop(&payer.pubkey(), 1_000_000_000)
        .expect("Failed to request airdrop");

    // Wait for airdrop confirmation
    loop {
        if client
            .confirm_transaction(&airdrop_signature)
            .unwrap_or(false)
        {
            break;
        }
        std::thread::sleep(std::time::Duration::from_millis(500));
    }
    println!("Airdrop confirmed");

    println!("\nInitializing counter...");
    let counter_keypair = Keypair::new();
    let initial_value = 100u64;

    // Serialize the initialize instruction data
    let instruction_data = borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
        .expect("Failed to serialize instruction");

    let initialize_instruction = Instruction::new_with_bytes(
        program_id,
        &instruction_data,
        vec![
            AccountMeta::new(counter_keypair.pubkey(), true),
            AccountMeta::new(payer.pubkey(), true),
            AccountMeta::new_readonly(system_program::id(), false),
        ],
    );

    let mut transaction =
        Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));

    let blockhash = client
        .get_latest_blockhash()
        .expect("Failed to get blockhash");
    transaction.sign(&[&payer, &counter_keypair], blockhash);

    match client.send_and_confirm_transaction(&transaction) {
        Ok(signature) => {
            println!("Counter initialized!");
            println!("Transaction: {}", signature);
            println!("Counter address: {}", counter_keypair.pubkey());
        }
        Err(err) => {
            eprintln!("Failed to initialize counter: {}", err);
            return;
        }
    }

    println!("\nIncrementing counter...");
    // Serialize the increment instruction data
    let increment_data = borsh::to_vec(&CounterInstruction::IncrementCounter)
        .expect("Failed to serialize instruction");

    let increment_instruction = Instruction::new_with_bytes(
        program_id,
        &increment_data,
        vec![AccountMeta::new(counter_keypair.pubkey(), true)],
    );

    let mut transaction =
        Transaction::new_with_payer(&[increment_instruction], Some(&payer.pubkey()));

    transaction.sign(&[&payer, &counter_keypair], blockhash);

    match client.send_and_confirm_transaction(&transaction) {
        Ok(signature) => {
            println!("Counter incremented!");
            println!("Transaction: {}", signature);
        }
        Err(err) => {
            eprintln!("Failed to increment counter: {}", err);
        }
    }
}
```

</ScrollyCoding>

## Teil 4: Das Programm bereitstellen

Jetzt, da wir unser Programm und unseren Client fertig haben, bauen, deployen
und rufen wir das Programm auf.

<Steps>

<Step>

### Das Programm bauen

Zuerst bauen wir unser Programm.

```terminal
$ cargo build-sbf
```

Dieser Befehl kompiliert Ihr Programm und generiert zwei wichtige Dateien in
`target/deploy/`:

```txt
counter_program.so              # The compiled program
counter_program-keypair.json    # Keypair for the program ID
```

Sie können die ID Ihres Programms anzeigen, indem Sie den folgenden Befehl
ausführen:

```terminal
$ solana address -k ./target/deploy/counter_program-keypair.json
```

Beispielausgabe:

```
HQ5Q2XXqbTKKQsWPtLzMn7rDhM8v9UPYPe7DfSoFQqJF
```

</Step>

<Step>

### Lokalen Validator starten

Für die Entwicklung verwenden wir einen lokalen Test-Validator.

Konfigurieren Sie zunächst die Solana CLI für die Verwendung von localhost:

```terminal
$ solana config set -ul
```

Beispielausgabe:

```
Config File: ~/.config/solana/cli/config.yml
RPC URL: http://localhost:8899
WebSocket URL: ws://localhost:8900/ (computed)
Keypair Path: ~/.config/solana/id.json
Commitment: confirmed
```

Starten Sie nun den Test-Validator in einem separaten Terminal:

```terminal
$ solana-test-validator
```

</Step>

<Step>

### Deployment des Programms

Während der Validator läuft, deployen Sie Ihr Programm auf den lokalen Cluster:

```terminal
$ solana program deploy ./target/deploy/counter_program.so
```

Beispielausgabe:

```
Program Id: HQ5Q2XXqbTKKQsWPtLzMn7rDhM8v9UPYPe7DfSoFQqJF

Signature: 5xKdnh3dDFnZXB5UevYYkFBpCVcuqo5SaUPLnryFWY7eQD2CJxaeVDKjQ4ezQVJfkGNqZGYqMZBNqymPKwCQQx5h
```

Sie können das Deployment mit dem Befehl `solana program show` und Ihrer
Programm-ID überprüfen:

```terminal
$ solana program show HQ5Q2XXqbTKKQsWPtLzMn7rDhM8v9UPYPe7DfSoFQqJF
```

Beispielausgabe:

```
Program Id: HQ5Q2XXqbTKKQsWPtLzMn7rDhM8v9UPYPe7DfSoFQqJF
Owner: BPFLoaderUpgradeab1e11111111111111111111111
ProgramData Address: 47MVf5tRZ4zWXQMX7ydrkgcFQr8XTk1QBjohwsUzaiuM
Authority: 4kh6HxYZiAebF8HWLsUWod2EaQQ6iWHpHYCz8UcmFbM1
Last Deployed In Slot: 16
Data Length: 82696 (0x14308) bytes
Balance: 0.57676824 SOL
```

</Step>

<Step>

### Ausführen des Clients

Während der lokale Validator noch läuft, führen Sie den Client aus:

```terminal
$ cargo run --example client
```

Erwartete Ausgabe:

```
Requesting airdrop...
Airdrop confirmed

Initializing counter...
Counter initialized!
Transaction: 2uenChtqNeLC1fitqoVE2LBeygSBTDchMZ4gGqs7AiDvZZVJguLDE5PfxsfkgY7xs6zFWnYsbEtb82dWv9tDT14k
Counter address: EppPAmwqD42u4SCPWpPT7wmWKdFad5VnM9J4R9Zfofcy

Incrementing counter...
Counter incremented!
Transaction: 4qv1Rx6FHu1M3woVgDQ6KtYUaJgBzGcHnhej76ZpaKGCgsTorbcHnPKxoH916UENw7X5ppnQ8PkPnhXxEwrYuUxS
```

Während der lokale Validator läuft, können Sie die Transaktionen im
[Solana Explorer](https://explorer.solana.com/?cluster=custom) anhand der
ausgegebenen Transaktionssignaturen einsehen. Beachten Sie, dass der Cluster im
Solana Explorer auf "Custom RPC URL" eingestellt sein muss, was standardmäßig
auf `http://localhost:8899` verweist, auf dem der `solana-test-validator` läuft.

</Step>

</Steps>
