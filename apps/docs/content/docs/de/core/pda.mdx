---
title: Programm-abgeleitete Adresse
description:
  Erfahren Sie mehr über Solanas programm-abgeleitete Adressen (PDAs) —
  deterministische Kontenadressen, die eine sichere Programmunterzeichnung
  ermöglichen. Verstehen Sie PDA-Ableitung, kanonische Bumps und wie man
  PDA-Konten erstellt.
---

Eine Solana [Kontenadresse](/docs/core/accounts#account-address) verweist auf
den Speicherort des Kontos in der Blockchain. Viele Kontenadressen sind der
öffentliche Schlüssel eines keypair, wobei der entsprechende private Schlüssel
verwendet wird, um Transaktionen zu signieren, die das Konto betreffen.

Eine nützliche Alternative zu einer öffentlichen Schlüsseladresse ist eine
programm-abgeleitete Adresse (PDA). PDAs bieten eine einfache Methode zum
Speichern, Zuordnen und Abrufen des Programmzustands. Eine PDA ist eine Adresse,
die deterministisch unter Verwendung einer Programm-ID und einer Kombination
optionaler vordefinierter Eingaben erstellt wird. PDAs sehen ähnlich aus wie
öffentliche Schlüsseladressen, haben aber keinen entsprechenden privaten
Schlüssel.

Die Solana-Laufzeitumgebung ermöglicht es Programmen, für PDAs zu signieren,
ohne einen privaten Schlüssel zu benötigen. Die Verwendung einer PDA beseitigt
die Notwendigkeit, die Adresse des Kontos zu verfolgen. Stattdessen können Sie
die spezifischen Eingaben abrufen, die für die Ableitung der PDA verwendet
wurden. (Um zu erfahren, wie Programme PDAs zum Signieren verwenden, siehe den
Abschnitt [Cross Program Invocations](/docs/core/cpi).)

## Hintergrund

Solana
[keypairs](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/keypair/src/lib.rs#L26)
sind Punkte auf der [Ed25519-Kurve](https://ed25519.cr.yp.to/) (elliptische
Kurven- Kryptographie). Sie bestehen aus einem öffentlichen Schlüssel und einem
privaten Schlüssel. Der öffentliche Schlüssel wird zur Kontenadresse, und der
private Schlüssel wird verwendet, um gültige
[Signaturen](/docs/core/transactions#signatures) für das Konto zu generieren.

![Zwei Konten mit Adressen auf der Kurve](/assets/docs/core/pda/address-on-curve.svg)

Eine PDA wird absichtlich so abgeleitet, dass sie außerhalb der Ed25519-Kurve
liegt. Das bedeutet, sie hat keinen gültigen entsprechenden privaten Schlüssel
und kann keine kryptografischen Operationen durchführen. (Wie zum Beispiel das
Bereitstellen einer Signatur.) Solana ermöglicht es Programmen jedoch, für PDAs
zu signieren, ohne einen privaten Schlüssel zu benötigen.

![Off Curve Address](/assets/docs/core/pda/address-off-curve.svg)

Man kann sich PDAs als eine Möglichkeit vorstellen, hashmap-ähnliche Strukturen
on-chain mit einem vordefinierten Satz von Eingaben zu erstellen. (Zum Beispiel
Strings, Zahlen und andere Konten-Adressen.)

![Program Derived Address](/assets/docs/core/pda/pda.svg)

## Eine PDA ableiten

Bevor ein Konto mit einer PDA erstellt wird, muss zuerst die Adresse abgeleitet
werden. Das Ableiten einer PDA erstellt _nicht_ automatisch ein On-Chain-Konto
an dieser Adresse – das Konto muss explizit durch das Programm erstellt werden,
das zur Ableitung der PDA verwendet wurde. Man kann sich eine PDA wie eine
Adresse auf einer Karte vorstellen: nur weil eine Adresse existiert, bedeutet
das nicht, dass dort etwas gebaut wurde.

Die Solana SDKs unterstützen die PDA-Erstellung mit den in der folgenden Tabelle
gezeigten Funktionen. Jede Funktion erhält folgende Eingaben:

- **Program ID**: Die Adresse des Programms, das zur Ableitung der PDA verwendet
  wird. Dieses Programm kann im Namen der PDA signieren.
- **Optional seeds**: Vordefinierte Eingaben wie Strings, Zahlen oder andere
  Konten-Adressen.

| SDK                            | Funktion                                                                                                                         |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `@solana/kit` (Typescript)     | [`getProgramDerivedAddress`](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L157) |
| `@solana/web3.js` (Typescript) | [`findProgramAddressSync`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/publickey.ts#L212)               |
| `solana_sdk` (Rust)            | [`find_program_address`](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/pubkey/src/lib.rs#L617)                        |

Die Funktion verwendet die Program ID und optionale seeds und iteriert dann
durch bump-Werte, um zu versuchen, eine gültige Programm-Adresse zu erstellen.
Die Iteration der bump-Werte beginnt bei 255 und wird um 1 verringert, bis eine
gültige PDA gefunden wird. Nachdem eine gültige PDA gefunden wurde, gibt die
Funktion die PDA und den bump seed zurück.

<Callout>
  Der bump seed ist ein zusätzliches Byte, das an die optionalen seeds angehängt
  wird, um sicherzustellen, dass eine gültige Off-Curve-Adresse generiert wird.
</Callout>

![PDA-Ableitung](/assets/docs/core/pda/pda-derivation.svg)

### Kanonischer Bump

Ein bump seed ist ein zusätzliches Byte, das an die optionalen seeds angehängt
wird. Die Ableitungsfunktion iteriert durch Bump-Werte, beginnend bei 255 und
dekrementiert um 1, bis ein Wert eine gültige Off-Curve-Adresse erzeugt. Der
erste Wert, der eine gültige Off-Curve-Adresse erzeugt, wird als "kanonischer
Bump" bezeichnet.

Die folgenden Beispiele zeigen die PDA-Ableitung mit allen möglichen bump seeds
(255 bis 0):

<Callout type="info">
  Kit-Beispiel ist nicht enthalten, da die
  [createProgramDerivedAddress](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L101)
  Funktion nicht exportiert wird.
</Callout>

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const optionalSeed = "helloWorld";

// Loop through all bump seeds (255 down to 0)
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(optionalSeed), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed = b"helloWorld";

    // Loop through all bump seeds (255 down to 0)
    for bump in (0..=255).rev() {
        match Pubkey::create_program_address(&[optional_seed.as_ref(), &[bump]], &program_id) {
            Ok(pda) => println!("bump {}: {}", bump, pda),
            Err(err) => println!("bump {}: {}", bump, err),
        }
    }

    Ok(())
}
```

</CodeTabs>

<CodeTabs>

```sh !! title="Expected TS Output"
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// remaining bump outputs
```

```sh !! title="Expected Rust Output"
bump 255: Provided seeds do not result in a valid address
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Provided seeds do not result in a valid address
...
// remaining bump outputs
```

</CodeTabs>

In diesem Beispiel wirft der erste bump seed einen Fehler. Der erste bump seed,
der eine gültige PDA ableitet, ist 254. Die bump seeds 253-251 leiten ebenfalls
eindeutige, gültige PDAs ab.

Das bedeutet, dass bei denselben optionalen Seeds und `programId` ein bump seed
mit einem anderen Wert dennoch eine gültige PDA ableiten kann.

<Callout type="warn">
  Fügen Sie immer Sicherheitsprüfungen ein, um sicherzustellen, dass eine an das
  Programm übergebene PDA vom kanonischen Bump abgeleitet wird. Wenn dies nicht
  erfolgt, können Schwachstellen entstehen, die es ermöglichen, unerwartete
  Konten in den Anweisungen des Programms zu verwenden. Es ist bewährte Praxis,
  nur den kanonischen Bump bei der Ableitung von PDAs zu verwenden.
</Callout>

### Beispiele

Die folgenden Beispiele leiten eine PDA mit den Solana SDKs ab. Klicken Sie auf
**&#9655; Run**, um den Code auszuführen.

#### Ableiten einer PDA mit einem String-Seed

Das folgende Beispiel leitet eine PDA mit einer Programm-ID und einem optionalen
String-Seed ab.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus
const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus
const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let seeds: &[&[u8]] = &[b"helloWorld"];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Ableiten einer PDA mit einer Adresse als seed

Das folgende Beispiel leitet eine PDA unter Verwendung einer Programm-ID und
eines optionalen Adress-seeds ab.

<CodeTabs storage="pda-examples"flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:4)
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

// !focus(1:3)
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Ableiten einer PDA mit mehreren seeds

Das folgende Beispiel leitet eine PDA unter Verwendung einer Programm-ID und
mehrerer optionaler seeds ab.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:5)
const optionalSeedString = "helloWorld";
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedString, optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus(1:4)
const optionalSeedString = "helloWorld";
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [Buffer.from(optionalSeedString), optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus(1:2)
    let optional_seed_bytes = b"helloWorld";
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

## Erstellen eines PDA-Kontos

<WithMentions>

Das folgende Beispiel verwendet das
[Anchor-Framework](https://www.anchor-lang.com/docs), um ein neues Konto mit
einer programmabgeleiteten Adresse zu erstellen. Das Programm enthält eine
einzige [`initialize`](mention:initialize)-Anweisung zum Erstellen des neuen
Kontos, welches die [Benutzeradresse](mention:user-address) und den
[bump seed](mention:bump) speichert, die zur Ableitung der PDA verwendet wurden.

```rs title="Program"
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    // !mention initialize
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        // !mark
        // !mention user-address
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bumpd
        // !mark
        // !mention bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    // !mention user-address
    pub user: Signer<'info>,

    #[account(
        init,
        // define the seeds to derive the PDA
        // !mark
        // !mention user-address
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        // !mark
        // !mention bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(InitSpace)]
pub struct DataAccount {
    // !mark
    // !mention user-address
    pub user: Pubkey,
    // !mark
    // !mention bump
    pub bump: u8,
}
```

</WithMentions>

<WithMentions>

Die [`init`](mention:init)-Einschränkung weist Anchor an, das
[System Program](/docs/core/programs#the-system-program) aufzurufen, um ein
neues Konto mit der PDA als Adresse zu erstellen. Die [Seeds](mention:seeds),
die zur Erstellung der PDA verwendet werden, sind:

- Die Adresse des in der Anweisung bereitgestellten Benutzerkontos
- Der feste String: "data"
- Der kanonische [bump seed](mention:bump)

In diesem Beispiel wird der bump-Einschränkung kein Wert zugewiesen, sodass
Anchor `find_program_address` verwendet, um die PDA abzuleiten und den bump zu
finden.

```rust title="pda_account"
#[account(
    // !mention init
    init,
    // !mention seeds
    seeds = [b"data", user.key().as_ref()],
    // !mention bump
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

</WithMentions>

<WithMentions>

Die folgende Testdatei enthält eine Transaktion, die die
[`initialize`](mention:initialize)-Anweisung aufruft, um ein neues Konto mit
einer programmabgeleiteten Adresse zu erstellen. Die Datei enthält Code zum
[Ableiten der PDA](mention:pda).

Das Beispiel zeigt auch, wie man das neue Konto, das erstellt wird,
[abrufen](mention:fetch) kann.

```ts title="Test"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PdaAccount } from "../target/types/pda_account";
import { PublicKey } from "@solana/web3.js";

describe("pda-account", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.PdaAccount as Program<PdaAccount>;
  const user = provider.wallet as anchor.Wallet;

  // !mention(1:5) pda
  // Derive the PDA address using the seeds specified on the program
  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("data"), user.publicKey.toBuffer()],
    program.programId
  );

  it("Is initialized!", async () => {
    const transactionSignature = await program.methods
      // !mention initialize
      .initialize()
      .accounts({
        user: user.publicKey
      })
      .rpc();

    console.log("Transaction Signature:", transactionSignature);
  });

  it("Fetch Account", async () => {
    // !mention fetch
    const pdaAccount = await program.account.dataAccount.fetch(PDA);
    console.log(JSON.stringify(pdaAccount, null, 2));
  });
});
```

</WithMentions>

<Callout type="warn">
  Wenn Sie die `initialize`-Anweisung erneut mit derselben `user`-Adresse als
  seed aufrufen, schlägt die Transaktion fehl. Dies geschieht, weil bereits ein
  Konto unter der abgeleiteten Adresse existiert.
</Callout>
