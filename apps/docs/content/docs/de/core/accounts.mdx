---
title: Konten
description:
  Erfahren Sie mehr über Solanas Kontenmodell, einschließlich wie Konten Daten
  und Programme speichern, Rent-Mechanismen, Konteneigentum und die Beziehung
  zwischen Programmen und Datenkonten. Verstehen Sie die Kernkonzepte von
  Solanas Key-Value-Speichersystem.
---

Alle Daten im Solana-Netzwerk werden in Konten gespeichert. Sie können sich das
Solana-Netzwerk als öffentliche Datenbank mit einer einzigen Konten-Tabelle
vorstellen. Die Beziehung zwischen einem Konto und seiner Adresse ähnelt der
eines Schlüssel-Wert-Paares, wobei der Schlüssel die Adresse und der Wert das
Konto ist.

Jedes Konto hat die gleiche grundlegende [Struktur](#account-structure) und kann
über seine [Adresse](#account-address) lokalisiert werden.

![Diagramm von 3 Konten und ihren Adressen. Enthält die Definition der Kontostruktur.](/assets/docs/core/accounts/accounts.png)

## Kontoadresse

Die Adresse des Kontos ist eine 32-Byte eindeutige ID, die verwendet wird, um
das Konto auf der Solana-Blockchain zu lokalisieren. Kontoadressen werden oft
als base58-kodierte Zeichenketten angezeigt. Die meisten Konten verwenden einen
[Ed25519](https://ed25519.cr.yp.to/) [öffentlichen Schlüssel](#public-key) als
ihre Adresse, aber dies ist nicht erforderlich, da Solana auch
[Program Derived Address](#program-derived-address) unterstützt.

![Ein Konto mit seiner base58-kodierten öffentlichen Schlüsseladresse](/assets/docs/core/accounts/account-address.svg)

### Öffentlicher Schlüssel

Das folgende Beispiel zeigt, wie man das Solana SDK verwendet, um ein Keypair zu
erstellen. Ein `Keypair` enthält:

- Einen öffentlichen Schlüssel, der als Kontenadresse dient
- Einen privaten Schlüssel, der zum Signieren von Transaktionen verwendet wird

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner } from "@solana/kit";

// Kit does not enable extractable private keys
const keypairSigner = await generateKeyPairSigner();
console.log(keypairSigner);
```

```ts !! title="Legacy"
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);
console.log(`Secret Key: ${keypair.secretKey}`);
```

```rs !! title="Rust"
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() {
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());
    println!("Secret Key: {:?}", keypair.to_bytes());
}
```

</CodeTabs>

### Program Derived Address

Eine [Program Derived Address](/docs/core/pda) (PDA) ist eine Adresse, die
deterministisch unter Verwendung einer Programm-ID und einer oder mehrerer
optionaler Eingaben (Seeds) abgeleitet wird. Das folgende Beispiel zeigt, wie
man das Solana SDK verwendet, um eine Program Derived Address zu erstellen.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey; // macro
use solana_sdk::pubkey::Pubkey;

#[tokio::main]
async fn main() {
    let program_address = pubkey!("11111111111111111111111111111111");
    let seeds = [b"helloWorld".as_ref()];
    let (pda, bump) = Pubkey::find_program_address(&seeds, &program_address);
    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
}
```

</CodeTabs>

## Kontenstruktur

Jedes
[`Account`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L48-L60)
hat eine maximale Größe von
[10MiB](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/system_instruction.rs#L85)
und enthält folgende Informationen:

<WithMentions>

- [`lamports`](mention:lamports): Die Anzahl der Lamports im Konto
- [`data`](mention:data): Die Daten des Kontos
- [`owner`](mention:owner): Die ID des Programms, das das Konto besitzt
- [`executable`](mention:executable): Gibt an, ob das Konto ausführbaren
  Binärcode enthält
- [`rent_epoch`](mention:rent_epoch): Das veraltete Rent-Epoch-Feld

```rust title="Account"
pub struct Account {
    /// lamports in the account
    // !mention lamports
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    // !mention data
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    // !mention owner
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    // !mention executable
    pub executable: bool,
    /// the epoch at which this account will next owe rent
    // !mention rent_epoch
    pub rent_epoch: Epoch,
}
```

</WithMentions>

<ScrollyCoding>

## !!steps Lamports

Das Guthaben des Kontos in [lamports](/docs/references/terminology#lamport).

Jedes Konto muss ein Mindestguthaben an lamports haben, genannt
[rent](/docs/references/terminology#rent), das es ermöglicht, seine Daten
on-chain zu speichern. Rent ist proportional zur Größe des Kontos.

<Callout type="info">
  Obwohl dieses Guthaben als rent bezeichnet wird, funktioniert es eher wie eine
  Kaution, da das gesamte Guthaben zurückerstattet werden kann, wenn das Konto
  geschlossen wird. (Der Name "rent" stammt aus dem inzwischen veralteten rent
  epoch Feld.)
</Callout>

(Siehe die
[Mindestguthaben-Formel](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97)
und die entsprechenden
[Konstanten](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L47-L70).)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    // !focus
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    // !focus
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Daten

Dieses Feld wird üblicherweise als "Kontodaten" bezeichnet. Das `data` in diesem
Feld wird als beliebig betrachtet, da es jede beliebige Byte-Sequenz enthalten
kann. Jedes Programm definiert die Struktur der in diesem Feld gespeicherten
Daten.

- Program account: Dieses Feld enthält entweder ausführbaren Programmcode oder
  die Adresse eines [Programmdatenkontos](#program-data-accounts), das den
  ausführbaren Programmcode speichert.
- Data accounts: Dieses Feld speichert in der Regel Zustandsdaten, die gelesen
  werden sollen.

Das Lesen von Daten aus einem Solana-Konto umfasst zwei Schritte:

1. Abrufen des Kontos über seine [Adresse](#account-address)
2. Deserialisieren des `data`-Felds des Kontos von rohen Bytes in die
   entsprechende Datenstruktur, wie vom Programm definiert, das das Konto
   besitzt.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    // !focus
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    // !focus
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    // !focus
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    // !focus
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Eigentümer

Dieses Feld enthält die Programm-ID des Eigentümers des Kontos.

Jedes Solana-Konto hat ein [Programm](/docs/core/programs), das als sein
Besitzer festgelegt ist. Der Besitzer des Kontos ist das einzige Programm, das
das `data` des Kontos ändern oder Lamports abziehen kann, wie durch die
Anweisungen des Programms angegeben.

(Im Fall eines program account ist der Eigentümer sein
[Loader-Programm](https://solana.com/docs/core/programs#loader-programs).)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    // !focus
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    // !focus
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Ausführbar

Dieses Feld gibt an, ob ein Konto ein [program account](#program-accounts) oder
ein [data account](#data-accounts) ist

- Wenn `true`: Das Konto ist ein Programmkonto
- Wenn `false`: Das Konto ist ein Datenkonto

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    // !focus
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    // !focus
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Rent epoch

**Das `rent_epoch`-Feld ist veraltet.**

In der Vergangenheit verfolgte dieses Feld, wann ein Konto rent zahlen müsste.
Allerdings wurde dieser rent-Erfassungsmechanismus inzwischen verworfen.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    // !focus
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    // !focus
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

</ScrollyCoding>

## Arten von Konten

Es gibt zwei grundlegende Kategorien, in die Konten fallen:

- [Program accounts](#program-accounts): Konten, die ausführbaren Code enthalten
- [Data accounts](#data-accounts): Konten, die keinen ausführbaren Code
  enthalten

Diese Trennung von Programmcode und Programmzustand ist ein Schlüsselmerkmal von
Solanas Kontenmodell. (Ähnlich wie bei Betriebssystemen, die typischerweise
separate Dateien für Programme und ihre Daten haben.)

### Program accounts

Jedes Programm wird von einem
[Loader-Programm](/docs/core/programs#loader-programs) verwaltet, das zum
Deployment und zur Verwaltung des Kontos verwendet wird. Wenn ein neues
[Programm](/docs/core/programs) bereitgestellt wird, wird ein Konto erstellt, um
seinen [ausführbaren](#executable) Code zu speichern. Dies wird als program
account bezeichnet. (Der Einfachheit halber können Sie das program account als
das Programm selbst betrachten.)

Im folgenden Diagramm sehen Sie, wie ein Loader-Programm verwendet wird, um ein
Programm-Konto bereitzustellen. Das `data` des Programm-Kontos enthält den
ausführbaren Programmcode.

![Diagramm eines program account, seiner 4 Komponenten und seines Loader-Programms.](/assets/docs/core/accounts/program-account-simple.svg)

#### Program data accounts

Programme, die mit loader-v3 bereitgestellt werden, enthalten keinen
Programmcode in ihrem `data`-Feld. Stattdessen verweist ihr `data` auf ein
separates **Programmdaten-Konto**, das den Programmcode enthält. (Siehe Diagramm
unten.)

![Ein program account mit Daten. Die Daten verweisen auf ein separates program data account](/assets/docs/core/accounts/program-account-expanded.svg)

<Callout>
  Während des Programm-Deployments oder Upgrades werden Buffer-Accounts
  verwendet, um den Upload vorübergehend zu speichern.
</Callout>

Das folgende Beispiel ruft das Token Program-Konto ab. Beachten Sie, dass das
`executable`-Feld auf `true` gesetzt ist, was anzeigt, dass das Konto ein
Programm ist.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc("https://api.mainnet.solana.com");

const programId = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address;

const accountInfo = await rpc
  .getAccountInfo(programId, { encoding: "base64" })
  .send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Connection, PublicKey } from "@solana/web3.js";

const connection = new Connection(
  "https://api.mainnet.solana.com",
  "confirmed"
);

const programId = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

const accountInfo = await connection.getAccountInfo(programId);
// !collapse(1:17) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::pubkey;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let program_id = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let account_info = connection.get_account(&program_id).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

### Datenkonten

Datenkonten enthalten keinen ausführbaren Code. Stattdessen speichern sie
Informationen.

#### Programmzustandskonto

Programme verwenden Datenkonten, um ihren Zustand zu verwalten. Dazu müssen sie
zunächst ein neues Datenkonto erstellen. Der Prozess der Erstellung eines
Programmzustandskontos wird oft abstrahiert, aber es ist hilfreich, den zugrunde
liegenden Prozess zu verstehen.

Um seinen Zustand zu verwalten, muss ein neues Programm:

1. Das [System Program](/docs/core/programs#the-system-program) aufrufen, um ein
   Konto zu erstellen. (Das System Program überträgt dann den Besitz an das neue
   Programm.)
2. Die Kontodaten initialisieren, wie durch seine
   [Anweisungen](/docs/core/instructions) definiert.

![Diagramm eines Datenkontos, das einem Programmkonto gehört](/assets/docs/core/accounts/data-account.svg)

Das folgende Beispiel erstellt und ruft ein Token Mint-Konto ab, das dem Token
2022-Programm gehört.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  fetchMint
} from "@solana-program/token-2022";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer
const feePayer = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Instruction to create new account for mint (token 2022 program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token 2022 program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address
});

const instructions = [createAccountInstruction, initializeMintInstruction];

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }), // Create transaction message
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx), // Set fee payer
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set transaction blockhash
  (tx) => appendTransactionMessageInstructions(instructions, tx) // Append instructions
);

// Sign transaction message with required signers (fee payer and mint keypair)
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Mint Address:", mint.address);
console.log("Transaction Signature:", transactionSignature);

const accountInfo = await rpc.getAccountInfo(mint.address).send();
console.log(accountInfo);

const mintAccount = await fetchMint(rpc, mint.address);
console.log(mintAccount);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  TOKEN_2022_PROGRAM_ID,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const recentBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: recentBlockhash.blockhash,
  lastValidBlockHeight: recentBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Generate keypair to use as address of mint
const mint = Keypair.generate();

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: await getMinimumBalanceForRentExemptMint(connection),
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);

const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint] // Signers
);

console.log("Mint Address: ", mint.publicKey.toBase58());
console.log("Transaction Signature: ", transactionSignature);

const accountInfo = await connection.getAccountInfo(mint.publicKey);

// !collapse(1:16) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);

const mintAccount = await getMint(
  connection,
  mint.publicKey,
  "confirmed",
  TOKEN_2022_PROGRAM_ID
);
console.log(mintAccount);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    program_pack::Pack,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_token_2022_interface::{
    id as token_2022_program_id, instruction::initialize_mint, state::Mint,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let recent_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    let space = Mint::LEN;
    let rent = client.get_minimum_balance_for_rent_exemption(space).await?;

    // Create account instruction
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),      // fee payer
        &mint.pubkey(),           // mint address
        rent,                     // rent
        space as u64,             // space
        &token_2022_program_id(), // program id
    );

    // Initialize mint instruction
    let initialize_mint_instruction = initialize_mint(
        &token_2022_program_id(),
        &mint.pubkey(),            // mint address
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        9,                         // decimals
    )?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        recent_blockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    let account_info = client.get_account(&mint.pubkey()).await?;
    println!("{:#?}", account_info);

    let mint_account = Mint::unpack(&account_info.data)?;
    println!("{:#?}", mint_account);

    Ok(())
}
```

</CodeTabs>

#### Systemkonten

Nicht alle Konten erhalten nach der Erstellung durch das System Program einen
neuen Besitzer. Konten, die dem System Program gehören, werden als Systemkonten
bezeichnet. Alle Wallet-Konten sind Systemkonten, was ihnen ermöglicht,
[Fee](docs/core/fees) zu bezahlen.

![Eine Wallet im Besitz des System Program mit 1.000.000 Lamports](/assets/docs/core/accounts/system-account.svg)

Wenn SOL zum ersten Mal an eine neue Adresse gesendet wird, wird an dieser
Adresse ein Konto erstellt, das dem System Program gehört.

Im folgenden Beispiel wird ein neues Keypair generiert und mit SOL finanziert.
Nach Ausführung des Codes können Sie sehen, dass die Adresse des `owner` des
Kontos `11111111111111111111111111111111` ist (das
[System Program](/docs/core/programs#the-system-program)).

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  generateKeyPairSigner,
  lamports
} from "@solana/kit";

// Create a connection to Solana cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate a new keypair
const keypair = await generateKeyPairSigner();
console.log(`Public Key: ${keypair.address}`);

// Funding an address with SOL automatically creates an account
const signature = await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: keypair.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

const accountInfo = await rpc.getAccountInfo(keypair.address).send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";

// Generate a new keypair
const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);

// Create a connection to the Solana cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Funding an address with SOL automatically creates an account
const signature = await connection.requestAirdrop(
  keypair.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const accountInfo = await connection.getAccountInfo(keypair.publicKey);
console.log(JSON.stringify(accountInfo, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signer::{keypair::Keypair, Signer},
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate a new keypair
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());

    // Create a connection to Solana cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Funding an address with SOL automatically creates an account
    let signature = connection
        .request_airdrop(&keypair.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = connection.confirm_transaction(&signature).await?;
        if confirmed {
            break;
        }
    }

    let account_info = connection.get_account(&keypair.pubkey()).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

#### Sysvar-Konten

Sysvar-Konten existieren an vordefinierten Adressen und bieten Zugriff auf
Cluster-Zustandsdaten. Sie werden dynamisch mit Daten über den Netzwerk-Cluster
aktualisiert. Siehe die vollständige Liste der
[Sysvar-Konten](https://docs.anza.xyz/runtime/sysvars).

Das folgende Beispiel ruft Daten vom Sysvar-Clock-Konto ab und deserialisiert
sie.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { createSolanaRpc } from "@solana/kit";
import { fetchSysvarClock, SYSVAR_CLOCK_ADDRESS } from "@solana/sysvars";

const rpc = createSolanaRpc("https://api.mainnet.solana.com");

const accountInfo = await rpc
  .getAccountInfo(SYSVAR_CLOCK_ADDRESS, { encoding: "base64" })
  .send();
console.log(accountInfo);

// Automatically fetch and deserialize the account data
const clock = await fetchSysvarClock(rpc);
console.log(clock);
```

```ts !! title="Legacy"
import { Connection, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getSysvarClockCodec } from "@solana/sysvars";

const connection = new Connection(
  "https://api.mainnet.solana.com",
  "confirmed"
);

const accountInfo = await connection.getAccountInfo(SYSVAR_CLOCK_PUBKEY);

// Deserialize the account data
const decodedClock = getSysvarClockCodec().decode(
  new Uint8Array(accountInfo?.data ?? [])
);
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
console.log(decodedClock);
```

```rs !! title="Rust"
use anyhow::Result;
use bincode::deserialize;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::sysvar::{self, clock::Clock};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let account = connection.get_account(&sysvar::clock::ID).await?;
    // Deserialize the account data
    let clock: Clock = deserialize(&account.data)?;

    println!("{:#?}", account);
    println!("{:#?}", clock);

    Ok(())
}
```

</CodeTabs>
