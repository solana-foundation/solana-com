---
title: Transaktionsgebühren
description:
  Erfahren Sie mehr über Solanas Transaktionsgebühren, einschließlich der Basis-
  und Prioritätsgebühren, wie diese angewendet werden und Best Practices für die
  Verwaltung von Compute Units in Ihren Transaktionen.
---

Jede Solana-Transaktion erfordert eine Transaktionsgebühr, die in SOL bezahlt
wird. Transaktionsgebühren werden in zwei Teile aufgeteilt: die Basisgebühr und
die Priorisierungsgebühr. Die Basisgebühr entschädigt Validatoren für die
Verarbeitung der Transaktion. Die Priorisierungsgebühr ist eine optionale
Gebühr, um die Chance zu erhöhen, dass der aktuelle Leader Ihre Transaktion
verarbeitet.

## Basisgebühr

Jede Transaktion kostet 5000 [Lamports](/docs/references/terminology#lamport)
pro enthaltener Signatur. Diese Gebühr wird vom ersten Signer der Transaktion
bezahlt. Nur Konten, die dem System Program gehören, können Transaktionsgebühren
bezahlen. Die Basisgebühr wird wie folgt aufgeteilt:

- **50% verbrannt:** Die Hälfte wird
  [verbrannt](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (aus dem zirkulierenden SOL-Angebot entfernt).
- **50% verteilt:** Die Hälfte wird
  [an den Validator gezahlt](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62),
  der die Transaktion verarbeitet hat.

## Priorisierungsgebühr

Eine
[Priorisierungsgebühr](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
ist eine optionale Gebühr, die verwendet wird, um die Chance zu erhöhen, dass
der aktuelle Leader (Validator) Ihre Transaktion verarbeitet. Der Validator
erhält
[100% der priority fee](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Priorisierungsgebühren können durch Anpassung des
[Compute Unit](/docs/references/terminology#compute-units) (CU) Preises und
CU-Limits der Transaktion festgelegt werden. (Siehe den
[How to Use Priority Fees Guide](/developers/guides/advanced/how-to-use-priority-fees)
für weitere Details zu Priorisierungsgebühren.)

Die Priorisierungsgebühr wird wie folgt berechnet:

```text title="Prioritization fee formula"
Prioritization fee = CU limit * CU price
```

Die Priorisierungsgebühr wird verwendet, um die
[Priorität Ihrer Transaktion](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646)
im Verhältnis zu anderen Transaktionen zu bestimmen. Sie wird mit der folgenden
Formel berechnet:

```text title="Transaction priority formula"
Priority = (Prioritization fee + Base fee) / (1 + CU limit + Signature CUs + Write lock CUs)
```

#### Compute Unit Limit

[Standardmäßig](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197)
werden jeder Instruktion
[200.000 CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
und jeder Transaktion
[1,4 Millionen CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14)
zugewiesen. Sie können diese Standardwerte ändern, indem Sie eine
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
Instruktion in Ihre Transaktion einfügen.

Um das passende CU-Limit für Ihre Transaktion zu berechnen, empfehlen wir die
folgenden Schritte:

1. Schätzen Sie die erforderlichen CU-Einheiten, indem Sie die Transaktion
   [simulieren](/developers/guides/advanced/how-to-request-optimal-compute)
2. Fügen Sie einen Sicherheitspuffer von 10% zu dieser Schätzung hinzu

<Callout type="warn">
  Die priority fee wird durch das angeforderte Compute-Unit-Limit der
  Transaktion bestimmt, *nicht* durch die tatsächlich verwendete Anzahl an
  Compute-Units. Wenn Sie ein zu hohes Compute-Unit-Limit festlegen oder den
  Standardwert verwenden, zahlen Sie möglicherweise für ungenutzte
  Compute-Units.
</Callout>

#### Compute-Unit-Preis

Der Compute-Unit-Preis ist ein optionaler Betrag in
[Micro-Lamports](/docs/references/terminology#micro-lamports), der für jede
angeforderte CU gezahlt wird. Sie können sich den CU-Preis als Trinkgeld
vorstellen, um den Validator zu ermutigen, Ihre Transaktion zu priorisieren. Um
den CU-Preis festzulegen, fügen Sie eine
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)-Anweisung
in Ihre Transaktion ein.

<Callout>
  Der Standard-CU-Preis beträgt 0, was bedeutet, dass auch die Standard-priority
  fee 0 ist.
</Callout>

Für Hilfe bei der Bestimmung des besten CU-Preises für Ihre Transaktion siehe
die Echtzeit-CU-Preis-Empfehlung in der unten stehenden Tabelle.

| Anbieter                                | Priority-Fee-API                                                                  |
| --------------------------------------- | --------------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [Dokumentation](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Dokumentation](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Dokumentation](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Beispiel

Die folgenden Beispiele zeigen, wie Sie das CU-Limit und den CU-Preis für eine
Transaktion mit Solana-SDKs festlegen.

| SDK                            | Quellcode-Referenz                                                                                                             |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
