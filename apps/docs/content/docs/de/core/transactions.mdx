---
title: Transaktionen
description:
  Erfahren Sie mehr über Solana-Transaktionen – die grundlegenden Bausteine für
  die Interaktion mit der Solana-Blockchain. Verstehen Sie Transaktionsstruktur
  und Anweisungszusammensetzung mit praktischen Beispielen.
---

Um mit dem Solana-Netzwerk zu interagieren, müssen Sie eine Transaktion senden.
Sie können sich eine Transaktion wie einen Umschlag vorstellen, der mehrere
Formulare enthält. Jedes Formular ist eine Anweisung, die dem Netzwerk mitteilt,
was zu tun ist. Das Senden der Transaktion ist wie das Versenden des Umschlags,
damit die Formulare verarbeitet werden können.

Das folgende Beispiel zeigt eine vereinfachte Version von zwei Transaktionen.
Wenn die erste Transaktion verarbeitet wird, führt sie eine einzelne Anweisung
aus. Wenn die zweite Transaktion verarbeitet wird, führt sie drei Anweisungen
**in sequentieller Reihenfolge** aus: zuerst Anweisung 1, gefolgt von Anweisung
2, gefolgt von Anweisung 3.

<Callout type="warn">
  Transaktionen sind **atomar**: Wenn eine einzelne Anweisung fehlschlägt, wird
  die gesamte Transaktion fehlschlagen und es werden keine Änderungen
  vorgenommen.
</Callout>

![Ein vereinfachtes Diagramm, das zwei Transaktionen zeigt](/assets/docs/core/transactions/transaction-simple.svg)

Eine
[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
besteht aus folgenden Informationen:

<WithMentions>

- [`signatures`](mention:signatures): Ein Array von [Signaturen](#signatures)
- [`message`](mention:message): Transaktionsinformationen, einschließlich der
  Liste der zu verarbeitenden Anweisungen

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![Diagramm, das die zwei Teile einer Transaktion zeigt](/assets/docs/core/transactions/tx_format.png)

Transaktionen haben eine Gesamtgrößenbeschränkung von
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
Bytes. Diese Beschränkung umfasst sowohl das [`signatures`](#signatures)-Array
als auch die [`message`](#message)-Struktur.

<Callout>
  Dieses Limit wurde entwickelt, um Paketfragmentierung in typischer
  Internet-Infrastruktur zu vermeiden. Obwohl IPv6 MTUs größer als 9000 Bytes
  unterstützt, verwenden die meisten Internet-Router eine Standard-MTU von 1500
  Bytes (Standard-Ethernet). Um sicherzustellen, dass Transaktionen ohne
  Fragmentierung in ein einzelnes Paket passen, verwendet Solana 1280 Bytes (die
  für IPv6 erforderliche Mindest-MTU) minus 48 Bytes für Netzwerk-Header (40
  Bytes IPv6 + 8 Bytes Fragment/UDP-Header), was zu dem Transaktionsgrößenlimit
  von 1232 Bytes führt.
</Callout>

![Diagramm, das das Transaktionsformat und Größenbegrenzungen zeigt](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## Signaturen

Das `signatures`-Array der Transaktion enthält `Signature`-Strukturen. Jede
[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
ist 64 Bytes groß und wird durch Signieren der `Message` der Transaktion mit dem
privaten Schlüssel des Kontos erstellt. Für jedes
[Signer-Konto](#account-addresses), das in einer der Anweisungen der Transaktion
enthalten ist, muss eine Signatur bereitgestellt werden.

Die erste Signatur gehört zu dem Konto, das die
[Basisgebühr](/docs/core/fees#base-fee) der Transaktion bezahlt, und ist die
Transaktionssignatur. Die Transaktionssignatur kann verwendet werden, um die
Details der Transaktion im Netzwerk nachzuschlagen.

## Nachricht

Die `message` der Transaktion ist eine
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)-Struktur,
die folgende Informationen enthält:

<WithMentions>

- [`header`](mention:message-header): Der Nachrichten-[Header](#header)
- [`account_keys`](mention:account-addresses): Ein Array von
  [Kontoadressen](#account-addresses), die für die Anweisungen der Transaktion
  erforderlich sind
- [`recent_blockhash`](mention:recent-blockhash): Ein
  [Blockhash](#recent-blockhash), der als Zeitstempel für die Transaktion dient
- [`instructions`](mention:instructions): Ein Array von
  [Anweisungen](#instructions)

<Callout>
  Um Platz zu sparen, speichert die Transaktion nicht die Berechtigungen für
  jedes Konto einzeln. Stattdessen werden die Kontoberechtigungen mithilfe des
  `header` und der `account_keys` bestimmt.
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### Header

<WithMentions>

Der `header` der Nachricht ist eine
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)-Struktur.
Er enthält folgende Informationen:

- [`num_required_signatures`](mention:num_required_signatures): Die Gesamtzahl
  der für die Transaktion erforderlichen Signaturen
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts): Die
  Gesamtzahl der schreibgeschützten Konten, die Signaturen erfordern
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts):
  Die Gesamtzahl der schreibgeschützten Konten, die keine Signaturen erfordern

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![Diagramm, das die drei Teile des Nachrichtenheaders zeigt](/assets/docs/core/transactions/message_header.png)

### Kontoadressen

Das
[`account_keys`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
der Nachricht ist ein Array von Kontoadressen, das im
[Compact-Array-Format](/docs/references/terminology#compact-array-format)
gesendet wird. Das Präfix des Arrays gibt dessen Länge an. Jedes Element im
Array ist ein öffentlicher Schlüssel, der auf ein Konto verweist, das von seinen
Anweisungen verwendet wird. Das `accounts_keys`-Array muss vollständig und
streng geordnet sein, wie folgt:

1. Signer + Beschreibbar
2. Signer + Schreibgeschützt
3. Kein Signer + Beschreibbar
4. Kein Signer + Schreibgeschützt

<Callout>
  Die strikte Reihenfolge ermöglicht es, das `account_keys`-Array mit den
  Informationen im [`header`](#header) der Nachricht zu kombinieren, um die
  Berechtigungen für jedes Konto zu bestimmen.
</Callout>

![Diagramm, das die Reihenfolge des Kontenadressenfeldes zeigt](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Aktueller Blockhash

Der `recent_blockhash` der Nachricht ist ein Hash-Wert, der als
Transaktions-Zeitstempel fungiert und doppelte Transaktionen verhindert. Ein
Blockhash läuft nach
[150 Blöcken](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134)
ab. (Entspricht einer Minute – unter der Annahme, dass jeder Block 400 ms
dauert.) Nach Ablauf des Blocks ist die Transaktion abgelaufen und kann nicht
mehr verarbeitet werden.

<Callout>
  Die RPC-Methode [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash)
  ermöglicht es Ihnen, den aktuellen Blockhash und die letzte Blockhöhe
  abzurufen, bei der der Blockhash gültig sein wird.
</Callout>

### Anweisungen

Die
[`instructions`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
der Nachricht ist ein Array aller zu verarbeitenden Anweisungen, das im
[Compact-Array-Format](/docs/references/terminology#compact-array-format)
gesendet wird. Das Präfix des Arrays gibt dessen Länge an. Jedes Element im
Array ist eine
[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
Struktur und enthält folgende Informationen:

<WithMentions>

1. [`program_id_index`](mention:program-id-index): Ein Index, der auf eine
   Adresse im [`account_keys`](#account-addresses)-Array verweist. Dieser Wert
   gibt die Adresse des Programms an, das die Anweisung verarbeitet.
2. [`accounts`](mention:account-indexes): Ein Array von Indizes, die auf
   Adressen im `account_keys`-Array verweisen. Jeder Index verweist auf die
   Adresse eines Kontos, das für diese Anweisung erforderlich ist.
3. [`data`](mention:instruction-data): Ein Byte-Array, das angibt, welche
   Anweisung auf dem Programm aufgerufen werden soll. Es enthält auch alle
   zusätzlichen Daten, die von der Anweisung benötigt werden. (Zum Beispiel
   Funktionsargumente)

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Kompaktes Array von Anweisungen](/assets/docs/core/transactions/compact_array_of_ixs.png)

## Beispiel einer Transaktionsstruktur

Das folgende Beispiel zeigt die Struktur einer Transaktion, die eine einzelne
SOL-Überweisungsanweisung enthält.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
Der folgende Code zeigt die Ausgabe der vorherigen Codeausschnitte.
Das Format unterscheidet sich zwischen den SDKs,
aber beachte, dass jede Anweisung die gleichen erforderlichen Informationen enthält.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

Nachdem eine Transaktion übermittelt wurde, können Sie ihre Details mithilfe der
Transaktionssignatur und der [getTransaction](/docs/rpc/http/gettransaction)
RPC-Methode abrufen. Die Antwort wird eine Struktur ähnlich dem folgenden
Ausschnitt haben.

<Callout>
  Sie können die Transaktion auch über den [Solana
  Explorer](https://explorer.solana.com) finden.
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
