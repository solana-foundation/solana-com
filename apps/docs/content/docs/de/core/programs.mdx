---
title: Programme
description:
  Erfahren Sie mehr über Solana-Programme (Smart Contracts) und wie Sie diese
  mit Rust oder dem Anchor-Framework entwickeln. Verstehen Sie Deployment,
  Upgrades und Verifizierung von Programmen im Solana-Netzwerk.
h1: Programme
---

Auf Solana wird ein Smart Contract als Programm bezeichnet. Ein Programm ist ein
zustandsloses [Konten](/docs/core/accounts#program-account), das ausführbaren
Code enthält. Dieser Code ist in Funktionen organisiert, die Anweisungen genannt
werden. Benutzer interagieren mit einem Programm, indem sie eine
[Transaktion](/docs/core/transactions) senden, die eine oder mehrere
[ Anweisungen](/docs/core/instructions) enthält. Eine Transaktion kann
Anweisungen aus mehreren Programmen enthalten.

Wenn ein Programm bereitgestellt wird, verwendet Solana
[LLVM](https://llvm.org/), um es in ein ausführbares und verlinkbares Format
([ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)) zu
kompilieren. Die ELF-Datei enthält die Binärdatei des Programms im Solana
Bytecode Format (sBPF) und wird on-chain in einem ausführbaren Konten
gespeichert.

<Callout>
  sBPF ist Solanas angepasste Version des
  [eBPF](https://en.wikipedia.org/wiki/EBPF)-Bytecodes.
</Callout>

## Programme schreiben

Die Mehrheit der Programme wird in
[Rust](https://rust-book.cs.brown.edu/title-page.html) geschrieben, mit zwei
gängigen Entwicklungsansätzen:

- [Anchor](https://www.anchor-lang.com/docs): Anchor ist ein Framework, das für
  schnelle und einfache Solana-Entwicklung konzipiert wurde. Es verwendet
  [Rust-Makros](https://doc.rust-lang.org/book/ch20-05-macros.html), um
  Boilerplate-Code zu reduzieren – ideal für Anfänger.
- [Native Rust](/docs/programs/rust): Schreiben Sie Programme in Rust, ohne
  Frameworks zu nutzen. Dieser Ansatz bietet mehr Flexibilität, geht aber mit
  erhöhter Komplexität einher.

## Programme aktualisieren

Um ein bestehendes Programm zu
[modifizieren](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L704),
muss ein Konten als
[Upgrade-Authority](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/lib.rs#L894)
festgelegt werden. (Typischerweise dasselbe Konten, das das Programm
ursprünglich [bereitgestellt hat](/docs/programs/deploying).) Wenn die
Upgrade-Authority widerrufen und auf `None` gesetzt wird, kann das Programm
nicht mehr aktualisiert werden.

## Programme verifizieren

Solana unterstützt [verifizierbare Builds](/docs/programs/verified-builds), die
es Benutzern ermöglichen zu überprüfen, ob der on-chain Code eines Programms mit
seinem öffentlichen Quellcode übereinstimmt. Das Anchor-Framework bietet
[integrierte Unterstützung](https://www.anchor-lang.com/docs/verifiable-builds)
für die Erstellung eines verifizierbaren Builds.

Um zu überprüfen, ob ein bestehendes Programm verifiziert ist, suchen Sie nach
seiner Programm-ID im
[Solana Explorer](https://explorer.solana.com/address/PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY).
Alternativ können Sie die
[Solana Verifiable Build CLI](https://github.com/Ellipsis-Labs/solana-verifiable-build)
von Ellipsis Labs verwenden, um On-Chain-Programme unabhängig zu verifizieren.

## Integrierte Programme

### Das System Program

Das System Program ist das einzige Konto, das neue Konten erstellen kann.
Standardmäßig gehören alle neuen Konten dem
[System Program](https://github.com/anza-xyz/agave/tree/v2.1.13/programs/system/src),
obwohl viele bei der Erstellung einem neuen Eigentümer zugewiesen werden. Das
System Program erfüllt die folgenden Hauptfunktionen:

| Funktion                                                                                                                              | Beschreibung                                                                                                                                                                                                                                                      |
| ------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Erstellung neuer Konten](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L146)                | Nur das System Program kann neue Konten erstellen.                                                                                                                                                                                                                |
| [Speicherplatzzuweisung](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L71)                  | Legt die Byte-Kapazität für das Datenfeld jedes Kontos fest.                                                                                                                                                                                                      |
| [Zuweisung der Programmeigentümerschaft](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L113) | Nachdem das System Program ein Konto erstellt hat, kann es den designierten Programmeigentümer einem anderen Programmkonto neu zuweisen. So übernehmen benutzerdefinierte Programme die Eigentümerschaft an neuen Konten, die vom System Program erstellt wurden. |
| [SOL übertragen](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L215)                         | Überträgt Lamports (SOL) von System-Konten auf andere Konten.                                                                                                                                                                                                     |

Die Adresse des System Program ist `11111111111111111111111111111111`.

### Loader-Programme

Jedes Programm gehört einem anderen – seinem Loader. Loader werden verwendet, um
Programme zu deployen, neu zu deployen, zu aktualisieren oder zu schließen. Sie
werden auch verwendet, um ein Programm zu finalisieren und die
Programmberechtigung zu übertragen.

<Callout>
  Loader-Programme werden manchmal als ‚BPF Loaders' bezeichnet.
</Callout>

Es gibt derzeit fünf Loader-Programme, wie in der folgenden Tabelle dargestellt.

| Loader | Programm-ID                                   | Hinweise                                                                                                                                       | Anweisungen-Link                                                                                                                               |
| ------ | --------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| native | `NativeLoader1111111111111111111111111111111` | Besitzt die anderen vier Loader                                                                                                                | —                                                                                                                                              |
| v1     | `BPFLoader1111111111111111111111111111111111` | Verwaltungsanweisungen sind deaktiviert, aber Programme werden weiterhin ausgeführt                                                            | —                                                                                                                                              |
| v2     | `BPFLoader2111111111111111111111111111111111` | Verwaltungsanweisungen sind deaktiviert, aber Programme werden weiterhin ausgeführt                                                            | [Anweisungen](https://docs.rs/solana-loader-v2-interface/latest/solana_loader_v2_interface/enum.LoaderInstruction.html)                        |
| v3     | `BPFLoaderUpgradeab1e11111111111111111111111` | Programme können nach dem Deployment aktualisiert werden. Die ausführbare Programmdatei wird in einem separaten Programmdatenkonto gespeichert | [Anweisungen](https://docs.rs/solana-loader-v3-interface/latest/solana_loader_v3_interface/instruction/enum.UpgradeableLoaderInstruction.html) |
| v4     | `LoaderV411111111111111111111111111111111111` | In Entwicklung (nicht veröffentlicht)                                                                                                          | [Anweisungen](https://docs.rs/solana-loader-v4-interface/latest/solana_loader_v4_interface/instruction/enum.LoaderV4Instruction.html)          |

Programme, die mit loader-v3 oder loader-v4 deployed wurden, können nach dem
Deployment modifizierbar sein, wie durch ihre Upgrade-Authority festgelegt.

<Callout>
  Wenn ein neues Programm deployed wird, wird standardmäßig die neueste
  Loader-Version verwendet.
</Callout>

### Vorkompilierte Programme

Zusätzlich zu den Loader-Programmen stellt Solana die folgenden vorkompilierten
Programme bereit.

#### Ed25519-Signatur verifizieren

Das ed25519-Programm wird verwendet, um eine oder mehrere ed25519-Signaturen zu
verifizieren.

| Programm         | Programm-ID                                   | Beschreibung                                                                                   | Anweisungen                                                                                    |
| ---------------- | --------------------------------------------- | ---------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| Ed25519-Programm | `Ed25519SigVerify111111111111111111111111111` | Verifiziert ed25519-Signaturen. Wenn eine Signatur fehlschlägt, wird ein Fehler zurückgegeben. | [Anweisungen](https://docs.rs/solana-ed25519-program/latest/solana_ed25519_program/index.html) |

Das ed25519-Programm verarbeitet eine Anweisung. Das erste `u8` der Anweisung
enthält die Anzahl der zu überprüfenden Signaturen, gefolgt von einem einzelnen
Byte Padding. Danach wird die folgende Struktur für jede zu überprüfende
Signatur serialisiert.

```rs title="Ed25519SignatureOffsets"
struct Ed25519SignatureOffsets {
    signature_offset: u16,             // offset to ed25519 signature of 64 bytes
    signature_instruction_index: u16,  // instruction index to find signature
    public_key_offset: u16,            // offset to public key of 32 bytes
    public_key_instruction_index: u16, // instruction index to find public key
    message_data_offset: u16,          // offset to start of message data
    message_data_size: u16,            // size of message data
    message_instruction_index: u16,    // index of instruction data to get message data
}
```

```txt title="Signature verification pseudocode"
process_instruction() {
    for i in 0..count {
        // i'th index values referenced:
        instructions = &transaction.message().instructions
        instruction_index = ed25519_signature_instruction_index != u16::MAX ? ed25519_signature_instruction_index : current_instruction;
        signature = instructions[instruction_index].data[ed25519_signature_offset..ed25519_signature_offset + 64]
        instruction_index = ed25519_pubkey_instruction_index != u16::MAX ? ed25519_pubkey_instruction_index : current_instruction;
        pubkey = instructions[instruction_index].data[ed25519_pubkey_offset..ed25519_pubkey_offset + 32]
        instruction_index = ed25519_message_instruction_index != u16::MAX ? ed25519_message_instruction_index : current_instruction;
        message = instructions[instruction_index].data[ed25519_message_data_offset..ed25519_message_data_offset + ed25519_message_data_size]
        if pubkey.verify(signature, message) != Success {
            return Error
        }
    }
    return Success
}
```

#### Secp256k1-Recovery verifizieren

Das secp256k1-Programm wird verwendet, um
secp256k1-Public-Key-Recovery-Operationen zu verifizieren.

| Programm           | Programm-ID                                   | Beschreibung                                                       | Anweisungen                                                                                        |
| ------------------ | --------------------------------------------- | ------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| Secp256k1-Programm | `KeccakSecp256k11111111111111111111111111111` | Verifiziert secp256k1-Public-Key-Recovery-Operationen (ecrecover). | [Anweisungen](https://docs.rs/solana-secp256k1-program/latest/solana_secp256k1_program/index.html) |

Das secp256k1-Programm verarbeitet eine Anweisung. Das erste Byte der Anweisung
enthält die Anzahl der zu überprüfenden öffentlichen Schlüssel. Danach wird die
folgende Struktur einmal für jeden öffentlichen Schlüssel erstellt, dann
serialisiert und zu den instruction data hinzugefügt.

```rs title="Secp256k1SignatureOffsets"
struct Secp256k1SignatureOffsets {
    secp_signature_offset: u16,            // offset to [signature,recovery_id] of 64+1 bytes
    secp_signature_instruction_index: u8,  // instruction index to find signature
    secp_pubkey_offset: u16,               // offset to ethereum_address pubkey of 20 bytes
    secp_pubkey_instruction_index: u8,     // instruction index to find pubkey
    secp_message_data_offset: u16,         // offset to start of message data
    secp_message_data_size: u16,           // size of message data
    secp_message_instruction_index: u8,    // instruction index to find message data
}
```

```txt title="Recovery verification pseudocode"
process_instruction() {
  for i in 0..count {
      // i'th index values referenced:
      instructions = &transaction.message().instructions
      signature = instructions[secp_signature_instruction_index].data[secp_signature_offset..secp_signature_offset + 64]
      recovery_id = instructions[secp_signature_instruction_index].data[secp_signature_offset + 64]
      ref_eth_pubkey = instructions[secp_pubkey_instruction_index].data[secp_pubkey_offset..secp_pubkey_offset + 20]
      message_hash = keccak256(instructions[secp_message_instruction_index].data[secp_message_data_offset..secp_message_data_offset + secp_message_data_size])
      pubkey = ecrecover(signature, recovery_id, message_hash)
      eth_pubkey = keccak256(pubkey[1..])[12..]
      if eth_pubkey != ref_eth_pubkey {
          return Error
      }
  }
  return Success
}
```

Dies ermöglicht dem Benutzer, beliebige instruction data in der Transaktion für
Signatur- und Nachrichtendaten anzugeben. Durch Angabe eines speziellen
instructions sysvar kann man auch Daten aus der Transaktion selbst empfangen.

Die Kosten der Transaktion werden anhand der Anzahl der zu verifizierenden
Signaturen multipliziert mit dem Signaturkosten-Verifizierungsmultiplikator
berechnet.

Das Secp256r1-Programm wird verwendet, um bis zu 8 Secp256r1-Signaturen zu
verifizieren.

| Programm           | Programm-ID                                   | Beschreibung                                                                                                                                                      | Anweisungen                                                                                      |
| ------------------ | --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| Secp256r1-Programm | `Secp256r1SigVerify1111111111111111111111111` | Verifiziert bis zu 8 secp256r1-Signaturen. Nimmt eine Signatur, einen öffentlichen Schlüssel und eine Nachricht. Gibt einen Fehler zurück, wenn eine fehlschlägt. | [Anweisungen](https://docs.rs/solana-secp256r1-program/latest/solana_secp256r1_program/all.html) |

Das secp256r1-Programm verarbeitet eine Anweisung. Das erste `u8` der Anweisung
enthält die Anzahl der zu überprüfenden Signaturen, gefolgt von einem einzelnen
Byte Padding. Danach wird für jede Signatur die folgende Struktur erstellt, dann
serialisiert und zu den instruction data hinzugefügt.

```rs title="Secp256r1SignatureOffsets"
struct Secp256r1SignatureOffsets {
    signature_offset: u16,             // offset to compact secp256r1 signature of 64 bytes
    signature_instruction_index: u16,  // instruction index to find signature
    public_key_offset: u16,            // offset to compressed public key of 33 bytes
    public_key_instruction_index: u16, // instruction index to find public key
    message_data_offset: u16,          // offset to start of message data
    message_data_size: u16,            // size of message data
    message_instruction_index: u16,    // index of instruction data to get message data
}

```

<Callout>
  Niedrige S-Werte werden für alle Signaturen erzwungen, um unbeabsichtigte
  Signaturveränderbarkeit zu vermeiden.
</Callout>

```txt title="Signature verification psuedocode"
process_instruction() {
    if data.len() < SIGNATURE_OFFSETS_START {
        return Error
    }

    num_signatures = data[0] as usize
    if num_signatures == 0 || num_signatures > 8 {
        return Error
    }

    expected_data_size = num_signatures * SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START
    if data.len() < expected_data_size {
        return Error
    }

    for i in 0..num_signatures {
        offsets = parse_signature_offsets(data, i)

        signature = get_data_slice(data, instruction_datas, offsets.signature_instruction_index, offsets.signature_offset, SIGNATURE_SERIALIZED_SIZE)

        if s > half_curve_order {
            return Error
        }

        pubkey = get_data_slice(data, instruction_datas, offsets.public_key_instruction_index, offsets.public_key_offset, COMPRESSED_PUBKEY_SERIALIZED_SIZE)

        message = get_data_slice(data, instruction_datas, offsets.message_instruction_index, offsets.message_data_offset, offsets.message_data_size)

        if !verify_signature(signature, pubkey, message) {
            return Error
        }
    }

    return Success
}
```

### Kernprogramme

Die Programme in der folgenden Liste bieten die Kernfunktionalität des
Netzwerks.

| Programm                 | Programm-ID                                   | Beschreibung                                                                                                                                                                                                                                                                                                                                                                                | Anweisungen                                                                                                                                           |
| ------------------------ | --------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| **System**               | `11111111111111111111111111111111`            | Erstellt neue Konten, weist Kontodaten zu, weist Konten besitzenden Programmen zu, überträgt Lamports von Konten im Besitz des System-Programms und zahlt Transaktionsgebühren                                                                                                                                                                                                              | [SystemInstruction](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html)                              |
| **Vote**                 | `Vote111111111111111111111111111111111111111` | Erstellt und verwaltet Konten, die den Abstimmungsstatus und Belohnungen von Validatoren verfolgen                                                                                                                                                                                                                                                                                          | [VoteInstruction](https://docs.rs/solana-vote-program/latest/solana_vote_program/vote_instruction/enum.VoteInstruction.html)                          |
| **Stake**                | `Stake11111111111111111111111111111111111111` | Erstellt und verwaltet Konten, die Stake und Belohnungen für Delegationen an Validatoren repräsentieren                                                                                                                                                                                                                                                                                     | [StakeInstruction](https://docs.rs/solana-sdk/latest/solana_sdk/stake/instruction/enum.StakeInstruction.html)                                         |
| **Config**               | `Config1111111111111111111111111111111111111` | Fügt Konfigurationsdaten zur Chain hinzu, gefolgt von der Liste öffentlicher Schlüssel, die diese ändern dürfen. Im Gegensatz zu anderen Programmen definiert das Config-Programm keine einzelnen Anweisungen. Es hat nur eine implizite Anweisung: "store". Seine instruction data sind eine Reihe von Schlüsseln, die den Zugriff auf das Konto und die darin gespeicherten Daten steuern | [ConfigInstruction](https://docs.rs/solana-config-program/latest/solana_config_program/config_instruction/index.html)                                 |
| **Compute Budget**       | `ComputeBudget111111111111111111111111111111` | Legt Compute-Unit-Limits und Preise für Transaktionen fest, sodass Benutzer Compute-Ressourcen und Priorisierungsgebühren kontrollieren können                                                                                                                                                                                                                                              | [ComputeBudgetInstruction](https://docs.rs/solana-compute-budget-interface/latest/solana_compute_budget_interface/enum.ComputeBudgetInstruction.html) |
| **Address Lookup Table** | `AddressLookupTab1e1111111111111111111111111` | Verwaltet Address-Lookup-Tabellen, die es Transaktionen ermöglichen, auf mehr Konten zu verweisen, als sonst in die Kontenliste der Transaktion passen würden                                                                                                                                                                                                                               | [ProgramInstruction](https://docs.rs/solana-sdk/latest/solana_sdk/address_lookup_table/instruction/enum.ProgramInstruction.html)                      |
| **ZK ElGamal Proof**     | `ZkE1Gama1Proof11111111111111111111111111111` | Bietet Zero-Knowledge-Proof-Verifizierung für ElGamal-verschlüsselte Daten                                                                                                                                                                                                                                                                                                                  | —                                                                                                                                                     |
