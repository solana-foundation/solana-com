---
title: Batch-Zahlungen
description:
  Erfahren Sie, wie Sie mehrere Empfänger in einer einzigen Transaktion bezahlen
  können.
---

Eine Solana-Transaktion ist ein Container, der eine oder mehrere Anweisungen
enthält. Jede Anweisung ist eine Operation – Token übertragen, ein Konto
erstellen, ein Programm aufrufen. Das Netzwerk führt alle Anweisungen in einer
Transaktion sequenziell und atomisch aus: Entweder gelingt jede Anweisung, oder
die gesamte Transaktion schlägt fehl und wird zurückgesetzt.

Das bedeutet, dass Sie mehrere Überweisungen in eine einzige Transaktion packen
können. Anstatt drei separate Transaktionen zu senden, um drei Empfänger zu
bezahlen, senden Sie eine Transaktion mit drei Überweisungsanweisungen. Das ist
schneller (eine Bestätigung anstatt drei) und günstiger (eine Grundgebühr
anstatt drei). Hier ist ein anschauliches Beispiel dafür, wie Zahlungen (in
diesem Bild als „Drops" bezeichnet) in einer einzigen Transaktion gebündelt
werden und mehrere Transaktionen gesendet werden, um den größeren Batch zu
verarbeiten.

![Batch-Zahlungen-Diagramm](/assets/docs/payments/qn-bulk-send.png)

_Quelle:
[QuickNode - How to Send Bulk Transactions on Solana](https://www.quicknode.com/guides/solana-development/transactions/how-to-send-bulk-transactions-on-solana)_

Weitere Informationen zu Transaktionen und Anweisungen finden Sie in den
Leitfäden [Transaktionen](/docs/core/transactions) und
[Anweisungen](/docs/core/instructions).

Die folgende Anleitung zeigt, wie Sie mehrere Überweisungsanweisungen in eine
einzige Transaktion für Batch-Zahlungen laden.

## Anweisungen in einer einzigen Transaktion bündeln

Eine Solana-Transaktion kann mehrere Überweisungen an verschiedene Empfänger
enthalten. Sie signieren einmal, zahlen eine Transaktionsgebühr, und alle
Überweisungen werden zusammen abgewickelt. Wenn eine Überweisung fehlschlägt,
wird die gesamte Transaktion abgelehnt.

<Callout>
  Siehe [Wie Zahlungen auf Solana
  funktionieren](/docs/payments/how-payments-work) für grundlegende
  Zahlungskonzepte.
</Callout>

Das Bündeln mehrerer Überweisungen erfordert das separate Erstellen jeder
Anweisung und anschließend das Kombinieren in einer einzigen Transaktion.

Die folgenden Schritte zeigen den grundlegenden Ablauf. Siehe die [Demo](#demo)
für vollständigen ausführbaren Code.

<ScrollyCoding>

## !!steps Token-Konten ableiten

Leiten Sie zunächst die Adressen der Associated Token Accounts (ATA) für den
Absender und jeden Empfänger ab. ATAs sind deterministische Adressen, die auf
der Wallet und dem Mint basieren.

<CodePlaceholder title="Batch-Zahlungen" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});
```

## !!steps Transfer-Anweisungen erstellen

Erstellen Sie für jeden Empfänger eine separate Transfer-Anweisung. Jede
Anweisung gibt Folgendes an:

- Adresse des Quell-Token-Kontos
- Adresse des Ziel-Token-Kontos
- Autorisierung (Adresse des Eigentümers des Quell-Token-Kontos)
- Betrag in Basiseinheiten (angepasst an die Dezimalstellen des Mints)

<CodePlaceholder title="Batch-Zahlungen" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !focus(1:12)
const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});
```

## !!steps Als einzelne Transaktion senden

Fügen Sie alle Transfer-Anweisungen in eine einzige Transaktion ein. Dadurch
werden alle Transfers atomar ausgeführt – entweder alle Transfers sind
erfolgreich oder die gesamte Transaktion schlägt fehl.

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});

// !focus(1:5)
const signature = await client.transaction.prepareAndSend({
  authority: sender,
  // !mark
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});
```

## !!steps Guthaben überprüfen

Überprüfen Sie nach dem Batch-Transfer die Token-Guthaben aller Beteiligten
mithilfe des `splToken`-Helpers.

<CodePlaceholder title="Batch-Zahlungen" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});

const signature = await client.transaction.prepareAndSend({
  authority: sender,
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});

// !focus(1:8)
const splToken = client.splToken({
  mint: mint.address,
  tokenProgram: "auto"
});

const senderBalance = await splToken.fetchBalance(sender.address);
const recipient1Balance = await splToken.fetchBalance(recipient1.address);
const recipient2Balance = await splToken.fetchBalance(recipient2.address);
```

</ScrollyCoding>

### Demo

<CodeTabs flags="r">

```ts !! title="Demo"
// !collapse(1:14) collapsed
// Click ">" icon on left to expand demo imports
import { createClient, lamports } from "@solana/client";
import { generateKeypair } from "@solana/client/server";
import type { ServerKeypair } from "@solana/client/server";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getCreateAssociatedTokenInstructionAsync,
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  findAssociatedTokenPda,
  getMintToInstruction,
  getTransferInstruction
} from "@solana-program/token-2022";

// Generate keypairs for sender and two recipients
const sender = (await generateKeypair()).signer;
const recipient1 = (await generateKeypair()).signer;
const recipient2 = (await generateKeypair()).signer;

console.log("Sender Address:", sender.address);
console.log("Recipient 1 Address:", recipient1.address);
console.log("Recipient 2 Address:", recipient2.address);

// Demo Setup: Create client, mint account, token accounts, and fund with initial tokens
const { client, mint } = await demoSetup(sender, recipient1, recipient2);

console.log("\nMint Address:", mint.address);

// Derive the Associated Token Accounts addresses (ATAs) for sender and recipients
// !mark(1:5)
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !mark(1:5)
const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !mark(1:5)
const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

console.log("Sender Token Account:", senderAta.toString());
console.log("Recipient 1 Token Account:", recipient1Ata.toString());
console.log("Recipient 2 Token Account:", recipient2Ata.toString());

// =============================================================================
// Batch Token Payment Demo
// =============================================================================

// Create instructions to transfer tokens from sender to both recipients
// Transferring 250,000 base units = 0.25 tokens (with 6 decimals) to each
// !mark(1:6)
const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n // 0.25 tokens
});

// !mark(1:6)
const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n // 0.25 tokens
});

// Prepare and send both transfers in a single transaction using @solana/client
const signature = await client.transaction.prepareAndSend({
  authority: sender,
  // !mark
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});

console.log("\n=== Batch Token Payment Complete ===");
console.log("Transaction Signature:", signature.toString());

// Fetch final token account balances using @solana/client SPL token helper
const splToken = client.splToken({
  mint: mint.address,
  tokenProgram: "auto"
});

const senderBalance = await splToken.fetchBalance(sender.address);
const recipient1Balance = await splToken.fetchBalance(recipient1.address);
const recipient2Balance = await splToken.fetchBalance(recipient2.address);

console.log("\nSender Token Account Balance:", senderBalance);
console.log("Recipient 1 Token Account Balance:", recipient1Balance);
console.log("Recipient 2 Token Account Balance:", recipient2Balance);

// =============================================================================
// Demo Setup Helper Function
// =============================================================================
// !collapse(1:1000) collapsed

/**
 * Sets up for a batch token transfer demo:
 * - Creates @solana/client instance
 * - Airdrops SOL to sender for transaction fees
 * - Generates mint keypair and creates/initializes mint account
 * - Creates associated token accounts for sender and both recipients
 * - Mints initial tokens to sender
 *
 * @param sender - The sender's keypair (will be funded and used as mint authority)
 * @param recipient1 - The first recipient's keypair
 * @param recipient2 - The second recipient's keypair
 * @returns Returns client instance and mint address
 */
async function demoSetup(
  sender: ServerKeypair["signer"],
  recipient1: ServerKeypair["signer"],
  recipient2: ServerKeypair["signer"]
) {
  // Create @solana/client instance pointing to local validator
  const client = createClient({
    endpoint: "http://localhost:8899",
    websocketEndpoint: "ws://localhost:8900",
    commitment: "confirmed",
    logger: () => {} // Disable all logs
  });

  // Fund sender with SOL for transaction fees using @solana/client actions
  await client.actions.requestAirdrop(sender.address, lamports(1_000_000_000n));

  // Generate keypair to use as address of mint
  const mint = (await generateKeypair()).signer;

  // Get default mint account size (in bytes), no extensions enabled
  const space = BigInt(getMintSize());

  // Get minimum balance for rent exemption
  const rent = await client.runtime.rpc
    .getMinimumBalanceForRentExemption(space)
    .send();

  // Instruction to create new account for mint (token program)
  // Invokes the system program
  const createAccountInstruction = getCreateAccountInstruction({
    payer: sender,
    newAccount: mint,
    lamports: rent,
    space,
    programAddress: TOKEN_2022_PROGRAM_ADDRESS
  });

  // Instruction to initialize mint account data
  // Invokes the token 2022 program
  const initializeMintInstruction = getInitializeMintInstruction({
    mint: mint.address,
    decimals: 6,
    mintAuthority: sender.address
  });

  // Derive sender's associated token account address (ATA)
  const [senderAta] = await findAssociatedTokenPda({
    mint: mint.address,
    owner: sender.address,
    tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
  });

  // Create instruction for sender's ATA
  const createSenderAtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: sender.address
    });

  // Create instruction for recipient 1's ATA
  const createRecipient1AtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: recipient1.address
    });

  // Create instruction for recipient 2's ATA
  const createRecipient2AtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: recipient2.address
    });

  // Create instruction to mint initial tokens to sender
  const mintToInstruction = getMintToInstruction({
    mint: mint.address,
    token: senderAta,
    mintAuthority: sender.address,
    amount: 1_000_000n // Mint 1.00 tokens (1,000,000 base units with 6 decimals)
  });

  // Combine all instructions and send using @solana/client transaction helper
  const setupInstructions = [
    createAccountInstruction, // Create mint account
    initializeMintInstruction, // Initialize mint
    createSenderAtaInstruction, // Create sender's ATA
    createRecipient1AtaInstruction, // Create recipient 1's ATA
    createRecipient2AtaInstruction, // Create recipient 2's ATA
    mintToInstruction // Mint tokens to sender
  ];

  // Prepare and send transaction using @solana/client
  await client.transaction.prepareAndSend({
    authority: sender,
    instructions: setupInstructions,
    version: 0
  });

  return {
    client,
    mint
  };
}
```

</CodeTabs>

## Skalierung mit Transaktionsplanung

Eine einzelne Transaktion hat Größenbeschränkungen – etwa 1232 Bytes. Bei großen
Batch-Operationen (Gehaltsabrechnung für Hunderte von Mitarbeitern,
Massen-Airdrops) überschreiten Sie dieses Limit und müssen die Arbeit auf
mehrere Transaktionen aufteilen.

Obwohl Sie gerne Ihre eigene Transaktionsverteilungslogik erstellen können,
übernimmt das
[`@solana/instruction-plans`](https://www.solanakit.com/docs/concepts/instruction-plans)-Paket
(Teil von Solana Kit) dies auf zwei Ebenen:

**Anweisungspläne** definieren Ihre Operationen und deren
Reihenfolgebeschränkungen:

- **Sequenziell** — Anweisungen, die in einer bestimmten Reihenfolge ausgeführt
  werden müssen
- **Parallel** — Anweisungen, die in beliebiger Reihenfolge ausgeführt werden
  können
- **Unteilbar** — Anweisungen, die in derselben Transaktion zusammenbleiben
  müssen

**Transaktionspläne** werden aus Anweisungsplänen generiert. Der Planer packt
Anweisungen intelligent in optimal dimensionierte Transaktionen und
berücksichtigt dabei Ihre Reihenfolgebeschränkungen. Der resultierende
Transaktionsplan kann dann:

- **Ausgeführt** werden — signiert und an das Netzwerk gesendet, wobei parallele
  Transaktionen gleichzeitig gesendet werden
- **Simuliert** werden — Testlauf gegen das Netzwerk zur Überprüfung vor dem
  Senden
- **Serialisiert** werden — zu Base64 kompiliert für externe Signaturdienste
  oder Mehrparteien-Workflows

Dieser zweistufige Ansatz ermöglicht es Ihnen, in Operationen zu denken
("Überweisung an Alice, dann Überweisung an Bob"), während die Bibliothek die
Mechanik der Transaktionsgröße, des Packens und der parallelen Ausführung
übernimmt.
