---
title: Produktionsbereitschaft
description: Vom Devnet-Testing zum Mainnet-Deployment
---

Lokales Entwickeln und Testen im Devnet sind gro√üartige M√∂glichkeiten, um mit
Solana-Zahlungen zu beginnen. Wenn Sie jedoch bereit sind, im Mainnet zu
deployen, m√ºssen Sie sich der Besonderheiten des Mainnets bewusst sein. Das
Devnet verzeiht Fehler. Das Mainnet nicht. Dieser Leitfaden behandelt die
wichtigen Unterschiede, um sicherzustellen, dass Ihre Nutzer eine reibungslose
Erfahrung haben.

| Devnet                            | Mainnet                                                                                 |
| --------------------------------- | --------------------------------------------------------------------------------------- |
| Kostenlose SOL von Faucets        | [Echte SOL erwerben](https://solana.com/ecosystem/explore?categories=exchange) f√ºr Fees |
| Geringe Konkurrenz um Block-Space | Priority Fees sind wichtig                                                              |
| Transaktionen landen problemlos   | Transaktionskonfiguration ist entscheidend                                              |
| √ñffentliche RPC ist ausreichend   | Produktions-RPC erforderlich                                                            |
| Devnet-Keypairs und Mints         | Andere Keys und Token-Mints ‚Äì aktualisieren Sie Ihre Konfiguration                      |

## RPC-Infrastruktur

[√ñffentliche Endpoints](https://solana.com/docs/references/clusters#solana-public-rpc-endpoints)
(`api.mainnet-beta.solana.com`) sind ratenlimitiert ohne SLA. Sie sind f√ºr die
Entwicklung geeignet, werden aber Produktions-Zahlungsabl√§ufe zum Scheitern
bringen ‚Äì als w√ºrden Sie versuchen, einen Zahlungsabwickler √ºber eine gemeinsam
genutzte API ohne Verf√ºgbarkeitsgarantie zu betreiben.

<Callout
  type="caution"
  title="Verwenden Sie niemals √∂ffentliche RPC f√ºr die Produktion"
>
  Nutzen Sie einen [privaten RPC-Provider](https://solana.com/rpc) f√ºr
  zuverl√§ssigen Zugriff mit niedriger Latenz.
</Callout>

Bei der Auswahl eines RPC-Providers sollten Sie auf Folgendes achten:

- **Zuverl√§ssigkeit**: SLAs mit Verf√ºgbarkeitsgarantien (99,9 %+)
- **Latenz**: geografische N√§he zu Ihren Nutzern
- **Features**: Transaction-Landing-Features, Indexierung, Priority-Fee-APIs

Eine vollst√§ndige Liste der RPC-Provider finden Sie im Leitfaden
[RPC Infrastructure Providers](https://solana.com/rpc).

### Redundante RPC-Konfiguration

Wie jeder Netzwerkdienstanbieter k√∂nnen auch RPC-Provider Ausfallzeiten oder
Phasen mit eingeschr√§nkter Leistung erleben. Um sicherzustellen, dass Ihre
Anwendung resilient ist, sollten Sie Ihre Anwendung so konfigurieren, dass sie
mehrere RPC-Provider verwendet.

[Solana Kit](https://github.com/anza-xyz/kit/tree/main/packages/rpc-transport-http)
bietet eine Bibliothek zur Anpassung von RPC-Transporten, mit der Sie Ihren
eigenen redundanten RPC-Client erstellen k√∂nnen. Hier ist ein Beispiel, wie Sie
ihn zum Aufbau eines redundanten RPC-Clients verwenden k√∂nnten:

```ts
import { RpcTransport } from "@solana/rpc-spec";
import { RpcResponse } from "@solana/rpc-spec-types";
import { createHttpTransport } from "@solana/rpc-transport-http";

// Create a transport for each RPC server
const transports = [
  createHttpTransport({ url: "https://mainnet-beta.my-server-1.com" }),
  createHttpTransport({ url: "https://mainnet-beta.my-server-2.com" }),
  createHttpTransport({ url: "https://mainnet-beta.my-server-3.com" })
];

// Create a wrapper transport that distributes requests to them
let nextTransport = 0;
async function roundRobinTransport<TResponse>(
  ...args: Parameters<RpcTransport>
): Promise<RpcResponse<TResponse>> {
  const transport = transports[nextTransport];
  nextTransport = (nextTransport + 1) % transports.length;
  return await transport(...args);
}
```

Wenn Sie es vorziehen, keine eigenen Routing-Tools zu erstellen, k√∂nnen Sie
einen Drittanbieterdienst wie [Iron Forge](https://www.ironforge.sanctum.so/)
nutzen, um das Routing f√ºr Sie zu √ºbernehmen.

## Transaktionslandung

Im Devnet landen Transaktionen relativ einfach. Im Mainnet konkurrieren Sie um
Blockspeicherplatz. Um die Chancen zu erh√∂hen, dass Ihre Transaktion in einen
Block aufgenommen wird, sollten Sie sicherstellen, dass Sie Ihre Transaktion
korrekt zusammengestellt haben. Das bedeutet:

- Einf√ºgen eines aktuellen Blockhashes vor dem Senden der Transaktion
- Einf√ºgen einer Priority-Fee-Anweisung in die Transaktion mit einer
  wettbewerbsf√§higen Priority Fee
- Einf√ºgen einer Compute-Unit-Limit-Anweisung in die Transaktion mit einem
  Compute-Unit-Limit basierend auf den gesch√§tzten Compute Units, die f√ºr die
  Transaktion erforderlich sind

Zus√§tzlich sollten Sie andere Tools wie Jito Bundles in Betracht ziehen, um die
Chancen zu erh√∂hen, dass Ihre Transaktion in einen Block aufgenommen wird.
Lassen Sie uns diese Tools genauer betrachten.

### Konfiguration des Transaktionsversands

Beim Senden von Transaktionen im Mainnet konfigurieren Sie diese Parameter f√ºr
optimale Landeraten:

**Blockhash-Verwaltung:**

- Abrufen mit `confirmed`-Commitment
- Speichern Sie den `lastValidBlockHeight`, der von `getLatestBlockhash`
  zur√ºckgegeben wird ‚Äì dieser zeigt Ihnen, wann Ihre Transaktion abl√§uft
- Blockhashes laufen nach ~150 Bl√∂cken (~60-90 Sekunden) ab

**Sendeoptionen:**

- `maxRetries: 0` ‚Äî Deaktiviert automatische RPC-Wiederholungen. Verwalten Sie
  Wiederholungen selbst, damit Sie den Blockhash bei Bedarf aktualisieren
  k√∂nnen.
- `skipPreflight: true` ‚Äî Umgeht die Simulation vor dem Senden. Verwenden Sie
  dies, wenn Sie die Transaktion bereits validiert haben und die niedrigste
  Latenz w√ºnschen. Behalten Sie es w√§hrend der Entwicklung auf `false`, um
  Fehler fr√ºhzeitig zu erkennen.

```typescript
import { createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc(process.env.RPC_URL!);

// 1. Get blockhash with confirmed commitment
const { value: latestBlockhash } = await rpc
  .getLatestBlockhash({ commitment: "confirmed" })
  .send();

// 2. Build and sign your transaction with the blockhash
// ... (transaction building code)

// 3. Send with production settings
const signature = await rpc
  .sendTransaction(encodedTransaction, {
    encoding: "base64",
    maxRetries: 0n, // Handle retries yourself
    skipPreflight: true, // Skip simulation for speed (use false during dev)
    preflightCommitment: "confirmed"
  })
  .send();

// 4. Track expiration using lastValidBlockHeight
const { lastValidBlockHeight } = latestBlockhash;
// Stop retrying when current block height exceeds lastValidBlockHeight
```

### Priority fees verwenden

Jede Solana-Transaktion erfordert eine Transaktionsgeb√ºhr, die in SOL bezahlt
wird. Transaktionsgeb√ºhren werden in zwei Teile aufgeteilt: die Basisgeb√ºhr und
die Priority fee. Die Basisgeb√ºhr entsch√§digt Validatoren f√ºr die Verarbeitung
der Transaktion. Die Priority fee ist eine optionale Geb√ºhr, um die Chance zu
erh√∂hen, dass der aktuelle Leader Ihre Transaktion verarbeitet. Stellen Sie es
sich wie einen Expressversand vor: Sie zahlen mehr f√ºr eine schnellere,
zuverl√§ssigere Zustellung.

**So funktionieren Geb√ºhren:**

```
Total fee = Base fee (5,000 lamports per signature) + Priority fee
Priority fee = Compute units x Price per unit (micro-lamports per compute unit)
```

**Kosten in der Praxis:**

- Einfache USDC-√úberweisung: ~0,001‚Äì0,005 $ unter normalen Bedingungen
- Bei √úberlastung: ~0,01‚Äì0,05 $
- Spitzen√ºberlastung: kann h√∂her steigen

**Beispielimplementierung:**

Das
[`@solana-program/compute-budget`](https://github.com/solana-program/compute-budget)-Paket
bietet eine Hilfsfunktion, um die Anweisung f√ºr den Compute-Unit-Preis (in
Micro-Lamports) einfach zu aktualisieren oder an eine Transaktion anzuh√§ngen.

```typescript
import { updateOrAppendSetComputeUnitPriceInstruction } from "@solana-program/compute-budget";

const tx = pipe(
  createTransactionMessage({ version: 0 }),
  (m) => setTransactionMessageFeePayerSigner(payer, m),
  (m) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, m),
  (m) => appendTransactionMessageInstructions([myInstructions], m),
  (m) => updateOrAppendSetComputeUnitPriceInstruction(1000n as MicroLamports, m)
);
```

**Geb√ºhrensch√§tzungen erhalten:** Die meisten RPC-Anbieter bieten
Priority-Fee-APIs an:

- [Helius Priority Fee API](https://docs.helius.dev/solana-apis/priority-fee-api)
- [QuickNode Priority Fee Add-on](https://marketplace.quicknode.com/add-on/solana-priority-fee)
- [Triton Priority Fees API](https://docs.triton.one/chains/solana/improved-priority-fees-api)

F√ºr die vollst√§ndige Fee-Mechanik siehe [Transaktionsgeb√ºhren](/docs/core/fees)
und unseren Leitfaden:
[So f√ºgen Sie Priority fees zu einer Transaktion hinzu](https://solana.com/developers/cookbook/transactions/add-priority-fees).

### Compute-Units optimieren

Compute auf Solana ist effektiv ein Ma√ü f√ºr die Menge an Arbeit, die das
Programm leistet. Es gibt eine Begrenzung f√ºr die Menge an Compute, die in einer
Transaktion verwendet werden kann (derzeit 1,4 Millionen Compute-Units), und
eine Begrenzung f√ºr die Menge an Compute, die pro Konto pro Block verwendet
werden kann (derzeit 100 Millionen Compute-Units).

Wenn Sie eine Transaktion einreichen, m√ºssen Sie die Menge an Compute sch√§tzen,
die verwendet wird, und das Compute-Unit-Limit entsprechend festlegen ‚Äì dies ist
effektiv eine Anfrage, wie viel der Gesamtkapazit√§t f√ºr Ihre Transaktion
reserviert werden soll. In der Praxis bedeutet dies, dass die ordnungsgem√§√üe
Sch√§tzung der f√ºr Ihre Transaktion erforderlichen Compute-Units entscheidend
daf√ºr ist, dass Ihre Transaktion in einen Block aufgenommen wird (und wichtig
f√ºr die Verwaltung Ihrer Priority fees).

Die Solana JSON RPC API verf√ºgt √ºber eine
[`simulatetransaction`](/docs/rpc/http/simulatetransaction)-Methode, die
verwendet werden kann, um die f√ºr eine Transaktion erforderlichen
Recheneinheiten zu sch√§tzen, einschlie√ülich einer Sch√§tzung der Recheneinheiten,
die verwendet werden. Das
[`@solana-program/compute-budget`](https://github.com/solana-program/compute-budget)-Paket
bietet eine Hilfsfunktion, um die f√ºr eine Transaktion erforderlichen
Recheneinheiten einfach zu sch√§tzen (die unter der Haube die
`simulatetransaction`-Methode verwendet).

```ts
import {
  estimateComputeUnitLimitFactory,
  updateOrAppendSetComputeUnitLimitInstruction
} from "@solana-program/compute-budget";

const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });
const computeUnitLimit = await estimateComputeUnitLimit(tx);
const txWithComputeUnitLimit = updateOrAppendSetComputeUnitLimitInstruction(
  computeUnitLimit,
  tx
);
```

In der Produktion sollten Sie, wenn Sie denselben Transaktionstyp mehrmals
wiederholen, erw√§gen, die Rechensch√§tzung f√ºr den Transaktionstyp zu cachen, um
den Overhead der Sch√§tzung der Recheneinheiten bei jedem Mal zu vermeiden.

### Jito Bundles

Jito Bundles sind ein Tool zur Verwaltung der atomaren Ausf√ºhrung mehrerer
Transaktionen. Dies wird erreicht, indem mehrere Transaktionen mit einem Tip an
das Jito-Netzwerk gesendet werden. Tips k√∂nnen verwendet werden, um das
Jito-Netzwerk zu incentivieren, Ihre Transaktionen in einen Block aufzunehmen.

**Ressourcen:**

- [Jito-Dokumentation](https://docs.jito.wtf/lowlatencytxnsend/)
- [üé• Video: Jito Bundles](https://www.youtube.com/watch?v=HZ1pK9i6zx4)
- [QuickNode-Leitfaden zu Jito Bundles](https://www.quicknode.com/guides/solana-development/transactions/jito-bundles)

### Retry-Strategien

Transaktionen k√∂nnen aus vielen Gr√ºnden fehlschlagen. Im Gegensatz zu
traditionellen Payment-APIs, die sofort Erfolg/Fehler zur√ºckgeben, erfordern
Blockchain-Transaktionen ein Confirmation-Tracking.

**Wichtige Konzepte:**

- **Blockhash-Ablauf**: Transaktionen sind f√ºr ~150 Bl√∂cke (~60-90 Sekunden)
  g√ºltig
- **Idempotenz**: Dieselbe signierte Transaktion erzeugt immer dieselbe Signatur
  ‚Äì erneutes Senden ist sicher
- **Exponential Backoff**: Vermeiden Sie es, das Netzwerk mit schnellen
  Wiederholungsversuchen zu √ºberlasten

```typescript
import {
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  sendAndConfirmTransactionFactory,
  isSolanaError,
  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED
} from "@solana/kit";

const rpc = createSolanaRpc(process.env.RPC_URL!);
const rpcSubscriptions = createSolanaRpcSubscriptions(process.env.RPC_WSS_URL!);

const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({
  rpc,
  rpcSubscriptions
});

// Send with automatic confirmation tracking and block height monitoring
try {
  await sendAndConfirmTransaction(signedTransaction, {
    commitment: "confirmed",
    // Optional: abort after 75 seconds
    abortSignal: AbortSignal.timeout(75_000)
  });
} catch (e) {
  if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {
    // Blockhash expired‚Äîrebuild transaction with fresh blockhash and retry
    rebuildAndRetryTransaction(); // implement your own logic for rebuilding and retrying the transaction
  }
  throw e;
}
```

Die `sendAndConfirmTransactionFactory` aus `@solana/kit` √ºbernimmt das
Confirmation-Polling und Block-Height-Tracking automatisch. Sie wirft
`SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED`, wenn der Blockhash der Transaktion
abl√§uft, was signalisiert, dass Sie die Transaktion mit einem frischen Blockhash
neu erstellen m√ºssen.

### Zus√§tzliche Ressourcen

- [Leitfaden: Transaktionsbest√§tigung & Ablauf](https://solana.com/developers/guides/advanced/confirmation)
- [Helius: Wie man Transaktionen auf Solana landet](https://www.helius.dev/blog/how-to-land-transactions-on-solana)
- [QuickNode: Strategien zur Optimierung von Solana-Transaktionen](https://www.quicknode.com/docs/solana/transactions)

## Best√§tigungsstufen verstehen

Solana bietet drei Best√§tigungsstufen. In traditionellen Finanzterminologie:

| Stufe       | Solana-Definition                     | Traditionelles √Ñquivalent | Anwendungsfall               |
| ----------- | ------------------------------------- | ------------------------- | ---------------------------- |
| `processed` | In einem Block, noch nicht abgestimmt | Ausstehende Autorisierung | Echtzeit-UI-Aktualisierungen |
| `confirmed` | Supermehrheit hat abgestimmt          | Freigegebene Mittel       | **Die meisten Zahlungen**    |
| `finalized` | Verwurzelt, unumkehrbar               | Abgerechnete Mittel       | Hoher Wert, Compliance       |

**Wann welche Stufe verwenden:**

- **UI-Aktualisierungen**: Zeige `processed` f√ºr sofortiges Feedback ("Zahlung
  √ºbermittelt")
- **Benutzerkonto gutschreiben**: Warte auf `confirmed` (sicher f√ºr die meisten
  Transaktionen)
- **Physische Waren versenden**: Warte auf `finalized`
- **Gro√üe Abhebungen**: Warte auf `finalized`
- **Compliance/Audit**: Erfasse immer den `finalized`-Status

Weitere Informationen zur √úberpr√ºfung des Transaktionsstatus finden Sie unter
[Interaktion mit Solana](/docs/payments/interacting-with-solana).

## Fehlerbehandlung

Solana Kit bietet typisierte Fehler √ºber `isSolanaError()`. Verwenden Sie
spezifische Fehlercodes anstelle von String-Matching:

```typescript
import {
  isSolanaError,
  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,
  SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,
  SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,
  SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS
} from "@solana/kit";

function handlePaymentError(error: unknown): {
  message: string;
  retryable: boolean;
} {
  // Blockhash expired‚Äîrebuild and retry
  if (
    isSolanaError(error, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED) ||
    isSolanaError(error, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND)
  ) {
    return { message: "Transaction expired‚Äîrebuilding", retryable: true };
  }

  // Insufficient SOL for fees
  if (
    isSolanaError(
      error,
      SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE
    )
  ) {
    return { message: "Not enough SOL for fees", retryable: false };
  }

  // Insufficient token balance
  if (
    isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS)
  ) {
    return { message: "Insufficient balance", retryable: false };
  }

  // Unknown error
  console.error("Payment error:", error);
  return { message: "Payment failed‚Äîplease retry", retryable: true };
}
```

**H√§ufige Fehlercodes:**

| Fehlercode                   | Ursache                  | Wiederherstellung                                                                                                                |
| ---------------------------- | ------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `BLOCK_HEIGHT_EXCEEDED`      | Blockhash abgelaufen     | Mit frischem Blockhash neu erstellen                                                                                             |
| `BLOCKHASH_NOT_FOUND`        | Blockhash nicht gefunden | Mit frischem Blockhash neu erstellen                                                                                             |
| `INSUFFICIENT_FUNDS_FOR_FEE` | Nicht genug SOL          | Geb√ºhrenzahler finanzieren oder [Geb√ºhrenabstraktion](/docs/payments/send-payments/payment-processing/fee-abstraction) verwenden |
| `INSUFFICIENT_FUNDS`         | Nicht genug Token        | Benutzer ben√∂tigt mehr Guthaben                                                                                                  |
| `ACCOUNT_NOT_FOUND`          | Token-Konto fehlt        | ATA in Transaktion erstellen                                                                                                     |

## Geb√ºhrenfreie Transaktionen

Nutzer erwarten, in Stablecoins zu zahlen, nicht SOL f√ºr Netzwerkgeb√ºhren zu
erwerben. Geb√ºhrenfreie Transaktionen l√∂sen dies ‚Äì √§hnlich wie Venmo-Nutzer
nicht √ºber ACH-Geb√ºhren nachdenken. Siehe
[Fee-Abstraktion](/docs/payments/send-payments/payment-processing/fee-abstraction)
f√ºr die vollst√§ndige Implementierung.

## Sicherheit

### Schl√ºsselverwaltung

- **Private Schl√ºssel niemals im Frontend-Code offenlegen.** Verwenden Sie
  Backend-Signierung, Hardware-Wallets, Multisignatur-Wallets oder
  Schl√ºsselverwaltungsdienste.
- **Hot und Cold Wallets trennen.** Hot Wallet f√ºr Operationen, Cold f√ºr
  Treasury.
- **Alle Produktionsschl√ºssel sichern.** Verschl√ºsselte Backups an mehreren
  sicheren Orten speichern. Der Verlust eines Schl√ºssels bedeutet dauerhaften
  Zugriffsverlust.
- **Unterschiedliche Schl√ºssel f√ºr Devnet und Mainnet verwenden.** Ihre
  Devnet-Schl√ºssel sollten nicht Ihre Mainnet-Schl√ºssel sein. Verwenden Sie
  umgebungsbasierte Konfiguration, um sicherzustellen, dass die richtigen
  Schl√ºssel f√ºr jedes Netzwerk geladen werden.

### RPC-Sicherheit

Behandeln Sie RPC-Endpunkte wie API-Schl√ºssel ‚Äì legen Sie sie nicht im
Frontend-Code offen, wo sie extrahiert und missbraucht werden k√∂nnen. Verwenden
Sie einen Backend-Proxy oder Umgebungsvariablen, die nicht in Client-Code
geb√ºndelt werden.

- [QuickNode: Best Practices f√ºr Endpunktsicherheit](https://www.quicknode.com/guides/quicknode-products/endpoint-security/endpoint-security-best-practices)
- [Helius: Sch√ºtzen Sie Ihre Solana-API-Schl√ºssel: Best Practices f√ºr Sicherheit](https://www.helius.dev/docs/rpc/protect-your-keys)

### Monitoring

√úberwachen Sie diese Metriken in der Produktion:

| Metrik                  | Warum                         |
| ----------------------- | ----------------------------- |
| Transaktionserfolgsrate | Probleme fr√ºh erkennen        |
| Best√§tigungslatenz      | Netzwerkgesundheit √ºberwachen |
| Priority-Fee-Ausgaben   | Kostenmanagement              |
| RPC-Fehlerrate          | Provider-Gesundheit           |

Richten Sie Benachrichtigungen ein f√ºr:

- √úberweisungen √ºber Schwellenwert aus Treasury
- Spitzen bei fehlgeschlagenen Transaktionen
- Ungew√∂hnliche Empf√§ngermuster
- Erh√∂hungen der RPC-Fehlerrate

F√ºr Echtzeit-Transaktions√ºberwachung im gro√üen Ma√üstab siehe unseren
[Indexing-Leitfaden](/docs/payments/accept-payments/indexing).

### Adressen verifizieren

Jeder Token und jedes Programm hat genau eine korrekte Adresse im Mainnet.
Gef√§lschte Tokens, die USDC oder andere Stablecoins imitieren, sind weit
verbreitet ‚Äì sie haben denselben Namen und dasselbe Symbol, aber eine andere
Mint-Adresse. Ihre Anwendung sollte die Mint-Adressen fest codieren oder auf
eine Allowlist setzen (basierend auf Ihren Anforderungen) und sie niemals
dynamisch aus nicht vertrauensw√ºrdigen Quellen akzeptieren.

**Umgebungsbasierte Konfiguration:** Devnet und Mainnet verwenden oft v√∂llig
unterschiedliche Token-Mints. Richten Sie Ihre Anwendungskonfiguration so ein,
dass sie die korrekten Adressen pro Umgebung l√§dt ‚Äì codieren Sie nicht
Mainnet-Adressen fest und vergessen Sie, diese w√§hrend des Testens
auszutauschen, oder noch schlimmer, liefern Sie Devnet-Adressen in die
Produktion aus.

Einige g√§ngige Stablecoin-Mints sind:

| Token | Herausgeber | Mint-Adresse                                   |
| ----- | ----------- | ---------------------------------------------- |
| USDC  | Circle      | `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v` |
| USDT  | Tether      | `Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB` |
| PYUSD | PayPal      | `2b1kV6DkPAnxd5ixfnxCpjxmKwqjjaYmCZfHsFu24GXo` |
| USDG  | Paxos       | `2u1tszSeqZ3qBWF3uNGPFc8TzMk2tdiwknnRMWGWjGWH` |

Programmadressen sind ebenfalls wichtig. Das Senden von Anweisungen an das
falsche Programm wird fehlschlagen ‚Äì oder schlimmer noch, zu einem irreversiblen
Verlust von Geldern f√ºhren. Die Token Program-Adressen sind:

| Programm           | Adresse                                       |
| ------------------ | --------------------------------------------- |
| Token Program      | `TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA` |
| Token-2022 Program | `TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb` |

## Checkliste vor dem Launch

- [ ] Mainnet-SOL f√ºr Fees und Rent erworben
- [ ] Produktions-RPC konfiguriert (kein √∂ffentlicher Endpunkt)
- [ ] Fallback-RPC-Endpunkt konfiguriert
- [ ] Priority Fees mit dynamischer Preisgestaltung implementiert
- [ ] Retry-Logik behandelt Blockhash-Ablauf
- [ ] Best√§tigungslevel dem Anwendungsfall angemessen
- [ ] Alle g√§ngigen Fehler werden elegant behandelt
- [ ] Gasless konfiguriert (falls zutreffend)
- [ ] Mainnet-Token-Adressen verifiziert (keine Devnet-Mints)
- [ ] Alle Schl√ºssel sicher gesichert
- [ ] Schl√ºsselverwaltung √ºberpr√ºft (keine Schl√ºssel im Frontend)
- [ ] Transaktions√ºberwachung und Alarmierung aktiv
- [ ] Lasttests mit erwartetem Volumen durchgef√ºhrt

## Deployment von Programmen

Wenn Sie ein benutzerdefiniertes Solana-Programm als Teil Ihrer
Zahlungsinfrastruktur deployen, gibt es zus√§tzliche √úberlegungen.

### Vor dem Deployment

- **Solana CLI-Version:** Stellen Sie sicher, dass Sie die neueste Version der
  [Solana CLI](https://solana.com/docs/intro/installation) verwenden.
- **Programm-Keypair:** Ihr Programm wird eine andere Adresse im Mainnet haben
  als im Devnet (es sei denn, Sie verwenden dasselbe Keypair wieder).
  Aktualisieren Sie alle Referenzen in Ihrer Anwendungskonfiguration. Bewahren
  Sie Ihr Programm-Keypair an einem sicheren Ort auf (beachten Sie, dass die
  Ausf√ºhrung von `cargo clean` wahrscheinlich Ihr Programm-Keypair l√∂schen
  wird).
- **Accounts initialisieren:** Wenn Ihr Programm Admin-Accounts, PDAs oder
  andere State-Accounts ben√∂tigt, stellen Sie sicher, dass diese im Mainnet
  erstellt werden, bevor Benutzer mit Ihrer Anwendung interagieren. Dasselbe
  gilt f√ºr alle Associated Token Accounts (ATAs), die Ihr Programm ben√∂tigt.

### Deployment-Prozess

- **Buffer-Accounts:** Gro√üe Programme werden √ºber Buffer-Accounts deployed. Der
  Befehl `solana program deploy` √ºbernimmt dies automatisch, aber beachten Sie,
  dass das Deployment nicht atomar ist ‚Äì bei Unterbrechung m√ºssen Sie
  m√∂glicherweise Buffer-Accounts wiederherstellen oder schlie√üen. Siehe
  [Deploying Programs](https://solana.com/docs/programs/deploying).
- **Upgrade-Authority:** Entscheiden Sie, ob Ihr Programm nach dem Launch
  aktualisierbar sein soll. F√ºr Unver√§nderlichkeit widerrufen Sie die
  Upgrade-Authority nach dem Deployment. F√ºr Flexibilit√§t sichern Sie den
  Upgrade-Authority-Schl√ºssel entsprechend ab.
- **Rent:** Stellen Sie sicher, dass Ihr Deployment-Wallet genug SOL hat, um die
  Rent-Exempt-Minima f√ºr alle Programm-Accounts zu decken.
- **Verifizierung:**
  [Verifizieren](https://solana.com/docs/programs/verified-builds) Sie Ihr
  Programm, um sicherzustellen, dass das ausf√ºhrbare Programm, das Sie im
  Solana-Netzwerk deployen, mit dem Quellcode in Ihrem Repository √ºbereinstimmt

F√ºr eine vollst√§ndige Anleitung zum Programm-Deployment siehe
[Deploying Programs](https://solana.com/docs/programs/deploying).
