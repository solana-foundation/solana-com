---
title: Programma-afgeleide adres
description:
  Leer over Solana's programma-afgeleide adressen (PDA's) — deterministische
  accountadressen die veilige programmaondertekening mogelijk maken. Begrijp
  PDA-afleiding, canonieke bumps en hoe je PDA-accounts kunt aanmaken.
---

Een Solana [accountadres](/docs/core/accounts#account-address) verwijst naar de
locatie van het account op de blockchain. Veel accountadressen zijn de publieke
sleutel van een keypair, waarbij de bijbehorende privésleutel wordt gebruikt om
transacties met het account te ondertekenen.

Een nuttig alternatief voor een publieke sleuteladres is een programma-afgeleid
adres (PDA). PDA's bieden een eenvoudige methode om programmastatus op te slaan,
te mappen en op te halen. Een PDA is een adres dat deterministisch wordt gemaakt
met behulp van een programma-ID en een combinatie van optionele vooraf
gedefinieerde inputs. PDA's lijken op publieke sleuteladressen, maar hebben geen
bijbehorende privésleutel.

De Solana runtime stelt programma's in staat om voor PDA's te ondertekenen
zonder dat er een privésleutel nodig is. Door een PDA te gebruiken, hoef je het
adres van het account niet bij te houden. In plaats daarvan kun je de specifieke
inputs die voor de afleiding van de PDA zijn gebruikt, oproepen. (Om te leren
hoe programma's PDA's gebruiken voor ondertekening, zie de
[Cross Program Invocations](/docs/core/cpi) sectie.)

## Achtergrond

Solana
[keypairs](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/keypair/src/lib.rs#L26)
zijn punten op de [Ed25519 curve](https://ed25519.cr.yp.to/) (elliptische-curve
cryptografie). Ze bestaan uit een publieke sleutel en een privésleutel. De
publieke sleutel wordt het accountadres, en de privésleutel wordt gebruikt om
geldige [handtekeningen](/docs/core/transactions#signatures) voor het account te
genereren.

![Twee accounts met adressen op de curve](/assets/docs/core/pda/address-on-curve.svg)

Een PDA wordt opzettelijk afgeleid om buiten de Ed25519 curve te vallen. Dit
betekent dat het geen geldige bijbehorende privésleutel heeft en geen
cryptografische operaties kan uitvoeren. (Zoals het leveren van een
handtekening.) Solana stelt programma's echter in staat om voor PDA's te
ondertekenen zonder dat er een privésleutel nodig is.

![Off Curve Address](/assets/docs/core/pda/address-off-curve.svg)

Je kunt PDAs zien als een manier om hashmap-achtige structuren op de blockchain
te creëren met behulp van een vooraf gedefinieerde set inputs. (Bijvoorbeeld
strings, getallen en andere accountadressen.)

![Program Derived Address](/assets/docs/core/pda/pda.svg)

## Een PDA afleiden

Voordat je een account met een PDA aanmaakt, moet je eerst het adres afleiden.
Het afleiden van een PDA creëert niet automatisch een on-chain account op dat
adres - het account moet expliciet worden aangemaakt via het programma dat
gebruikt wordt om de PDA af te leiden. Je kunt een PDA zien als een adres op een
kaart: alleen omdat een adres bestaat, betekent niet dat er iets gebouwd is.

De Solana SDK's ondersteunen PDA-creatie met de functies die in de onderstaande
tabel worden getoond. Elke functie ontvangt de volgende input:

- **Program ID**: Het adres van het programma dat wordt gebruikt om de PDA af te
  leiden. Dit programma kan namens de PDA ondertekenen.
- **Optionele seeds**: Vooraf gedefinieerde inputs, zoals strings, getallen of
  andere accountadressen.

| SDK                            | Functie                                                                                                                          |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `@solana/kit` (Typescript)     | [`getProgramDerivedAddress`](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L157) |
| `@solana/web3.js` (Typescript) | [`findProgramAddressSync`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/publickey.ts#L212)               |
| `solana_sdk` (Rust)            | [`find_program_address`](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/pubkey/src/lib.rs#L617)                        |

De functie gebruikt de program ID en optionele seeds, en itereert vervolgens
door bump-waarden om te proberen een geldig programma-adres te creëren. De
iteratie van bump-waarden begint bij 255 en wordt met 1 verlaagd totdat een
geldige PDA wordt gevonden. Nadat een geldige PDA is gevonden, geeft de functie
de PDA en de bump seed terug.

<Callout>
  De bump seed is een extra byte die aan de optionele seeds wordt toegevoegd om
  ervoor te zorgen dat een geldig off-curve adres wordt gegenereerd.
</Callout>

![PDA Afleiding](/assets/docs/core/pda/pda-derivation.svg)

### Canonieke bump

Een bump seed is een extra byte die wordt toegevoegd aan de optionele seeds. De
afleidingsfunctie doorloopt bump-waarden, beginnend bij 255 en verlagend met 1,
totdat een waarde een geldig off-curve adres produceert. De eerste waarde die
een geldig off-curve adres produceert wordt de "canonieke bump" genoemd.

De volgende voorbeelden tonen PDA-afleiding met alle mogelijke bump seeds (255
tot 0):

<Callout type="info">
  Kit voorbeeld is niet inbegrepen omdat de
  [createProgramDerivedAddress](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L101)
  functie niet wordt geëxporteerd.
</Callout>

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const optionalSeed = "helloWorld";

// Loop through all bump seeds (255 down to 0)
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(optionalSeed), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed = b"helloWorld";

    // Loop through all bump seeds (255 down to 0)
    for bump in (0..=255).rev() {
        match Pubkey::create_program_address(&[optional_seed.as_ref(), &[bump]], &program_id) {
            Ok(pda) => println!("bump {}: {}", bump, pda),
            Err(err) => println!("bump {}: {}", bump, err),
        }
    }

    Ok(())
}
```

</CodeTabs>

<CodeTabs>

```sh !! title="Expected TS Output"
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// remaining bump outputs
```

```sh !! title="Expected Rust Output"
bump 255: Provided seeds do not result in a valid address
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Provided seeds do not result in a valid address
...
// remaining bump outputs
```

</CodeTabs>

In dit voorbeeld geeft de eerste bump seed een foutmelding. De eerste bump seed
die een geldige PDA afleidt is 254. Bump seeds 253-251 leiden ook unieke,
geldige PDA's af.

Dit betekent dat gegeven dezelfde optionele seeds en `programId`, een bump seed
met een andere waarde nog steeds een geldige PDA kan afleiden.

<Callout type="warn">
  Voeg altijd beveiligingscontroles toe om ervoor te zorgen dat een PDA die aan
  het programma wordt doorgegeven, is afgeleid van de canonieke bump. Als u dit
  niet doet, kunnen er kwetsbaarheden ontstaan waardoor onverwachte accounts
  kunnen worden gebruikt in de instructies van het programma. Het is een best
  practice om alleen de canonieke bump te gebruiken bij het afleiden van PDA's.
</Callout>

### Voorbeelden

De onderstaande voorbeelden leiden een PDA af met behulp van de Solana SDK's.
Klik op **&#9655; Run** om de code uit te voeren.

#### Een PDA afleiden met een string seed

Het onderstaande voorbeeld leidt een PDA af met behulp van een programma-ID en
een optionele string seed.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus
const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus
const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let seeds: &[&[u8]] = &[b"helloWorld"];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Een PDA afleiden met een adres seed

Het onderstaande voorbeeld leidt een PDA af met behulp van een program ID en een
optionele adres seed.

<CodeTabs storage="pda-examples"flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:4)
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

// !focus(1:3)
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Een PDA afleiden met meerdere seeds

Het onderstaande voorbeeld leidt een PDA af met behulp van een program ID en
meerdere optionele seeds.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:5)
const optionalSeedString = "helloWorld";
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedString, optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus(1:4)
const optionalSeedString = "helloWorld";
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [Buffer.from(optionalSeedString), optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus(1:2)
    let optional_seed_bytes = b"helloWorld";
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

## Een PDA-account aanmaken

<WithMentions>

Het onderstaande voorbeeld gebruikt het
[Anchor framework](https://www.anchor-lang.com/docs) om een nieuw account aan te
maken met een program-derived address. Het programma bevat één
[`initialize`](mention:initialize) instructie om het nieuwe account aan te
maken, dat het [gebruikersadres](mention:user-address) en de
[bump seed](mention:bump) zal opslaan die gebruikt zijn om de PDA af te leiden.

```rs title="Program"
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    // !mention initialize
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        // !mark
        // !mention user-address
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bumpd
        // !mark
        // !mention bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    // !mention user-address
    pub user: Signer<'info>,

    #[account(
        init,
        // define the seeds to derive the PDA
        // !mark
        // !mention user-address
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        // !mark
        // !mention bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(InitSpace)]
pub struct DataAccount {
    // !mark
    // !mention user-address
    pub user: Pubkey,
    // !mark
    // !mention bump
    pub bump: u8,
}
```

</WithMentions>

<WithMentions>

De [`init`](mention:init) constraint vertelt Anchor om het
[System Program](/docs/core/programs#the-system-program) aan te roepen om een
nieuw account aan te maken met de PDA als adres. De [seeds](mention:seeds) die
gebruikt worden om de PDA aan te maken zijn:

- Het adres van het gebruikersaccount dat in de instructie is opgegeven
- De vaste string: "data"
- De canonieke [bump seed](mention:bump)

In dit voorbeeld krijgt de bump constraint geen waarde toegewezen, dus Anchor
zal `find_program_address` gebruiken om de PDA af te leiden en de bump te
vinden.

```rust title="pda_account"
#[account(
    // !mention init
    init,
    // !mention seeds
    seeds = [b"data", user.key().as_ref()],
    // !mention bump
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

</WithMentions>

<WithMentions>

Het onderstaande testbestand bevat een transactie die de
[`initialize`](mention:initialize) instructie aanroept om een nieuw account aan
te maken met een program-derived address. Het bestand bevat code om de
[PDA af te leiden](mention:pda).

Het voorbeeld laat ook zien hoe je het nieuwe account dat zal worden aangemaakt
kunt [ophalen](mention:fetch).

```ts title="Test"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PdaAccount } from "../target/types/pda_account";
import { PublicKey } from "@solana/web3.js";

describe("pda-account", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.PdaAccount as Program<PdaAccount>;
  const user = provider.wallet as anchor.Wallet;

  // !mention(1:5) pda
  // Derive the PDA address using the seeds specified on the program
  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("data"), user.publicKey.toBuffer()],
    program.programId
  );

  it("Is initialized!", async () => {
    const transactionSignature = await program.methods
      // !mention initialize
      .initialize()
      .accounts({
        user: user.publicKey
      })
      .rpc();

    console.log("Transaction Signature:", transactionSignature);
  });

  it("Fetch Account", async () => {
    // !mention fetch
    const pdaAccount = await program.account.dataAccount.fetch(PDA);
    console.log(JSON.stringify(pdaAccount, null, 2));
  });
});
```

</WithMentions>

<Callout type="warn">
  Als je de `initialize` instructie opnieuw aanroept met hetzelfde `user` adres
  als seed, zal de transactie mislukken. Dit gebeurt omdat er al een account
  bestaat op het afgeleide adres.
</Callout>
