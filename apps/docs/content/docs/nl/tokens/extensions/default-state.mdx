---
title: Standaardstatus
description: Leer hoe je de DefaultAccountStateExtension kunt inschakelen.
---

## Hoe je de DefaultAccountStateExtension inschakelt

De
[`DefaultAccountStateExtension`](https://github.com/solana-program/token-2022/blob/6f2473344d70271f632c3e9b7e945be00186c536/interface/src/instruction.rs#L593)
stelt een standaardstatus in voor alle nieuwe token accounts die voor een mint
worden aangemaakt. Wanneer ingeschakeld, initialiseert deze extensie automatisch
elk nieuw token account met een opgegeven status, zoals bevroren. Hierdoor
kunnen token creators specifieke gedragingen afdwingen, zoals het standaard
bevriezen van alle nieuwe accounts totdat ze expliciet worden ontdooid.

### Typescript

<CodeTabs storage="token-ts" flags="r">

```ts !! title="Kit"
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  AccountState,
  extension,
  getInitializeAccountInstruction,
  getInitializeDefaultAccountStateInstruction,
  getInitializeMintInstruction,
  getMintSize,
  getTokenSize,
  TOKEN_2022_PROGRAM_ADDRESS
} from "@solana-program/token-2022";
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate the authority for the mint (also acts as fee payer)
const authority = await generateKeyPairSigner();

// Fund authority/fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: authority.address,
  lamports: lamports(5_000_000_000n), // 5 SOL
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// default account state extension
const defaultAccountStateExtension = extension("DefaultAccountState", {
  state: AccountState.Frozen
});

// Get default mint account size (in bytes), default account state enabled
const space = BigInt(getMintSize([defaultAccountStateExtension]));

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Instruction to create new account for mint (token program)
// Invokes the system program
const createMintAccountInstruction = getCreateAccountInstruction({
  payer: authority,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

// Generate keypair to use as address of token account
const tokenAccount = await generateKeyPairSigner();

// get token account size with extension enabled
const tokenAccountLen = BigInt(getTokenSize([defaultAccountStateExtension]));

// Get minimum balance for rent exemption
const tokenAccountRent = await rpc
  .getMinimumBalanceForRentExemption(tokenAccountLen)
  .send();

// Instruction to create new account for the token account
// Invokes the system program
const createTokenAccountInstruction = getCreateAccountInstruction({
  payer: authority,
  newAccount: tokenAccount,
  lamports: tokenAccountRent,
  space: tokenAccountLen,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

// Instruction to initialize the created token account
const initializeTokenAccountInstruction = getInitializeAccountInstruction({
  account: tokenAccount.address,
  mint: mint.address,
  owner: authority.address
});

// Instruction to initialize account with default account state (frozen)
let initializeDefaultAccountState = getInitializeDefaultAccountStateInstruction(
  {
    mint: mint.address,
    state: AccountState.Frozen
  }
);

// Instruction to initialize mint account data
// Invokes the token22 program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: authority.address,
  freezeAuthority: authority.address
});

const instructions = [
  createMintAccountInstruction,
  initializeDefaultAccountState,
  initializeMintInstruction,
  createTokenAccountInstruction,
  initializeTokenAccountInstruction
];

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(authority, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions(instructions, tx)
);

// Sign transaction message with all required signers
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed", skipPreflight: true }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Mint Address:", mint.address.toString());
console.log("Frozen token account:", tokenAccount.address.toString());
console.log("Transaction Signature:", transactionSignature);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL,
  PublicKey,
  TransactionInstruction
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  ExtensionType,
  getMintLen,
  TOKEN_2022_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  getAccountLen,
  createInitializeAccountInstruction,
  createInitializeDefaultAccountStateInstruction,
  AccountState
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const latestBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 5 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  5 * LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Default account state extension
const extensions = [ExtensionType.DefaultAccountState];

// Generate keypair to use as address of mint
const mint = Keypair.generate();

// get mint length (no extensions for mint in this example)
const mintLength = getMintLen(extensions);

// Get minimum balance for rent exemption
const mintRent = await connection.getMinimumBalanceForRentExemption(mintLength);

// Create account instruction for mint
const createMintAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: mintLength,
  lamports: mintRent,
  programId: TOKEN_2022_PROGRAM_ID
});

// Initialize mint instruction
const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

// Generate keypair to use as token account
const tokenAccount = new Keypair();

// Get token account size with extension enabled
const tokenAccountLen = getAccountLen(extensions);

// Get minimum balance for rent exemption
const tokenAccountRent =
  await connection.getMinimumBalanceForRentExemption(tokenAccountLen);

// Instruction to create new account for the token account
const createTokenAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: tokenAccount.publicKey,
  space: tokenAccountLen,
  lamports: tokenAccountRent,
  programId: TOKEN_2022_PROGRAM_ID
});

// Initialize the default account state extension
const initializeDefaultStateInstruction =
  createInitializeDefaultAccountStateInstruction(
    mint.publicKey,
    AccountState.Frozen,
    TOKEN_2022_PROGRAM_ID
  );

// Initialize token account
const initializeTokenAccountInstruction = createInitializeAccountInstruction(
  tokenAccount.publicKey,
  mint.publicKey,
  feePayer.publicKey,
  TOKEN_2022_PROGRAM_ID
);

// Construct transaction to create mint, ATA, mint tokens, create token account,
// and initialize with default account state extension
const transaction = new Transaction({
  feePayer: feePayer.publicKey,
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight
}).add(
  createMintAccountInstruction,
  initializeDefaultStateInstruction,
  initializeMintInstruction,
  createTokenAccountInstruction,
  initializeTokenAccountInstruction
);

// Sign transaction
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint, tokenAccount]
);

console.log("Mint Address:", mint.publicKey.toBase58());
console.log("Token Account (frozen state):", tokenAccount.publicKey.toBase58());
console.log("Transaction Signature:", transactionSignature);
```

</CodeTabs>

### Rust

<CodeTabs storage="token-rs" flags="r">

```rust !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_token_2022_interface::{
    extension::{
        default_account_state::{
            instruction::initialize_default_account_state, DefaultAccountState,
        },
        BaseStateWithExtensions, ExtensionType, StateWithExtensions,
    },
    instruction::{initialize_account, initialize_mint},
    state::{Account, AccountState, Mint},
    ID as TOKEN_2022_PROGRAM_ID,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let latest_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 5 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 5_000_000_000)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    // Get default mint account size (in bytes),
    let mint_space =
        ExtensionType::try_calculate_account_len::<Mint>(&[ExtensionType::DefaultAccountState])?;

    let mint_rent = client
        .get_minimum_balance_for_rent_exemption(mint_space)
        .await?;

    // Instruction to create new account for mint (token22)
    let create_mint_account_instruction = create_account(
        &fee_payer.pubkey(),    // payer
        &mint.pubkey(),         // new account (mint)
        mint_rent,              // lamports
        mint_space as u64,      // space
        &TOKEN_2022_PROGRAM_ID, // program id
    );

    // Instruction to initialize mint account data
    let initialize_mint_instruction = initialize_mint(
        &TOKEN_2022_PROGRAM_ID,    // program id
        &mint.pubkey(),            // mint
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        9,                         // decimals
    )?;

    // Generate keypair to use as address of token account
    let token_account = Keypair::new();

    // Get default token account size (in bytes)
    let token_account_space = ExtensionType::try_calculate_account_len::<Account>(&[])?;

    let token_account_rent = client
        .get_minimum_balance_for_rent_exemption(token_account_space)
        .await?;

    // Instruction to create new account for token account (token22)
    let create_token_account_instruction = create_account(
        &fee_payer.pubkey(),        // payer
        &token_account.pubkey(),    // new account (token account)
        token_account_rent,         // rent
        token_account_space as u64, // space
        &TOKEN_2022_PROGRAM_ID,     // program id
    );

    // initialize token account
    let initialize_token_account = initialize_account(
        &TOKEN_2022_PROGRAM_ID,  // program_id
        &token_account.pubkey(), // token account
        &mint.pubkey(),          //  mint
        &fee_payer.pubkey(),     // authority
    )?;

    // initialize default token account state instruction
    let initialize_default_account_state_instruction = initialize_default_account_state(
        &TOKEN_2022_PROGRAM_ID,
        &mint.pubkey(),
        &AccountState::Frozen,
    )?;

    // Construct transaction with previous instructions
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_mint_account_instruction,
            initialize_default_account_state_instruction,
            initialize_mint_instruction,
            create_token_account_instruction,
            initialize_token_account,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint, &token_account],
        latest_blockhash,
    );

    // Send and confirm transaction
    client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());

    // Fetch mint account
    let mint_account = client.get_account(&mint.pubkey()).await?;
    // Deserialize the mint account with extensions
    let mint_state = StateWithExtensions::<Mint>::unpack(&mint_account.data)?;

    // Get all extension types enabled on this mint
    let mint_extension_types = mint_state.get_extension_types()?;
    println!("\nMint extensions enabled: {:?}", mint_extension_types);

    // Deserialize the DefaultAccountState extension data
    let default_account_state = mint_state.get_extension::<DefaultAccountState>()?;
    println!("\n{:#?}", default_account_state);

    // Fetch token account
    let token_account_data = client.get_account(&token_account.pubkey()).await?;
    // Deserialize the token account with extensions
    let token_account_state = StateWithExtensions::<Account>::unpack(&token_account_data.data)?;

    println!(
        "\nToken account with default state (frozen): {}",
        token_account.pubkey()
    );
    // Display base token account info
    println!("\n{:#?}", token_account_state.base);

    Ok(())
}
```

</CodeTabs>
