---
title: Cross Program Invocation
description:
  Tìm hiểu về Cross Program Invocation (CPI) trên Solana — cách các chương trình
  có thể gọi các lệnh trên các chương trình khác, xử lý người ký PDA và kết hợp
  chức năng trên mạng lưới Solana.
---

Cross Program Invocation (CPI) xảy ra khi một chương trình Solana trực tiếp gọi
các lệnh của một chương trình khác. Điều này cho phép khả năng kết hợp giữa các
chương trình. Nếu bạn coi một [lệnh](/docs/core/instructions) Solana như một
điểm cuối API mà một chương trình cung cấp cho mạng lưới, thì CPI giống như một
điểm cuối nội bộ gọi một điểm cuối khác.

Khi thực hiện CPI, một chương trình có thể
[ký](/docs/references/terminology#signature) thay mặt cho một
[PDA](/docs/core/pda) được tạo ra từ ID chương trình của nó. Các đặc quyền ký
này được mở rộng từ chương trình gọi đến chương trình được gọi.

![Ví dụ về Cross-program invocation](/assets/docs/core/cpi/cpi.svg)

Khi thực hiện CPI, các đặc quyền tài khoản được mở rộng từ chương trình này sang
chương trình khác. Giả sử Chương trình A nhận được một lệnh với một tài khoản
người ký và một tài khoản có thể ghi. Sau đó Chương trình A thực hiện CPI đến
Chương trình B. Bây giờ, Chương trình B có thể sử dụng các tài khoản giống như
Chương trình A, với các quyền ban đầu của chúng. (Nghĩa là Chương trình B có thể
ký với tài khoản người ký và có thể ghi vào tài khoản có thể ghi.) Nếu Chương
trình B thực hiện CPI riêng của nó, nó có thể chuyển tiếp các quyền này, lên đến
độ sâu là 4.

<Callout>
  Chiều cao tối đa của việc gọi lệnh chương trình được gọi là
  [`max_instruction_stack_depth`](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L38)
  và được đặt thành hằng số [MAX_INSTRUCTION_STACK_DEPTH](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L13)
  là 5.

Chiều cao ngăn xếp bắt đầu từ 1 cho giao dịch ban đầu và tăng thêm 1 mỗi khi một
chương trình gọi một lệnh khác, giới hạn độ sâu gọi cho CPI là 4.

</Callout>

## CPI với người ký PDA

<WithMentions>

Khi một CPI yêu cầu người ký PDA, hàm
[`invoke_signed`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/program.rs#L51-L73)
được sử dụng. Nó nhận các [signer seeds](mention:signer-seeds) được dùng để tạo
ra các [PDA](/docs/core/pda) người ký. Solana runtime gọi nội bộ hàm
[`create_program_address`](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/syscalls/cpi.rs#L552)
sử dụng `signers_seeds` và `program_id` của chương trình gọi. Khi một PDA được
xác minh, nó sẽ được
[thêm vào như một người ký hợp lệ](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/bpf_loader/src/syscalls/cpi.rs#L554).

```rust title="Invoke signed"
pub fn invoke_signed(
    instruction: &Instruction,
    account_infos: &[AccountInfo],
    // !mention signer-seeds
    signers_seeds: &[&[&[u8]]],
) -> ProgramResult {
    // --snip--
    invoke_signed_unchecked(instruction, account_infos, signers_seeds)
}
```

</WithMentions>

Các ví dụ dưới đây thực hiện CPI với PDA signers sử dụng Anchor và Native Rust.
Mỗi ví dụ bao gồm một lệnh duy nhất để chuyển SOL từ một PDA đến một tài khoản
người nhận, sử dụng CPI được ký bởi PDA.

#### Anchor

Các ví dụ sau đây cho thấy ba cách tiếp cận để triển khai CPI trong một chương
trình [Anchor](https://www.anchor-lang.com/docs). Các ví dụ này tương đương về
chức năng, nhưng mỗi ví dụ minh họa một mức độ trừu tượng hóa khác nhau.

- **Ví dụ 1**: Sử dụng _rs`CpiContext`_ của Anchor và hàm hỗ trợ.
- **Ví dụ 2**: Sử dụng hàm _rs`system_instruction::transfer`_ từ crate
  `solana_program`. (Ví dụ 1 là một trừu tượng hóa của cách triển khai này.)
- **Ví dụ 3**: Xây dựng lệnh CPI thủ công. Cách tiếp cận này hữu ích khi không
  có crate nào có sẵn để giúp xây dựng lệnh bạn muốn gọi.

<CodeTabs>

```rs !! title="Example 1"
use anchor_lang::prelude::*;
use anchor_lang::system_program::{transfer, Transfer};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;
        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        let cpi_context = CpiContext::new(
            program_id,
            Transfer {
                from: from_pubkey,
                to: to_pubkey,
            },
        )
        .with_signer(signer_seeds);

        transfer(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Example 2"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke_signed, system_instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;

        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        let instruction =
            &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

        invoke_signed(instruction, &[from_pubkey, to_pubkey, program_id], signer_seeds)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Example 3"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke_signed, instruction::{Instruction, AccountMeta}};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.pda_account.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        // Get PDA signer seeds
        let seed = to_pubkey.key();
        let bump_seed = ctx.bumps.pda_account;
        let signer_seeds: &[&[&[u8]]] = &[&[b"pda", seed.as_ref(), &[bump_seed]]];

        // Prepare instruction AccountMetas
        let account_metas = vec![
            AccountMeta::new(from_pubkey.key(), true),
            AccountMeta::new(to_pubkey.key(), false),
        ];

        // SOL transfer instruction discriminator
        let instruction_discriminator: u32 = 2;

        // Prepare instruction data
        let mut instruction_data = Vec::with_capacity(4 + 8);
        instruction_data.extend_from_slice(&instruction_discriminator.to_le_bytes());
        instruction_data.extend_from_slice(&amount.to_le_bytes());

        // Create instruction
        let instruction = Instruction {
            program_id: program_id.key(),
            accounts: account_metas,
            data: instruction_data,
        };

        // Invoke instruction with PDA signer
        invoke_signed(&instruction, &[from_pubkey, to_pubkey, program_id], signer_seeds)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(
        mut,
        seeds = [b"pda", recipient.key().as_ref()],
        bump,
    )]
    pda_account: SystemAccount<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```ts !! title="Test"
import * as anchor from "@coral-xyz/anchor";

import { BN, Program } from "@coral-xyz/anchor";
import { LAMPORTS_PER_SOL, PublicKey } from "@solana/web3.js";

import { Cpi } from "../target/types/cpi";

describe("cpi", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Cpi as Program<Cpi>;
  const connection = program.provider.connection;
  const wallet = provider.wallet as anchor.Wallet;

  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("pda"), wallet.publicKey.toBuffer()],
    program.programId
  );

  const transferAmount = 0.1 * LAMPORTS_PER_SOL;

  before(async () => {
    // Request airdrop to fund PDA
    const signature = await connection.requestAirdrop(PDA, transferAmount);

    const { blockhash, lastValidBlockHeight } =
      await connection.getLatestBlockhash();

    await connection.confirmTransaction({
      signature,
      blockhash,
      lastValidBlockHeight
    });
  });

  it("SOL Transfer with PDA signer", async () => {
    const transactionSignature = await program.methods
      .solTransfer(new BN(transferAmount))
      .accounts({
        recipient: wallet.publicKey
      })
      .rpc();

    console.log(`\nTransaction Signature: ${transactionSignature}`);
  });
});
```

</CodeTabs>

#### Rust

Ví dụ dưới đây thực hiện CPI với PDA signers từ một chương trình được viết bằng
Native Rust. Nó bao gồm một lệnh duy nhất chuyển SOL từ tài khoản PDA đến tài
khoản khác. CPI được ký bởi tài khoản PDA. (Tệp kiểm thử sử dụng
[LiteSVM](https://github.com/LiteSVM/litesvm) để kiểm tra chương trình.)

<CodeTabs>

```rs !! title="Example"
use borsh::BorshDeserialize;
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke_signed,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
};

// Declare program entrypoint
entrypoint!(process_instruction);

// Define program instructions
#[derive(BorshDeserialize)]
enum ProgramInstruction {
    SolTransfer { amount: u64 },
}

impl ProgramInstruction {
    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        Self::try_from_slice(input).map_err(|_| ProgramError::InvalidInstructionData)
    }
}

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Deserialize instruction data
    let instruction = ProgramInstruction::unpack(instruction_data)?;

    // Process instruction
    match instruction {
        ProgramInstruction::SolTransfer { amount } => {
            // Parse accounts
            let [pda_account_info, recipient_info, system_program_info] = accounts else {
                return Err(ProgramError::NotEnoughAccountKeys);
            };

            // Derive PDA and verify it matches the account provided by client
            let recipient_pubkey = recipient_info.key;
            let seeds = &[b"pda", recipient_pubkey.as_ref()];
            let (expected_pda, bump_seed) = Pubkey::find_program_address(seeds, program_id);

            if expected_pda != *pda_account_info.key {
                return Err(ProgramError::InvalidArgument);
            }

            // Create the transfer instruction
            let transfer_ix = system_instruction::transfer(
                pda_account_info.key,
                recipient_info.key,
                amount,
            );

            // Create signer seeds for PDA
            let signer_seeds: &[&[&[u8]]] = &[&[b"pda", recipient_pubkey.as_ref(), &[bump_seed]]];

            // Invoke the transfer instruction with PDA as signer
            invoke_signed(
                &transfer_ix,
                &[
                    pda_account_info.clone(),
                    recipient_info.clone(),
                    system_program_info.clone(),
                ],
                signer_seeds,
            )?;

            Ok(())
        }
    }
}
```

```ts !! title="Test"
import * as path from "path";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from "@solana/web3.js";
import { LiteSVM } from "litesvm";

test("sol transfer cpi with pda signer", () => {
  const svm = new LiteSVM();

  const programId = PublicKey.unique();
  const programPath = path.join(__dirname, "program.so");
  svm.addProgramFromFile(programId, programPath);

  // Create recipient
  const recipient = new Keypair();

  // Derive PDA that will hold and send funds
  const [pdaAddress] = PublicKey.findProgramAddressSync(
    [Buffer.from("pda"), recipient.publicKey.toBuffer()],
    programId
  );

  // Fund accounts
  const amount = BigInt(LAMPORTS_PER_SOL);
  svm.airdrop(recipient.publicKey, amount); // 1 SOL
  svm.airdrop(pdaAddress, amount); // 1 SOL

  // Create instruction data buffer
  const transferAmount = amount / BigInt(2); // 0.5 SOL
  const instructionIndex = 0; // instruction index 0 for SolTransfer enum

  const data = Buffer.alloc(9); // 1 byte for instruction enum + 8 bytes for u64
  data.writeUInt8(instructionIndex, 0); // first byte identifies the instruction
  data.writeBigUInt64LE(transferAmount, 1); // remaining bytes are instruction arguments

  // Create instruction
  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: pdaAddress, isSigner: false, isWritable: true },
      { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ],
    data
  });

  // Create and send transaction
  const transaction = new Transaction().add(instruction);
  transaction.recentBlockhash = svm.latestBlockhash();
  transaction.sign(recipient);

  svm.sendTransaction(transaction);

  // Check balances
  const recipientBalance = svm.getBalance(recipient.publicKey);
  const pdaBalance = svm.getBalance(pdaAddress);

  const transactionFee = BigInt(5000);
  // Recipient starts with 1 SOL, receives 0.5 SOL, pays tx fee
  expect(recipientBalance).toBe(amount + transferAmount - transactionFee);
  // PDA starts with 1 SOL, sends 0.5 SOL
  expect(pdaBalance).toBe(amount - transferAmount);
});
```

</CodeTabs>

## CPIs không có PDA signers

Khi một CPI không yêu cầu người ký PDA, hàm
[`invoke`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/program.rs#L26-L28)
được sử dụng. Hàm `invoke` gọi hàm `invoke_signed` với một mảng `signers_seeds`
rỗng. Mảng signers rỗng cho biết rằng không có PDA nào được yêu cầu để ký.

```rust title="Invoke function"
pub fn invoke(instruction: &Instruction, account_infos: &[AccountInfo]) -> ProgramResult {
    invoke_signed(instruction, account_infos, &[])
}
```

Các ví dụ dưới đây thực hiện CPI sử dụng Anchor và Native Rust. Mỗi ví dụ bao
gồm một lệnh duy nhất chuyển SOL từ tài khoản này sang tài khoản khác.

#### Anchor

Các ví dụ sau đây trình bày ba cách tiếp cận để triển khai CPI trong một chương
trình [Anchor](https://www.anchor-lang.com/docs). Các ví dụ có chức năng tương
đương nhau, nhưng mỗi ví dụ thể hiện một mức độ trừu tượng khác nhau.

- **Ví dụ 1**: Sử dụng _rs`CpiContext`_ của Anchor và hàm hỗ trợ.
- **Ví dụ 2**: Sử dụng hàm _rs`system_instruction::transfer`_ từ crate
  `solana_program`.
- **Ví dụ 3**: Xây dựng lệnh CPI thủ công. Cách tiếp cận này hữu ích khi không
  có crate nào tồn tại để giúp xây dựng lệnh bạn muốn gọi.

<CodeTabs>

```rs !! title="Example 1"
use anchor_lang::prelude::*;
use anchor_lang::system_program::{transfer, Transfer};

declare_id!("9AvUNHjxscdkiKQ8tUn12QCMXtcnbR9BVGq3ULNzFMRi");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let cpi_context = CpiContext::new(
            program_id,
            Transfer {
                from: from_pubkey,
                to: to_pubkey,
            },
        );

        transfer(cpi_context, amount)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Example 2"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke, system_instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        let instruction =
            &system_instruction::transfer(&from_pubkey.key(), &to_pubkey.key(), amount);

        invoke(instruction, &[from_pubkey, to_pubkey, program_id])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```rs !! title="Example 3"
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{program::invoke, instruction::Instruction};

declare_id!("BrcdB9sV7z9DvF9rDHG263HUxXgJM3iCQdF36TcxbFEn");

#[program]
pub mod cpi {
    use super::*;

    pub fn sol_transfer(ctx: Context<SolTransfer>, amount: u64) -> Result<()> {
        let from_pubkey = ctx.accounts.sender.to_account_info();
        let to_pubkey = ctx.accounts.recipient.to_account_info();
        let program_id = ctx.accounts.system_program.to_account_info();

        // Prepare instruction AccountMetas
        let account_metas = vec![
            AccountMeta::new(from_pubkey.key(), true),
            AccountMeta::new(to_pubkey.key(), false),
        ];

        // SOL transfer instruction discriminator
        let instruction_discriminator: u32 = 2;

        // Prepare instruction data
        let mut instruction_data = Vec::with_capacity(4 + 8);
        instruction_data.extend_from_slice(&instruction_discriminator.to_le_bytes());
        instruction_data.extend_from_slice(&amount.to_le_bytes());

        // Create instruction
        let instruction = Instruction {
            program_id: program_id.key(),
            accounts: account_metas,
            data: instruction_data,
        };

        // Invoke instruction
        invoke(&instruction, &[from_pubkey, to_pubkey, program_id])?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SolTransfer<'info> {
    #[account(mut)]
    sender: Signer<'info>,
    #[account(mut)]
    recipient: SystemAccount<'info>,
    system_program: Program<'info, System>,
}
```

```ts !! title="Test"
import * as anchor from "@coral-xyz/anchor";
import { BN, Program } from "@coral-xyz/anchor";
import { Cpi } from "../target/types/cpi";
import { Keypair, LAMPORTS_PER_SOL } from "@solana/web3.js";

describe("cpi", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Cpi as Program<Cpi>;
  const sender = provider.wallet as anchor.Wallet;
  const recipient = new Keypair();

  const transferAmount = 0.01 * LAMPORTS_PER_SOL;

  it("SOL Transfer Anchor", async () => {
    const transactionSignature = await program.methods
      .solTransfer(new BN(transferAmount))
      .accounts({
        sender: sender.publicKey,
        recipient: recipient.publicKey
      })
      .rpc();

    console.log(`\nTransaction Signature: ${transactionSignature}`);
  });
});
```

</CodeTabs>

#### Rust

Ví dụ sau đây cho thấy cách thực hiện CPI từ một chương trình được viết bằng
Native Rust. Nó bao gồm một lệnh duy nhất chuyển SOL từ tài khoản này sang tài
khoản khác. (File kiểm thử sử dụng [LiteSVM](https://github.com/LiteSVM/litesvm)
để kiểm tra chương trình.)

<CodeTabs>

```rs !! title="Example"
use borsh::BorshDeserialize;
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
};

// Declare program entrypoint
entrypoint!(process_instruction);

// Define program instructions
#[derive(BorshDeserialize)]
enum ProgramInstruction {
    SolTransfer { amount: u64 },
}

impl ProgramInstruction {
    fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        Self::try_from_slice(input).map_err(|_| ProgramError::InvalidInstructionData)
    }
}

pub fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Deserialize instruction data
    let instruction = ProgramInstruction::unpack(instruction_data)?;

    // Process instruction
    match instruction {
        ProgramInstruction::SolTransfer { amount } => {
            // Parse accounts
            let [sender_info, recipient_info, system_program_info] = accounts else {
                return Err(ProgramError::NotEnoughAccountKeys);
            };

            // Verify the sender is a signer
            if !sender_info.is_signer {
                return Err(ProgramError::MissingRequiredSignature);
            }

            // Create and invoke the transfer instruction
            let transfer_ix = system_instruction::transfer(
                sender_info.key,
                recipient_info.key,
                amount,
            );

            invoke(
                &transfer_ix,
                &[
                    sender_info.clone(),
                    recipient_info.clone(),
                    system_program_info.clone(),
                ],
            )?;

            Ok(())
        }
    }
}
```

```ts !! title="Test"
import * as path from "path";
import {
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from "@solana/web3.js";
import { LiteSVM } from "litesvm";

test("sol transfer cpi", () => {
  const svm = new LiteSVM();

  const programId = PublicKey.unique();
  const programPath = path.join(__dirname, "program.so");
  svm.addProgramFromFile(programId, programPath);

  // Create sender and recipient
  const sender = new Keypair();
  const recipient = new Keypair();

  // Fund sender
  const amount = BigInt(LAMPORTS_PER_SOL);
  svm.airdrop(sender.publicKey, amount); // 1 SOL

  // Create instruction data buffer
  const transferAmount = amount / BigInt(2); // 0.5 SOL
  const instructionIndex = 0; // instruction index 0 for SolTransfer enum

  const data = Buffer.alloc(9); // 1 byte for instruction enum + 8 bytes for u64
  data.writeUInt8(instructionIndex, 0); // first byte identifies the instruction
  data.writeBigUInt64LE(transferAmount, 1); // remaining bytes are instruction arguments

  // Create instruction
  const instruction = new TransactionInstruction({
    programId,
    keys: [
      { pubkey: sender.publicKey, isSigner: true, isWritable: true },
      { pubkey: recipient.publicKey, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
    ],
    data
  });

  // Create and send transaction
  const transaction = new Transaction().add(instruction);
  transaction.recentBlockhash = svm.latestBlockhash();
  transaction.sign(sender);

  svm.sendTransaction(transaction);

  // Check balances
  const recipientBalance = svm.getBalance(recipient.publicKey);
  const senderBalance = svm.getBalance(sender.publicKey);

  const transactionFee = BigInt(5000);
  expect(recipientBalance).toBe(transferAmount);
  expect(senderBalance).toBe(amount - transferAmount - transactionFee);
});
```

</CodeTabs>
