---
title: Tài khoản
description:
  Tìm hiểu về mô hình tài khoản của Solana, bao gồm cách tài khoản lưu trữ dữ
  liệu và chương trình, cơ chế rent, quyền sở hữu tài khoản và mối quan hệ giữa
  chương trình và tài khoản dữ liệu. Hiểu các khái niệm cốt lõi của hệ thống lưu
  trữ key-value của Solana.
---

Tất cả dữ liệu trên mạng Solana được lưu trữ trong các tài khoản. Bạn có thể coi
mạng Solana như một cơ sở dữ liệu công khai với một bảng Tài khoản duy nhất. Mối
quan hệ giữa một tài khoản và địa chỉ của nó tương tự như một cặp khóa-giá trị,
trong đó khóa là địa chỉ và giá trị là tài khoản.

Mỗi tài khoản đều có cùng [cấu trúc](#account-structure) cơ bản và có thể được
xác định vị trí bằng [địa chỉ](#account-address) của nó.

![Sơ đồ 3 tài khoản và địa chỉ của chúng. Bao gồm định nghĩa cấu trúc tài khoản.](/assets/docs/core/accounts/accounts.png)

## Địa chỉ tài khoản

Địa chỉ tài khoản là một ID duy nhất 32-byte được sử dụng để xác định vị trí tài
khoản trên blockchain Solana. Địa chỉ tài khoản thường được hiển thị dưới dạng
chuỗi mã hóa base58. Hầu hết các tài khoản sử dụng [khóa công khai](#public-key)
[Ed25519](https://ed25519.cr.yp.to/) làm địa chỉ, nhưng điều này không bắt buộc,
vì Solana cũng hỗ trợ
[địa chỉ dẫn xuất từ chương trình](#program-derived-address).

![Một tài khoản với địa chỉ khóa công khai được mã hóa base58](/assets/docs/core/accounts/account-address.svg)

### Khóa công khai

Ví dụ dưới đây minh họa cách sử dụng Solana SDK để tạo một keypair. Một
`Keypair` bao gồm:

- Một khóa công khai đóng vai trò là địa chỉ tài khoản
- Một khóa riêng tư được sử dụng để ký các giao dịch

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner } from "@solana/kit";

// Kit does not enable extractable private keys
const keypairSigner = await generateKeyPairSigner();
console.log(keypairSigner);
```

```ts !! title="Legacy"
import { Keypair } from "@solana/web3.js";

const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);
console.log(`Secret Key: ${keypair.secretKey}`);
```

```rs !! title="Rust"
use solana_sdk::signer::{keypair::Keypair, Signer};

#[tokio::main]
async fn main() {
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());
    println!("Secret Key: {:?}", keypair.to_bytes());
}
```

</CodeTabs>

### Program Derived Address

[Program Derived Address](/docs/core/pda) (PDA) là một địa chỉ được xác định một
cách xác định bằng cách sử dụng ID chương trình và một hoặc nhiều đầu vào tùy
chọn (seeds). Ví dụ dưới đây minh họa cách sử dụng Solana SDK để tạo một Program
Derived Address.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;

const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey; // macro
use solana_sdk::pubkey::Pubkey;

#[tokio::main]
async fn main() {
    let program_address = pubkey!("11111111111111111111111111111111");
    let seeds = [b"helloWorld".as_ref()];
    let (pda, bump) = Pubkey::find_program_address(&seeds, &program_address);
    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
}
```

</CodeTabs>

## Cấu trúc tài khoản

Mỗi
[`Account`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/account/src/lib.rs#L48-L60)
có kích thước tối đa là
[10MiB](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/system_instruction.rs#L85)
và chứa các thông tin sau:

<WithMentions>

- [`lamports`](mention:lamports): Số lượng lamport trong tài khoản
- [`data`](mention:data): Dữ liệu của tài khoản
- [`owner`](mention:owner): ID của chương trình sở hữu tài khoản
- [`executable`](mention:executable): Chỉ ra liệu tài khoản có chứa mã nhị phân
  có thể thực thi hay không
- [`rent_epoch`](mention:rent_epoch): Trường epoch thuê đã không còn được sử
  dụng

```rust title="Account"
pub struct Account {
    /// lamports in the account
    // !mention lamports
    pub lamports: u64,
    /// data held in this account
    #[cfg_attr(feature = "serde", serde(with = "serde_bytes"))]
    // !mention data
    pub data: Vec<u8>,
    /// the program that owns this account. If executable, the program that loads this account.
    // !mention owner
    pub owner: Pubkey,
    /// this account's data contains a loaded program (and is now read-only)
    // !mention executable
    pub executable: bool,
    /// the epoch at which this account will next owe rent
    // !mention rent_epoch
    pub rent_epoch: Epoch,
}
```

</WithMentions>

<ScrollyCoding>

## !!steps Lamports

Số dư tài khoản tính bằng [lamport](/docs/references/terminology#lamport).

Mỗi tài khoản phải có số dư lamport tối thiểu, gọi là
[rent](/docs/references/terminology#rent), cho phép dữ liệu của nó được lưu trữ
trên chuỗi. Rent tỷ lệ thuận với kích thước của tài khoản.

<Callout type="info">
  Mặc dù số dư này được gọi là rent, nó hoạt động giống như một khoản đặt cọc
  hơn, vì toàn bộ số dư có thể được thu hồi khi tài khoản bị đóng. (Tên "rent"
  bắt nguồn từ trường rent epoch đã bị loại bỏ.)
</Callout>

(Xem công thức tính
[số dư tối thiểu](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L93-L97)
và các
[hằng số](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/rent/src/lib.rs#L47-L70)
áp dụng.)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    // !focus
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    // !focus
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Dữ liệu

Trường này thường được gọi là "dữ liệu tài khoản". Dữ liệu trong trường này được
coi là tùy ý vì nó có thể chứa bất kỳ chuỗi byte nào. Mỗi chương trình xác định
cấu trúc của dữ liệu được lưu trữ trong trường này.

- Program account: Trường này chứa mã chương trình có thể thực thi hoặc địa chỉ
  của [tài khoản dữ liệu chương trình](#program-data-accounts) lưu trữ mã chương
  trình có thể thực thi.
- Tài khoản dữ liệu: Trường này thường lưu trữ dữ liệu trạng thái, dùng để đọc.

Đọc dữ liệu từ tài khoản Solana bao gồm hai bước:

1. Lấy tài khoản bằng cách sử dụng [địa chỉ](#account-address) của nó
2. Giải mã trường dữ liệu của tài khoản từ các byte thô thành cấu trúc dữ liệu
   thích hợp, theo định nghĩa của chương trình sở hữu tài khoản.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    // !focus
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    // !focus
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    // !focus
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    // !focus
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Chủ sở hữu

Trường này chứa ID chương trình của chủ sở hữu tài khoản.

Mỗi tài khoản Solana có một [chương trình](/docs/core/programs) được chỉ định
làm chủ sở hữu. Chủ sở hữu tài khoản là chương trình duy nhất có thể thay đổi dữ
liệu của tài khoản hoặc trừ lamport, theo chỉ dẫn của chương trình.

(Trong trường hợp program account, chủ sở hữu là
[chương trình tải](https://solana.com/docs/core/programs#loader-programs) của
nó.)

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    // !focus
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    // !focus
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Có thể thực thi

Trường này chỉ ra liệu một tài khoản là [program account](#program-accounts) hay
[tài khoản dữ liệu](#data-accounts)

- Nếu true: Tài khoản là program account
- Nếu false: Tài khoản là tài khoản dữ liệu

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    // !focus
    executable: false,
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    // !focus
    executable: true,
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

## !!steps Epoch của rent

**Trường rent_epoch đã bị loại bỏ.**

Trong quá khứ, trường này theo dõi khi nào tài khoản cần phải trả rent. Tuy
nhiên, cơ chế thu rent này đã bị loại bỏ.

```rust !! title="Account Examples"
// Example Token Mint Account
Account {
    lamports: 1461600,
    data.len: 82,
    owner: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb,
    executable: false,
    // !focus
    rent_epoch: 0,
    data: 010000001e213c90625a7e643d9555bb01b6c3fe6416d7afd523ce8c7ddd9b923ceafb9d00000000000000000901010000001e213c90625a7e643d9555bb01b6,
}

// Example Token Program Account
Account {
    lamports: 4513200894,
    data.len: 134080,
    owner: BPFLoader2111111111111111111111111111111111,
    executable: true,
    // !focus
    rent_epoch: 18446744073709551615,
    data: 7f454c460201010000000000000000000300f70001000000d8f90000000000004000000000000000800902000000000000000000400038000400400009000800,
}
```

</ScrollyCoding>

## Các loại tài khoản

Có hai loại tài khoản cơ bản:

- [Tài khoản chương trình](#program-accounts): Tài khoản chứa mã thực thi
- [Tài khoản dữ liệu](#data-accounts): Tài khoản không chứa mã thực thi

Sự tách biệt giữa mã của chương trình và trạng thái của nó là một tính năng quan
trọng trong mô hình tài khoản của Solana. (Tương tự như hệ điều hành, thường có
các tệp riêng biệt cho chương trình và dữ liệu của chúng.)

### Tài khoản chương trình

Mỗi chương trình đều thuộc sở hữu của một
[chương trình tải](/docs/core/programs#loader-programs), được sử dụng để triển
khai và quản lý tài khoản. Khi một [chương trình](/docs/core/programs) mới được
triển khai, một tài khoản được tạo ra để lưu trữ mã
[có thể thực thi](#executable) của nó. Đây được gọi là tài khoản chương trình.
(Để đơn giản, bạn có thể coi tài khoản chương trình chính là bản thân chương
trình.)

Trong sơ đồ dưới đây, bạn có thể thấy một chương trình tải được sử dụng để triển
khai một tài khoản chương trình. Trường `data` của tài khoản chương trình chứa
mã chương trình có thể thực thi.

![Sơ đồ của một tài khoản chương trình, 4 thành phần của nó và chương trình tải của nó.](/assets/docs/core/accounts/program-account-simple.svg)

#### Tài khoản dữ liệu chương trình

Các chương trình được triển khai bằng loader-v3 không chứa mã chương trình trong
trường `data` của chúng. Thay vào đó, trường `data` của chúng trỏ đến một **tài
khoản dữ liệu chương trình** riêng biệt, chứa mã chương trình. (Xem sơ đồ dưới
đây.)

![Một tài khoản chương trình với dữ liệu. Dữ liệu trỏ đến một tài khoản dữ liệu chương trình riêng biệt](/assets/docs/core/accounts/program-account-expanded.svg)

<Callout>
  Trong quá trình triển khai hoặc nâng cấp chương trình, các tài khoản đệm được
  sử dụng để tạm thời lưu trữ việc tải lên.
</Callout>

Ví dụ dưới đây lấy thông tin tài khoản Token Program. Lưu ý rằng trường
`executable` được đặt thành `true`, cho biết tài khoản là một chương trình.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { Address, createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc("https://api.mainnet.solana.com");

const programId = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address;

const accountInfo = await rpc
  .getAccountInfo(programId, { encoding: "base64" })
  .send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Connection, PublicKey } from "@solana/web3.js";

const connection = new Connection(
  "https://api.mainnet.solana.com",
  "confirmed"
);

const programId = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

const accountInfo = await connection.getAccountInfo(programId);
// !collapse(1:17) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::pubkey;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let program_id = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let account_info = connection.get_account(&program_id).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

### Tài khoản dữ liệu

Tài khoản dữ liệu không chứa mã thực thi. Thay vào đó, chúng lưu trữ thông tin.

#### Tài khoản trạng thái chương trình

Các chương trình sử dụng tài khoản dữ liệu để duy trì trạng thái của chúng. Để
làm được điều này, trước tiên họ phải tạo một tài khoản dữ liệu mới. Quá trình
tạo tài khoản trạng thái chương trình thường được trừu tượng hóa, nhưng việc
hiểu quy trình cơ bản là hữu ích.

Để quản lý trạng thái của mình, một chương trình mới phải:

1. Gọi [System Program](/docs/core/programs#the-system-program) để tạo một tài
   khoản. (System Program sau đó chuyển quyền sở hữu cho chương trình mới.)
2. Khởi tạo dữ liệu tài khoản, như được định nghĩa bởi
   [hướng dẫn](/docs/core/instructions) của nó.

![Sơ đồ tài khoản dữ liệu thuộc sở hữu của tài khoản chương trình](/assets/docs/core/accounts/data-account.svg)

Ví dụ dưới đây tạo và lấy một tài khoản Token Mint thuộc sở hữu của chương trình
Token 2022.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  fetchMint
} from "@solana-program/token-2022";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer
const feePayer = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Instruction to create new account for mint (token 2022 program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_2022_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token 2022 program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address
});

const instructions = [createAccountInstruction, initializeMintInstruction];

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }), // Create transaction message
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx), // Set fee payer
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), // Set transaction blockhash
  (tx) => appendTransactionMessageInstructions(instructions, tx) // Append instructions
);

// Sign transaction message with required signers (fee payer and mint keypair)
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Mint Address:", mint.address);
console.log("Transaction Signature:", transactionSignature);

const accountInfo = await rpc.getAccountInfo(mint.address).send();
console.log(accountInfo);

const mintAccount = await fetchMint(rpc, mint.address);
console.log(mintAccount);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  createInitializeMintInstruction,
  TOKEN_2022_PROGRAM_ID,
  MINT_SIZE,
  getMinimumBalanceForRentExemptMint,
  getMint
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const recentBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: recentBlockhash.blockhash,
  lastValidBlockHeight: recentBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Generate keypair to use as address of mint
const mint = Keypair.generate();

const createAccountInstruction = SystemProgram.createAccount({
  fromPubkey: feePayer.publicKey,
  newAccountPubkey: mint.publicKey,
  space: MINT_SIZE,
  lamports: await getMinimumBalanceForRentExemptMint(connection),
  programId: TOKEN_2022_PROGRAM_ID
});

const initializeMintInstruction = createInitializeMintInstruction(
  mint.publicKey, // mint pubkey
  9, // decimals
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  TOKEN_2022_PROGRAM_ID
);

const transaction = new Transaction().add(
  createAccountInstruction,
  initializeMintInstruction
);

const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer, mint] // Signers
);

console.log("Mint Address: ", mint.publicKey.toBase58());
console.log("Transaction Signature: ", transactionSignature);

const accountInfo = await connection.getAccountInfo(mint.publicKey);

// !collapse(1:16) collapsed
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);

const mintAccount = await getMint(
  connection,
  mint.publicKey,
  "confirmed",
  TOKEN_2022_PROGRAM_ID
);
console.log(mintAccount);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    program_pack::Pack,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_token_2022_interface::{
    id as token_2022_program_id, instruction::initialize_mint, state::Mint,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let recent_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    let space = Mint::LEN;
    let rent = client.get_minimum_balance_for_rent_exemption(space).await?;

    // Create account instruction
    let create_account_instruction = create_account(
        &fee_payer.pubkey(),      // fee payer
        &mint.pubkey(),           // mint address
        rent,                     // rent
        space as u64,             // space
        &token_2022_program_id(), // program id
    );

    // Initialize mint instruction
    let initialize_mint_instruction = initialize_mint(
        &token_2022_program_id(),
        &mint.pubkey(),            // mint address
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        9,                         // decimals
    )?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[create_account_instruction, initialize_mint_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        recent_blockhash,
    );

    // Send and confirm transaction
    let transaction_signature = client.send_and_confirm_transaction(&transaction).await?;

    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    let account_info = client.get_account(&mint.pubkey()).await?;
    println!("{:#?}", account_info);

    let mint_account = Mint::unpack(&account_info.data)?;
    println!("{:#?}", mint_account);

    Ok(())
}
```

</CodeTabs>

#### Tài khoản hệ thống

Không phải tất cả các tài khoản đều được gán một chủ sở hữu mới sau khi được tạo
bởi System Program. Các tài khoản thuộc sở hữu của System Program được gọi là
tài khoản hệ thống. Tất cả các tài khoản ví đều là tài khoản hệ thống, điều này
cho phép chúng thanh toán [phí giao dịch](docs/core/fees).

![Ví thuộc sở hữu của System Program chứa 1.000.000 lamports](/assets/docs/core/accounts/system-account.svg)

Khi SOL được gửi đến một địa chỉ mới lần đầu tiên, một tài khoản được tạo tại
địa chỉ đó thuộc sở hữu của System Program.

Trong ví dụ dưới đây, một keypair mới được tạo và nạp tiền bằng SOL. Sau khi
chạy mã, bạn có thể thấy địa chỉ của `owner` tài khoản là
`11111111111111111111111111111111`
([System Program](/docs/core/programs#the-system-program)).

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  generateKeyPairSigner,
  lamports
} from "@solana/kit";

// Create a connection to Solana cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate a new keypair
const keypair = await generateKeyPairSigner();
console.log(`Public Key: ${keypair.address}`);

// Funding an address with SOL automatically creates an account
const signature = await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: keypair.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

const accountInfo = await rpc.getAccountInfo(keypair.address).send();
console.log(accountInfo);
```

```ts !! title="Legacy"
import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";

// Generate a new keypair
const keypair = Keypair.generate();
console.log(`Public Key: ${keypair.publicKey}`);

// Create a connection to the Solana cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Funding an address with SOL automatically creates an account
const signature = await connection.requestAirdrop(
  keypair.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature, "confirmed");

const accountInfo = await connection.getAccountInfo(keypair.publicKey);
console.log(JSON.stringify(accountInfo, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signer::{keypair::Keypair, Signer},
};

#[tokio::main]
async fn main() -> Result<()> {
    // Generate a new keypair
    let keypair = Keypair::new();
    println!("Public Key: {}", keypair.pubkey());

    // Create a connection to Solana cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Funding an address with SOL automatically creates an account
    let signature = connection
        .request_airdrop(&keypair.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = connection.confirm_transaction(&signature).await?;
        if confirmed {
            break;
        }
    }

    let account_info = connection.get_account(&keypair.pubkey()).await?;
    println!("{:#?}", account_info);

    Ok(())
}
```

</CodeTabs>

#### Tài khoản Sysvar

Tài khoản Sysvar tồn tại tại các địa chỉ được xác định trước và cung cấp quyền
truy cập vào dữ liệu trạng thái của cụm. Chúng cập nhật động với dữ liệu về cụm
mạng. Xem danh sách đầy đủ của
[Tài khoản Sysvar](https://docs.anza.xyz/runtime/sysvars).

Ví dụ dưới đây lấy và giải mã dữ liệu từ tài khoản Sysvar Clock.

<CodeTabs storage="accounts" flags="r">

```ts !! title="Kit"
import { createSolanaRpc } from "@solana/kit";
import { fetchSysvarClock, SYSVAR_CLOCK_ADDRESS } from "@solana/sysvars";

const rpc = createSolanaRpc("https://api.mainnet.solana.com");

const accountInfo = await rpc
  .getAccountInfo(SYSVAR_CLOCK_ADDRESS, { encoding: "base64" })
  .send();
console.log(accountInfo);

// Automatically fetch and deserialize the account data
const clock = await fetchSysvarClock(rpc);
console.log(clock);
```

```ts !! title="Legacy"
import { Connection, SYSVAR_CLOCK_PUBKEY } from "@solana/web3.js";
import { getSysvarClockCodec } from "@solana/sysvars";

const connection = new Connection(
  "https://api.mainnet.solana.com",
  "confirmed"
);

const accountInfo = await connection.getAccountInfo(SYSVAR_CLOCK_PUBKEY);

// Deserialize the account data
const decodedClock = getSysvarClockCodec().decode(
  new Uint8Array(accountInfo?.data ?? [])
);
console.log(
  JSON.stringify(
    accountInfo,
    (key, value) => {
      if (key === "data" && value && value.length > 1) {
        return [
          value[0],
          "...truncated, total bytes: " + value.length + "...",
          value[value.length - 1]
        ];
      }
      return value;
    },
    2
  )
);
console.log(decodedClock);
```

```rs !! title="Rust"
use anyhow::Result;
use bincode::deserialize;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::sysvar::{self, clock::Clock};

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "https://api.mainnet.solana.com".to_string(),
        CommitmentConfig::confirmed(),
    );

    let account = connection.get_account(&sysvar::clock::ID).await?;
    // Deserialize the account data
    let clock: Clock = deserialize(&account.data)?;

    println!("{:#?}", account);
    println!("{:#?}", clock);

    Ok(())
}
```

</CodeTabs>
