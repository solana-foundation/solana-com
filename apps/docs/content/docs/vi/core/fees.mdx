---
title: Phí giao dịch
description:
  Tìm hiểu về phí giao dịch của Solana, bao gồm phí cơ bản và phí ưu tiên, cách
  áp dụng từng loại phí, và các phương pháp tốt nhất để quản lý đơn vị tính toán
  trong giao dịch của bạn.
---

Mỗi giao dịch Solana đều yêu cầu một khoản phí giao dịch, được thanh toán bằng
SOL. Phí giao dịch được chia thành hai phần: phí cơ bản và phí ưu tiên. Phí cơ
bản bù đắp cho các validator khi xử lý giao dịch. Phí ưu tiên là một khoản phí
tùy chọn, nhằm tăng khả năng leader hiện tại sẽ xử lý giao dịch của bạn.

## Phí cơ bản

Mỗi giao dịch tốn 5000 [lamports](/docs/references/terminology#lamport) cho mỗi
chữ ký được bao gồm. Khoản phí này được thanh toán bởi người ký đầu tiên trong
giao dịch. Chỉ các tài khoản thuộc sở hữu của System Program mới có thể thanh
toán phí giao dịch. Phí cơ bản được phân chia như sau:

- **50% bị đốt:** Một nửa bị
  [đốt](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (loại bỏ khỏi nguồn cung SOL lưu thông).
- **50% được phân phối:** Một nửa được
  [trả cho validator](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
  đã xử lý giao dịch.

## Phí ưu tiên

[Phí ưu tiên](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
là một khoản phí tùy chọn được sử dụng để tăng khả năng leader hiện tại
(validator) sẽ xử lý giao dịch của bạn. Validator nhận
[100% phí ưu tiên](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Phí ưu tiên có thể được thiết lập bằng cách điều chỉnh giá
[đơn vị tính toán](/docs/references/terminology#compute-units) (CU) và giới hạn
CU của giao dịch. (Xem
[hướng dẫn Cách sử dụng phí ưu tiên](/developers/guides/advanced/how-to-use-priority-fees)
để biết thêm chi tiết về phí ưu tiên.)

Phí ưu tiên được tính như sau:

```text title="Prioritization fee formula"
Prioritization fee = CU limit * CU price
```

Phí ưu tiên được sử dụng để xác định
[mức độ ưu tiên của giao dịch](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646)
của bạn, so với các giao dịch khác. Nó được tính bằng công thức sau:

```text title="Transaction priority formula"
Priority = (Prioritization fee + Base fee) / (1 + CU limit + Signature CUs + Write lock CUs)
```

#### Giới hạn đơn vị tính toán

Theo
[mặc định](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
mỗi instruction được phân bổ
[200.000 CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
và mỗi giao dịch được phân bổ
[1,4 triệu CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14).
Bạn có thể thay đổi các giá trị mặc định này bằng cách bao gồm một instruction
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
trong giao dịch của bạn.

Để tính toán giới hạn CU phù hợp cho giao dịch của bạn, chúng tôi khuyến nghị
các bước sau:

1. Ước tính số đơn vị CU cần thiết bằng cách
   [mô phỏng](/developers/guides/advanced/how-to-request-optimal-compute) giao
   dịch
2. Thêm 10% dự phòng an toàn vào ước tính này

<Callout type="warn">
  Phí ưu tiên được xác định bởi giới hạn đơn vị tính toán được yêu cầu trong
  giao dịch, *không phải* số lượng đơn vị tính toán thực tế được sử dụng. Nếu
  bạn đặt giới hạn đơn vị tính toán quá cao hoặc sử dụng số lượng mặc định, bạn
  có thể phải trả cho các đơn vị tính toán không sử dụng.
</Callout>

#### Giá đơn vị tính toán

Giá đơn vị tính toán là số lượng tùy chọn
[micro-lamports](/docs/references/terminology#micro-lamports) được trả cho mỗi
CU được yêu cầu. Bạn có thể coi giá CU như một khoản tip để khuyến khích
validator ưu tiên giao dịch của bạn. Để đặt giá CU, hãy bao gồm một instruction
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
trong giao dịch của bạn.

<Callout>
  Giá CU mặc định là 0, nghĩa là phí ưu tiên mặc định cũng là 0.
</Callout>

Để được trợ giúp xác định giá CU tốt nhất cho giao dịch của bạn, hãy xem khuyến
nghị giá CU theo thời gian thực được liệt kê trong bảng dưới đây.

| Nhà cung cấp                            | API phí ưu tiên                                                              |
| --------------------------------------- | ---------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [Tài liệu](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Tài liệu](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Tài liệu](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Ví dụ

Các ví dụ dưới đây cho thấy cách đặt giới hạn CU và giá CU trên một giao dịch sử
dụng Solana SDK.

| SDK                            | Tham chiếu mã nguồn                                                                                                            |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
