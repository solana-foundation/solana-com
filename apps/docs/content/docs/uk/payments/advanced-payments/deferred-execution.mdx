---
title: Відкладене виконання
description:
  Підписуйте транзакції зараз, виконуйте пізніше — забезпечуючи робочі процеси
  затвердження, операції казначейства та безпечне підписання
---

Кожна транзакція Solana містить нещодавній blockhash — посилання на недавній
стан мережі, що підтверджує створення транзакції "зараз". Мережа відхиляє
будь-яку транзакцію з blockhash старішим за ~150 блоків (~60-90 секунд),
запобігаючи атакам повторного відтворення та застарілим поданням. Це ідеально
працює для платежів у реальному часі. Але це порушує робочі процеси, які
потребують проміжку між підписанням та поданням, наприклад:

| Сценарій                         | Чому стандартні транзакції не працюють                                                         |
| -------------------------------- | ---------------------------------------------------------------------------------------------- |
| **Операції казначейства**        | Фінансовий директор у Токіо підписує, контролер у Нью-Йорку затверджує — 90 секунд недостатньо |
| **Робочі процеси комплаєнсу**    | Транзакції потребують юридичної перевірки/перевірки відповідності перед виконанням             |
| **Підписання холодного сховища** | Ізольовані машини вимагають ручного передавання підписаних транзакцій                          |
| **Підготовка пакетів**           | Підготовка зарплати або виплат у робочий час, виконання вночі                                  |
| **Координація мультипідпису**    | Кілька затверджувачів у різних часових поясах                                                  |
| **Заплановані платежі**          | Планування платежів для виконання в майбутню дату                                              |

У традиційних фінансах підписаний чек не втрачає чинності через 90 секунд. Певні
блокчейн-операції також не повинні. **Довговічні nonce** вирішують це, замінюючи
нещодавній blockhash збереженим, постійним значенням, яке змінюється лише тоді,
коли ви його використовуєте — надаючи вам транзакції, що залишаються дійсними,
доки ви не будете готові їх подати.

## Як це працює

Замість нещодавнього blockhash (дійсний ~150 блоків) ви використовуєте
**nonce-акаунт**, спеціальний акаунт, що зберігає _унікальне_ значення. Кожна
транзакція, що використовує цей nonce, повинна "просунути" його як першу
інструкцію, запобігаючи атакам повторного відтворення.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  STANDARD BLOCKHASH                                                         │
│                                                                             │
│    ┌──────┐      ┌──────────┐                                               │
│    │ Sign │ ───▶ │  Submit  │     ⏱️ Must happen within ~90 seconds         │
│    └──────┘      └──────────┘                                               │
│       │                                                                     │
│       └─────────  Transaction expires if not submitted in time              │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  DURABLE NONCE                                                              │
│                                                                             │
│    ┌──────┐      ┌───────┐       ┌─────────┐      ┌──────────┐              │
│    │ Sign │ ───▶ │ Store │ ───▶  │ Approve │ ───▶ │  Submit  │              │
│    └──────┘      └───────┘       └─────────┘      └──────────┘              │
│                                                                             │
│    Transaction remains valid until you submit it                            │
└─────────────────────────────────────────────────────────────────────────────┘
```

<Callout type="info">
  Обліковий запис nonce коштує ~0.0015 SOL для звільнення від rent. Один
  обліковий запис nonce = одна очікувана транзакція одночасно. Для паралельних
  робочих процесів створіть кілька облікових записів nonce.
</Callout>

## Налаштування: створення облікового запису nonce

Створення облікового запису nonce вимагає двох інструкцій в одній транзакції:

1. **Створіть обліковий запис** за допомогою `getCreateAccountInstruction` із
   системної програми
2. **Ініціалізуйте його як nonce** за допомогою
   `getInitializeNonceAccountInstruction`

```ts
import { generateKeyPairSigner } from "@solana/kit";
import {
  getNonceSize,
  getCreateAccountInstruction,
  getInitializeNonceAccountInstruction,
  SYSTEM_PROGRAM_ADDRESS
} from "@solana-program/system";

// Generate a keypair for the nonce account address
const nonceKeypair = await generateKeyPairSigner();

// Get required account size for rent calculation
const space = BigInt(getNonceSize());

// 1. Create the account (owned by System Program)
getCreateAccountInstruction({
  payer,
  newAccount: nonceKeypair,
  lamports: rent,
  space,
  programAddress: SYSTEM_PROGRAM_ADDRESS
});

// 2. Initialize as nonce account
getInitializeNonceAccountInstruction({
  nonceAccount: nonceKeypair.address,
  nonceAuthority: authorityAddress // Controls nonce advancement
});

// Assemble and send transaction to the network
```

## Побудова відкладеної транзакції

Замість останнього блокхешу використовуйте значення nonce як час життя
транзакції. Для цього спочатку потрібно отримати значення nonce з nonce-акаунта,
а потім використати його для встановлення часу життя транзакції.

### Отримання значення nonce

Спочатку отримайте значення nonce з nonce-акаунта:

```ts
import { fetchNonce } from "@solana-program/system";

const nonceAccount = await fetchNonce(rpc, nonceAddress);
const nonceValue = nonceAccount.data.blockhash; // Use this as your "blockhash"
```

### Встановлення терміну дії транзакції за допомогою nonce

Замість використання останнього блокхешу, який втрачає чинність, використовуйте
`setTransactionMessageLifetimeUsingDurableNonce`. Ця функція виконує дві дії:

1. Встановлює значення nonce як "blockhash" транзакції
2. Автоматично додає інструкцію `advanceNonceAccount` на початок (обов'язково як
   перша інструкція у всіх durable nonce транзакціях)

```ts
import {
  setTransactionMessageLifetimeUsingDurableNonce,
  type Nonce
} from "@solana/kit";

setTransactionMessageLifetimeUsingDurableNonce(
  {
    nonce: nonceAccount.data.blockhash as Nonce,
    nonceAccountAddress: nonceAddress,
    nonceAuthorityAddress: authorityAddress
  },
  transactionMessage
);
```

## Підписання та збереження

Після створення підпишіть транзакцію та серіалізуйте її для збереження:

```ts
import {
  signTransactionMessageWithSigners,
  getBase64EncodedWireTransaction
} from "@solana/kit";

// Sign the transaction
const signedTx = await signTransactionMessageWithSigners(transactionMessage);

// Serialize for storage (database, file, etc.)
const serialized = getBase64EncodedWireTransaction(signedTx);
```

Збережіть серіалізований рядок у вашій базі даних — він залишається дійсним,
доки nonce не буде просунуто.

## Робочий процес багатостороннього схвалення

Десеріалізуйте транзакцію, щоб додати додаткові підписи, потім знову
серіалізуйте для збереження або відправлення:

```ts
import {
  getBase64Decoder,
  getTransactionDecoder,
  getBase64EncodedWireTransaction,
  partiallySignTransaction
} from "@solana/kit";

// Deserialize the stored transaction
const txBytes = getBase64Decoder().decode(serializedString);
const partiallySignedTx = getTransactionDecoder().decode(txBytes);

// Each approver adds their signature
const fullySignedTx = await partiallySignTransaction(
  [newSigner],
  partiallySignedTx
);

// Serialize again for storage or submission
const serialized = getBase64EncodedWireTransaction(fullySignedTx);
```

Транзакцію можна серіалізувати, зберігати та передавати між учасниками
схвалення. Після збору всіх необхідних підписів відправте її в мережу.

## Виконання за готовності

Коли всі схвалення отримано, надішліть серіалізовану транзакцію в мережу:

```ts
const signature = await rpc
  .sendTransaction(serializedTransaction, { encoding: "base64" })
  .send();
```

<Callout type="caution">
  Кожен nonce можна використати лише один раз. Якщо транзакція не вдалася або ви
  вирішили її не відправляти, необхідно просунути nonce перед підготовкою іншої
  транзакції з тим самим nonce-акаунтом.
</Callout>

## Просування використаного або відхиленого nonce

Щоб анулювати очікувану транзакцію або підготувати nonce для повторного
використання, просуньте його вручну:

```ts
import { getAdvanceNonceAccountInstruction } from "@solana-program/system";

// Submit this instruction (with a regular blockhash) to invalidate any pending transaction
getAdvanceNonceAccountInstruction({
  nonceAccount: nonceAddress,
  nonceAuthority
});
```

Це генерує нове значення nonce, роблячи будь-яку транзакцію, підписану старим
значенням, назавжди недійсною.

## Міркування щодо продакшену

**Управління nonce-акаунтами:**

- Створіть пул nonce-акаунтів для паралельної підготовки транзакцій
- Відстежуйте, які nonce «використовуються» (мають очікувані підписані
  транзакції)
- Реалізуйте повторне використання nonce після надсилання або скасування
  транзакцій

**Безпека:**

- Nonce authority контролює, чи можна анулювати транзакції. Розгляньте
  можливість відокремлення nonce authority від підписувачів транзакцій для
  додаткового контролю та розподілу обов'язків
- _Будь-хто_, хто має серіалізовані байти транзакції, може надіслати її в мережу

## Пов'язані ресурси

- [Вступ до Durable Nonces](https://solana.com/developers/guides/advanced/introduction-to-durable-nonces)
