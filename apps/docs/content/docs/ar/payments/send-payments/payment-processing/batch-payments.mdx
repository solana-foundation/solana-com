---
title: الدفعات المجمعة
description: تعلم كيفية الدفع لعدة مستلمين في معاملة واحدة.
---

معاملة سولانا هي حاوية تحتوي على تعليمة واحدة أو أكثر. كل تعليمة هي عملية—تحويل
الرموز، إنشاء حساب، استدعاء برنامج. تنفذ الشبكة جميع التعليمات في المعاملة بشكل
تسلسلي وذري: إما أن تنجح كل تعليمة، أو تفشل المعاملة بأكملها وتتراجع.

هذا يعني أنه يمكنك تجميع عدة تحويلات في معاملة واحدة. بدلاً من إرسال ثلاث
معاملات منفصلة للدفع لثلاثة مستلمين، ترسل معاملة واحدة تحتوي على ثلاث تعليمات
تحويل. هذا أسرع (تأكيد واحد بدلاً من ثلاثة) وأرخص (رسوم أساسية واحدة بدلاً من
ثلاثة). إليك مثال توضيحي لكيفية تجميع المدفوعات (المشار إليها باسم "drops" في
هذه الصورة) في معاملة واحدة وإرسال معاملات متعددة للتعامل مع الدفعة الأكبر.

![مخطط الدفعات المجمعة](/assets/docs/payments/qn-bulk-send.png)

_المصدر:
[QuickNode - كيفية إرسال معاملات مجمعة على سولانا](https://www.quicknode.com/guides/solana-development/transactions/how-to-send-bulk-transactions-on-solana)_

لمزيد من المعلومات حول المعاملات والتعليمات، راجع دليل
[المعاملات](/docs/core/transactions) ودليل [التعليمات](/docs/core/instructions).

يوضح الشرح أدناه كيفية تحميل تعليمات تحويل متعددة في معاملة واحدة للدفعات
المجمعة.

## تجميع التعليمات في معاملة واحدة

يمكن أن تحتوي معاملة سولانا على تحويلات متعددة لمستلمين مختلفين. توقع مرة واحدة،
وتدفع رسوم معاملة واحدة، وتتم تسوية جميع التحويلات معاً. إذا فشل أي تحويل، يتم
رفض المعاملة بأكملها.

<Callout>
  راجع [كيفية عمل المدفوعات على سولانا](/docs/payments/how-payments-work)
  لمفاهيم الدفع الأساسية.
</Callout>

يتطلب تجميع تحويلات متعددة بناء كل تعليمة بشكل منفصل، ثم دمجها في معاملة واحدة.

توضح الخطوات أدناه التدفق الأساسي. راجع [العرض التوضيحي](#demo) للحصول على كود
كامل قابل للتشغيل.

<ScrollyCoding>

## !!steps اشتقاق حسابات الرموز

أولاً، اشتق عناوين حساب الرموز المرتبط (ATA) للمرسل ولكل مستلم. حسابات ATA هي
عناوين حتمية تعتمد على المحفظة والنعناع.

<CodePlaceholder title="دفعات مجمعة" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});
```

## !!steps إنشاء تعليمات التحويل

أنشئ تعليمة تحويل منفصلة لكل مستلم. تحدد كل تعليمة:

- عنوان حساب الرموز المصدر
- عنوان حساب الرموز الوجهة
- السلطة (عنوان مالك حساب الرموز المصدر)
- المبلغ بالوحدات الأساسية (معدل حسب الكسور العشرية للنعناع)

<CodePlaceholder title="دفعات مجمعة" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !focus(1:12)
const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});
```

## !!steps الإرسال كمعاملة واحدة

أضف جميع تعليمات التحويل في معاملة واحدة. ينفذ هذا جميع التحويلات بشكل ذري، إما
تنجح جميع التحويلات أو تفشل المعاملة بأكملها.

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});

// !focus(1:5)
const signature = await client.transaction.prepareAndSend({
  authority: sender,
  // !mark
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});
```

## !!steps التحقق من الأرصدة

بعد التحويل المجمع، تحقق من أرصدة الرموز لجميع الأطراف باستخدام مساعد
`splToken`.

<CodePlaceholder title="دفعات مجمعة" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});

const signature = await client.transaction.prepareAndSend({
  authority: sender,
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});

// !focus(1:8)
const splToken = client.splToken({
  mint: mint.address,
  tokenProgram: "auto"
});

const senderBalance = await splToken.fetchBalance(sender.address);
const recipient1Balance = await splToken.fetchBalance(recipient1.address);
const recipient2Balance = await splToken.fetchBalance(recipient2.address);
```

</ScrollyCoding>

### عرض توضيحي

<CodeTabs flags="r">

```ts !! title="Demo"
// !collapse(1:14) collapsed
// Click ">" icon on left to expand demo imports
import { createClient, lamports } from "@solana/client";
import { generateKeypair } from "@solana/client/server";
import type { ServerKeypair } from "@solana/client/server";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getCreateAssociatedTokenInstructionAsync,
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  findAssociatedTokenPda,
  getMintToInstruction,
  getTransferInstruction
} from "@solana-program/token-2022";

// Generate keypairs for sender and two recipients
const sender = (await generateKeypair()).signer;
const recipient1 = (await generateKeypair()).signer;
const recipient2 = (await generateKeypair()).signer;

console.log("Sender Address:", sender.address);
console.log("Recipient 1 Address:", recipient1.address);
console.log("Recipient 2 Address:", recipient2.address);

// Demo Setup: Create client, mint account, token accounts, and fund with initial tokens
const { client, mint } = await demoSetup(sender, recipient1, recipient2);

console.log("\nMint Address:", mint.address);

// Derive the Associated Token Accounts addresses (ATAs) for sender and recipients
// !mark(1:5)
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !mark(1:5)
const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !mark(1:5)
const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

console.log("Sender Token Account:", senderAta.toString());
console.log("Recipient 1 Token Account:", recipient1Ata.toString());
console.log("Recipient 2 Token Account:", recipient2Ata.toString());

// =============================================================================
// Batch Token Payment Demo
// =============================================================================

// Create instructions to transfer tokens from sender to both recipients
// Transferring 250,000 base units = 0.25 tokens (with 6 decimals) to each
// !mark(1:6)
const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n // 0.25 tokens
});

// !mark(1:6)
const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n // 0.25 tokens
});

// Prepare and send both transfers in a single transaction using @solana/client
const signature = await client.transaction.prepareAndSend({
  authority: sender,
  // !mark
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});

console.log("\n=== Batch Token Payment Complete ===");
console.log("Transaction Signature:", signature.toString());

// Fetch final token account balances using @solana/client SPL token helper
const splToken = client.splToken({
  mint: mint.address,
  tokenProgram: "auto"
});

const senderBalance = await splToken.fetchBalance(sender.address);
const recipient1Balance = await splToken.fetchBalance(recipient1.address);
const recipient2Balance = await splToken.fetchBalance(recipient2.address);

console.log("\nSender Token Account Balance:", senderBalance);
console.log("Recipient 1 Token Account Balance:", recipient1Balance);
console.log("Recipient 2 Token Account Balance:", recipient2Balance);

// =============================================================================
// Demo Setup Helper Function
// =============================================================================
// !collapse(1:1000) collapsed

/**
 * Sets up for a batch token transfer demo:
 * - Creates @solana/client instance
 * - Airdrops SOL to sender for transaction fees
 * - Generates mint keypair and creates/initializes mint account
 * - Creates associated token accounts for sender and both recipients
 * - Mints initial tokens to sender
 *
 * @param sender - The sender's keypair (will be funded and used as mint authority)
 * @param recipient1 - The first recipient's keypair
 * @param recipient2 - The second recipient's keypair
 * @returns Returns client instance and mint address
 */
async function demoSetup(
  sender: ServerKeypair["signer"],
  recipient1: ServerKeypair["signer"],
  recipient2: ServerKeypair["signer"]
) {
  // Create @solana/client instance pointing to local validator
  const client = createClient({
    endpoint: "http://localhost:8899",
    websocketEndpoint: "ws://localhost:8900",
    commitment: "confirmed",
    logger: () => {} // Disable all logs
  });

  // Fund sender with SOL for transaction fees using @solana/client actions
  await client.actions.requestAirdrop(sender.address, lamports(1_000_000_000n));

  // Generate keypair to use as address of mint
  const mint = (await generateKeypair()).signer;

  // Get default mint account size (in bytes), no extensions enabled
  const space = BigInt(getMintSize());

  // Get minimum balance for rent exemption
  const rent = await client.runtime.rpc
    .getMinimumBalanceForRentExemption(space)
    .send();

  // Instruction to create new account for mint (token program)
  // Invokes the system program
  const createAccountInstruction = getCreateAccountInstruction({
    payer: sender,
    newAccount: mint,
    lamports: rent,
    space,
    programAddress: TOKEN_2022_PROGRAM_ADDRESS
  });

  // Instruction to initialize mint account data
  // Invokes the token 2022 program
  const initializeMintInstruction = getInitializeMintInstruction({
    mint: mint.address,
    decimals: 6,
    mintAuthority: sender.address
  });

  // Derive sender's associated token account address (ATA)
  const [senderAta] = await findAssociatedTokenPda({
    mint: mint.address,
    owner: sender.address,
    tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
  });

  // Create instruction for sender's ATA
  const createSenderAtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: sender.address
    });

  // Create instruction for recipient 1's ATA
  const createRecipient1AtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: recipient1.address
    });

  // Create instruction for recipient 2's ATA
  const createRecipient2AtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: recipient2.address
    });

  // Create instruction to mint initial tokens to sender
  const mintToInstruction = getMintToInstruction({
    mint: mint.address,
    token: senderAta,
    mintAuthority: sender.address,
    amount: 1_000_000n // Mint 1.00 tokens (1,000,000 base units with 6 decimals)
  });

  // Combine all instructions and send using @solana/client transaction helper
  const setupInstructions = [
    createAccountInstruction, // Create mint account
    initializeMintInstruction, // Initialize mint
    createSenderAtaInstruction, // Create sender's ATA
    createRecipient1AtaInstruction, // Create recipient 1's ATA
    createRecipient2AtaInstruction, // Create recipient 2's ATA
    mintToInstruction // Mint tokens to sender
  ];

  // Prepare and send transaction using @solana/client
  await client.transaction.prepareAndSend({
    authority: sender,
    instructions: setupInstructions,
    version: 0
  });

  return {
    client,
    mint
  };
}
```

</CodeTabs>

## التوسع مع تخطيط المعاملات

تحتوي المعاملة الواحدة على حدود حجم—حوالي 1232 بايت. بالنسبة للعمليات المجمعة
الكبيرة (كشوف المرتبات لمئات الموظفين، الإسقاطات الجوية الجماعية)، ستتجاوز هذا
الحد وستحتاج إلى تقسيم العمل عبر معاملات متعددة.

على الرغم من أنك مرحب بك لإنشاء منطق توزيع المعاملات الخاص بك، فإن حزمة
[`@solana/instruction-plans`](https://www.solanakit.com/docs/concepts/instruction-plans)
(جزء من Solana Kit) تتعامل مع هذا على مستويين:

**خطط التعليمات** تحدد عملياتك وقيود الترتيب الخاصة بها:

- **تسلسلية** — تعليمات يجب تنفيذها بالترتيب
- **متوازية** — تعليمات يمكن تنفيذها بأي ترتيب
- **غير قابلة للتقسيم** — تعليمات يجب أن تبقى معاً في نفس المعاملة

**خطط المعاملات** يتم إنشاؤها من خطط التعليمات. يقوم المخطط بتعبئة التعليمات
بذكاء في معاملات ذات حجم أمثل، مع احترام قيود الترتيب الخاصة بك. يمكن بعد ذلك
لخطة المعاملة الناتجة أن:

- **تُنفذ** — يتم توقيعها وإرسالها إلى الشبكة، مع إرسال المعاملات المتوازية بشكل
  متزامن
- **تُحاكى** — تُختبر مقابل الشبكة للتحقق قبل الإرسال
- **تُسلسل** — تُجمع إلى base64 لخدمات التوقيع الخارجية أو سير العمل متعدد
  الأطراف

يتيح لك هذا النهج ذو المستويين التفكير من حيث العمليات ("تحويل إلى Alice، ثم
تحويل إلى Bob") بينما تتعامل المكتبة مع آليات حجم المعاملة والتعبئة والتنفيذ
المتوازي.
