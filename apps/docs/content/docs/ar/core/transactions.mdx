---
title: المعاملات
description:
  تعرف على معاملات سولانا - اللبنات الأساسية للتفاعل مع بلوكتشين سولانا. افهم
  بنية المعاملات وتكوين التعليمات مع أمثلة عملية.
---

للتفاعل مع شبكة سولانا، يجب عليك إرسال معاملة. يمكنك التفكير في المعاملة كمظروف
يحتوي على عدة نماذج. كل نموذج هو تعليمة تخبر الشبكة بما يجب القيام به. إرسال
المعاملة يشبه إرسال المظروف بالبريد حتى يمكن معالجة النماذج.

يوضح المثال أدناه نسخة مبسطة من معاملتين. عند معالجة المعاملة الأولى، ستنفذ
تعليمة واحدة. عند معالجة المعاملة الثانية، ستنفذ ثلاث تعليمات **بترتيب متسلسل**:
أولاً التعليمة 1، تليها التعليمة 2، ثم التعليمة 3.

<Callout type="warn">
  المعاملات **ذرية**: إذا فشلت تعليمة واحدة، ستفشل المعاملة بأكملها ولن تحدث أي
  تغييرات.
</Callout>

![رسم توضيحي مبسط يوضح معاملتين](/assets/docs/core/transactions/transaction-simple.svg)

تتكون
[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
من المعلومات التالية:

<WithMentions>

- [`signatures`](mention:signatures): مصفوفة من [التوقيعات](#signatures)
- [`message`](mention:message): معلومات المعاملة، بما في ذلك قائمة التعليمات
  المراد معالجتها

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![رسم توضيحي يوضح جزأي المعاملة](/assets/docs/core/transactions/tx_format.png)

تحتوي المعاملات على حد إجمالي للحجم يبلغ
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
بايت. يشمل هذا الحد كلاً من مصفوفة [`signatures`](#signatures) وبنية
[`message`](#message).

<Callout>
  تم تصميم هذا الحد لتجنب تجزئة الحزم على البنية التحتية النموذجية للإنترنت. في
  حين أن IPv6 يدعم وحدات نقل البيانات (MTUs) الأكبر من 9000 بايت، إلا أن معظم
  أجهزة توجيه الإنترنت تستخدم وحدة نقل بيانات افتراضية تبلغ 1500 بايت (إيثرنت
  قياسي). لضمان ملاءمة المعاملات ضمن حزمة واحدة دون تجزئة، تستخدم سولانا 1280
  بايت (الحد الأدنى لوحدة نقل البيانات المطلوبة لـ IPv6) ناقص 48 بايت لرؤوس
  الشبكة (40 بايت IPv6 + 8 بايت رأس التجزئة/UDP)، مما يؤدي إلى حد حجم المعاملة
  البالغ 1232 بايت.
</Callout>

![رسم توضيحي يوضح تنسيق المعاملة وحدود الحجم](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## التوقيعات

تحتوي مصفوفة `signatures` الخاصة بالمعاملة على بنيات `Signature`. كل
[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
يبلغ حجمه 64 بايت ويتم إنشاؤه من خلال توقيع `Message` الخاص بالمعاملة باستخدام
المفتاح الخاص للحساب. يجب توفير توقيع لكل [حساب موقّع](#account-addresses) مضمّن
في أي من تعليمات المعاملة.

التوقيع الأول ينتمي إلى الحساب الذي سيدفع
[الرسوم الأساسية](docs/core/fees#base-fee) للمعاملة وهو توقيع المعاملة. يمكن
استخدام توقيع المعاملة للبحث عن تفاصيل المعاملة على الشبكة.

## الرسالة

يعتبر `message` الخاص بالمعاملة بنية
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)
تحتوي على المعلومات التالية:

<WithMentions>

- [`header`](mention:message-header): [رأس](#header) الرسالة
- [`account_keys`](mention:account-addresses): مصفوفة من
  [عناوين الحسابات](#account-addresses) المطلوبة لتعليمات المعاملة
- [`recent_blockhash`](mention:recent-blockhash): [blockhash](#recent-blockhash)
  يعمل كطابع زمني للمعاملة
- [`instructions`](mention:instructions): مصفوفة من [التعليمات](#instructions)

<Callout>
  لتوفير المساحة، لا تقوم المعاملة بتخزين الأذونات لكل حساب بشكل فردي. بدلاً من
  ذلك، يتم تحديد أذونات الحساب باستخدام `header` و `account_keys`.
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### الرأس

<WithMentions>

يعتبر `header` الخاص بالرسالة بنية
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97).
يحتوي على المعلومات التالية:

- [`num_required_signatures`](mention:num_required_signatures): العدد الإجمالي
  للتوقيعات المطلوبة من قبل المعاملة
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts): العدد
  الإجمالي للحسابات للقراءة فقط التي تتطلب توقيعات
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts):
  العدد الإجمالي للحسابات للقراءة فقط التي لا تتطلب توقيعات

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![رسم توضيحي يوضح الأجزاء الثلاثة لرأس الرسالة](/assets/docs/core/transactions/message_header.png)

### عناوين الحسابات

إن
[`account_keys`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
الخاص بالرسالة هو مصفوفة من عناوين الحسابات، يتم إرسالها بتنسيق
[مصفوفة مضغوطة](/docs/references/terminology#compact-array-format). يشير بادئة
المصفوفة إلى طولها. كل عنصر في المصفوفة هو مفتاح عام، يشير إلى حساب تستخدمه
التعليمات الخاصة به. يجب أن تكون مصفوفة `accounts_keys` كاملة ومرتبة بشكل صارم،
على النحو التالي:

1. موقّع + قابل للكتابة
2. موقّع + للقراءة فقط
3. ليس موقّعًا + قابل للكتابة
4. ليس موقّعًا + للقراءة فقط

<Callout>
  يسمح الترتيب الصارم بدمج مصفوفة `account_keys` مع المعلومات الموجودة في
  [`header`](#header) الخاص بالرسالة لتحديد الأذونات لكل حساب.
</Callout>

![رسم توضيحي يوضح ترتيب مصفوفة عناوين الحسابات](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### كتلة التجزئة الأخيرة

إن `recent_blockhash` الخاص بالرسالة هو قيمة تجزئة تعمل كطابع زمني للمعاملة
وتمنع المعاملات المكررة. تنتهي صلاحية blockhash بعد
[150 كتلة](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134).
(ما يعادل دقيقة واحدة—بافتراض أن كل كتلة تستغرق 400 ميلي ثانية.) بعد انتهاء
صلاحية الكتلة، تنتهي صلاحية المعاملة ولا يمكن معالجتها.

<Callout>
  تتيح لك طريقة [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) في RPC
  الحصول على blockhash الحالي وآخر ارتفاع للكتلة الذي سيكون عنده blockhash
  صالحاً.
</Callout>

### التعليمات

إن
[`instructions`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
الخاص بالرسالة هو مصفوفة من جميع التعليمات المراد معالجتها، يتم إرسالها بتنسيق
[مصفوفة مضغوطة](/docs/references/terminology#compact-array-format). تشير بادئة
المصفوفة إلى طولها. كل عنصر في المصفوفة هو بنية
[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
وتتضمن المعلومات التالية:

<WithMentions>

1. [`program_id_index`](mention:program-id-index): فهرس يشير إلى عنوان في مصفوفة
   [`account_keys`](#account-addresses). تشير هذه القيمة إلى عنوان البرنامج الذي
   يعالج التعليمات.
2. [`accounts`](mention:account-indexes): مصفوفة من الفهارس تشير إلى عناوين في
   مصفوفة `account_keys`. يشير كل فهرس إلى عنوان حساب مطلوب لهذه التعليمات.
3. [`data`](mention:instruction-data): مصفوفة بايتات تحدد التعليمات المراد
   استدعاؤها على البرنامج. كما تتضمن أي بيانات إضافية مطلوبة للتعليمات. (على
   سبيل المثال، وسائط الدالة)

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![مصفوفة مضغوطة من التعليمات](/assets/docs/core/transactions/compact_array_of_ixs.png)

## مثال على بنية المعاملة

يوضح المثال التالي بنية معاملة تحتوي على تعليمة واحدة لتحويل SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
يوضح الكود أدناه الناتج من مقتطفات الكود السابقة.
يختلف التنسيق بين مجموعات أدوات التطوير (SDKs)،
ولكن لاحظ أن كل تعليمة تحتوي على نفس المعلومات المطلوبة.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

بعد إرسال المعاملة، يمكنك استرداد تفاصيلها باستخدام توقيع المعاملة وطريقة RPC
[getTransaction](/docs/rpc/http/gettransaction). سيكون للاستجابة بنية مشابهة
للمقتطف التالي.

<Callout>
  يمكنك أيضًا العثور على المعاملة باستخدام [مستكشف
  سولانا](https://explorer.solana.com).
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
