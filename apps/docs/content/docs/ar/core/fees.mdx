---
title: رسوم المعاملات
description:
  تعرف على رسوم معاملات سولانا، بما في ذلك الرسوم الأساسية ورسوم الأولوية،
  وكيفية تطبيق كل منها، وأفضل الممارسات لإدارة وحدات الحوسبة في معاملاتك.
---

تتطلب كل معاملة على سولانا رسوم معاملة، تُدفع بعملة SOL. تنقسم رسوم المعاملات
إلى جزأين: الرسوم الأساسية ورسوم الأولوية. تعوض الرسوم الأساسية المدققين عن
معالجة المعاملة. رسوم الأولوية هي رسوم اختيارية، لزيادة فرصة قيام القائد الحالي
بمعالجة معاملتك.

## الرسوم الأساسية

تكلف كل معاملة 5000 [لامبورت](/docs/references/terminology#lamport) لكل توقيع
مضمن. يتم دفع هذه الرسوم من قبل الموقع الأول على المعاملة. يمكن فقط للحسابات
المملوكة من قبل System Program دفع رسوم المعاملات. يتم تقسيم الرسوم الأساسية على
النحو التالي:

- **50% يتم حرقها:** يتم
  [حرق](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  النصف (إزالته من المعروض المتداول من SOL).
- **50% يتم توزيعها:** يتم
  [دفع](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
  النصف إلى المدقق الذي عالج المعاملة.

## رسوم الأولوية

[رسوم الأولوية](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
هي رسوم اختيارية تُستخدم لزيادة فرصة قيام القائد الحالي (المدقق) بمعالجة
معاملتك. يحصل المدقق على
[100% من رسوم الأولوية](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
يمكن تعيين رسوم الأولوية عن طريق تعديل سعر
[وحدة الحوسبة](/docs/references/terminology#compute-units) (CU) وحد وحدة الحوسبة
للمعاملة. (راجع
[دليل كيفية استخدام رسوم الأولوية](/developers/guides/advanced/how-to-use-priority-fees)
لمزيد من التفاصيل حول رسوم الأولوية.)

يتم حساب رسوم الأولوية على النحو التالي:

```text title="Prioritization fee formula"
Prioritization fee = CU limit * CU price
```

تُستخدم رسوم الأولوية لتحديد
[أولوية معاملتك](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646)،
بالنسبة للمعاملات الأخرى. يتم حسابها باستخدام الصيغة التالية:

```text title="Transaction priority formula"
Priority = (Prioritization fee + Base fee) / (1 + CU limit + Signature CUs + Write lock CUs)
```

#### حد وحدة الحوسبة

[افتراضياً](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197)،
يتم تخصيص
[200,000 وحدة حوسبة](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
لكل تعليمة ويتم تخصيص
[1.4 مليون وحدة حوسبة](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14)
لكل معاملة. يمكنك تغيير هذه الإعدادات الافتراضية عن طريق تضمين تعليمة
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
في معاملتك.

لحساب حد وحدات الحوسبة المناسب لمعاملتك، نوصي بالخطوات التالية:

1. قدّر وحدات الحوسبة المطلوبة عن طريق
   [محاكاة](/developers/guides/advanced/how-to-request-optimal-compute) المعاملة
2. أضف هامش أمان بنسبة 10% إلى هذا التقدير

<Callout type="warn">
  يتم تحديد رسوم الأولوية بناءً على حد وحدات الحوسبة المطلوب في المعاملة، *وليس*
  العدد الفعلي لوحدات الحوسبة المستخدمة. إذا قمت بتعيين حد وحدات حوسبة مرتفع
  جداً أو استخدمت المقدار الافتراضي، فقد تدفع مقابل وحدات حوسبة غير مستخدمة.
</Callout>

#### سعر وحدة الحوسبة

سعر وحدة الحوسبة هو مبلغ اختياري من
[المايكرو-لامبورت](/docs/references/terminology#micro-lamports) يُدفع مقابل كل
وحدة حوسبة مطلوبة. يمكنك اعتبار سعر وحدة الحوسبة بمثابة إكرامية لتشجيع المدقق
على إعطاء الأولوية لمعاملتك. لتعيين سعر وحدة الحوسبة، قم بتضمين تعليمة
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
في معاملتك.

<Callout>
  سعر وحدة الحوسبة الافتراضي هو 0، مما يعني أن رسوم الأولوية الافتراضية هي أيضاً
  0.
</Callout>

للمساعدة في تحديد أفضل سعر لوحدة الحوسبة لمعاملتك، راجع توصية سعر وحدة الحوسبة
في الوقت الفعلي المدرجة في الجدول أدناه.

| المزود                                  | واجهة برمجة تطبيقات رسوم الأولوية                                           |
| --------------------------------------- | --------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [التوثيق](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [التوثيق](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [التوثيق](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### مثال

توضح الأمثلة أدناه كيفية تعيين حد وحدات الحوسبة وسعر وحدة الحوسبة على معاملة
باستخدام مجموعات تطوير سولانا.

| مجموعة التطوير                 | مرجع الكود المصدري                                                                                                             |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
