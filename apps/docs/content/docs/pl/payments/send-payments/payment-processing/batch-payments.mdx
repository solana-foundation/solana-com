---
title: Płatności zbiorcze
description: Dowiedz się, jak zapłacić wielu odbiorcom w jednej transakcji.
---

Transakcja Solana to kontener, który zawiera jedną lub więcej instrukcji. Każda
instrukcja to operacja — przesłanie tokenów, utworzenie konta, wywołanie
programu. Sieć wykonuje wszystkie instrukcje w transakcji sekwencyjnie i
atomowo: albo każda instrukcja zakończy się powodzeniem, albo cała transakcja
zostanie odrzucona i cofnięta.

Oznacza to, że możesz spakować wiele przelewów w jedną transakcję. Zamiast
wysyłać trzy oddzielne transakcje, aby zapłacić trzem odbiorcom, wysyłasz jedną
transakcję z trzema instrukcjami przelewu. To szybsze (jedno potwierdzenie
zamiast trzech) i tańsze (jedna opłata bazowa zamiast trzech). Poniżej znajduje
się przykładowa ilustracja, jak płatności (w tym obrazie nazywane „dropami”) są
grupowane w jedną transakcję, a wiele transakcji jest wysyłanych, aby obsłużyć
większą partię.

![Schemat płatności zbiorczych](/assets/docs/payments/qn-bulk-send.png)

_Źródło:
[QuickNode - Jak wysyłać transakcje zbiorcze na Solanie](https://www.quicknode.com/guides/solana-development/transactions/how-to-send-bulk-transactions-on-solana)_

Więcej informacji o transakcjach i instrukcjach znajdziesz w przewodnikach
[Transakcje](/docs/core/transactions) oraz
[Instrukcje](/docs/core/instructions).

Poniższy przewodnik pokazuje, jak załadować wiele instrukcji przelewu do jednej
transakcji w celu realizacji płatności zbiorczych.

## Grupowanie instrukcji w jednej transakcji

Transakcja Solana może zawierać wiele przelewów do różnych odbiorców.
Podpisujesz tylko raz, płacisz jedną opłatę transakcyjną, a wszystkie przelewy
są rozliczane razem. Jeśli którykolwiek przelew się nie powiedzie, cała
transakcja zostaje odrzucona.

<Callout>
  Zobacz [Jak działają płatności na Solanie](/docs/payments/how-payments-work),
  aby poznać podstawowe pojęcia dotyczące płatności.
</Callout>

Grupowanie wielu przelewów wymaga osobnego zbudowania każdej instrukcji, a
następnie połączenia ich w jednej transakcji.

Poniższe kroki pokazują główny przebieg. Pełny, działający kod znajdziesz w
sekcji [Demo](#demo).

<ScrollyCoding>

## !!steps Wyprowadź konta tokenów

Najpierw wyprowadź adresy Associated Token Account (ATA) dla nadawcy oraz
każdego odbiorcy. ATA to deterministyczne adresy oparte na portfelu i mincie.

<CodePlaceholder title="Batch Payments" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});
```

## !!steps Utwórz instrukcje transferu

Utwórz osobną instrukcję transferu dla każdego odbiorcy. Każda instrukcja
określa:

- adres źródłowego token account
- adres docelowego token account
- autoryzację (adres właściciela źródłowego token account)
- kwotę w jednostkach bazowych (skorygowaną o liczbę miejsc po przecinku dla
  danego mintu)

<CodePlaceholder title="Batch Payments" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !focus(1:12)
const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});
```

## !!steps Wyślij jako jedną transakcję

Dodaj wszystkie instrukcje transferu do jednej transakcji. Dzięki temu wszystkie
transfery zostaną wykonane atomowo — albo wszystkie się powiodą, albo cała
transakcja zostanie odrzucona.

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});

// !focus(1:5)
const signature = await client.transaction.prepareAndSend({
  authority: sender,
  // !mark
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});
```

## !!steps Zweryfikuj salda

Po przeprowadzeniu transferu zbiorczego zweryfikuj salda tokenów dla wszystkich
stron za pomocą pomocnika `splToken`.

<CodePlaceholder title="Batch Payments" />

```ts !! title="Batch Payments"
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n
});

const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n
});

const signature = await client.transaction.prepareAndSend({
  authority: sender,
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});

// !focus(1:8)
const splToken = client.splToken({
  mint: mint.address,
  tokenProgram: "auto"
});

const senderBalance = await splToken.fetchBalance(sender.address);
const recipient1Balance = await splToken.fetchBalance(recipient1.address);
const recipient2Balance = await splToken.fetchBalance(recipient2.address);
```

</ScrollyCoding>

### Demo

<CodeTabs flags="r">

```ts !! title="Demo"
// !collapse(1:14) collapsed
// Click ">" icon on left to expand demo imports
import { createClient, lamports } from "@solana/client";
import { generateKeypair } from "@solana/client/server";
import type { ServerKeypair } from "@solana/client/server";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getCreateAssociatedTokenInstructionAsync,
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_2022_PROGRAM_ADDRESS,
  findAssociatedTokenPda,
  getMintToInstruction,
  getTransferInstruction
} from "@solana-program/token-2022";

// Generate keypairs for sender and two recipients
const sender = (await generateKeypair()).signer;
const recipient1 = (await generateKeypair()).signer;
const recipient2 = (await generateKeypair()).signer;

console.log("Sender Address:", sender.address);
console.log("Recipient 1 Address:", recipient1.address);
console.log("Recipient 2 Address:", recipient2.address);

// Demo Setup: Create client, mint account, token accounts, and fund with initial tokens
const { client, mint } = await demoSetup(sender, recipient1, recipient2);

console.log("\nMint Address:", mint.address);

// Derive the Associated Token Accounts addresses (ATAs) for sender and recipients
// !mark(1:5)
const [senderAta] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: sender.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !mark(1:5)
const [recipient1Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient1.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

// !mark(1:5)
const [recipient2Ata] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: recipient2.address,
  tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
});

console.log("Sender Token Account:", senderAta.toString());
console.log("Recipient 1 Token Account:", recipient1Ata.toString());
console.log("Recipient 2 Token Account:", recipient2Ata.toString());

// =============================================================================
// Batch Token Payment Demo
// =============================================================================

// Create instructions to transfer tokens from sender to both recipients
// Transferring 250,000 base units = 0.25 tokens (with 6 decimals) to each
// !mark(1:6)
const transfer1Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient1Ata,
  authority: sender.address,
  amount: 250_000n // 0.25 tokens
});

// !mark(1:6)
const transfer2Instruction = getTransferInstruction({
  source: senderAta,
  destination: recipient2Ata,
  authority: sender.address,
  amount: 250_000n // 0.25 tokens
});

// Prepare and send both transfers in a single transaction using @solana/client
const signature = await client.transaction.prepareAndSend({
  authority: sender,
  // !mark
  instructions: [transfer1Instruction, transfer2Instruction],
  version: 0
});

console.log("\n=== Batch Token Payment Complete ===");
console.log("Transaction Signature:", signature.toString());

// Fetch final token account balances using @solana/client SPL token helper
const splToken = client.splToken({
  mint: mint.address,
  tokenProgram: "auto"
});

const senderBalance = await splToken.fetchBalance(sender.address);
const recipient1Balance = await splToken.fetchBalance(recipient1.address);
const recipient2Balance = await splToken.fetchBalance(recipient2.address);

console.log("\nSender Token Account Balance:", senderBalance);
console.log("Recipient 1 Token Account Balance:", recipient1Balance);
console.log("Recipient 2 Token Account Balance:", recipient2Balance);

// =============================================================================
// Demo Setup Helper Function
// =============================================================================
// !collapse(1:1000) collapsed

/**
 * Sets up for a batch token transfer demo:
 * - Creates @solana/client instance
 * - Airdrops SOL to sender for transaction fees
 * - Generates mint keypair and creates/initializes mint account
 * - Creates associated token accounts for sender and both recipients
 * - Mints initial tokens to sender
 *
 * @param sender - The sender's keypair (will be funded and used as mint authority)
 * @param recipient1 - The first recipient's keypair
 * @param recipient2 - The second recipient's keypair
 * @returns Returns client instance and mint address
 */
async function demoSetup(
  sender: ServerKeypair["signer"],
  recipient1: ServerKeypair["signer"],
  recipient2: ServerKeypair["signer"]
) {
  // Create @solana/client instance pointing to local validator
  const client = createClient({
    endpoint: "http://localhost:8899",
    websocketEndpoint: "ws://localhost:8900",
    commitment: "confirmed",
    logger: () => {} // Disable all logs
  });

  // Fund sender with SOL for transaction fees using @solana/client actions
  await client.actions.requestAirdrop(sender.address, lamports(1_000_000_000n));

  // Generate keypair to use as address of mint
  const mint = (await generateKeypair()).signer;

  // Get default mint account size (in bytes), no extensions enabled
  const space = BigInt(getMintSize());

  // Get minimum balance for rent exemption
  const rent = await client.runtime.rpc
    .getMinimumBalanceForRentExemption(space)
    .send();

  // Instruction to create new account for mint (token program)
  // Invokes the system program
  const createAccountInstruction = getCreateAccountInstruction({
    payer: sender,
    newAccount: mint,
    lamports: rent,
    space,
    programAddress: TOKEN_2022_PROGRAM_ADDRESS
  });

  // Instruction to initialize mint account data
  // Invokes the token 2022 program
  const initializeMintInstruction = getInitializeMintInstruction({
    mint: mint.address,
    decimals: 6,
    mintAuthority: sender.address
  });

  // Derive sender's associated token account address (ATA)
  const [senderAta] = await findAssociatedTokenPda({
    mint: mint.address,
    owner: sender.address,
    tokenProgram: TOKEN_2022_PROGRAM_ADDRESS
  });

  // Create instruction for sender's ATA
  const createSenderAtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: sender.address
    });

  // Create instruction for recipient 1's ATA
  const createRecipient1AtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: recipient1.address
    });

  // Create instruction for recipient 2's ATA
  const createRecipient2AtaInstruction =
    await getCreateAssociatedTokenInstructionAsync({
      payer: sender,
      mint: mint.address,
      owner: recipient2.address
    });

  // Create instruction to mint initial tokens to sender
  const mintToInstruction = getMintToInstruction({
    mint: mint.address,
    token: senderAta,
    mintAuthority: sender.address,
    amount: 1_000_000n // Mint 1.00 tokens (1,000,000 base units with 6 decimals)
  });

  // Combine all instructions and send using @solana/client transaction helper
  const setupInstructions = [
    createAccountInstruction, // Create mint account
    initializeMintInstruction, // Initialize mint
    createSenderAtaInstruction, // Create sender's ATA
    createRecipient1AtaInstruction, // Create recipient 1's ATA
    createRecipient2AtaInstruction, // Create recipient 2's ATA
    mintToInstruction // Mint tokens to sender
  ];

  // Prepare and send transaction using @solana/client
  await client.transaction.prepareAndSend({
    authority: sender,
    instructions: setupInstructions,
    version: 0
  });

  return {
    client,
    mint
  };
}
```

</CodeTabs>

## Skalowanie dzięki planowaniu transakcji

Pojedyncza transakcja ma ograniczenia rozmiaru — około 1232 bajtów. Przy dużych
operacjach zbiorczych (np. wypłaty dla setek pracowników, masowe airdropy)
przekroczysz ten limit i będziesz musiał podzielić pracę na kilka transakcji.

Możesz oczywiście stworzyć własną logikę rozdzielania transakcji, ale pakiet
[`@solana/instruction-plans`](https://www.solanakit.com/docs/concepts/instruction-plans)
(część Solana Kit) obsługuje to na dwóch poziomach:

**Plany instrukcji** definiują operacje oraz ograniczenia dotyczące ich
kolejności:

- **Sekwencyjne** — instrukcje, które muszą być wykonane w określonej kolejności
- **Równoległe** — instrukcje, które mogą być wykonane w dowolnej kolejności
- **Niedzielne** — instrukcje, które muszą pozostać razem w tej samej transakcji

**Plany transakcji** są generowane na podstawie planów instrukcji. Planer
inteligentnie pakuje instrukcje w transakcje o optymalnym rozmiarze, zachowując
Twoje ograniczenia dotyczące kolejności. Otrzymany plan transakcji może być:

- **Wykonany** — podpisany i wysłany do sieci, przy czym transakcje równoległe
  są wysyłane jednocześnie
- **Symulowany** — testowo uruchomiony w sieci w celu weryfikacji przed
  wysłaniem
- **Serializowany** — skompilowany do formatu base64 dla zewnętrznych usług
  podpisywania lub procesów wielostronnych

To dwupoziomowe podejście pozwala myśleć w kategoriach operacji ("przelej do
Alice, potem przelej do Boba"), podczas gdy biblioteka zajmuje się mechaniką
doboru rozmiaru transakcji, pakowaniem i równoległym wykonywaniem.
