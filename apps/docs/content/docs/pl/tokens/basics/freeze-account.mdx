---
title: Zamrożenie konta
description: Dowiedz się, jak zamrozić konta tokenów.
---

## Zamrożenie konta

Instrukcja
[`FreezeAccount`](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/program/src/instruction.rs#L228)
blokuje wszystkie transfery tokenów oraz spalanie tokenów z określonego konta
tokenowego. Po zamrożeniu konto nie może wysyłać ani odbierać tokenów, ani
zostać zamknięte, dopóki nie zostanie odmrożone. Tylko autorytet zamrażania dla
danej emisji tokena może zamrażać konta. Jeśli autorytet zamrażania zostanie
odebrany (ustawiony na null) na koncie emisji, tokeny nie mogą być już
zamrażane.

<Callout type="info">
  [Token
  Program](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/program/src/instruction.rs#L228)
  oraz [Token Extension
  Program](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/instruction.rs#L291)
  mają podobne implementacje, aby osiągnąć tę samą funkcjonalność.
</Callout>

### Typescript

<CodeTabs storage="token-ts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getCreateAccountInstruction } from "@solana-program/system";
import {
  getCreateAssociatedTokenInstructionAsync,
  getInitializeMintInstruction,
  getMintSize,
  TOKEN_PROGRAM_ADDRESS,
  findAssociatedTokenPda,
  getMintToInstruction,
  getFreezeAccountInstruction
} from "@solana-program/token";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer
const feePayer = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(1_000_000_000n),
  commitment: "confirmed"
});

// Generate keypair to use as address of mint
const mint = await generateKeyPairSigner();

// Get default mint account size (in bytes), no extensions enabled
const space = BigInt(getMintSize());

// Get minimum balance for rent exemption
const rent = await rpc.getMinimumBalanceForRentExemption(space).send();

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Instruction to create new account for mint (token program)
// Invokes the system program
const createAccountInstruction = getCreateAccountInstruction({
  payer: feePayer,
  newAccount: mint,
  lamports: rent,
  space,
  programAddress: TOKEN_PROGRAM_ADDRESS
});

// Instruction to initialize mint account data
// Invokes the token program
const initializeMintInstruction = getInitializeMintInstruction({
  mint: mint.address,
  decimals: 9,
  mintAuthority: feePayer.address,
  freezeAuthority: feePayer.address
});

// Use findAssociatedTokenPda to derive the ATA address
const [associatedTokenAddress] = await findAssociatedTokenPda({
  mint: mint.address,
  owner: feePayer.address,
  tokenProgram: TOKEN_PROGRAM_ADDRESS
});

// Create instruction to create the associated token account
const createAtaInstruction = await getCreateAssociatedTokenInstructionAsync({
  payer: feePayer,
  mint: mint.address,
  owner: feePayer.address
});

// Create instruction to mint tokens
const mintToInstruction = getMintToInstruction({
  mint: mint.address,
  token: associatedTokenAddress,
  mintAuthority: feePayer.address,
  amount: 1000_000_000_000n // 1000.0 tokens with 9 decimals
});

const instructions = [
  createAccountInstruction,
  initializeMintInstruction,
  createAtaInstruction,
  mintToInstruction
];

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions(instructions, tx)
);

// Sign transaction message with all required signers
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Mint Address:", mint.address.toString());
console.log(
  "Associated Token Account Address:",
  associatedTokenAddress.toString()
);
console.log("Transaction Signature:", transactionSignature);
console.log("Successfully minted 1000.0 tokens");

// Get a fresh blockhash for the freeze transaction
const { value: freezeBlockhash } = await rpc.getLatestBlockhash().send();

// Create instruction to freeze the token account
const freezeInstruction = getFreezeAccountInstruction({
  account: associatedTokenAddress,
  mint: mint.address,
  owner: feePayer.address
});

// Create transaction message for freezing
const freezeTxMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(freezeBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([freezeInstruction], tx)
);

// Sign transaction message with all required signers
const signedFreezeTx = await signTransactionMessageWithSigners(freezeTxMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedFreezeTx,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature2 = getSignatureFromTransaction(signedFreezeTx);

console.log("\nSuccessfully frozen the token account");
console.log("Transaction Signature:", transactionSignature2);
```

```ts !! title="Legacy"
import { Connection, Keypair, LAMPORTS_PER_SOL } from "@solana/web3.js";
import {
  createMint,
  createAssociatedTokenAccount,
  mintTo,
  freezeAccount,
  TOKEN_PROGRAM_ID
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const latestBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Create mint using helper function
const mintPubkey = await createMint(
  connection, // connection
  feePayer, // fee payer
  feePayer.publicKey, // mint authority
  feePayer.publicKey, // freeze authority
  9, // decimals
  Keypair.generate(), // keypair (optional)
  {
    commitment: "confirmed" // confirmation options
  },
  TOKEN_PROGRAM_ID // program id
);
console.log("Mint Address:", mintPubkey.toBase58());

// Create associated token account using helper function
const associatedTokenAccount = await createAssociatedTokenAccount(
  connection, // connection
  feePayer, // fee payer
  mintPubkey, // mint
  feePayer.publicKey, // owner
  {
    commitment: "confirmed" // confirmation options
  },
  TOKEN_PROGRAM_ID // program id
);
console.log(
  "Associated Token Account Address:",
  associatedTokenAccount.toBase58()
);

// Mint 1000 tokens to the associated token account (with 9 decimals, this is 1000.0 tokens)
const mintAmount = 1000_000_000_000; // 1000.0 tokens with 9 decimals
const transactionSignature2 = await mintTo(
  connection, // connection
  feePayer, // payer
  mintPubkey, // mint
  associatedTokenAccount, // destination
  feePayer, // authority (mint authority)
  mintAmount, // amount
  [], // additional signers
  {
    commitment: "confirmed" // confirmation options
  },
  TOKEN_PROGRAM_ID // program id
);
console.log("Successfully minted 1000.0 tokens");
console.log("Transaction Signature:", transactionSignature2);

// Freeze the token account
const transactionSignature3 = await freezeAccount(
  connection,
  feePayer,
  associatedTokenAccount,
  mintPubkey,
  feePayer, // Freeze authority
  [],
  {
    commitment: "confirmed"
  },
  TOKEN_PROGRAM_ID
);

console.log("\nSuccessfully frozen the token account");
console.log("Transaction Signature:", transactionSignature3);
```

```ts !! title="Legacy Helper"
import {
  createMint,
  freezeAccount,
  getOrCreateAssociatedTokenAccount,
  mintTo
} from "@solana/spl-token";
import { Connection, Keypair } from "@solana/web3.js";

// Connect to local Solana node
const connection = new Connection("http://localhost:8899", "confirmed");

// Create a fee payer account
const feePayer = Keypair.generate();

// Request airdrop for fee payer
const airdropSig = await connection.requestAirdrop(
  feePayer.publicKey,
  1000000000
);
await connection.confirmTransaction(airdropSig);

// Step 1: Create a new mint
const mintAuthority = feePayer;
const freezeAuthority = feePayer;
const decimals = 2;

const mint = await createMint(
  connection,
  feePayer,
  mintAuthority.publicKey,
  freezeAuthority.publicKey,
  decimals
);
console.log("Mint Address:", mint.toBase58());

// Step 2: Create Associated Token Account
const tokenAccount = await getOrCreateAssociatedTokenAccount(
  connection,
  feePayer,
  mint,
  feePayer.publicKey
);
console.log("Token Account Address:", tokenAccount.address.toBase58());

// Step 3: Mint tokens
const amountToMint = 100;
console.log("\nMinting tokens...");
const transactionSignature2 = await mintTo(
  connection,
  feePayer,
  mint,
  tokenAccount.address,
  mintAuthority,
  amountToMint
);
console.log("Transaction Signature:", transactionSignature2);

// Step 4: Freeze token account
console.log("\nFreezing token account...");
const transactionSignature3 = await freezeAccount(
  connection,
  feePayer,
  tokenAccount.address,
  mint,
  freezeAuthority
);
console.log("Transaction Signature:", transactionSignature3);
```

</CodeTabs>

### Rust

<CodeTabs storage="token-rs" flags="r">

```rust !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    program_pack::Pack,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::create_account;
use spl_associated_token_account_interface::{
    address::get_associated_token_address, instruction::create_associated_token_account,
};
use spl_token_interface::{
    id as token_program_id,
    instruction::{freeze_account, initialize_mint, mint_to, transfer_checked},
    state::Mint,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let latest_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 1 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 1_000_000_000)
        .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Generate keypair to use as address of mint
    let mint = Keypair::new();

    // Set decimals for mint
    let decimals = 2;

    // Get default mint account size (in bytes), no extensions enabled
    let mint_space = Mint::LEN;
    let mint_rent = client
        .get_minimum_balance_for_rent_exemption(mint_space)
        .await?;

    // Instruction to create new account for mint (token program)
    let create_account_instruction = create_account(
        &fee_payer.pubkey(), // payer
        &mint.pubkey(),      // new account (mint)
        mint_rent,           // lamports
        mint_space as u64,   // space
        &token_program_id(), // program id
    );

    // Instruction to initialize mint account data
    let initialize_mint_instruction = initialize_mint(
        &token_program_id(),
        &mint.pubkey(),            // mint
        &fee_payer.pubkey(),       // mint authority
        Some(&fee_payer.pubkey()), // freeze authority
        decimals,                  // decimals
    )?;

    // Calculate the associated token account address for fee_payer
    let associated_token_address = get_associated_token_address(
        &fee_payer.pubkey(), // owner
        &mint.pubkey(),      // mint
    );

    // Instruction to create associated token account
    let create_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), // funding address
        &fee_payer.pubkey(), // wallet address
        &mint.pubkey(),      // mint address
        &token_program_id(), // program id
    );

    // Amount of tokens to mint (100 tokens with 2 decimals)
    let amount = 100_00;

    // Create mint_to instruction to mint tokens to the associated token account
    let mint_to_instruction = mint_to(
        &token_program_id(),
        &mint.pubkey(),            // mint
        &associated_token_address, // destination
        &fee_payer.pubkey(),       // authority
        &[&fee_payer.pubkey()],    // signer
        amount,                    // amount
    )?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_account_instruction,
            initialize_mint_instruction,
            create_ata_instruction,
            mint_to_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer, &mint],
        latest_blockhash,
    );

    // Send and confirm transaction
    client.send_and_confirm_transaction(&transaction).await?;

    // Create freeze account instruction
    let freeze_instruction = freeze_account(
        &token_program_id(),       // program id
        &associated_token_address, // token account to freeze
        &mint.pubkey(),            // mint
        &fee_payer.pubkey(),       // freeze authority
        &[&fee_payer.pubkey()],    // signers
    )?;

    // Create transaction for freezing token account
    let transaction = Transaction::new_signed_with_payer(
        &[freeze_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        latest_blockhash,
    );

    // Send and confirm transaction
    client.send_and_confirm_transaction(&transaction).await?;

    println!("Token Account Address: {}", associated_token_address);
    let token_account = client.get_token_account(&associated_token_address).await?;
    if let Some(token_account) = token_account {
        println!("{:#?}", token_account);
    }

    // Self token transfer to demonstrate failure with frozen token account
    let transfer_instruction = transfer_checked(
        &token_program_id(),       // program id
        &associated_token_address, // source
        &mint.pubkey(),            // mint
        &associated_token_address, // destination
        &fee_payer.pubkey(),       // authority
        &[&fee_payer.pubkey()],    // signers
        amount,                    // amount
        decimals,                  // decimals
    )?;

    let transaction = Transaction::new_signed_with_payer(
        &[transfer_instruction],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        latest_blockhash,
    );

    println!("\nTransfer Expect to Fail with Frozen Token Account");
    match client.send_and_confirm_transaction(&transaction).await {
        Ok(_) => println!("Transaction successful"),
        Err(e) => println!("{:#?}", e),
    }

    Ok(())
}
```

</CodeTabs>
