---
title: Sync Native
description: Yerel SOL'u sarılmış SOL'a dönüştürmeyi öğrenin.
---

## Yerel SOL'u Senkronize Et

Sarılmış SOL (WSOL), hesaptaki lamport miktarını token bakiyesi olarak takip
eden bir token hesabıdır. WSOL, SOL'u bir SPL token olarak transfer etmek için
DeFi protokolleriyle entegrasyonu sağlar.

[`SyncNative`](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/interface/src/instruction.rs#L387)
komutu, sarılmış SOL (WSOL) token hesabı bakiyesini içinde saklanan gerçek SOL
(lamport) ile senkronize eder. Yerel SOL'u bir WSOL token hesabına transfer
ettiğinizde, token bakiyesi otomatik olarak güncellenmez. Doğru WSOL bakiyesini
yansıtmak için SyncNative'i çağırmanız gerekir.

<Callout type="info">
  [Token
  Program](https://github.com/solana-program/token/blob/a7c488ca39ed4cd71a87950ed854929816e9099f/interface/src/instruction.rs#L387)
  ve [Token Extension
  Program](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/instruction.rs#L182)
  aynı işlevselliği sağlamak için benzer uygulamalara sahiptir.
</Callout>

### Typescript

<CodeTabs storage="token-ts" flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners,
  address
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";
import {
  getCreateAssociatedTokenInstructionAsync,
  TOKEN_PROGRAM_ADDRESS,
  findAssociatedTokenPda,
  getSyncNativeInstruction
} from "@solana-program/token";

// Create Connection, local validator in this example
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate keypairs for fee payer
const feePayer = await generateKeyPairSigner();

// Fund fee payer
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: feePayer.address,
  lamports: lamports(2_000_000_000n),
  commitment: "confirmed"
});

// Native mint (Wrapped SOL) address
const NATIVE_MINT = address("So11111111111111111111111111111111111111112");

// Use findAssociatedTokenPda to derive the ATA address for WSOL
const [associatedTokenAddress] = await findAssociatedTokenPda({
  mint: NATIVE_MINT,
  owner: feePayer.address,
  tokenProgram: TOKEN_PROGRAM_ADDRESS
});

// Get latest blockhash to include in transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Create instruction to create the WSOL associated token account
const createAtaInstruction = await getCreateAssociatedTokenInstructionAsync({
  payer: feePayer,
  mint: NATIVE_MINT,
  owner: feePayer.address
});

// Amount to wrap (1 SOL = 1,000,000,000 lamports)
const amountToSync = 1_000_000_000n;

// Create instruction to transfer SOL to the WSOL token account
const transferSolInstruction = getTransferSolInstruction({
  source: feePayer,
  destination: associatedTokenAddress,
  amount: amountToSync
});

// Create instruction to sync native SOL balance with WSOL token balance
const syncNativeInstruction = getSyncNativeInstruction({
  account: associatedTokenAddress
});

const instructions = [
  createAtaInstruction,
  transferSolInstruction,
  syncNativeInstruction
];

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(feePayer, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions(instructions, tx)
);

// Sign transaction message with all required signers
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Send and confirm transaction
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);

// Get transaction signature
const transactionSignature = getSignatureFromTransaction(signedTransaction);

console.log("Fee Payer Address:", feePayer.address.toString());
console.log("WSOL Token Account Address:", associatedTokenAddress.toString());
console.log("Successfully wrapped 1.0 SOL into WSOL");
console.log("Transaction Signature:", transactionSignature);
```

```ts !! title="Legacy"
import {
  Connection,
  Keypair,
  sendAndConfirmTransaction,
  SystemProgram,
  Transaction,
  LAMPORTS_PER_SOL
} from "@solana/web3.js";
import {
  NATIVE_MINT,
  getAssociatedTokenAddressSync,
  createAssociatedTokenAccountInstruction,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
  createSyncNativeInstruction
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const latestBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 1 SOL to fee payer
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  2 * LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Get the associated token account address for WSOL
const associatedTokenAccount = getAssociatedTokenAddressSync(
  NATIVE_MINT, // mint (Wrapped SOL)
  feePayer.publicKey, // owner
  false, // allowOwnerOffCurve
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID
);

// Create associated token account instruction for WSOL
const createAssociatedTokenAccountIx = createAssociatedTokenAccountInstruction(
  feePayer.publicKey, // payer
  associatedTokenAccount, // associated token account address
  feePayer.publicKey, // owner
  NATIVE_MINT, // mint
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID
);

// Amount to wrap (1 SOL = 1,000,000,000 lamports)
const amountToSync = 1_000_000_000;

// Create transfer instruction to send SOL to the WSOL token account
const transferInstruction = SystemProgram.transfer({
  fromPubkey: feePayer.publicKey,
  toPubkey: associatedTokenAccount,
  lamports: amountToSync
});

// Create sync native instruction to update WSOL balance
const syncNativeInstruction = createSyncNativeInstruction(
  associatedTokenAccount, // token account
  TOKEN_PROGRAM_ID // programId
);

// Create and sign transaction
const transaction = new Transaction({
  feePayer: feePayer.publicKey,
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight
}).add(
  createAssociatedTokenAccountIx,
  transferInstruction,
  syncNativeInstruction
);

// Sign and send transaction
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [feePayer]
);

console.log("Fee Payer Address:", feePayer.publicKey.toBase58());
console.log("WSOL Token Account Address:", associatedTokenAccount.toBase58());
console.log("Successfully wrapped 1.0 SOL into WSOL");
console.log("Transaction Signature:", transactionSignature);
```

```ts !! title="Legacy Helper"
import {
  Connection,
  Keypair,
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction
} from "@solana/web3.js";
import {
  NATIVE_MINT,
  createAssociatedTokenAccount,
  syncNative,
  TOKEN_PROGRAM_ID
} from "@solana/spl-token";

// Create connection to local validator
const connection = new Connection("http://localhost:8899", "confirmed");
const latestBlockhash = await connection.getLatestBlockhash();

// Generate a new keypair for the fee payer
const feePayer = Keypair.generate();

// Airdrop 2 SOL to fee payer (1 for wrapping, 1 for fees)
const airdropSignature = await connection.requestAirdrop(
  feePayer.publicKey,
  2 * LAMPORTS_PER_SOL
);
await connection.confirmTransaction({
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
  signature: airdropSignature
});

// Create associated token account for WSOL using helper function
const associatedTokenAccount = await createAssociatedTokenAccount(
  connection,
  feePayer,
  NATIVE_MINT, // Mint (Wrapped SOL)
  feePayer.publicKey,
  {
    commitment: "confirmed"
  },
  TOKEN_PROGRAM_ID
);
console.log("WSOL Token Account Address:", associatedTokenAccount.toBase58());

// Amount to wrap (1 SOL = 1,000,000,000 lamports)
const amountToSync = 1_000_000_000;

// Transfer SOL to the WSOL token account
const transactionSignature2 = await connection.sendTransaction(
  new Transaction().add(
    SystemProgram.transfer({
      fromPubkey: feePayer.publicKey,
      toPubkey: associatedTokenAccount,
      lamports: amountToSync
    })
  ),
  [feePayer]
);

await connection.confirmTransaction({
  blockhash: latestBlockhash.blockhash,
  lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
  signature: transactionSignature2
});

console.log("Transferred 1.0 SOL to WSOL token account");
console.log("Transaction Signature:", transactionSignature2);

// Sync native SOL balance with WSOL token balance
const transactionSignature3 = await syncNative(
  connection,
  feePayer,
  associatedTokenAccount,
  {
    commitment: "confirmed"
  },
  TOKEN_PROGRAM_ID
);

console.log("Successfully wrapped 1.0 SOL into WSOL");
console.log("Transaction Signature:", transactionSignature3);
```

</CodeTabs>

### Rust

<CodeTabs storage="token-rs" flags="r">

```rust !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;
use spl_associated_token_account_interface::{
    address::get_associated_token_address, instruction::create_associated_token_account,
};
use spl_token_interface::{
    id as token_program_id, instruction::sync_native, native_mint::ID as NATIVE_MINT_ID,
};

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local validator
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );
    let latest_blockhash = client.get_latest_blockhash().await?;

    // Generate a new keypair for the fee payer
    let fee_payer = Keypair::new();

    // Airdrop 2 SOL to fee payer
    let airdrop_signature = client
        .request_airdrop(&fee_payer.pubkey(), 2_000_000_000)
        .await?;
    client.confirm_transaction(&airdrop_signature).await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Get associated token account address for WSOL
    let associated_token_address = get_associated_token_address(
        &fee_payer.pubkey(), // owner
        &NATIVE_MINT_ID,     // mint (Wrapped SOL)
    );

    // Instruction to create associated token account for WSOL
    let create_ata_instruction = create_associated_token_account(
        &fee_payer.pubkey(), // funding address
        &fee_payer.pubkey(), // wallet address
        &NATIVE_MINT_ID,     // mint address
        &token_program_id(), // program id
    );

    // Amount to wrap (1 SOL = 1,000,000,000 lamports)
    let amount = 1_000_000_000;

    // Create transfer instruction to send SOL to the WSOL token account
    let transfer_instruction = transfer(&fee_payer.pubkey(), &associated_token_address, amount);

    // Create sync native instruction to update WSOL balance
    let sync_native_instruction = sync_native(&token_program_id(), &associated_token_address)?;

    // Create transaction and add instructions
    let transaction = Transaction::new_signed_with_payer(
        &[
            create_ata_instruction,
            transfer_instruction,
            sync_native_instruction,
        ],
        Some(&fee_payer.pubkey()),
        &[&fee_payer],
        latest_blockhash,
    );

    // Send and confirm transaction
    client.send_and_confirm_transaction(&transaction).await?;

    let token_account = client.get_token_account(&associated_token_address).await?;

    println!("WSOL Token Account Address: {}", associated_token_address);
    if let Some(token_account) = token_account {
        println!("{:#?}", token_account);
    }

    Ok(())
}
```

</CodeTabs>

### Python

<CodeTabs flags="r">

```py !! title="Python"
#!/usr/bin/env python3

import asyncio
from solana.rpc.async_api import AsyncClient
from solders.keypair import Keypair
from solders.transaction import VersionedTransaction
from solders.message import MessageV0
from solders.system_program import transfer, TransferParams
from spl.token.instructions import (
    create_associated_token_account,
    sync_native, SyncNativeParams,
    close_account, CloseAccountParams,
    get_associated_token_address
)
from spl.token.constants import TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID
from solders.pubkey import Pubkey

# Native mint address for wrapped SOL
NATIVE_MINT = Pubkey.from_string("So11111111111111111111111111111111111111112")

async def main():
    rpc = AsyncClient("http://localhost:8899")

    # Example keypairs
    payer = Keypair()
    owner = Keypair()

    # Amount to wrap (in lamports)
    amount_to_wrap = 1000000000  # 1 SOL

    async with rpc:
        # Get associated token address for wrapped SOL
        wrapped_sol_account = get_associated_token_address(
            owner=owner.pubkey(),
            mint=NATIVE_MINT,
            token_program_id=TOKEN_PROGRAM_ID
        )

        # Create associated token account for wrapped SOL
        create_ata_instruction = create_associated_token_account(
            payer=payer.pubkey(),
            owner=owner.pubkey(),
            mint=NATIVE_MINT
        )

        # Transfer SOL to the wrapped SOL account
        transfer_instruction = transfer(
            TransferParams(
                from_pubkey=payer.pubkey(),
                to_pubkey=wrapped_sol_account,
                lamports=amount_to_wrap
            )
        )

        # Sync native instruction to update the wrapped SOL balance
        sync_native_instruction = sync_native(
            SyncNativeParams(
                program_id=TOKEN_PROGRAM_ID,
                account=wrapped_sol_account
            )
        )

        instructions = [
            create_ata_instruction,
            transfer_instruction,
            sync_native_instruction
        ]

        # Get latest blockhash
        recent_blockhash = await rpc.get_latest_blockhash()

        # Create message
        message = MessageV0.try_compile(
            payer=payer.pubkey(),
            instructions=instructions,
            address_lookup_table_accounts=[],
            recent_blockhash=recent_blockhash.value.blockhash
        )

        # Create transaction
        transaction = VersionedTransaction(message, [payer])

        print(f"Wrapped SOL Operations:")
        print(f"Owner: {owner.pubkey()}")
        print(f"Wrapped SOL Account: {wrapped_sol_account}")
        print(f"Amount to wrap: {amount_to_wrap} lamports ({amount_to_wrap / 1e9} SOL)")
        print(f"Native Mint: {NATIVE_MINT}")
        print(f"Payer: {payer.pubkey()}")
        print(f"Wrapped SOL transaction created successfully")

async def unwrap_sol_example():
    """Example of unwrapping SOL (closing wrapped SOL account)"""
    rpc = AsyncClient("http://localhost:8899")

    payer = Keypair()
    owner = Keypair()

    async with rpc:
        # Get wrapped SOL account
        wrapped_sol_account = get_associated_token_address(
            owner=owner.pubkey(),
            mint=NATIVE_MINT,
            token_program_id=TOKEN_PROGRAM_ID
        )

        # Close account instruction (unwraps SOL)
        close_account_instruction = close_account(
            CloseAccountParams(
                program_id=TOKEN_PROGRAM_ID,
                account=wrapped_sol_account,
                dest=owner.pubkey(),  # SOL will be sent back to owner
                owner=owner.pubkey()
            )
        )

        # Get latest blockhash
        recent_blockhash = await rpc.get_latest_blockhash()

        # Create message
        message = MessageV0.try_compile(
            payer=payer.pubkey(),
            instructions=[close_account_instruction],
            address_lookup_table_accounts=[],
            recent_blockhash=recent_blockhash.value.blockhash
        )

        # Create transaction
        transaction = VersionedTransaction(message, [payer, owner])

        print(f"\nUnwrap SOL Example:")
        print(f"Wrapped SOL Account: {wrapped_sol_account}")
        print(f"Owner: {owner.pubkey()}")
        print(f"Destination: {owner.pubkey()}")
        print(f"Unwrap SOL transaction created successfully")

if __name__ == "__main__":
    asyncio.run(main())
    asyncio.run(unwrap_sol_example())
```

</CodeTabs>
