---
title: Transactions
description:
  Learn about Solana transactions—the fundamental building blocks for
  interacting with the Solana blockchain. Understand transaction structure and
  instruction composition with practical examples.
---

To interact with the Solana network, you must send a transaction. You can think
of a transaction as an envelope that holds several forms. Each form is an
instruction that tells the network what to do. Sending the transaction is like
mailing the envelope so the forms can be processed.

The example below shows a simplified version of two transactions. When the first
transaction is processed, it will execute a single instruction. When the second
transaction is processed, it will execute three instructions **in sequential
order**: first instruction 1, followed by instruction 2, followed by
instruction 3.

<Callout type="warn">
  Transactions are **atomic**: If a single instruction fails, the entire
  transaction will fail and no changes will occur.
</Callout>

![A simplified diagram showing two transactions](/assets/docs/core/transactions/transaction-simple.svg)

A
[`Transaction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/transaction/mod.rs#L207)
consists of the following information:

<WithMentions>

- [`signatures`](mention:signatures): An array of [signatures](#signatures)
- [`message`](mention:message): Transaction information, including the list of
  instructions to be processed

```rust title="Transaction"
pub struct Transaction {
    #[wasm_bindgen(skip)]
    #[serde(with = "short_vec")]
    // !mention signatures
    pub signatures: Vec<Signature>,

    #[wasm_bindgen(skip)]
    // !mention message
    pub message: Message,
}
```

</WithMentions>

![Diagram showing the two parts of a transaction](/assets/docs/core/transactions/tx_format.png)

Transactions have a total size limit of
[1232](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/packet/src/lib.rs#L29)
bytes. This limit includes both the [`signatures`](#signatures) array and the
[`message`](#message) struct.

<Callout>
  This limit is designed to avoid packet fragmentation on typical internet
  infrastructure. While IPv6 supports MTUs larger than 9000 bytes, most internet
  routers use a default MTU of 1500 bytes (standard Ethernet). To ensure
  transactions fit within a single packet without fragmentation, Solana uses
  1280 bytes (the minimum MTU required for IPv6) minus 48 bytes for network
  headers (40 bytes IPv6 + 8 bytes fragment/UDP header), resulting in the 1232
  byte transaction size limit.
</Callout>

![Diagram showing the transaction format and size limits](/assets/docs/core/transactions/issues_with_legacy_txs.png)

## Signatures

The transaction's `signatures` array contains `Signature` structs. Each
[`Signature`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/signature/src/lib.rs#L30)
is 64 bytes and is created by signing the transaction's `Message` with the
account's private key. A signature must be provided for each
[signer account](#account-addresses) included on any of the transaction's
instructions.

The first signature belongs to the account that will pay the transaction's
[base fee](/docs/core/fees#base-fee) and is the transaction signature. The
transaction signature can be used to look up the transaction's details on the
network.

## Message

The transaction's `message` is a
[`Message`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L131)
struct that contains the following information:

<WithMentions>

- [`header`](mention:message-header): The message [header](#header)
- [`account_keys`](mention:account-addresses): An array of
  [account addresses](#account-addresses) required by the transaction's
  instructions
- [`recent_blockhash`](mention:recent-blockhash): A
  [blockhash](#recent-blockhash) that acts as a timestamp for the transaction
- [`instructions`](mention:instructions): An array of
  [instructions](#instructions)

<Callout>
  To save space, the transaction does not store permissions for each account
  individually. Instead, account permissions are determined using the `header`
  and `account_keys`.
</Callout>

```rust title="Message"
pub struct Message {
    /// The message header, identifying signed and read-only `account_keys`.
    // !mention message-header
    pub header: MessageHeader,

    /// All the account keys used by this transaction.
    #[serde(with = "short_vec")]
    // !mention account-addresses
    pub account_keys: Vec<Pubkey>,

    /// The id of a recent ledger entry.
    // !mention recent-blockhash
    pub recent_blockhash: Hash,

    /// Programs that will be executed in sequence and committed in
    /// one atomic transaction if all succeed.
    #[serde(with = "short_vec")]
    // !mention instructions
    pub instructions: Vec<CompiledInstruction>,
}
```

</WithMentions>

### Header

<WithMentions>

The message's `header` is a
[`MessageHeader`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/mod.rs#L97)
struct. It contains the following information:

- [`num_required_signatures`](mention:num_required_signatures): The total number
  of signatures required by the transaction
- [`num_readonly_signed_accounts`](mention:num_readonly_signed_accounts): The
  total number of read-only accounts that require signatures
- [`num_readonly_unsigned_accounts`](mention:num_readonly_unsigned_accounts):
  The total number of read-only accounts that don't require signatures

```rust title="MessageHeader"
pub struct MessageHeader {
    /// The number of signatures required for this message to be considered
    /// valid. The signers of those signatures must match the first
    /// `num_required_signatures` of [`Message::account_keys`].
    // !mention num_required_signatures
    pub num_required_signatures: u8,

    /// The last `num_readonly_signed_accounts` of the signed keys are read-only
    /// accounts.
    // !mention num_readonly_signed_accounts
    pub num_readonly_signed_accounts: u8,

    /// The last `num_readonly_unsigned_accounts` of the unsigned keys are
    /// read-only accounts.
    // !mention num_readonly_unsigned_accounts
    pub num_readonly_unsigned_accounts: u8,
}
```

</WithMentions>

![Diagram showing the three parts of the message header](/assets/docs/core/transactions/message_header.png)

### Account addresses

The message's
[`account_keys`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L138)
is an array of account addresses, sent in
[compact array format](/docs/references/terminology#compact-array-format). The
array's prefix indicates its length. Each item in the array is a public key,
pointing to an account used by its instructions. The `accounts_keys` array must
be complete, and strictly ordered, as follows:

1. Signer + Writable
2. Signer + Read-only
3. Not signer + Writable
4. Not signer + Read-only

<Callout>
  Strict ordering allows the `account_keys` array to be combined with the
  information in the message's [`header`](#header) to determine the permissions
  for each account.
</Callout>

![Diagram showing the order of the account addresses array](/assets/docs/core/transactions/compat_array_of_account_addresses.png)

### Recent blockhash

The message's `recent_blockhash` is a hash value that acts as a transaction
timestamp and prevents duplicate transactions. A blockhash expires after
[150 blocks](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/clock/src/lib.rs#L134).
(Equivalent to one minute—assuming each block is 400ms.) After the block
expires, the transaction is expired and cannot be processed.

<Callout>
  The [`getLatestBlockhash`](/docs/rpc/http/getlatestblockhash) RPC method
  allows you to get the current blockhash and last block height at which the
  blockhash will be valid.
</Callout>

### Instructions

The message's
[`instructions`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/message/legacy.rs#L146)
is an array of all the instructions to be processed, sent in
[compact array format](/docs/references/terminology#compact-array-format). The
array's prefix indicates its length. Each item in the array is a
[`CompiledInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/program/src/instruction.rs#L22)
struct and includes the following information:

<WithMentions>

1. [`program_id_index`](mention:program-id-index): An index pointing to an
   address in the [`account_keys`](#account-addresses) array. This value
   indicates the address of the program that processes the instruction.
2. [`accounts`](mention:account-indexes): An array of indices pointing to
   addresses in the `account_keys` array. Each index points to the address of an
   account required for this instruction.
3. [`data`](mention:instruction-data): A byte array specifying which instruction
   to invoke on the program. It also includes any additional data required by
   the instruction. (For example, function arguments)

```rust title="CompiledInstruction"
pub struct CompiledInstruction {
    /// Index into the transaction keys array indicating the program account that executes this instruction.
    // !mention program-id-index
    pub program_id_index: u8,
    /// Ordered indices into the transaction keys array indicating which accounts to pass to the program.
    #[serde(with = "short_vec")]
    // !mention account-indexes
    pub accounts: Vec<u8>,
    /// The program input data.
    #[serde(with = "short_vec")]
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

![Compact array of Instructions](/assets/docs/core/transactions/compact_array_of_ixs.png)

## Example transaction structure

The following example shows the structure of a transaction that contains a
single SOL transfer instruction.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import {
  createSolanaRpc,
  generateKeyPairSigner,
  lamports,
  createTransactionMessage,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstructions,
  pipe,
  signTransactionMessageWithSigners,
  getCompiledTransactionMessageDecoder
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

const rpc = createSolanaRpc("http://localhost:8899");
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

// Create transaction message
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);

// Decode the messageBytes
const compiledTransactionMessage =
  getCompiledTransactionMessageDecoder().decode(signedTransaction.messageBytes);

console.log(JSON.stringify(compiledTransactionMessage, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");
const { blockhash, lastValidBlockHeight } =
  await connection.getLatestBlockhash();

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

const transaction = new Transaction({
  blockhash,
  lastValidBlockHeight,
  feePayer: sender.publicKey
}).add(transferInstruction);
transaction.sign(sender);

const compiledMessage = transaction.compileMessage();
console.log(JSON.stringify(compiledMessage, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Fetch the latest blockhash and last valid block height
    let blockhash = connection.get_latest_blockhash().await?;

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(
        &sender.pubkey(),
        &recipient.pubkey(),
        LAMPORTS_PER_SOL / 100, // 0.01 SOL
    );

    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    transaction.sign(&[&sender], blockhash);

    println!("{:#?}", transaction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>
The code below shows the output from the previous code snippets.
The format differs between SDKs,
but notice that each instruction contains the same required information.

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  "version": 0,
  // !mention header
  "header": {
    "numSignerAccounts": 1,
    "numReadonlySignerAccounts": 0,
    "numReadonlyNonSignerAccounts": 1
  },
  // !mention account_keys
  "staticAccounts": [
    "HoCy8p5xxDDYTYWEbQZasEjVNM5rxvidx8AfyqA4ywBa",
    "5T388jBjovy7d8mQ3emHxMDTbUF8b7nWvAnSiP3EAdFL",
    "11111111111111111111111111111111"
  ],
  // !mention recent_blockhash
  "lifetimeToken": "EGCWPUEXhqHJWYBfDirq3mHZb4qDpATmYqBZMBy9TBC1",
  // !mention instructions
  "instructions": [
    {
      "programAddressIndex": 2,
      "accountIndices": [0, 1],
      "data": {
        "0": 2,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 128,
        "5": 150,
        "6": 152,
        "7": 0,
        "8": 0,
        "9": 0,
        "10": 0,
        "11": 0
      }
    }
  ]
}
```

```json !! title="Legacy"
{
  // !mention header
  "header": {
    "numRequiredSignatures": 1,
    "numReadonlySignedAccounts": 0,
    "numReadonlyUnsignedAccounts": 1
  },
  // !mention account_keys
  "accountKeys": [
    "EPLUagqZZAuAtJ5LSbK7eeXjqeTdesd4q8WhoqVrfG3g",
    "9Txf5pi5jzm7FydFAsQafk7xn5wY9yN2UNm5LW15qvcK",
    "11111111111111111111111111111111"
  ],
  "recentBlockhash": "2qYPgehzMKXcMt4Ku1tKAk9DACKUbtYEY9EUEN42cseT",
  // !mention instructions
  "instructions": [
    {
      "programIdIndex": 2,
      "accounts": [0, 1],
      "data": "3Bxs4NN8M2Yn4TLb"
    }
  ],
  "indexToProgramIds": {}
}
```

```json !! title="Rust"
{
  "signatures": [
    "2fPXZtQGWWj6suxfc55FBQiexS8hEhNELqasSL5DRYa1RB1GChHz86Cyy8ukiVwA6qbq91P4cY1FuvTuYtmTHmJP"
  ],
  "message": {
    // !mention header
    "header": {
      "num_required_signatures": 1,
      "num_readonly_signed_accounts": 0,
      "num_readonly_unsigned_accounts": 1
    },
    "account_keys": [
      "9CpbtdXfUTgLMJL8DEAeEm8thERJPwDuruohjvUuzY7m",
      "6jELNgS8Q35sF4QZCvwgyKGaKrbcm8P5QcNWUyAb5ekJ",
      "11111111111111111111111111111111"
    ],
    "recent_blockhash": "3P7CVQ9nwXx4B37MvBzghzbcM9K9p5xo7ivDE8W78dCi",
    // !mention instructions
    "instructions": [
      {
        "program_id_index": 2,
        "accounts": [0, 1],
        "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
      }
    ]
  }
}
```

</CodeTabs>
</WithMentions>

After a transaction is submitted, you can retrieve its details using the
transaction signature and the [getTransaction](/docs/rpc/http/gettransaction)
RPC method. The response will have a structure similar to the following snippet.

<Callout>
  You can also find the transaction using [Solana
  Explorer](https://explorer.solana.com).
</Callout>

```json title="Transaction Data"
{
  "blockTime": 1745196488,
  "meta": {
    "computeUnitsConsumed": 150,
    "err": null,
    "fee": 5000,
    "innerInstructions": [],
    "loadedAddresses": {
      "readonly": [],
      "writable": []
    },
    "logMessages": [
      "Program 11111111111111111111111111111111 invoke [1]",
      "Program 11111111111111111111111111111111 success"
    ],
    "postBalances": [989995000, 10000000, 1],
    "postTokenBalances": [],
    "preBalances": [1000000000, 0, 1],
    "preTokenBalances": [],
    "rewards": [],
    "status": {
      "Ok": null
    }
  },
  "slot": 13049,
  "transaction": {
    "message": {
      "header": {
        "numReadonlySignedAccounts": 0,
        "numReadonlyUnsignedAccounts": 1,
        "numRequiredSignatures": 1
      },
      "accountKeys": [
        "8PLdpLxkuv9Nt8w3XcGXvNa663LXDjSrSNon4EK7QSjQ",
        "7GLg7bqgLBv1HVWXKgWAm6YoPf1LoWnyWGABbgk487Ma",
        "11111111111111111111111111111111"
      ],
      "recentBlockhash": "7ZCxc2SDhzV2bYgEQqdxTpweYJkpwshVSDtXuY7uPtjf",
      "instructions": [
        {
          "accounts": [0, 1],
          "data": "3Bxs4NN8M2Yn4TLb",
          "programIdIndex": 2,
          "stackHeight": null
        }
      ],
      "indexToProgramIds": {}
    },
    "signatures": [
      "3jUKrQp1UGq5ih6FTDUUt2kkqUfoG2o4kY5T1DoVHK2tXXDLdxJSXzuJGY4JPoRivgbi45U2bc7LZfMa6C4R3szX"
    ]
  },
  "version": "legacy"
}
```
