---
title: Pr√©paration √† la production
description: Passer des tests sur devnet au d√©ploiement sur mainnet
---

Construire localement et tester sur devnet sont d'excellents moyens de d√©buter
avec les paiements Solana. Cependant, lorsque vous √™tes pr√™t √† d√©ployer sur
Mainnet, vous devez √™tre conscient des nuances du mainnet. Devnet pardonne les
erreurs. Mainnet ne pardonne pas. Ce guide couvre les diff√©rences importantes
pour garantir √† vos utilisateurs une exp√©rience fluide.

| Devnet                                   | Mainnet                                                                                         |
| ---------------------------------------- | ----------------------------------------------------------------------------------------------- |
| SOL gratuit via les faucets              | [Acqu√©rir du vrai SOL](https://solana.com/ecosystem/explore?categories=exchange) pour les frais |
| Faible concurrence pour l'espace de bloc | Les frais de priorit√© comptent                                                                  |
| Les transactions passent facilement      | La configuration des transactions est critique                                                  |
| Le RPC public convient                   | RPC de production requis                                                                        |
| Keypairs et mints devnet                 | Cl√©s et mints de tokens diff√©rents‚Äîmettez √† jour votre configuration                            |

## Infrastructure RPC

Les
[endpoints publics](https://solana.com/docs/references/clusters#solana-public-rpc-endpoints)
(`api.mainnet-beta.solana.com`) sont limit√©s en d√©bit sans SLA. Ils conviennent
pour le d√©veloppement mais √©choueront dans les flux de paiement en
production‚Äîcomme essayer de faire fonctionner un processeur de paiement via une
API partag√©e sans garantie de disponibilit√©.

<Callout
  type="caution"
  title="N'utilisez jamais le RPC public pour la production"
>
  Utilisez un [fournisseur RPC priv√©](https://solana.com/rpc) pour un acc√®s
  fiable et √† faible latence.
</Callout>

Lors du choix d'un fournisseur RPC, recherchez :

- **Fiabilit√©** : SLA avec garanties de disponibilit√© (99,9 %+)
- **Latence** : proximit√© g√©ographique avec vos utilisateurs
- **Fonctionnalit√©s** : fonctionnalit√©s d'atterrissage de transactions,
  indexation, API de frais de priorit√©

Pour une liste compl√®te des fournisseurs RPC, consultez le guide
[Fournisseurs d'infrastructure RPC](https://solana.com/rpc).

### Configuration RPC redondante

Comme tout fournisseur de services r√©seau, les fournisseurs RPC peuvent
conna√Ætre des temps d'arr√™t ou des p√©riodes de performances d√©grad√©es. Pour
garantir la r√©silience de votre application, vous devez configurer votre
application pour utiliser plusieurs fournisseurs RPC.

[Solana Kit](https://github.com/anza-xyz/kit/tree/main/packages/rpc-transport-http)
fournit une biblioth√®que pour personnaliser les transports RPC qui vous permet
de construire votre propre client RPC redondant. Voici un exemple de la fa√ßon
dont vous pourriez l'utiliser pour construire un client RPC redondant :

```ts
import { RpcTransport } from "@solana/rpc-spec";
import { RpcResponse } from "@solana/rpc-spec-types";
import { createHttpTransport } from "@solana/rpc-transport-http";

// Create a transport for each RPC server
const transports = [
  createHttpTransport({ url: "https://mainnet-beta.my-server-1.com" }),
  createHttpTransport({ url: "https://mainnet-beta.my-server-2.com" }),
  createHttpTransport({ url: "https://mainnet-beta.my-server-3.com" })
];

// Create a wrapper transport that distributes requests to them
let nextTransport = 0;
async function roundRobinTransport<TResponse>(
  ...args: Parameters<RpcTransport>
): Promise<RpcResponse<TResponse>> {
  const transport = transports[nextTransport];
  nextTransport = (nextTransport + 1) % transports.length;
  return await transport(...args);
}
```

Si vous pr√©f√©rez ne pas construire vos propres outils de routage, vous pouvez
utiliser un service tierce partie comme
[Iron Forge](https://www.ironforge.sanctum.so/) pour g√©rer le routage √† votre
place.

## Atterrissage des transactions

Sur Devnet, les transactions atterrissent assez facilement. Sur Mainnet, vous
√™tes en concurrence pour l'espace de bloc. Pour augmenter les chances que votre
transaction soit incluse dans un bloc, vous devez vous assurer d'avoir
correctement assembl√© votre transaction. Cela signifie :

- inclure un blockhash r√©cent avant d'envoyer la transaction
- inclure une instruction de frais de priorit√© dans la transaction avec des
  frais de priorit√© comp√©titifs
- inclure une instruction de limite d'unit√©s de calcul dans la transaction avec
  une limite d'unit√©s de calcul bas√©e sur les unit√©s de calcul estim√©es requises
  pour la transaction

De plus, vous devriez envisager d'autres outils comme Jito Bundles pour
augmenter les chances que votre transaction soit incluse dans un bloc. Explorons
ces outils plus en d√©tail.

### Configuration d'envoi de transaction

Lors de l'envoi de transactions sur Mainnet, configurez ces param√®tres pour des
taux d'atterrissage optimaux :

**Gestion du blockhash :**

- R√©cup√©rez avec `confirmed` commitment
- Stockez le `lastValidBlockHeight` renvoy√© par `getLatestBlockhash` ‚Äî cela vous
  indique quand votre transaction expire
- Les blockhashes expirent apr√®s ~150 blocs (~60-90 secondes)

**Options d'envoi :**

- `maxRetries: 0` ‚Äî D√©sactive les nouvelles tentatives RPC automatiques. G√©rez
  les nouvelles tentatives vous-m√™me afin de pouvoir actualiser le blockhash si
  n√©cessaire.
- `skipPreflight: true` ‚Äî Contourne la simulation avant l'envoi. Utilisez ceci
  lorsque vous avez d√©j√† valid√© la transaction et souhaitez la latence la plus
  faible. Gardez-le √† `false` pendant le d√©veloppement pour d√©tecter les erreurs
  t√¥t.

```typescript
import { createSolanaRpc } from "@solana/kit";

const rpc = createSolanaRpc(process.env.RPC_URL!);

// 1. Get blockhash with confirmed commitment
const { value: latestBlockhash } = await rpc
  .getLatestBlockhash({ commitment: "confirmed" })
  .send();

// 2. Build and sign your transaction with the blockhash
// ... (transaction building code)

// 3. Send with production settings
const signature = await rpc
  .sendTransaction(encodedTransaction, {
    encoding: "base64",
    maxRetries: 0n, // Handle retries yourself
    skipPreflight: true, // Skip simulation for speed (use false during dev)
    preflightCommitment: "confirmed"
  })
  .send();

// 4. Track expiration using lastValidBlockHeight
const { lastValidBlockHeight } = latestBlockhash;
// Stop retrying when current block height exceeds lastValidBlockHeight
```

### Utiliser les frais de priorit√©

Chaque transaction Solana n√©cessite des frais de transaction, pay√©s en SOL. Les
frais de transaction sont divis√©s en deux parties : les frais de base et les
frais de priorit√©. Les frais de base r√©mun√®rent les validateurs pour le
traitement de la transaction. Les frais de priorit√© sont des frais optionnels,
pour augmenter les chances que le leader actuel traite votre transaction.
Consid√©rez cela comme une livraison express : vous payez plus pour une livraison
plus rapide et plus fiable.

**Fonctionnement des frais :**

```
Total fee = Base fee (5,000 lamports per signature) + Priority fee
Priority fee = Compute units x Price per unit (micro-lamports per compute unit)
```

**Co√ªts r√©els :**

- Transfert USDC simple : ~0,001-0,005 $ dans des conditions normales
- En cas de congestion : ~0,01-0,05 $
- Congestion maximale : peut augmenter davantage

**Exemple d'impl√©mentation :**

Le package
[`@solana-program/compute-budget`](https://github.com/solana-program/compute-budget)
fournit une fonction d'aide pour mettre √† jour ou ajouter facilement
l'instruction de prix d'unit√© de calcul (en micro-lamports) √† une transaction.

```typescript
import { updateOrAppendSetComputeUnitPriceInstruction } from "@solana-program/compute-budget";

const tx = pipe(
  createTransactionMessage({ version: 0 }),
  (m) => setTransactionMessageFeePayerSigner(payer, m),
  (m) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, m),
  (m) => appendTransactionMessageInstructions([myInstructions], m),
  (m) => updateOrAppendSetComputeUnitPriceInstruction(1000n as MicroLamports, m)
);
```

**Obtenir des estimations de frais :** la plupart des fournisseurs RPC proposent
des API de frais de priorit√© :

- [API de frais de priorit√© Helius](https://docs.helius.dev/solana-apis/priority-fee-api)
- [Module compl√©mentaire de frais de priorit√© QuickNode](https://marketplace.quicknode.com/add-on/solana-priority-fee)
- [API de frais de priorit√© Triton](https://docs.triton.one/chains/solana/improved-priority-fees-api)

Pour la m√©canique compl√®te des frais, consultez
[Frais de transaction](/docs/core/fees) et notre guide :
[Comment ajouter des frais de priorit√© √† une transaction](https://solana.com/developers/cookbook/transactions/add-priority-fees).

### Optimiser les unit√©s de calcul

Le calcul sur Solana est effectivement une mesure de la quantit√© de travail
effectu√©e par le programme. Il existe une limite sur la quantit√© de calcul
pouvant √™tre utilis√©e dans une transaction (actuellement 1,4 million d'unit√©s de
calcul), et une limite sur la quantit√© de calcul pouvant √™tre utilis√©e par
compte par bloc (actuellement 100 millions d'unit√©s de calcul).

Lorsque vous soumettez une transaction, vous devez estimer la quantit√© de calcul
qui sera utilis√©e et d√©finir la limite d'unit√©s de calcul en cons√©quence - il
s'agit effectivement d'une demande de la part de la capacit√© totale qui doit
√™tre r√©serv√©e pour votre transaction. En pratique, cela signifie qu'estimer
correctement les unit√©s de calcul requises pour votre transaction est essentiel
pour que votre transaction soit incluse dans un bloc (et important pour g√©rer
vos frais de priorit√©).

L'API JSON RPC de Solana dispose d'une m√©thode
[`simulatetransaction`](/docs/rpc/http/simulatetransaction) qui peut √™tre
utilis√©e pour estimer les unit√©s de calcul requises pour une transaction, ce qui
inclut une estimation des unit√©s de calcul qui seront utilis√©es. Le package
[`@solana-program/compute-budget`](https://github.com/solana-program/compute-budget)
fournit une fonction d'aide pour estimer facilement les unit√©s de calcul
requises pour une transaction (qui utilise la m√©thode `simulatetransaction` en
arri√®re-plan).

```ts
import {
  estimateComputeUnitLimitFactory,
  updateOrAppendSetComputeUnitLimitInstruction
} from "@solana-program/compute-budget";

const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });
const computeUnitLimit = await estimateComputeUnitLimit(tx);
const txWithComputeUnitLimit = updateOrAppendSetComputeUnitLimitInstruction(
  computeUnitLimit,
  tx
);
```

En production, si vous r√©p√©tez le m√™me type de transaction plusieurs fois, vous
devriez envisager de mettre en cache l'estimation de calcul pour le type de
transaction afin d'√©viter la surcharge li√©e √† l'estimation des unit√©s de calcul
√† chaque fois.

### Bundles Jito

Les bundles Jito sont un outil pour g√©rer l'ex√©cution atomique de plusieurs
transactions. Cela est r√©alis√© en envoyant plusieurs transactions au r√©seau Jito
avec un pourboire. Les pourboires peuvent √™tre utilis√©s pour inciter le r√©seau
Jito √† inclure vos transactions dans un bloc.

**Ressources :**

- [Documentation Jito](https://docs.jito.wtf/lowlatencytxnsend/)
- [üé• Vid√©o : Bundles Jito](https://www.youtube.com/watch?v=HZ1pK9i6zx4)
- [Guide QuickNode sur les bundles Jito](https://www.quicknode.com/guides/solana-development/transactions/jito-bundles)

### Strat√©gies de nouvelle tentative

Les transactions peuvent √©chouer pour de nombreuses raisons. Contrairement aux
API de paiement traditionnelles qui retournent succ√®s/√©chec imm√©diatement, les
transactions blockchain n√©cessitent un suivi de confirmation.

**Concepts cl√©s :**

- **Expiration du blockhash** : les transactions sont valides pendant ~150 blocs
  (~60-90 secondes)
- **Idempotence** : la m√™me transaction sign√©e produit toujours la m√™me
  signature ‚Äî la resoumettre est sans risque
- **Backoff exponentiel** : √©vitez de surcharger le r√©seau avec des tentatives
  rapides

```typescript
import {
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  sendAndConfirmTransactionFactory,
  isSolanaError,
  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED
} from "@solana/kit";

const rpc = createSolanaRpc(process.env.RPC_URL!);
const rpcSubscriptions = createSolanaRpcSubscriptions(process.env.RPC_WSS_URL!);

const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({
  rpc,
  rpcSubscriptions
});

// Send with automatic confirmation tracking and block height monitoring
try {
  await sendAndConfirmTransaction(signedTransaction, {
    commitment: "confirmed",
    // Optional: abort after 75 seconds
    abortSignal: AbortSignal.timeout(75_000)
  });
} catch (e) {
  if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {
    // Blockhash expired‚Äîrebuild transaction with fresh blockhash and retry
    rebuildAndRetryTransaction(); // implement your own logic for rebuilding and retrying the transaction
  }
  throw e;
}
```

Le `sendAndConfirmTransactionFactory` de `@solana/kit` g√®re automatiquement
l'interrogation de confirmation et le suivi de la hauteur de bloc. Il l√®ve
`SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED` lorsque le blockhash de la transaction
expire, signalant que vous devez reconstruire la transaction avec un blockhash
r√©cent.

### Ressources suppl√©mentaires

- [Guide : confirmation et expiration des transactions](https://solana.com/developers/guides/advanced/confirmation)
- [Helius : comment r√©ussir les transactions sur Solana](https://www.helius.dev/blog/how-to-land-transactions-on-solana)
- [QuickNode : strat√©gies pour optimiser les transactions Solana](https://www.quicknode.com/docs/solana/transactions)

## Comprendre les niveaux de confirmation

Solana propose trois niveaux de confirmation. En termes de finance
traditionnelle :

| Niveau      | D√©finition Solana             | √âquivalent traditionnel | Cas d'usage                   |
| ----------- | ----------------------------- | ----------------------- | ----------------------------- |
| `processed` | Dans un bloc, pas encore vot√© | Autorisation en attente | Mises √† jour UI en temps r√©el |
| `confirmed` | Vot√© par la supermajorit√©     | Fonds compens√©s         | **La plupart des paiements**  |
| `finalized` | Enracin√©, irr√©versible        | Fonds r√©gl√©s            | Montants √©lev√©s, conformit√©   |

**Quand utiliser chacun :**

- **Mises √† jour UI** : afficher `processed` pour un retour imm√©diat (¬´ Paiement
  soumis ¬ª)
- **Cr√©diter le compte utilisateur** : attendre `confirmed` (s√ªr pour la plupart
  des transactions)
- **Exp√©dier des biens physiques** : attendre `finalized`
- **Retraits importants** : attendre `finalized`
- **Conformit√©/audit** : toujours enregistrer le statut `finalized`

Pour plus d'informations sur la v√©rification du statut des transactions,
consultez [Interagir avec Solana](/docs/payments/interacting-with-solana).

## Gestion des erreurs

Solana Kit fournit des erreurs typ√©es via `isSolanaError()`. Utilisez des codes
d'erreur sp√©cifiques plut√¥t que la correspondance de cha√Ænes :

```typescript
import {
  isSolanaError,
  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,
  SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,
  SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,
  SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS
} from "@solana/kit";

function handlePaymentError(error: unknown): {
  message: string;
  retryable: boolean;
} {
  // Blockhash expired‚Äîrebuild and retry
  if (
    isSolanaError(error, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED) ||
    isSolanaError(error, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND)
  ) {
    return { message: "Transaction expired‚Äîrebuilding", retryable: true };
  }

  // Insufficient SOL for fees
  if (
    isSolanaError(
      error,
      SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE
    )
  ) {
    return { message: "Not enough SOL for fees", retryable: false };
  }

  // Insufficient token balance
  if (
    isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS)
  ) {
    return { message: "Insufficient balance", retryable: false };
  }

  // Unknown error
  console.error("Payment error:", error);
  return { message: "Payment failed‚Äîplease retry", retryable: true };
}
```

**Codes d'erreur courants :**

| Code d'erreur                | Cause                    | R√©cup√©ration                                                                                                                            |
| ---------------------------- | ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------- |
| `BLOCK_HEIGHT_EXCEEDED`      | Blockhash expir√©         | Reconstruire avec un blockhash r√©cent                                                                                                   |
| `BLOCKHASH_NOT_FOUND`        | Blockhash introuvable    | Reconstruire avec un blockhash r√©cent                                                                                                   |
| `INSUFFICIENT_FUNDS_FOR_FEE` | Pas assez de SOL         | Approvisionner le payeur de frais ou utiliser [l'abstraction de frais](/docs/payments/send-payments/payment-processing/fee-abstraction) |
| `INSUFFICIENT_FUNDS`         | Pas assez de tokens      | L'utilisateur a besoin de plus de solde                                                                                                 |
| `ACCOUNT_NOT_FOUND`          | Compte de token manquant | Cr√©er l'ATA dans la transaction                                                                                                         |

## Transactions sans frais

Les utilisateurs s'attendent √† payer en stablecoins, pas √† acqu√©rir du SOL pour
les frais de r√©seau. Les transactions sans frais r√©solvent ce probl√®me, de la
m√™me mani√®re que les utilisateurs de Venmo ne pensent pas aux frais ACH.
Consultez
[Abstraction des frais](/docs/payments/send-payments/payment-processing/fee-abstraction)
pour une impl√©mentation compl√®te.

## S√©curit√©

### Gestion des cl√©s

- **Ne jamais exposer les cl√©s priv√©es dans le code frontend.** Utilisez la
  signature backend, les portefeuilles mat√©riels, les portefeuilles
  multisignatures ou les services de gestion de cl√©s.
- **S√©parez les portefeuilles chauds et froids.** Portefeuille chaud pour les
  op√©rations, froid pour la tr√©sorerie.
- **Sauvegardez toutes les cl√©s de production.** Stockez les sauvegardes
  chiffr√©es dans plusieurs emplacements s√©curis√©s. Perdre une cl√© signifie
  perdre l'acc√®s de mani√®re permanente.
- **Utilisez des cl√©s diff√©rentes pour devnet et mainnet.** Vos cl√©s devnet ne
  doivent pas √™tre vos cl√©s mainnet. Utilisez une configuration bas√©e sur
  l'environnement pour garantir le chargement des bonnes cl√©s pour chaque
  r√©seau.

### S√©curit√© RPC

Traitez les points de terminaison RPC comme des cl√©s API : ne les exposez pas
dans le code frontend o√π ils peuvent √™tre extraits et utilis√©s de mani√®re
abusive. Utilisez un proxy backend ou des variables d'environnement qui ne sont
pas int√©gr√©es dans le code client.

- [QuickNode : bonnes pratiques de s√©curit√© des points de terminaison](https://www.quicknode.com/guides/quicknode-products/endpoint-security/endpoint-security-best-practices)
- [Helius : prot√©gez vos cl√©s API Solana : bonnes pratiques de s√©curit√©](https://www.helius.dev/docs/rpc/protect-your-keys)

### Surveillance

Suivez ces m√©triques en production :

| M√©trique                          | Pourquoi                      |
| --------------------------------- | ----------------------------- |
| Taux de r√©ussite des transactions | D√©tecter les probl√®mes t√¥t    |
| Latence de confirmation           | Surveiller la sant√© du r√©seau |
| D√©pense en frais prioritaires     | Gestion des co√ªts             |
| Taux d'erreur RPC                 | Sant√© du fournisseur          |

Configurez des alertes pour :

- Transferts au-dessus du seuil depuis la tr√©sorerie
- Pics de taux de transactions √©chou√©es
- Sch√©mas de destinataires inhabituels
- Augmentations du taux d'erreur RPC

Pour la surveillance des transactions en temps r√©el √† grande √©chelle, consultez
notre [guide d'indexation](/docs/payments/accept-payments/indexing).

### V√©rifier les adresses

Chaque token et programme poss√®de exactement une adresse correcte sur le
mainnet. Les tokens usurp√©s imitant l'USDC ou d'autres stablecoins sont courants
‚Äî ils auront le m√™me nom et symbole mais un mint diff√©rent. Votre application
doit coder en dur ou mettre en liste blanche les adresses de mint (selon vos
besoins), ne jamais les accepter dynamiquement de sources non fiables.

**Configuration bas√©e sur l'environnement :** Devnet et Mainnet utilisent
souvent des mints de tokens compl√®tement diff√©rents. Configurez votre
application pour charger les adresses correctes par environnement ‚Äî ne codez pas
en dur les adresses mainnet en oubliant de les √©changer pendant les tests, ou
pire, ne d√©ployez pas les adresses devnet en production.

Voici quelques mints de stablecoins courants :

| Token | √âmetteur | Adresse du mint                                |
| ----- | -------- | ---------------------------------------------- |
| USDC  | Circle   | `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v` |
| USDT  | Tether   | `Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB` |
| PYUSD | PayPal   | `2b1kV6DkPAnxd5ixfnxCpjxmKwqjjaYmCZfHsFu24GXo` |
| USDG  | Paxos    | `2u1tszSeqZ3qBWF3uNGPFc8TzMk2tdiwknnRMWGWjGWH` |

Les adresses de programme sont √©galement importantes. Envoyer des instructions
au mauvais programme √©chouera ‚Äî ou pire, entra√Ænera une perte irr√©versible de
fonds. Les adresses du Token Program sont :

| Programme          | Adresse                                       |
| ------------------ | --------------------------------------------- |
| Token Program      | `TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA` |
| Token-2022 Program | `TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb` |

## Liste de v√©rification avant le lancement

- [ ] SOL mainnet acquis pour les frais et le rent
- [ ] RPC de production configur√© (pas de point de terminaison public)
- [ ] Point de terminaison RPC de secours configur√©
- [ ] Frais de priorit√© impl√©ment√©s avec tarification dynamique
- [ ] La logique de nouvelle tentative g√®re l'expiration du blockhash
- [ ] Niveau de confirmation appropri√© au cas d'usage
- [ ] Toutes les erreurs courantes g√©r√©es avec √©l√©gance
- [ ] Gasless configur√© (le cas √©ch√©ant)
- [ ] Adresses de tokens mainnet v√©rifi√©es (pas de mints devnet)
- [ ] Toutes les cl√©s sauvegard√©es en toute s√©curit√©
- [ ] Gestion des cl√©s v√©rifi√©e (pas de cl√©s dans le frontend)
- [ ] Surveillance et alertes des transactions actives
- [ ] Test de charge effectu√© au volume attendu

## D√©ploiement de programmes

Si vous d√©ployez un programme Solana personnalis√© dans le cadre de votre
infrastructure de paiement, des consid√©rations suppl√©mentaires s'appliquent.

### Pr√©-d√©ploiement

- **Version de Solana CLI :** assurez-vous d'utiliser la derni√®re version de
  [Solana CLI](https://solana.com/docs/intro/installation).
- **Keypair du programme :** votre programme aura une adresse diff√©rente sur le
  mainnet par rapport au devnet (sauf si vous r√©utilisez le m√™me keypair).
  Mettez √† jour toutes les r√©f√©rences dans la configuration de votre
  application. Stockez votre keypair de programme dans un emplacement s√©curis√©
  (notez que l'ex√©cution de `cargo clean` supprimera probablement votre keypair
  de programme).
- **Initialiser les comptes :** si votre programme n√©cessite des comptes
  administrateur, des PDA ou d'autres comptes d'√©tat, assurez-vous qu'ils sont
  cr√©√©s sur le mainnet avant que les utilisateurs n'interagissent avec votre
  application. Il en va de m√™me pour tous les comptes de jetons associ√©s (ATA)
  dont votre programme a besoin.

### Processus de d√©ploiement

- **Comptes tampons :** les programmes volumineux se d√©ploient via des comptes
  tampons. La commande `solana program deploy` g√®re cela automatiquement, mais
  comprenez que le d√©ploiement n'est pas atomique ‚Äî en cas d'interruption, vous
  devrez peut-√™tre r√©cup√©rer ou fermer les comptes tampons. Voir
  [Deploying Programs](https://solana.com/docs/programs/deploying).
- **Autorit√© de mise √† niveau :** d√©cidez si votre programme doit √™tre √©volutif
  apr√®s le lancement. Pour l'immuabilit√©, r√©voquez l'autorit√© de mise √† niveau
  apr√®s le d√©ploiement. Pour plus de flexibilit√©, s√©curisez la cl√© d'autorit√© de
  mise √† niveau de mani√®re appropri√©e.
- **Loyer :** assurez-vous que votre portefeuille de d√©ploiement dispose de
  suffisamment de SOL pour couvrir les minimums exempts de loyer pour tous les
  comptes de programme.
- **V√©rification :**
  [v√©rifiez](https://solana.com/docs/programs/verified-builds) votre programme
  pour vous assurer que le programme ex√©cutable que vous d√©ployez sur le r√©seau
  Solana correspond au code source de votre d√©p√¥t

Pour des instructions compl√®tes sur le d√©ploiement de programmes, consultez
[Deploying Programs](https://solana.com/docs/programs/deploying).
