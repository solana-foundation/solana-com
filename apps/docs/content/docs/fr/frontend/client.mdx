---
title: "@solana/client"
description:
  Créez des interfaces Solana légères avec le runtime client Solana headless.
---

`@solana/client` maintient une surface d'exécution légère. Un store, une pile
RPC et un registre de portefeuilles alimentent les différents helpers afin que
la même instance puisse prendre en charge des CLI, des scripts ou des interfaces
complètes. Les actions, watchers et helpers partagent tous le cache, les
abonnements et les sessions de portefeuilles via ce client unique.

<Callout type="info">
  Lorsque vous créez une expérience purement React, il est généralement plus
  rapide de commencer avec [`@solana/react-hooks`](/docs/frontend/react-hooks).
  Le package de hooks encapsule ce même runtime client et expose des hooks prêts
  à l'emploi afin que vous ne descendiez au client headless que lorsque vous
  avez besoin d'un contrôle supplémentaire.
</Callout>

## Installation

```terminal
$ npm install @solana/client
```

Utilisez n'importe quel gestionnaire de packages ; le client s'exécute dans les
navigateurs, workers, React, Svelte ou les runtimes côté serveur.

## Créer un client une seule fois

Choisissez les connecteurs Wallet Standard (la découverte automatique est le
moyen le plus rapide pour commencer), puis créez le client. Cet objet unique
expose le store, les actions, les watchers et les helpers.

```ts
import { autoDiscover, createClient } from "@solana/client";

const client = createClient({
  endpoint: "https://api.devnet.solana.com",
  websocketEndpoint: "wss://api.devnet.solana.com",
  walletConnectors: autoDiscover()
});

await client.actions.connectWallet("wallet-standard:phantom");
const balance = await client.actions.fetchBalance("Fke...address");
console.log(balance.lamports?.toString());
```

Le store du client suit la configuration du cluster, les abonnements, les
transactions en attente et les sessions de portefeuilles. Vous pouvez fournir
votre propre store Zustand si vous avez besoin de persistance ou de coordination
multi-onglets.

## Orchestration des portefeuilles

Les connecteurs encapsulent les métadonnées Wallet Standard ainsi que la logique
de connexion/déconnexion. Enregistrez les helpers intégrés `phantom()`,
`solflare()`, `backpack()`, ou `autoDiscover()`, ou encapsulez des fournisseurs
personnalisés avec `createWalletStandardConnector`. Toutes les actions de
portefeuille (connexion, déconnexion, signature, envoi) transitent par le
registre du client afin que chaque consommateur reste synchronisé.

## Actions, watchers et helpers

- **Actions** encapsulent les lectures et écritures RPC courantes tout en
  mettant à jour le store (par ex., `fetchAccount`, `requestAirdrop`,
  `setCluster`).
- **Watchers** multiplexent les abonnements websocket, diffusent les mises à
  jour dans le store et vous fournissent des handles d'abandon pour le
  nettoyage.
- **Helpers** exposent des flux de niveau supérieur tels que les transferts SOL,
  les helpers de tokens SPL, l'interrogation de signatures et les pools de
  transactions.

```ts
const abortWatcher = client.watchers.watchBalance(
  { address: "Fke...address" },
  (lamports) => {
    console.log("live balance", lamports.toString());
  }
);

// Later when the component unmounts or the flow ends
abortWatcher.abort();
```

## Modèle d'assistance aux transactions

L'assistant de transaction gère l'actualisation du blockhash, la résolution du
payeur de frais et la signature. Vous pouvez préparer, inspecter et envoyer avec
l'expérience utilisateur de votre choix.

```ts
const prepared = await client.helpers.transaction.prepare({
  authority: client.store.getState().wallet.session!,
  instructions: [instructionA, instructionB]
});

await client.helpers.transaction.simulate(prepared, {
  commitment: "processed"
});
const signature = await client.helpers.transaction.send(prepared);
console.log("submitted", signature.toString());
```

Utilisez `prepareAndSend` pour un flux préconfiguré (simulation et
journalisation) ou appelez `sign` / `toWire` pour collecter les signatures
manuellement avant de relayer le format de transmission vous-même.

## Modèles courants pour les développeurs Solana

- **Machines à états sans interface** : exécutez le client dans des routes API,
  des scripts ou des workers pour réutiliser la même logique d'orchestration
  wallet + RPC qui alimente votre interface utilisateur.
- **Tableaux de bord en temps réel** : combinez des observateurs (soldes,
  comptes, signatures) avec votre bibliothèque d'interface utilisateur préférée
  ; le client gère la distribution websocket et l'invalidation du cache.
- **Stores personnalisés** : injectez votre propre store Zustand pour hydrater
  depuis IndexedDB/localStorage, répliquer l'état vers les sessions serveur ou
  coordonner entre les onglets du navigateur.
- **Pont vers les hooks React** : transmettez une instance de client configurée
  à `@solana/react-hooks` lorsque vous souhaitez des hooks ergonomiques
  au-dessus du même runtime.
- **Testabilité** : l'interface client unique peut être simulée dans les tests
  unitaires, facilitant la simulation des réponses RPC ou des sessions wallet
  sans qu'un wallet de navigateur soit présent.
