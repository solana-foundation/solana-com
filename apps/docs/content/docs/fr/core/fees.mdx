---
title: Frais de transaction
description:
  Découvrez les frais de transaction de Solana, incluant les frais de base et
  les frais de priorité, comment chacun est appliqué, et les meilleures
  pratiques pour gérer les unités de calcul dans vos transactions.
---

Chaque transaction Solana nécessite des frais de transaction, payés en SOL. Les
frais de transaction sont divisés en deux parties : les frais de base et les
frais de priorisation. Les frais de base rémunèrent les validateurs pour le
traitement de la transaction. Les frais de priorisation sont des frais
optionnels, pour augmenter la probabilité que le leader actuel traite votre
transaction.

## Frais de base

Chaque transaction coûte 5000 [lamports](/docs/references/terminology#lamport)
par signature incluse. Ces frais sont payés par le premier signataire de la
transaction. Seuls les comptes détenus par le System Program peuvent payer les
frais de transaction. Les frais de base sont répartis comme suit :

- **50 % brûlés :** La moitié est
  [brûlée](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (retirée de l'offre de SOL en circulation).
- **50 % distribués :** La moitié est
  [versée au validateur](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
  qui a traité la transaction.

## Frais de priorisation

Les
[frais de priorisation](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
sont des frais optionnels utilisés pour augmenter la probabilité que le leader
actuel (validateur) traite votre transaction. Le validateur reçoit
[100 % des frais de priorité](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Les frais de priorisation peuvent être définis en ajustant le prix des
[unités de calcul](/docs/references/terminology#compute-units) (CU) et la limite
de CU de la transaction. (Consultez le
[guide Comment utiliser les frais de priorité](/developers/guides/advanced/how-to-use-priority-fees)
pour plus de détails sur les frais de priorisation.)

Les frais de priorisation sont calculés comme suit :

```text title="Prioritization fee formula"
Prioritization fee = CU limit * CU price
```

Les frais de priorisation sont utilisés pour déterminer la
[priorité de votre transaction](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646),
par rapport aux autres transactions. Ils sont calculés à l'aide de la formule
suivante :

```text title="Transaction priority formula"
Priority = (Prioritization fee + Base fee) / (1 + CU limit + Signature CUs + Write lock CUs)
```

#### Limite d'unités de calcul

Par
[défaut](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
chaque instruction se voit allouer
[200 000 CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
et chaque transaction se voit allouer
[1,4 million de CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14).
Vous pouvez modifier ces valeurs par défaut en incluant une instruction
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
dans votre transaction.

Pour calculer la limite de CU appropriée pour votre transaction, nous
recommandons les étapes suivantes :

1. Estimez les unités de CU requises en
   [simulant](/developers/guides/advanced/how-to-request-optimal-compute) la
   transaction
2. Ajoutez une marge de sécurité de 10 % à cette estimation

<Callout type="warn">
  Les frais de priorité sont déterminés par la limite d'unités de calcul
  demandée pour la transaction, *et non* par le nombre réel d'unités de calcul
  utilisées. Si vous définissez une limite d'unités de calcul trop élevée ou
  utilisez le montant par défaut, vous risquez de payer pour des unités de
  calcul non utilisées.
</Callout>

#### Prix de l'unité de calcul

Le prix de l'unité de calcul est un montant optionnel de
[micro-lamports](/docs/references/terminology#micro-lamports) payé pour chaque
CU demandée. Vous pouvez considérer le prix de la CU comme un pourboire pour
encourager le validateur à prioriser votre transaction. Pour définir le prix de
la CU, incluez une instruction
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
dans votre transaction.

<Callout>
  Le prix de la CU par défaut est 0, ce qui signifie que les frais de
  priorisation par défaut sont également de 0.
</Callout>

Pour vous aider à déterminer le meilleur prix de CU pour votre transaction,
consultez la recommandation de prix de CU en temps réel fournie dans le tableau
ci-dessous.

| Fournisseur                             | API de frais de priorité                                                          |
| --------------------------------------- | --------------------------------------------------------------------------------- |
| [Helius](https://www.helius.dev/)       | [Documentation](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Documentation](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Documentation](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Exemple

Les exemples ci-dessous montrent comment définir la limite de CU et le prix de
la CU sur une transaction à l'aide des SDK Solana.

| SDK                            | Référence du code source                                                                                                       |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
