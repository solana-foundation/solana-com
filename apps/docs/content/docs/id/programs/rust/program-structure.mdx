---
title: Struktur program
description:
  Pelajari cara menyusun program Solana dalam Rust, termasuk entrypoint,
  manajemen state, penanganan instruksi, dan pengujian.
h1: Struktur program Rust
---

Program Solana yang ditulis dalam Rust memiliki persyaratan struktural minimal,
sehingga memberikan fleksibilitas dalam cara kode diorganisir. Satu-satunya
persyaratan adalah program harus memiliki `entrypoint`, yang menentukan di mana
eksekusi program dimulai.

## Struktur program

Meskipun tidak ada aturan ketat untuk struktur file, program Solana biasanya
mengikuti pola umum:

- `entrypoint.rs`: Mendefinisikan entrypoint yang merutekan instruksi yang
  masuk.
- `state.rs`: Mendefinisikan state program (data akun).
- `instructions.rs`: Mendefinisikan instruksi yang dapat dieksekusi oleh
  program.
- `processor.rs`: Mendefinisikan handler instruksi (fungsi) yang
  mengimplementasikan logika bisnis untuk setiap instruksi.
- `error.rs`: Mendefinisikan error kustom yang dapat dikembalikan oleh program.

Sebagai contoh, lihat
[Token Program](https://github.com/solana-program/token/tree/main/program/src).

## Contoh program

Untuk mendemonstrasikan cara membangun program Rust native dengan beberapa
instruksi, kita akan membahas program counter sederhana yang mengimplementasikan
dua instruksi:

1. `InitializeCounter`: Membuat dan menginisialisasi akun baru dengan nilai
   awal.
2. `IncrementCounter`: Menambah nilai yang disimpan dalam akun yang sudah ada.

Untuk kesederhanaan, program akan diimplementasikan dalam satu file `lib.rs`,
meskipun dalam praktiknya Anda mungkin ingin membagi program yang lebih besar ke
dalam beberapa file.

<Accordions>
<Accordion title="Kode program lengkap">

<CodeTabs>

```rs !! title="src/lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

// Program entrypoint
entrypoint!(process_instruction);

// Function to route instructions to the correct handler
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Unpack instruction data
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    // Match instruction type
    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => process_increment_counter(program_id, accounts)?,
    };
    Ok(())
}

// Instructions that our program can execute
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 }, // variant 0
    IncrementCounter,                         // variant 1
}

// Initialize a new counter account
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // Size of our counter account
    let account_space = 8; // u64 requires 8 bytes

    // Calculate minimum balance for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for the new account
            counter_account.key,  // Account to be created
            required_lamports,    // Amount of lamports to transfer to the new account
            account_space as u64, // Size in bytes to allocate for the data field
            program_id,           // Set program owner to our program
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Create a new CounterAccount struct with the initial value
    let counter_data = CounterAccount {
        count: initial_value,
    };

    // Get a mutable reference to the counter account's data
    let mut account_data = &mut counter_account.data.borrow_mut()[..];

    // Serialize the CounterAccount struct into the account's data
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}

// Update an existing counter's value
fn process_increment_counter(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify account ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Mutable borrow the account data
    let mut data = counter_account.data.borrow_mut();

    // Deserialize the account data into our CounterAccount struct
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    // Increment the counter value
    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    // Serialize the updated counter data back into the account
    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);
    Ok(())
}

// Struct representing our counter account's data
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    count: u64,
}

#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        // Create a new LiteSVM instance
        let mut svm = LiteSVM::new();

        // Create a keypair for the transaction payer
        let payer = Keypair::new();

        // Airdrop some lamports to the payer
        svm.airdrop(&payer.pubkey(), 1_000_000_000).unwrap();

        // Load our program
        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();
        svm.add_program_from_file(program_id, "target/deploy/counter_program.so")
            .unwrap();

        // Create a new keypair to use as the address for our counter account
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Use Borsh serialization for the instruction
        let init_instruction_data =
            borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
                .expect("Failed to serialize instruction");

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Create transaction
        let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(&[&payer, &counter_keypair], message, svm.latest_blockhash());

        // Send transaction
        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Initialize transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);

        // Check account data
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");
        assert_eq!(counter.count, 42);
        println!(
            "Counter initialized successfully with value: {}",
            counter.count
        );

        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Use Borsh serialization for increment instruction
        let increment_data = borsh::to_vec(&CounterInstruction::IncrementCounter)
            .expect("Failed to serialize instruction");

        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &increment_data,
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Create transaction
        let message = Message::new(&[increment_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(&[&payer, &counter_keypair], message, svm.latest_blockhash());

        // Send transaction
        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Increment transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);

        // Check account data
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");
        assert_eq!(counter.count, 43);
        println!("Counter incremented successfully to: {}", counter.count);
    }
}
```

```rs !! title="examples/client.rs"
use counter_program::CounterInstruction;
use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    system_program,
    transaction::Transaction,
};
use std::str::FromStr;

#[tokio::main]
async fn main() {
    // Replace with your actual program ID from deployment
    let program_id = Pubkey::from_str("AUia4JuToXDAB4gR2ZXWqJ6kDyCqn7WqunGAgw1KxdKU")
        .expect("Invalid program ID");

    // Connect to local cluster
    let rpc_url = String::from("http://localhost:8899");
    let client = RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed());

    // Generate a new keypair for paying fees
    let payer = Keypair::new();

    // Request airdrop of 1 SOL for transaction fees
    println!("Requesting airdrop...");
    let airdrop_signature = client
        .request_airdrop(&payer.pubkey(), 1_000_000_000)
        .expect("Failed to request airdrop");

    // Wait for airdrop confirmation
    loop {
        if client
            .confirm_transaction(&airdrop_signature)
            .unwrap_or(false)
        {
            break;
        }
        std::thread::sleep(std::time::Duration::from_millis(500));
    }
    println!("Airdrop confirmed");

    println!("\nInitializing counter...");
    let counter_keypair = Keypair::new();
    let initial_value = 100u64;

    // Serialize the initialize instruction data
    let instruction_data = borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
        .expect("Failed to serialize instruction");

    let initialize_instruction = Instruction::new_with_bytes(
        program_id,
        &instruction_data,
        vec![
            AccountMeta::new(counter_keypair.pubkey(), true),
            AccountMeta::new(payer.pubkey(), true),
            AccountMeta::new_readonly(system_program::id(), false),
        ],
    );

    let mut transaction =
        Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));

    let blockhash = client
        .get_latest_blockhash()
        .expect("Failed to get blockhash");
    transaction.sign(&[&payer, &counter_keypair], blockhash);

    match client.send_and_confirm_transaction(&transaction) {
        Ok(signature) => {
            println!("Counter initialized!");
            println!("Transaction: {}", signature);
            println!("Counter address: {}", counter_keypair.pubkey());
        }
        Err(err) => {
            eprintln!("Failed to initialize counter: {}", err);
            return;
        }
    }

    println!("\nIncrementing counter...");
    // Serialize the increment instruction data
    let increment_data = borsh::to_vec(&CounterInstruction::IncrementCounter)
        .expect("Failed to serialize instruction");

    let increment_instruction = Instruction::new_with_bytes(
        program_id,
        &increment_data,
        vec![AccountMeta::new(counter_keypair.pubkey(), true)],
    );

    let mut transaction =
        Transaction::new_with_payer(&[increment_instruction], Some(&payer.pubkey()));

    transaction.sign(&[&payer, &counter_keypair], blockhash);

    match client.send_and_confirm_transaction(&transaction) {
        Ok(signature) => {
            println!("Counter incremented!");
            println!("Transaction: {}", signature);
        }
        Err(err) => {
            eprintln!("Failed to increment counter: {}", err);
        }
    }
}
```

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
borsh = "1.5.7"
solana-program = "2.2.0"

[dev-dependencies]
litesvm = "0.6.1"
solana-client = "2.2.0"
solana-sdk = "2.2.0"
tokio = "1.47.1"

[[example]]
name = "client"
path = "examples/client.rs"
```

</CodeTabs>

</Accordion>
</Accordions>

## Bagian 1: Menulis program

Mari kita mulai dengan membangun program counter. Kita akan membuat program yang
dapat menginisialisasi counter dengan nilai awal dan menambahnya.

<ScrollyCoding>

## !!steps Buat program baru

Pertama, mari kita buat proyek Rust baru untuk program Solana kita.

```terminal
$ cargo new counter_program --lib
$ cd counter_program
```

Anda akan melihat file `src/lib.rs` dan `Cargo.toml` default.

<Callout type="warn">
  Perbarui field `edition` di `Cargo.toml` menjadi 2021. Jika tidak, Anda
  mungkin akan mengalami error saat membangun program.
</Callout>

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
# !mark
edition = "2021"

[dependencies]
```

```rs !! title="lib.rs"
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
```

## !!steps Tambahkan dependensi

Sekarang mari kita tambahkan dependensi yang diperlukan untuk membangun program
Solana. Kita memerlukan `solana-program` untuk SDK inti dan `borsh` untuk
serialisasi.

```terminal
$ cargo add solana-program@2.2.0
$ cargo add borsh
```

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[dependencies]
# !focus(1:4)
# Borsh is used for serializing/deserializing
borsh = "1.5.7"
# The core Solana program SDK
solana-program = "2.2.0"
```

<Callout type="info">
  Tidak ada keharusan untuk menggunakan Borsh. Namun, ini adalah library
  serialisasi yang umum digunakan untuk program Solana.
</Callout>

## !!steps Konfigurasi crate-type

Program Solana harus dikompilasi sebagai dynamic library. Tambahkan bagian
`[lib]` untuk mengkonfigurasi cara Cargo membangun program.

```toml title="Cargo.toml"
[lib]
crate-type = ["cdylib", "lib"]
```

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

# !focus(1:2)
[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
borsh = "1.5.7"
solana-program = "2.2.0"
```

<Callout type="warn">
  Jika Anda tidak menyertakan konfigurasi ini, direktori target/deploy tidak
  akan dibuat saat Anda membangun program.
</Callout>

## !!steps Setup entrypoint program

Setiap program Solana memiliki entrypoint, yaitu fungsi yang dipanggil ketika
program dijalankan. Mari kita mulai dengan menambahkan import yang kita perlukan
untuk program dan menyiapkan entrypoint.

Tambahkan kode berikut ke `lib.rs`:

```rs title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    Ok(())
}
```

Macro
[entrypoint](https://github.com/anza-xyz/solana-sdk/blob/449d97c0ed164611dae538e2ee91ca0caaaec515/program-entrypoint/src/lib.rs#L126-L140)
menangani deserialisasi data `input` ke dalam parameter fungsi
`process_instruction`.

Sebuah `entrypoint` program Solana memiliki function signature berikut.
Developer bebas membuat implementasi sendiri dari fungsi `entrypoint`.

```rs
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64;
```

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

// This macro defines the program's entrypoint
// !mark
entrypoint!(process_instruction);

// The main function that processes all incoming instructions
pub fn process_instruction(
    program_id: &Pubkey,      // This program's public key
    accounts: &[AccountInfo],  // Accounts passed to the instruction
    instruction_data: &[u8],   // Raw instruction data as bytes
) -> ProgramResult {
    // Program logic will go here
    Ok(())
}
```

## !!steps Definisikan state program

Sekarang mari kita definisikan struktur data yang akan disimpan dalam akun
counter kita. Ini adalah data yang akan disimpan dalam field `data` dari akun.

Tambahkan kode berikut ke `lib.rs`:

```rs title="lib.rs"
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    Ok(())
}

// !focus(1:7)
// Define the data structure for our counter account
// The derive macros enable automatic serialization/deserialization
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    // Store the counter value
    pub count: u64,
}
```

## !!steps Definisikan enum instruksi

Mari kita definisikan instruksi-instruksi yang dapat dieksekusi oleh program
kita. Kita akan menggunakan enum di mana setiap varian mewakili instruksi yang
berbeda.

Tambahkan kode berikut ke `lib.rs`:

```rs title="lib.rs"
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 },
    IncrementCounter,
}
```

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    Ok(())
}

// !focus(1:8)
// Define the instructions our program can execute
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    // Variant 0: Initialize a counter with a starting value
    InitializeCounter { initial_value: u64 },
    // Variant 1: Increment an existing counter by 1
    IncrementCounter,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

## !!steps Implementasikan deserialisasi instruksi

Sekarang kita perlu mendeserialisasi `instruction_data` (byte mentah) menjadi
salah satu varian enum `CounterInstruction` kita. Metode `try_from_slice` Borsh
menangani konversi ini secara otomatis.

Perbarui fungsi `process_instruction` untuk menggunakan deserialisasi Borsh:

```rs title="lib.rs"
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    Ok(())
}
```

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

// !focus(1:10)
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Deserialize instruction data using Borsh
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    Ok(())
}

// !focus(1:8)
// Instructions are automatically serialized/deserialized by Borsh
// The enum variants are numbered 0, 1, etc. in order of declaration
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 },  // Variant 0
    IncrementCounter,                          // Variant 1
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

## !!steps Arahkan instruksi ke handler

Sekarang mari kita perbarui fungsi `process_instruction` utama untuk mengarahkan
instruksi ke fungsi handler yang sesuai.

Pola routing ini umum digunakan dalam program Solana. `instruction_data`
dideserialisasi menjadi varian dari enum yang mewakili instruksi, kemudian
fungsi handler yang sesuai dipanggil. Setiap fungsi handler mencakup
implementasi untuk instruksi tersebut.

Tambahkan kode berikut ke `lib.rs` untuk memperbarui fungsi
`process_instruction` dan menambahkan handler untuk instruksi
`InitializeCounter` dan `IncrementCounter`:

```rs title="lib.rs"
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => {
            process_increment_counter(program_id, accounts)?
        }
    };
    Ok(())
}

fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    Ok(())
}

fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    Ok(())
}
```

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

// !focus(1:40)
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Deserialize the instruction using Borsh
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    // Route to the appropriate handler based on the instruction
    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => {
            process_increment_counter(program_id, accounts)?
        }
    };

    Ok(())
}

// Handler function for initializing a counter
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    // Implementation coming next
    Ok(())
}

// Handler function for incrementing a counter
fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    // Implementation coming next
    Ok(())
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 },
    IncrementCounter,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

## !!steps Implementasikan handler initialize

Mari kita implementasikan handler untuk membuat dan menginisialisasi akun
counter baru. Karena hanya System Program yang dapat membuat akun di Solana,
kita akan menggunakan Cross Program Invocation (CPI), pada dasarnya memanggil
program lain dari program kita.

Program kita melakukan CPI untuk memanggil instruksi `create_account` dari
System Program. Akun baru dibuat dengan program kita sebagai pemilik, memberikan
program kita kemampuan untuk menulis ke akun dan menginisialisasi data.

Tambahkan kode berikut ke `lib.rs` untuk memperbarui fungsi
`process_initialize_counter`:

```rs title="lib.rs"
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    let account_space = 8;

    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    invoke(
        &system_instruction::create_account(
            payer_account.key,
            counter_account.key,
            required_lamports,
            account_space as u64,
            program_id,
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    let counter_data = CounterAccount {
        count: initial_value,
    };

    let mut account_data = &mut counter_account.data.borrow_mut()[..];
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}
```

<Callout type="warn">
  Instruksi ini hanya untuk tujuan demonstrasi. Ini tidak mencakup pemeriksaan
  keamanan dan validasi yang diperlukan untuk program produksi.
</Callout>

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,                      // For logging messages
    program::invoke,          // For Cross Program Invocations
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,       // System Program instructions
    sysvar::{rent::Rent, Sysvar},  // For rent calculations
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => {
            process_increment_counter(program_id, accounts)?
        }
    };

    Ok(())
}

// !focus(1:50)
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    // Create an iterator over the accounts
    let accounts_iter = &mut accounts.iter();

    // Extract the required accounts in order
    let counter_account = next_account_info(accounts_iter)?;  // The new counter account
    let payer_account = next_account_info(accounts_iter)?;    // Who pays for the account
    let system_program = next_account_info(accounts_iter)?;   // System Program for CPI

    // Calculate the space needed for our counter data
    let account_space = 8; // 8 bytes for a u64

    // Get the minimum balance required for rent exemption
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create the counter account via CPI to the System Program
    // !focus(1:15)
    invoke(
        &system_instruction::create_account(
            payer_account.key,    // Account paying for creation
            counter_account.key,  // New account being created
            required_lamports,    // Lamports to transfer
            account_space as u64, // Space to allocate in bytes
            program_id,          // Program that will own this account (our program)
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Initialize the counter data
    let counter_data = CounterAccount {
        count: initial_value,
    };

    // Serialize and write the data to the account
    let mut account_data = &mut counter_account.data.borrow_mut()[..];
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}

fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    Ok(())
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 },
    IncrementCounter,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

## !!steps Implementasikan handler increment

Sekarang mari kita implementasikan handler yang menambah counter yang sudah ada.
Instruksi ini:

- Membaca field `data` akun untuk `counter_account`
- Mendeserialisasikannya menjadi struct `CounterAccount`
- Menambah field `count` sebesar 1
- Menserialisasikan struct `CounterAccount` kembali ke field `data` akun

Tambahkan kode berikut ke `lib.rs` untuk memperbarui fungsi
`process_increment_counter`:

```rs title="lib.rs"
fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;

    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    let mut data = counter_account.data.borrow_mut();

    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);

    Ok(())
}
```

<Callout type="warn">
  Instruksi ini hanya untuk tujuan demonstrasi. Ini tidak mencakup pemeriksaan
  keamanan dan validasi yang diperlukan untuk program produksi.
</Callout>

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => {
            process_increment_counter(program_id, accounts)?
        }
    };

    Ok(())
}

fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    let account_space = 8;

    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    invoke(
        &system_instruction::create_account(
            payer_account.key,
            counter_account.key,
            required_lamports,
            account_space as u64,
            program_id,
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    let counter_data = CounterAccount {
        count: initial_value,
    };

    let mut account_data = &mut counter_account.data.borrow_mut()[..];
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}

// !focus(1:33)
fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    // Get the counter account to increment
    let counter_account = next_account_info(accounts_iter)?;

    // Security check: Verify this program owns the account
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Get a mutable reference to the account's data
    let mut data = counter_account.data.borrow_mut();

    // Deserialize the current counter value
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    // Increment the counter value
    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    // Serialize the updated data back to the account
    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);

    Ok(())
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    InitializeCounter { initial_value: u64 },
    IncrementCounter,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    pub count: u64,
}
```

## !!steps Program selesai

Selamat! Anda telah membangun program Solana lengkap yang mendemonstrasikan
struktur dasar yang dimiliki oleh semua program Solana:

- **Entrypoint**: Mendefinisikan di mana eksekusi program dimulai dan
  mengarahkan semua permintaan masuk ke handler instruksi yang sesuai
- **Penanganan instruksi**: Mendefinisikan instruksi dan fungsi handler
  terkaitnya
- **Manajemen state**: Mendefinisikan struktur data akun dan mengelola state
  mereka di akun yang dimiliki program
- **Cross Program Invocation (CPI)**: Memanggil System Program untuk membuat
  akun baru yang dimiliki program

Langkah selanjutnya adalah menguji program untuk memastikan semuanya berfungsi
dengan benar.

```rs !! title="lib.rs"
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    system_instruction,
    sysvar::{rent::Rent, Sysvar},
};

// Program entrypoint - this is where execution starts
entrypoint!(process_instruction);

/// Main instruction processing function
/// Routes incoming instructions to appropriate handlers
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Parse instruction data
    let instruction = CounterInstruction::try_from_slice(instruction_data)
        .map_err(|_| ProgramError::InvalidInstructionData)?;

    // Route to appropriate handler
    match instruction {
        CounterInstruction::InitializeCounter { initial_value } => {
            msg!("Instruction: Initialize Counter");
            process_initialize_counter(program_id, accounts, initial_value)?
        }
        CounterInstruction::IncrementCounter => {
            msg!("Instruction: Increment Counter");
            process_increment_counter(program_id, accounts)?
        }
    };

    Ok(())
}

/// Instructions supported by the counter program
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub enum CounterInstruction {
    /// Initialize a new counter with the given value
    InitializeCounter { initial_value: u64 },

    /// Increment an existing counter by 1
    IncrementCounter,
}

/// Initialize a new counter account
///
/// Accounts expected:
/// 1. `[signer, writable]` Counter account to create
/// 2. `[signer, writable]` Payer account
/// 3. `[]` System Program
fn process_initialize_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    initial_value: u64,
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    let counter_account = next_account_info(accounts_iter)?;
    let payer_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    let account_space = 8;
    let rent = Rent::get()?;
    let required_lamports = rent.minimum_balance(account_space);

    // Create account via CPI to System Program
    invoke(
        &system_instruction::create_account(
            payer_account.key,
            counter_account.key,
            required_lamports,
            account_space as u64,
            program_id,
        ),
        &[
            payer_account.clone(),
            counter_account.clone(),
            system_program.clone(),
        ],
    )?;

    // Initialize counter data
    let counter_data = CounterAccount {
        count: initial_value,
    };

    let mut account_data = &mut counter_account.data.borrow_mut()[..];
    counter_data.serialize(&mut account_data)?;

    msg!("Counter initialized with value: {}", initial_value);

    Ok(())
}

/// Increment an existing counter
///
/// Accounts expected:
/// 1. `[writable]` Counter account to increment
fn process_increment_counter(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let counter_account = next_account_info(accounts_iter)?;

    // Verify ownership
    if counter_account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Read, update, write
    let mut data = counter_account.data.borrow_mut();
    let mut counter_data: CounterAccount = CounterAccount::try_from_slice(&data)?;

    counter_data.count = counter_data
        .count
        .checked_add(1)
        .ok_or(ProgramError::InvalidAccountData)?;

    counter_data.serialize(&mut &mut data[..])?;

    msg!("Counter incremented to: {}", counter_data.count);

    Ok(())
}

/// Counter account data structure
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct CounterAccount {
    /// Current counter value
    pub count: u64,
}
```

</ScrollyCoding>

## Bagian 2: Menguji program

Sekarang mari kita uji program counter kita. Kita akan menggunakan
[LiteSVM](https://github.com/LiteSVM/litesvm), sebuah framework pengujian yang
memungkinkan kita menguji program tanpa melakukan deployment ke cluster.

<ScrollyCoding>

## !!steps Tambahkan dependensi pengujian

Pertama, mari tambahkan dependensi yang diperlukan untuk pengujian. Kita akan
menggunakan `litesvm` untuk pengujian dan `solana-sdk`.

```terminal
$ cargo add litesvm@0.6.1 --dev
$ cargo add solana-sdk@2.2.0 --dev
```

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
borsh = "1.5.7"
solana-program = "2.2.0"

# !focus(1:3)
[dev-dependencies]
litesvm = "0.6.1"
solana-sdk = "2.2.0"
```

## !!steps Buat modul pengujian

Sekarang mari tambahkan modul pengujian ke program kita. Kita akan mulai dengan
struktur dasar dan import yang diperlukan.

Tambahkan kode berikut ke `lib.rs`, tepat di bawah kode program:

```rs title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        // Test implementation will go here
    }
}
```

```rs !! title="lib.rs"
// ... (program code above) ...

// !focus(1:22)
// Test module - only compiled when running tests
#[cfg(test)]
mod test {
    use super::*;  // Import everything from the parent module
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        // Test implementation will go here
    }
}
```

Atribut `#[cfg(test)]` memastikan kode ini hanya dikompilasi saat menjalankan
pengujian.

## !!steps Inisialisasi lingkungan pengujian

Mari siapkan lingkungan pengujian dengan LiteSVM dan danai akun payer.

LiteSVM mensimulasikan lingkungan runtime Solana, memungkinkan kita menguji
program tanpa melakukan deployment ke cluster yang sebenarnya.

Tambahkan kode berikut ke `lib.rs` dengan memperbarui fungsi
`test_counter_program`:

```rs title="lib.rs"
let mut svm = LiteSVM::new();

let payer = Keypair::new();

svm.airdrop(&payer.pubkey(), 1_000_000_000)
    .expect("Failed to airdrop");
```

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        // !focus(1:12)
        // Create a new instance of the Solana VM for testing
        let mut svm = LiteSVM::new();

        // Create a keypair for the transaction payer
        let payer = Keypair::new();

        // Fund the payer account with 1 SOL (1 billion lamports)
        // This is needed to pay for transaction fees and account creation
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");
    }
}
```

## !!steps Muat program

Sekarang kita perlu membangun dan memuat program kita ke dalam lingkungan
pengujian. Jalankan perintah `cargo build-sbf` untuk membangun program. Ini akan
menghasilkan file `counter_program.so` di direktori `target/deploy`.

```terminal
$ cargo build-sbf
```

<Callout type="warn">
  Pastikan `edition` di `Cargo.toml` diatur ke `2021`.
</Callout>

Setelah build, kita dapat memuat program.

Perbarui fungsi `test_counter_program` untuk memuat program ke dalam lingkungan
pengujian.

```rs title="lib.rs"
let program_keypair = Keypair::new();
let program_id = program_keypair.pubkey();

svm.add_program_from_file(
    program_id,
    "target/deploy/counter_program.so"
).expect("Failed to load program");
```

<Callout type="warn">
  Anda harus menjalankan `cargo build-sbf` sebelum menjalankan pengujian untuk
  menghasilkan file `.so`. Pengujian memuat program yang telah dikompilasi.
</Callout>

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        let mut svm = LiteSVM::new();

        let payer = Keypair::new();
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");

        // !focus(1:11)
        // Load our compiled program into the test environment
        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();

        // Load the compiled program
        svm.add_program_from_file(
            program_id,
            "target/deploy/counter_program.so"
        ).expect("Failed to load program");
    }
}
```

## !!steps Menguji instruksi inisialisasi

Mari kita uji instruksi inisialisasi dengan membuat akun counter baru dengan
nilai awal.

Tambahkan kode berikut ke `lib.rs` untuk memperbarui fungsi
`test_counter_program`:

```rs title="lib.rs"
let counter_keypair = Keypair::new();
let initial_value: u64 = 42;

println!("Testing counter initialization...");

let init_instruction_data =
    borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
        .expect("Failed to serialize instruction");

let initialize_instruction = Instruction::new_with_bytes(
    program_id,
    &init_instruction_data,
    vec![
        AccountMeta::new(counter_keypair.pubkey(), true),
        AccountMeta::new(payer.pubkey(), true),
        AccountMeta::new_readonly(system_program::id(), false),
    ],
);

let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
let transaction = Transaction::new(
    &[&payer, &counter_keypair],
    message,
    svm.latest_blockhash()
);

let result = svm.send_transaction(transaction);
assert!(result.is_ok(), "Initialize transaction should succeed");

let logs = result.unwrap().logs;
println!("Transaction logs:\n{:#?}", logs);
```

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        let mut svm = LiteSVM::new();

        let payer = Keypair::new();
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");

        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();
        svm.add_program_from_file(
            program_id,
            "target/deploy/counter_program.so"
        ).expect("Failed to load program");

        // !focus(1:38)
        // Step 1: Initialize the counter
        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        println!("Testing counter initialization...");

        // Use Borsh serialization for the instruction
        let init_instruction_data =
            borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
                .expect("Failed to serialize instruction");

        // Create the initialization instruction
        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                // Account 1: Counter account (signer, writable)
                AccountMeta::new(counter_keypair.pubkey(), true),
                // Account 2: Payer (signer, writable)
                AccountMeta::new(payer.pubkey(), true),
                // Account 3: System Program (not signer, not writable)
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        // Build and send the transaction
        let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],  // Signers
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Initialize transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);
    }
}
```

## !!steps Memverifikasi inisialisasi

Setelah inisialisasi, mari kita verifikasi bahwa akun counter telah dibuat
dengan benar dengan nilai yang diharapkan.

Tambahkan kode berikut ke `lib.rs` untuk memperbarui fungsi
`test_counter_program`:

```rs title="lib.rs"
let account = svm
    .get_account(&counter_keypair.pubkey())
    .expect("Failed to get counter account");

let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
    .expect("Failed to deserialize counter data");

assert_eq!(counter.count, 42);
println!("Counter initialized successfully with value: {}", counter.count);
```

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        let mut svm = LiteSVM::new();

        let payer = Keypair::new();
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");

        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();
        svm.add_program_from_file(program_id, "target/deploy/counter_program.so")
            .unwrap();

        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        println!("Testing counter initialization...");

        // Use Borsh serialization for the instruction
        let init_instruction_data =
            borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
                .expect("Failed to serialize instruction");

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Initialize transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);

        // !focus(1:14)
        // Check account data after initialization
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        // Deserialize and verify the counter data
        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");

        assert_eq!(counter.count, 42);
        println!("Counter initialized successfully with value: {}", counter.count);
    }
}
```

## !!steps Menguji instruksi increment

Sekarang mari kita uji instruksi increment untuk memastikan bahwa instruksi
tersebut memperbarui nilai counter dengan benar.

Tambahkan kode berikut ke `lib.rs` untuk memperbarui fungsi
`test_counter_program`:

```rs title="lib.rs"
println!("Testing counter increment...");

let increment_instruction_data =
    borsh::to_vec(&CounterInstruction::IncrementCounter)
        .expect("Failed to serialize instruction");

let increment_instruction = Instruction::new_with_bytes(
    program_id,
    &increment_instruction_data,
    vec![AccountMeta::new(counter_keypair.pubkey(), true)],
);

let message = Message::new(&[increment_instruction], Some(&payer.pubkey()));
let transaction = Transaction::new(
    &[&payer, &counter_keypair],
    message,
    svm.latest_blockhash()
);

let result = svm.send_transaction(transaction);
assert!(result.is_ok(), "Increment transaction should succeed");

let logs = result.unwrap().logs;
println!("Transaction logs:\n{:#?}", logs);
```

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        let mut svm = LiteSVM::new();

        let payer = Keypair::new();
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");

        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();
        svm.add_program_from_file(program_id, "target/deploy/counter_program.so")
            .unwrap();

        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Use Borsh serialization for the instruction
        let init_instruction_data =
            borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
                .expect("Failed to serialize instruction");

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Initialize transaction should succeed");

        // Check account data
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");
        assert_eq!(counter.count, 42);
        println!("Counter initialized successfully with value: {}", counter.count);

        // !focus(1:26)
        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Use Borsh serialization for increment instruction
        let increment_data = borsh::to_vec(&CounterInstruction::IncrementCounter)
            .expect("Failed to serialize instruction");

        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &increment_data,
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Build and send increment transaction
        let message = Message::new(&[increment_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Increment transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);
    }
}
```

## !!steps Memverifikasi hasil akhir

Terakhir, mari kita verifikasi bahwa increment berfungsi dengan benar dengan
memeriksa nilai counter yang telah diperbarui.

Tambahkan kode berikut ke `lib.rs` untuk memperbarui fungsi
`test_counter_program`:

```rs title="lib.rs"
let account = svm
    .get_account(&counter_keypair.pubkey())
    .expect("Failed to get counter account");

let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
    .expect("Failed to deserialize counter data");
assert_eq!(counter.count, 43);
println!("Counter incremented successfully to: {}", counter.count);
```

```rs !! title="lib.rs"
#[cfg(test)]
mod test {
    use super::*;
    use litesvm::LiteSVM;
    use solana_sdk::{
        account::ReadableAccount,
        instruction::{AccountMeta, Instruction},
        message::Message,
        signature::{Keypair, Signer},
        system_program,
        transaction::Transaction,
    };

    #[test]
    fn test_counter_program() {
        let mut svm = LiteSVM::new();

        let payer = Keypair::new();
        svm.airdrop(&payer.pubkey(), 1_000_000_000)
            .expect("Failed to airdrop");

        let program_keypair = Keypair::new();
        let program_id = program_keypair.pubkey();
        svm.add_program_from_file(program_id, "target/deploy/counter_program.so")
            .unwrap();

        let counter_keypair = Keypair::new();
        let initial_value: u64 = 42;

        // Step 1: Initialize the counter
        println!("Testing counter initialization...");

        // Use Borsh serialization for the instruction
        let init_instruction_data =
            borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
                .expect("Failed to serialize instruction");

        let initialize_instruction = Instruction::new_with_bytes(
            program_id,
            &init_instruction_data,
            vec![
                AccountMeta::new(counter_keypair.pubkey(), true),
                AccountMeta::new(payer.pubkey(), true),
                AccountMeta::new_readonly(system_program::id(), false),
            ],
        );

        let message = Message::new(&[initialize_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Initialize transaction should succeed");

        // Check account data
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");
        assert_eq!(counter.count, 42);
        println!("Counter initialized successfully with value: {}", counter.count);

        // Step 2: Increment the counter
        println!("Testing counter increment...");

        // Use Borsh serialization for increment instruction
        let increment_data = borsh::to_vec(&CounterInstruction::IncrementCounter)
            .expect("Failed to serialize instruction");

        let increment_instruction = Instruction::new_with_bytes(
            program_id,
            &increment_data,
            vec![AccountMeta::new(counter_keypair.pubkey(), true)],
        );

        // Build and send increment transaction
        let message = Message::new(&[increment_instruction], Some(&payer.pubkey()));
        let transaction = Transaction::new(
            &[&payer, &counter_keypair],
            message,
            svm.latest_blockhash()
        );

        let result = svm.send_transaction(transaction);
        assert!(result.is_ok(), "Increment transaction should succeed");

        let logs = result.unwrap().logs;
        println!("Transaction logs:\n{:#?}", logs);

        // !focus(1:11)
        // Check account data
        let account = svm
            .get_account(&counter_keypair.pubkey())
            .expect("Failed to get counter account");

        let counter: CounterAccount = CounterAccount::try_from_slice(account.data())
            .expect("Failed to deserialize counter data");
        assert_eq!(counter.count, 43);
        println!("Counter incremented successfully to: {}", counter.count);
    }
}
```

Jalankan tes dengan perintah berikut. Flag `--nocapture` mencetak output dari
tes.

```terminal
$ cargo test -- --nocapture
```

Output yang diharapkan:

```
Testing counter initialization...
Transaction logs:
[
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq invoke [1]",
    "Program 11111111111111111111111111111111 invoke [2]",
    "Program 11111111111111111111111111111111 success",
    "Program log: Counter initialized with value: 42",
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq consumed 3803 of 200000 compute units",
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq success",
]
Counter initialized successfully with value: 42
Testing counter increment...
Transaction logs:
[
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq invoke [1]",
    "Program log: Counter incremented to: 43",
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq consumed 762 of 200000 compute units",
    "Program 3QpyHXhFtYY32iY7foF3EjkVdCDrUppADk9aDwSWn6Sq success",
]
Counter incremented successfully to: 43
```

</ScrollyCoding>

## Bagian 3: Memanggil Program

Sekarang mari kita tambahkan skrip klien untuk memanggil program.

<ScrollyCoding>

## !!steps Buat contoh klien

Mari kita buat klien Rust untuk berinteraksi dengan program yang telah
di-deploy.

```terminal
$ mkdir examples
$ touch examples/client.rs
```

Tambahkan konfigurasi berikut ke `Cargo.toml`:

```toml title="Cargo.toml"
[[example]]
name = "client"
path = "examples/client.rs"
```

```toml !! title="Cargo.toml"
[package]
name = "counter_program"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
borsh = "1.5.7"
solana-program = "2.2.0"

[dev-dependencies]
litesvm = "0.6.1"
solana-sdk = "2.2.0"
# !focus(1:2)
solana-client = "2.2.0"
tokio = "1.47.1"

# !focus(1:3)
[[example]]
name = "client"
path = "examples/client.rs"
```

Instal dependensi klien:

```terminal
$ cargo add solana-client@2.2.0 --dev
$ cargo add tokio --dev
```

## !!steps Implementasikan kode klien

Sekarang mari kita implementasikan klien yang akan memanggil program yang telah
di-deploy.

Jalankan perintah berikut untuk mendapatkan ID program Anda dari file keypair:

```terminal
$ solana address -k ./target/deploy/counter_program-keypair.json
```

Tambahkan kode klien ke `examples/client.rs` dan ganti `program_id` dengan
output dari perintah sebelumnya:

```rs title="examples/client.rs"
// !mark
let program_id = Pubkey::from_str("BDLLezrtFEXVGYqG3aS7eAC7GVeojJ4JHhKJM6pAFCDH")
    .expect("Invalid program ID");
```

<CodePlaceholder title="examples/client.rs" />

```rs !! title="examples/client.rs"
use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    system_program,
    transaction::Transaction,
};
use std::str::FromStr;
use counter_program::CounterInstruction;

#[tokio::main]
async fn main() {
    // Replace with your actual program ID from deployment
    // !mark
    let program_id = Pubkey::from_str("BDLLezrtFEXVGYqG3aS7eAC7GVeojJ4JHhKJM6pAFCDH")
        .expect("Invalid program ID");

    // Connect to local cluster
    let rpc_url = String::from("http://localhost:8899");
    let client = RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed());

    // Generate a new keypair for paying fees
    let payer = Keypair::new();

    // Request airdrop of 1 SOL for transaction fees
    println!("Requesting airdrop...");
    let airdrop_signature = client
        .request_airdrop(&payer.pubkey(), 1_000_000_000)
        .expect("Failed to request airdrop");

    // Wait for airdrop confirmation
    loop {
        if client
            .confirm_transaction(&airdrop_signature)
            .unwrap_or(false)
        {
            break;
        }
        std::thread::sleep(std::time::Duration::from_millis(500));
    }
    println!("Airdrop confirmed");

    println!("\nInitializing counter...");
    let counter_keypair = Keypair::new();
    let initial_value = 100u64;

    // Serialize the initialize instruction data
    let instruction_data = borsh::to_vec(&CounterInstruction::InitializeCounter { initial_value })
        .expect("Failed to serialize instruction");

    let initialize_instruction = Instruction::new_with_bytes(
        program_id,
        &instruction_data,
        vec![
            AccountMeta::new(counter_keypair.pubkey(), true),
            AccountMeta::new(payer.pubkey(), true),
            AccountMeta::new_readonly(system_program::id(), false),
        ],
    );

    let mut transaction =
        Transaction::new_with_payer(&[initialize_instruction], Some(&payer.pubkey()));

    let blockhash = client
        .get_latest_blockhash()
        .expect("Failed to get blockhash");
    transaction.sign(&[&payer, &counter_keypair], blockhash);

    match client.send_and_confirm_transaction(&transaction) {
        Ok(signature) => {
            println!("Counter initialized!");
            println!("Transaction: {}", signature);
            println!("Counter address: {}", counter_keypair.pubkey());
        }
        Err(err) => {
            eprintln!("Failed to initialize counter: {}", err);
            return;
        }
    }

    println!("\nIncrementing counter...");
    // Serialize the increment instruction data
    let increment_data = borsh::to_vec(&CounterInstruction::IncrementCounter)
        .expect("Failed to serialize instruction");

    let increment_instruction = Instruction::new_with_bytes(
        program_id,
        &increment_data,
        vec![AccountMeta::new(counter_keypair.pubkey(), true)],
    );

    let mut transaction =
        Transaction::new_with_payer(&[increment_instruction], Some(&payer.pubkey()));

    transaction.sign(&[&payer, &counter_keypair], blockhash);

    match client.send_and_confirm_transaction(&transaction) {
        Ok(signature) => {
            println!("Counter incremented!");
            println!("Transaction: {}", signature);
        }
        Err(err) => {
            eprintln!("Failed to increment counter: {}", err);
        }
    }
}
```

</ScrollyCoding>

## Bagian 4: Melakukan Deploy Program

Sekarang setelah program dan klien kita siap, mari kita build, deploy, dan
panggil programnya.

<Steps>

<Step>

### Build program

Pertama, mari kita build program kita.

```terminal
$ cargo build-sbf
```

Perintah ini mengompilasi program Anda dan menghasilkan dua file penting di
`target/deploy/`:

```txt
counter_program.so              # The compiled program
counter_program-keypair.json    # Keypair for the program ID
```

Anda dapat melihat ID program Anda dengan menjalankan perintah berikut:

```terminal
$ solana address -k ./target/deploy/counter_program-keypair.json
```

Contoh output:

```
HQ5Q2XXqbTKKQsWPtLzMn7rDhM8v9UPYPe7DfSoFQqJF
```

</Step>

<Step>

### Jalankan validator lokal

Untuk pengembangan, kita akan menggunakan test validator lokal.

Pertama, konfigurasikan Solana CLI untuk menggunakan localhost:

```terminal
$ solana config set -ul
```

Contoh output:

```
Config File: ~/.config/solana/cli/config.yml
RPC URL: http://localhost:8899
WebSocket URL: ws://localhost:8900/ (computed)
Keypair Path: ~/.config/solana/id.json
Commitment: confirmed
```

Sekarang jalankan test validator di terminal terpisah:

```terminal
$ solana-test-validator
```

</Step>

<Step>

### Deploy program

Dengan validator berjalan, deploy program Anda ke cluster lokal:

```terminal
$ solana program deploy ./target/deploy/counter_program.so
```

Contoh output:

```
Program Id: HQ5Q2XXqbTKKQsWPtLzMn7rDhM8v9UPYPe7DfSoFQqJF

Signature: 5xKdnh3dDFnZXB5UevYYkFBpCVcuqo5SaUPLnryFWY7eQD2CJxaeVDKjQ4ezQVJfkGNqZGYqMZBNqymPKwCQQx5h
```

Anda dapat memverifikasi deployment menggunakan perintah `solana program show`
dengan program ID Anda:

```terminal
$ solana program show HQ5Q2XXqbTKKQsWPtLzMn7rDhM8v9UPYPe7DfSoFQqJF
```

Contoh output:

```
Program Id: HQ5Q2XXqbTKKQsWPtLzMn7rDhM8v9UPYPe7DfSoFQqJF
Owner: BPFLoaderUpgradeab1e11111111111111111111111
ProgramData Address: 47MVf5tRZ4zWXQMX7ydrkgcFQr8XTk1QBjohwsUzaiuM
Authority: 4kh6HxYZiAebF8HWLsUWod2EaQQ6iWHpHYCz8UcmFbM1
Last Deployed In Slot: 16
Data Length: 82696 (0x14308) bytes
Balance: 0.57676824 SOL
```

</Step>

<Step>

### Jalankan client

Dengan validator lokal masih berjalan, jalankan client:

```terminal
$ cargo run --example client
```

Output yang diharapkan:

```
Requesting airdrop...
Airdrop confirmed

Initializing counter...
Counter initialized!
Transaction: 2uenChtqNeLC1fitqoVE2LBeygSBTDchMZ4gGqs7AiDvZZVJguLDE5PfxsfkgY7xs6zFWnYsbEtb82dWv9tDT14k
Counter address: EppPAmwqD42u4SCPWpPT7wmWKdFad5VnM9J4R9Zfofcy

Incrementing counter...
Counter incremented!
Transaction: 4qv1Rx6FHu1M3woVgDQ6KtYUaJgBzGcHnhej76ZpaKGCgsTorbcHnPKxoH916UENw7X5ppnQ8PkPnhXxEwrYuUxS
```

Dengan validator lokal berjalan, Anda dapat melihat transaksi di
[Solana Explorer](https://explorer.solana.com/?cluster=custom) menggunakan
signature transaksi dari output. Perhatikan bahwa cluster di Solana Explorer
harus diatur ke "Custom RPC URL", yang secara default adalah
`http://localhost:8899` tempat `solana-test-validator` berjalan.

</Step>

</Steps>
