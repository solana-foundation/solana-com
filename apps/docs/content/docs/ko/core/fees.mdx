---
title: 트랜잭션 수수료
description:
  기본 수수료와 우선순위 수수료를 포함한 Solana의 트랜잭션 수수료, 각 수수료가
  적용되는 방식, 그리고 트랜잭션에서 컴퓨트 유닛을 관리하는 모범 사례에 대해
  알아보세요.
---

모든 Solana 트랜잭션은 SOL로 지불되는 트랜잭션 수수료가 필요합니다. 트랜잭션
수수료는 기본 수수료와 우선순위 수수료의 두 부분으로 나뉩니다. 기본 수수료는
트랜잭션을 처리하는 검증자에게 보상합니다. 우선순위 수수료는 현재 리더가 귀하의
트랜잭션을 처리할 가능성을 높이기 위한 선택적 수수료입니다.

## 기본 수수료

모든 트랜잭션은 포함된 서명당 5000
[램포트](/docs/references/terminology#lamport)의 비용이 듭니다. 이 수수료는
트랜잭션의 첫 번째 서명자가 지불합니다. System Program이 소유한 계정만 트랜잭션
수수료를 지불할 수 있습니다. 기본 수수료는 다음과 같이 분배됩니다:

- **50% 소각:** 절반은
  [소각됩니다](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (유통 중인 SOL 공급량에서 제거됩니다).
- **50% 분배:** 절반은 트랜잭션을 처리한
  [validator에게 지급됩니다](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62).

## 우선순위 수수료

[우선순위 수수료](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)는
현재 리더(validator)가 귀하의 트랜잭션을 처리할 가능성을 높이기 위해 사용되는
선택적 수수료입니다. validator는
[우선순위 수수료의 100%를 받습니다](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
우선순위 수수료는 트랜잭션의
[컴퓨트 유닛](/docs/references/terminology#compute-units) (CU) 가격과 CU 한도를
조정하여 설정할 수 있습니다. (우선순위 수수료에 대한 자세한 내용은
[우선순위 수수료 사용 방법 가이드](/developers/guides/advanced/how-to-use-priority-fees)를
참조하세요.)

우선순위 수수료는 다음과 같이 계산됩니다:

```text title="Prioritization fee formula"
Prioritization fee = CU limit * CU price
```

우선순위 수수료는 다른 트랜잭션과 비교하여
[트랜잭션의 우선순위](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646)를
결정하는 데 사용됩니다. 다음 공식을 사용하여 계산됩니다:

```text title="Transaction priority formula"
Priority = (Prioritization fee + Base fee) / (1 + CU limit + Signature CUs + Write lock CUs)
```

#### 컴퓨트 유닛 한도

[기본적으로](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
각 명령어에는
[200,000 CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)가
할당되고 각 트랜잭션에는
[140만 CU](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14)가
할당됩니다. 트랜잭션에
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
명령어를 포함하여 이러한 기본값을 변경할 수 있습니다.

트랜잭션에 적합한 CU 한도를 계산하려면 다음 단계를 권장합니다:

1. 트랜잭션을
   [시뮬레이션](/developers/guides/advanced/how-to-request-optimal-compute)하여
   필요한 CU 단위를 추정합니다
2. 이 추정치에 10%의 안전 마진을 추가합니다

<Callout type="warn">
  우선순위 수수료는 실제 사용된 컴퓨트 유닛 수가 *아닌* 요청된 컴퓨트 유닛 한도
  트랜잭션에 의해 결정됩니다. 컴퓨트 유닛 한도를 너무 높게 설정하거나 기본
  금액을 사용하면 사용하지 않은 컴퓨트 유닛에 대해 비용을 지불할 수 있습니다.
</Callout>

#### 컴퓨트 유닛 가격

컴퓨트 유닛 가격은 요청된 각 CU에 대해 지불되는
[마이크로 램포트](/docs/references/terminology#micro-lamports)의 선택적
금액입니다. CU 가격은 validator가 트랜잭션의 우선순위를 지정하도록 장려하는
팁으로 생각할 수 있습니다. CU 가격을 설정하려면 트랜잭션에
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
명령어를 포함하세요.

<Callout>
  기본 CU 가격은 0이며, 이는 기본 우선순위 수수료도 0임을 의미합니다.
</Callout>

트랜잭션에 가장 적합한 CU 가격을 결정하는 데 도움이 필요하면 아래 표에 나열된
실시간 CU 가격 권장 사항을 참조하세요.

| 제공업체                                | 우선순위 수수료 API                                                      |
| --------------------------------------- | ------------------------------------------------------------------------ |
| [Helius](https://www.helius.dev/)       | [문서](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [문서](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [문서](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### 예제

아래 예제는 Solana SDK를 사용하여 트랜잭션에 CU 한도와 CU 가격을 설정하는 방법을
보여줍니다.

| SDK                            | 소스 코드 참조                                                                                                                 |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
