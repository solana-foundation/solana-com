---
title: Οδηγίες
description:
  Μάθετε για τις οδηγίες του Solana—τα θεμελιώδη δομικά στοιχεία για την
  αλληλεπίδραση με το blockchain του Solana. Κατανοήστε τη σύνθεση οδηγιών με
  πρακτικά παραδείγματα.
---

Οι οδηγίες είναι το θεμελιώδες δομικό στοιχείο για την αλληλεπίδραση με το
blockchain του Solana. Μια οδηγία είναι ουσιαστικά μια δημόσια συνάρτηση που
οποιοσδήποτε χρησιμοποιεί το δίκτυο Solana μπορεί να καλέσει. Κάθε οδηγία
χρησιμοποιείται για την εκτέλεση μιας συγκεκριμένης ενέργειας. Η λογική
εκτέλεσης για τις οδηγίες αποθηκεύεται στα [προγράμματα](/docs/core/programs),
όπου κάθε πρόγραμμα ορίζει το δικό του σύνολο οδηγιών. Για να αλληλεπιδράσετε με
το δίκτυο Solana, μία ή περισσότερες οδηγίες προστίθενται σε μια
[συναλλαγή](/docs/core/transactions) και αποστέλλονται στο δίκτυο για
επεξεργασία.

## Παράδειγμα μεταφοράς SOL

Το παρακάτω διάγραμμα δείχνει πώς οι συναλλαγές και οι οδηγίες συνεργάζονται για
να επιτρέψουν στους χρήστες να αλληλεπιδράσουν με το δίκτυο. Σε αυτό το
παράδειγμα, το SOL μεταφέρεται από έναν λογαριασμό σε έναν άλλο.

Τα [μεταδεδομένα](#account-metadata) του λογαριασμού αποστολέα υποδεικνύουν ότι
πρέπει να υπογράψει για τη συναλλαγή. (Αυτό επιτρέπει στο System Program να
αφαιρέσει [lamports](/docs/references/terminology#lamport).) Τόσο ο λογαριασμός
αποστολέα όσο και ο λογαριασμός παραλήπτη πρέπει να είναι εγγράψιμοι, ώστε να
μπορεί να αλλάξει το υπόλοιπο των lamport τους. Για να εκτελέσει αυτή την
οδηγία, το πορτοφόλι του αποστολέα στέλνει τη συναλλαγή που περιέχει την
[υπογραφή](/docs/references/terminology#signature) του και το μήνυμα που
περιέχει την οδηγία μεταφοράς SOL.

![Διάγραμμα μεταφοράς SOL](/assets/docs/core/transactions/sol-transfer.svg)

Μετά την αποστολή της συναλλαγής, το System Program επεξεργάζεται την οδηγία
μεταφοράς και ενημερώνει το υπόλοιπο lamport και των δύο λογαριασμών.

![Διάγραμμα διαδικασίας μεταφοράς SOL](/assets/docs/core/transactions/sol-transfer-process.svg)

Το παρακάτω παράδειγμα δείχνει τον κώδικα που σχετίζεται με τα παραπάνω
διαγράμματα. (Δείτε την
[οδηγία](https://github.com/anza-xyz/agave/blob/v2.1.13/programs/system/src/system_processor.rs#L183)
μεταφοράς του System Program.)

<CodeTabs flags="r">

```ts !! title="Kit"
import {
  airdropFactory,
  appendTransactionMessageInstructions,
  createSolanaRpc,
  createSolanaRpcSubscriptions,
  createTransactionMessage,
  generateKeyPairSigner,
  getSignatureFromTransaction,
  lamports,
  pipe,
  sendAndConfirmTransactionFactory,
  setTransactionMessageFeePayerSigner,
  setTransactionMessageLifetimeUsingBlockhash,
  signTransactionMessageWithSigners
} from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

// Create a connection to cluster
const rpc = createSolanaRpc("http://localhost:8899");
const rpcSubscriptions = createSolanaRpcSubscriptions("ws://localhost:8900");

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Fund sender with airdrop
await airdropFactory({ rpc, rpcSubscriptions })({
  recipientAddress: sender.address,
  lamports: lamports(LAMPORTS_PER_SOL), // 1 SOL
  commitment: "confirmed"
});

// Check balance before transfer
const { value: preBalance1 } = await rpc.getBalance(sender.address).send();
const { value: preBalance2 } = await rpc.getBalance(recipient.address).send();

// !mark(1:6)
// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount // 0.01 SOL in lamports
});

// Add the transfer instruction to a new transaction
const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();
const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (tx) => setTransactionMessageFeePayerSigner(sender, tx),
  (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),
  (tx) => appendTransactionMessageInstructions([transferInstruction], tx)
);

// Send the transaction to the network
const signedTransaction =
  await signTransactionMessageWithSigners(transactionMessage);
await sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions })(
  signedTransaction,
  { commitment: "confirmed" }
);
const transactionSignature = getSignatureFromTransaction(signedTransaction);

// Check balance after transfer
const { value: postBalance1 } = await rpc.getBalance(sender.address).send();
const { value: postBalance2 } = await rpc.getBalance(recipient.address).send();

console.log(
  "Sender prebalance:",
  Number(preBalance1) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Recipient prebalance:",
  Number(preBalance2) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Sender postbalance:",
  Number(postBalance1) / Number(LAMPORTS_PER_SOL)
);
console.log(
  "Recipient postbalance:",
  Number(postBalance2) / Number(LAMPORTS_PER_SOL)
);
console.log("Transaction Signature:", transactionSignature);
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
  Keypair,
  Connection
} from "@solana/web3.js";

// Create a connection to cluster
const connection = new Connection("http://localhost:8899", "confirmed");

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Fund sender with airdrop
const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Check balance before transfer
const preBalance1 = await connection.getBalance(sender.publicKey);
const preBalance2 = await connection.getBalance(recipient.publicKey);

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// !mark(1:6)
// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

// Add the transfer instruction to a new transaction
const transaction = new Transaction().add(transferInstruction);

// Send the transaction to the network
const transactionSignature = await sendAndConfirmTransaction(
  connection,
  transaction,
  [sender] // signer
);

// Check balance after transfer
const postBalance1 = await connection.getBalance(sender.publicKey);
const postBalance2 = await connection.getBalance(recipient.publicKey);

console.log("Sender prebalance:", preBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient prebalance:", preBalance2 / LAMPORTS_PER_SOL);
console.log("Sender postbalance:", postBalance1 / LAMPORTS_PER_SOL);
console.log("Recipient postbalance:", postBalance2 / LAMPORTS_PER_SOL);
console.log("Transaction Signature:", transactionSignature);
```

```rs !! title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair,
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    // Create a connection to cluster
    let connection = RpcClient::new_with_commitment(
        "http://localhost:8899".to_string(),
        CommitmentConfig::confirmed(),
    );

    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Fund sender with airdrop
    let airdrop_signature = connection
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;
    loop {
        let confirmed = connection.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Check balance before transfer
    let pre_balance1 = connection.get_balance(&sender.pubkey()).await?;
    let pre_balance2 = connection.get_balance(&recipient.pubkey()).await?;

    // Define the amount to transfer
    let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    // Add the transfer instruction to a new transaction
    let mut transaction =
        Transaction::new_with_payer(&[transfer_instruction], Some(&sender.pubkey()));
    let blockhash = connection.get_latest_blockhash().await?;
    transaction.sign(&[&sender], blockhash);

    // Send the transaction to the network
    let transaction_signature = connection
        .send_and_confirm_transaction(&transaction)
        .await?;

    // Check balance after transfer
    let post_balance1 = connection.get_balance(&sender.pubkey()).await?;
    let post_balance2 = connection.get_balance(&recipient.pubkey()).await?;

    println!(
        "Sender prebalance: {}",
        pre_balance1 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Recipient prebalance: {}",
        pre_balance2 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Sender postbalance: {}",
        post_balance1 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!(
        "Recipient postbalance: {}",
        post_balance2 as f64 / LAMPORTS_PER_SOL as f64
    );
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}
```

</CodeTabs>

<WithMentions>

## Οδηγίες

![Διάγραμμα που απεικονίζει μια συναλλαγή με μια οδηγία, χωρισμένη στα 3 συστατικά της](/assets/docs/core/transactions/instruction.svg)

Μια
[`Instruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/lib.rs#L94)
αποτελείται από τις ακόλουθες πληροφορίες:

- [`program_id`](mention:program-id): Το [ID](#program-id) του προγράμματος που
  καλείται.
- [`accounts`](mention:accounts): Ένας πίνακας από
  [metadata λογαριασμών](#account-metadata)
- [`data`](mention:instruction-data): Ένας πίνακας bytes με πρόσθετα [δεδομένα]
  για χρήση από την εντολή.

```rust title="Instruction struct"
pub struct Instruction {
    /// Pubkey of the program that executes this instruction.
    // !mention program-id
    pub program_id: Pubkey,
    /// Metadata describing accounts that should be passed to the program.
    // !mention accounts
    pub accounts: Vec<AccountMeta>,
    /// Opaque data passed to the program for its own interpretation.
    // !mention instruction-data
    pub data: Vec<u8>,
}
```

</WithMentions>

### Program ID

Το [`program_id`](/docs/references/terminology#program-id) της εντολής είναι η
δημόσια διεύθυνση κλειδιού του προγράμματος που περιέχει τη λογική
επιχειρηματικής λειτουργίας της εντολής.

### Μεταδεδομένα λογαριασμού

<WithMentions>

Ο πίνακας `accounts` της εντολής είναι ένας πίνακας από structs
[`AccountMeta`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/instruction/src/account_meta.rs#L25).
Πρέπει να παρέχονται metadata για κάθε λογαριασμό με τον οποίο αλληλεπιδρά η
εντολή. (Αυτό επιτρέπει στις συναλλαγές να εκτελούν εντολές παράλληλα, εφόσον
δεν τροποποιούν τον ίδιο λογαριασμό.)

Το παρακάτω διάγραμμα απεικονίζει μια συναλλαγή που περιέχει μία μόνο εντολή. Ο
πίνακας `accounts` της εντολής περιέχει metadata για δύο λογαριασμούς.

![Μια συναλλαγή με μία εντολή. Η εντολή περιέχει δύο structs `AccountMeta` στον πίνακα `accounts` της.](/assets/docs/core/transactions/accountmeta.svg)

Τα μεταδεδομένα λογαριασμού περιλαμβάνουν τις ακόλουθες πληροφορίες:

- [pubkey](mention:pubkey): Η δημόσια διεύθυνση κλειδιού του λογαριασμού
- [is_signer](mention:is-signer): Ορίζεται σε `true` αν ο λογαριασμός πρέπει να
  υπογράψει τη συναλλαγή
- [is_writable](mention:is-writable): Ορίζεται σε `true` αν η εντολή τροποποιεί
  τα δεδομένα του λογαριασμού

<Callout>
  Για να γνωρίζετε ποιους λογαριασμούς απαιτεί μια εντολή, συμπεριλαμβανομένου
  του ποιοι πρέπει να είναι εγγράψιμοι, μόνο για ανάγνωση ή να υπογράφουν τη
  συναλλαγή, πρέπει να ανατρέξετε στην υλοποίηση της εντολής, όπως ορίζεται από
  το πρόγραμμα.
</Callout>

```rust title="AccountMeta"
pub struct AccountMeta {
    /// An account's public key.
    // !mention pubkey
    pub pubkey: Pubkey,
    /// True if an `Instruction` requires a `Transaction` signature matching `pubkey`.
    // !mention is-signer
    pub is_signer: bool,
    /// True if the account data or metadata may be mutated during program execution.
    // !mention is-writable
    pub is_writable: bool,
}
```

</WithMentions>

### Δεδομένα

Το `data` της εντολής είναι ένας πίνακας bytes που καθορίζει ποια από τις
εντολές του προγράμματος θα κληθεί. Περιλαμβάνει επίσης οποιαδήποτε ορίσματα
απαιτούνται από την εντολή.

## Παράδειγμα δημιουργίας εντολής

Το παρακάτω παράδειγμα δείχνει τη δομή μιας εντολής μεταφοράς SOL.

<CodeTabs storage="sol-transfer" flags="r">

```ts !! title="Kit"
import { generateKeyPairSigner, lamports } from "@solana/kit";
import { getTransferSolInstruction } from "@solana-program/system";

// Generate sender and recipient keypairs
const sender = await generateKeyPairSigner();
const recipient = await generateKeyPairSigner();

// Define the amount to transfer
const LAMPORTS_PER_SOL = 1_000_000_000n;
const transferAmount = lamports(LAMPORTS_PER_SOL / 100n); // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```ts !! title="Legacy"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair
} from "@solana/web3.js";

// Generate sender and recipient keypairs
const sender = Keypair.generate();
const recipient = new Keypair();

// Define the amount to transfer
const transferAmount = 0.01; // 0.01 SOL

// Create a transfer instruction for transferring SOL from sender to recipient
const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL // Convert transferAmount to lamports
});

console.log(JSON.stringify(transferInstruction, null, 2));
```

```rs !! title="Rust"
use anyhow::Result;
use solana_sdk::{native_token::LAMPORTS_PER_SOL, signature::Signer, signer::keypair::Keypair};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> Result<()> {
    // Generate sender and recipient keypairs
    let sender = Keypair::new();
    let recipient = Keypair::new();

    // Define the amount to transfer
    let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

    // Create a transfer instruction for transferring SOL from sender to recipient
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    println!("{:#?}", transfer_instruction);

    Ok(())
}
```

</CodeTabs>

<WithMentions>

Ο παρακάτω κώδικας δείχνει το αποτέλεσμα από τα προηγούμενα αποσπάσματα κώδικα.
Η μορφή θα διαφέρει μεταξύ των SDK, αλλά παρατηρήστε ότι κάθε εντολή περιέχει
τις ίδιες τρεις απαιτούμενες πληροφορίες: [`program_id`](mention:program-id),
[`accounts`](mention:accounts), [`data`](mention:data).

<CodeTabs storage="sol-transfer">

```json !! title="Kit"
{
  // !mention(1:16) accounts
  "accounts": [
    {
      "address": "Hu28vRMGWpQXN56eaE7jRiDDRRz3vCXEs7EKHRfL6bC",
      "role": 3,
      "signer": {
        "address": "Hu28vRMGWpQXN56eaE7jRiDDRRz3vCXEs7EKHRfL6bC",
        "keyPair": {
          "privateKey": {},
          "publicKey": {}
        }
      }
    },
    {
      "address": "2mBY6CTgeyJNJDzo6d2Umipw2aGUquUA7hLdFttNEj7p",
      "role": 1
    }
  ],
  // !mention program-id
  "programAddress": "11111111111111111111111111111111",
  // !mention(1:14) data
  "data": {
    "0": 2,
    "1": 0,
    "2": 0,
    "3": 0,
    "4": 128,
    "5": 150,
    "6": 152,
    "7": 0,
    "8": 0,
    "9": 0,
    "10": 0,
    "11": 0
  }
}
```

```json !! title="Legacy"
{
  // !mention(1:12) accounts
  "keys": [
    {
      "pubkey": "3z9vL1zjN6qyAFHhHQdWYRTFAcy69pJydkZmSFBKHg1R",
      "isSigner": true,
      "isWritable": true
    },
    {
      "pubkey": "BpvxsLYKQZTH42jjtWHZpsVSa7s6JVwLKwBptPSHXuZc",
      "isSigner": false,
      "isWritable": true
    }
  ],
  // !mention program-id
  "programId": "11111111111111111111111111111111",
  // !mention data
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

```json !! title="Rust"
{
  // !mention program-id
  "program_id": "11111111111111111111111111111111",
  // !mention(1:12) accounts
  "accounts": [
    {
      "pubkey": "Hhh6vrA6xUNwaNftJVAXSTzfHiRiAKFKLGmHdcRH6Pmo",
      "is_signer": true,
      "is_writable": true
    },
    {
      "pubkey": "6RYMY3mFLixELbfNCMA7zNtzgNfRyEZs5YYkZQb8aK4t",
      "is_signer": false,
      "is_writable": true
    }
  ],
  // !mention data
  "data": [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
}
```

</CodeTabs>

</WithMentions>

Τα παρακάτω παραδείγματα δείχνουν πώς να δημιουργήσετε χειροκίνητα την εντολή
μεταφοράς. (Η καρτέλα `Expanded Instruction` είναι λειτουργικά ισοδύναμη με την
καρτέλα `Instruction`.)

<Callout type="info">
  Στην πράξη, συνήθως δεν χρειάζεται να κατασκευάσετε μια `Instruction`
  χειροκίνητα. Τα περισσότερα προγράμματα παρέχουν βιβλιοθήκες client με
  βοηθητικές συναρτήσεις που δημιουργούν τις εντολές για εσάς. Εάν δεν είναι
  διαθέσιμη κάποια βιβλιοθήκη, μπορείτε να δημιουργήσετε χειροκίνητα την εντολή.
</Callout>

<Tabs items={['Kit', 'Legacy', 'Rust']}>

<Tab value="Kit">

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = getTransferSolInstruction({
  source: sender,
  destination: recipient.address,
  amount: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const TRANSFER_INSTRUCTION_INDEX = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(TRANSFER_INSTRUCTION_INDEX, 0);
instructionData.writeBigUInt64LE(transferAmount * LAMPORTS_PER_SOL, 4);

const SYSTEM_PROGRAM_ADDRESS = "11111111111111111111111111111111" as Address;

// Manually create the transfer instruction
const transferInstruction: IInstruction = {
  programAddress: SYSTEM_PROGRAM_ADDRESS,
  accounts: [
    {
      address: sender.address,
      role: AccountRole.WRITABLE_SIGNER
    },
    {
      address: recipient.address,
      role: AccountRole.WRITABLE
    }
  ],
  data: new Uint8Array(instructionData)
};
```

</CodeTabs>

</Tab>

<Tab value="Legacy">

<CodeTabs>

```ts !! title="Instruction"
const transferAmount = 0.01; // 0.01 SOL

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: receiver.publicKey,
  lamports: transferAmount * LAMPORTS_PER_SOL
});
```

```ts !! title="Expanded Instruction"
const transferAmount = 0.01; // 0.01 SOL

// Instruction index for the System Program's transfer instruction
const transferInstructionIndex = 2;

// Create a buffer for the data to include in the instruction
const instructionData = Buffer.alloc(4 + 8); // uint32 + uint64
instructionData.writeUInt32LE(transferInstructionIndex, 0);
instructionData.writeBigUInt64LE(BigInt(transferAmount * LAMPORTS_PER_SOL), 4);

// Manually create a transfer instruction
const transferInstruction = new TransactionInstruction({
  keys: [
    { pubkey: sender.publicKey, isSigner: true, isWritable: true }, // from account, is signer and is writable
    { pubkey: receiver.publicKey, isSigner: false, isWritable: true } // to account, is not signer but is writable
  ],
  programId: SystemProgram.programId,
  data: instructionData
});
```

</CodeTabs>

</Tab>

<Tab value="Rust">

<CodeTabs>

```rs !! title="Instruction"
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

let transfer_instruction =
    system_instruction::transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);
```

```rs !! title="Expanded Instruction"
// Instruction index for the System Program's transfer instruction
let transfer_instruction_index: u32 = 2;

// Define the amount to transfer
let transfer_amount = LAMPORTS_PER_SOL / 100; // 0.01 SOL

// Create instruction data manually (12 bytes: 4 for u32 index + 8 for u64 lamports)
let mut instruction_data = Vec::with_capacity(12);
instruction_data.extend_from_slice(&transfer_instruction_index.to_le_bytes());
instruction_data.extend_from_slice(&transfer_amount.to_le_bytes());

// Manually create the transfer instruction
let transfer_instruction = Instruction {
    program_id: system_program::id(),
    accounts: vec![
        AccountMeta::new(sender.pubkey(), true), // from account, is signer and is writable
        AccountMeta::new(recipient.pubkey(), false), // to account, is not signer but is writable
    ],
    data: instruction_data,
};
```

</CodeTabs>

</Tab>

</Tabs>
