---
title: Τέλη συναλλαγών
description:
  Μάθετε για τα τέλη συναλλαγών του Solana, συμπεριλαμβανομένων των βασικών και
  των τελών προτεραιότητας, πώς εφαρμόζεται το καθένα και τις βέλτιστες
  πρακτικές για τη διαχείριση των μονάδων υπολογισμού στις συναλλαγές σας.
---

Κάθε συναλλαγή Solana απαιτεί τέλος συναλλαγής, που καταβάλλεται σε SOL. Τα τέλη
συναλλαγών χωρίζονται σε δύο μέρη: το βασικό τέλος και το τέλος προτεραιότητας.
Το βασικό τέλος αποζημιώνει τους validators για την επεξεργασία της συναλλαγής.
Το τέλος προτεραιότητας είναι ένα προαιρετικό τέλος, για να αυξηθεί η πιθανότητα
ο τρέχων leader να επεξεργαστεί τη συναλλαγή σας.

## Βασικό τέλος

Κάθε συναλλαγή κοστίζει 5000 [lamports](/docs/references/terminology#lamport)
ανά συμπεριλαμβανόμενη υπογραφή. Αυτό το τέλος καταβάλλεται από τον πρώτο
υπογράφοντα της συναλλαγής. Μόνο λογαριασμοί που ανήκουν στο System Program
μπορούν να πληρώσουν τέλη συναλλαγών. Το βασικό τέλος κατανέμεται ως εξής:

- **50% καίγεται:** Το μισό
  [καίγεται](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/fee-calculator/src/lib.rs#L70)
  (αφαιρείται από την κυκλοφορούσα προσφορά SOL).
- **50% διανέμεται:** Το μισό
  [καταβάλλεται στον validator](https://github.com/anza-xyz/agave/blob/e621336acad4f5d6e5b860eaa1b074b01c99253c/runtime/src/bank/fee_distribution.rs#L58-L62)
  που επεξεργάστηκε τη συναλλαγή.

## Τέλος προτεραιότητας

Το
[τέλος προτεραιότητας](https://github.com/anza-xyz/agave/blob/v2.2.14/compute-budget/src/compute_budget_limits.rs#L47-L48)
είναι ένα προαιρετικό τέλος που χρησιμοποιείται για να αυξηθεί η πιθανότητα ο
τρέχων leader (validator) να επεξεργαστεί τη συναλλαγή σας. Ο validator λαμβάνει
[το 100% του τέλους προτεραιότητας](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0096-reward-collected-priority-fee-in-entirety.md).
Τα τέλη προτεραιότητας μπορούν να οριστούν προσαρμόζοντας την τιμή
[μονάδας υπολογισμού](/docs/references/terminology#compute-units) (CU) και το
όριο CU της συναλλαγής. (Δείτε τον
[οδηγό Πώς να χρησιμοποιήσετε τα τέλη προτεραιότητας](/developers/guides/advanced/how-to-use-priority-fees)
για περισσότερες λεπτομέρειες σχετικά με τα τέλη προτεραιότητας.)

Το τέλος προτεραιότητας υπολογίζεται ως εξής:

```text title="Prioritization fee formula"
Prioritization fee = CU limit * CU price
```

Το τέλος προτεραιότητας χρησιμοποιείται για να καθοριστεί η
[προτεραιότητα της συναλλαγής σας](https://github.com/anza-xyz/agave/blob/v2.2.14/core/src/banking_stage/transaction_scheduler/receive_and_buffer.rs#L646),
σε σχέση με άλλες συναλλαγές. Υπολογίζεται χρησιμοποιώντας τον ακόλουθο τύπο:

```text title="Transaction priority formula"
Priority = (Prioritization fee + Base fee) / (1 + CU limit + Signature CUs + Write lock CUs)
```

#### Όριο μονάδων υπολογισμού

Από
[προεπιλογή](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget.rs#L149-L197),
σε κάθε εντολή εκχωρούνται
[200.000 CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L10)
και σε κάθε συναλλαγή εκχωρούνται
[1,4 εκατομμύρια CUs](https://github.com/anza-xyz/agave/blob/v2.1.13/compute-budget/src/compute_budget_limits.rs#L14).
Μπορείτε να αλλάξετε αυτές τις προεπιλογές συμπεριλαμβάνοντας μια εντολή
[`SetComputeUnitLimit`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L42-L44)
στη συναλλαγή σας.

Για να υπολογίσετε το κατάλληλο όριο CU για τη συναλλαγή σας, συνιστούμε τα
ακόλουθα βήματα:

1. Εκτιμήστε τις απαιτούμενες μονάδες CU
   [προσομοιώνοντας](/developers/guides/advanced/how-to-request-optimal-compute)
   τη συναλλαγή
2. Προσθέστε ένα περιθώριο ασφαλείας 10% σε αυτήν την εκτίμηση

<Callout type="warn">
  Η προτεραιότητα χρέωσης καθορίζεται από το αιτούμενο όριο μονάδων υπολογισμού
  της συναλλαγής, *όχι* από τον πραγματικό αριθμό μονάδων υπολογισμού που
  χρησιμοποιήθηκαν. Εάν ορίσετε ένα όριο μονάδων υπολογισμού που είναι πολύ
  υψηλό ή χρησιμοποιήσετε την προεπιλεγμένη ποσότητα, ενδέχεται να πληρώσετε για
  μη χρησιμοποιούμενες μονάδες υπολογισμού.
</Callout>

#### Τιμή μονάδας υπολογισμού

Η τιμή μονάδας υπολογισμού είναι ένα προαιρετικό ποσό
[micro-lamports](/docs/references/terminology#micro-lamports) που καταβάλλεται
για κάθε αιτούμενη CU. Μπορείτε να σκεφτείτε την τιμή CU ως ένα φιλοδώρημα για
να ενθαρρύνετε τον validator να δώσει προτεραιότητα στη συναλλαγή σας. Για να
ορίσετε την τιμή CU, συμπεριλάβετε μια εντολή
[`SetComputeUnitPrice`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L48-L50)
στη συναλλαγή σας.

<Callout>
  Η προεπιλεγμένη τιμή CU είναι 0, που σημαίνει ότι η προεπιλεγμένη χρέωση
  προτεραιότητας είναι επίσης 0.
</Callout>

Για βοήθεια στον προσδιορισμό της καλύτερης τιμής CU για τη συναλλαγή σας, δείτε
τη σύσταση τιμής CU σε πραγματικό χρόνο που παρέχεται στον παρακάτω πίνακα.

| Πάροχος                                 | API χρέωσης προτεραιότητας                                                     |
| --------------------------------------- | ------------------------------------------------------------------------------ |
| [Helius](https://www.helius.dev/)       | [Τεκμηρίωση](https://docs.helius.dev/solana-apis/priority-fee-api)             |
| [QuickNode](https://www.quicknode.com/) | [Τεκμηρίωση](https://marketplace.quicknode.com/add-on/solana-priority-fee)     |
| [Triton](https://triton.one/)           | [Τεκμηρίωση](https://docs.triton.one/chains/solana/improved-priority-fees-api) |

#### Παράδειγμα

Τα παρακάτω παραδείγματα δείχνουν πώς να ορίσετε το όριο CU και την τιμή CU σε
μια συναλλαγή χρησιμοποιώντας τα Solana SDK.

| SDK                            | Αναφορά πηγαίου κώδικα                                                                                                         |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `@solana/web3.js` (Typescript) | [`ComputeBudgetProgram`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/programs/compute-budget.ts#L218) |
| `solana-sdk` (Rust)            | [`ComputeBudgetInstruction`](https://github.com/anza-xyz/agave/blob/v2.1.13/sdk/src/compute_budget.rs#L17-L31)                 |

<CodeTabs storage="compute-budget">

```ts !! title="Typescript"
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});

const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});
```

```rust !! title="Rust"
let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);

let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);
```

</CodeTabs>

<CodeTabs storage="compute-budget" flags="r">

```ts !! title="Typescript"
import {
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  Keypair,
  Connection,
  ComputeBudgetProgram,
  sendAndConfirmTransaction
} from "@solana/web3.js";

const connection = new Connection("http://localhost:8899", "confirmed");

const sender = Keypair.generate();
const recipient = new Keypair();

const airdropSignature = await connection.requestAirdrop(
  sender.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(airdropSignature, "confirmed");

// Create compute budget instructions
const limitInstruction = ComputeBudgetProgram.setComputeUnitLimit({
  units: 300_000
});
const priceInstruction = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1
});

const transferInstruction = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient.publicKey,
  lamports: 0.01 * LAMPORTS_PER_SOL
});

// Add the compute budget and transfer instructions to a new transaction
const transaction = new Transaction()
  .add(limitInstruction)
  .add(priceInstruction)
  .add(transferInstruction);

const signature = await sendAndConfirmTransaction(connection, transaction, [
  sender
]);

console.log("Transaction Signature:", signature);
```

```rust !! title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use solana_system_interface::instruction::transfer;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    let sender = Keypair::new();
    let recipient = Keypair::new();

    let airdrop_signature = client
        .request_airdrop(&sender.pubkey(), LAMPORTS_PER_SOL)
        .await?;

    loop {
        let confirmed = client.confirm_transaction(&airdrop_signature).await?;
        if confirmed {
            break;
        }
    }

    // Create compute budget instructions
    let limit_instruction = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    let price_instruction = ComputeBudgetInstruction::set_compute_unit_price(1);

    let transfer_amount = LAMPORTS_PER_SOL / 100;
    let transfer_instruction = transfer(&sender.pubkey(), &recipient.pubkey(), transfer_amount);

    let recent_blockhash = client.get_latest_blockhash().await?;

    let mut transaction = Transaction::new_with_payer(
        &[limit_instruction, price_instruction, transfer_instruction],
        Some(&sender.pubkey()),
    );
    transaction.sign(&[&sender], recent_blockhash);

    let signature = client.send_and_confirm_transaction(&transaction).await?;
    println!("Transaction Signature: {}", signature);

    Ok(())
}
```

</CodeTabs>
