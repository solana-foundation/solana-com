---
title: Διεύθυνση Προερχόμενη από Πρόγραμμα
description:
  Μάθετε για τις Διευθύνσεις Προερχόμενες από Πρόγραμμα (PDAs) της Solana —
  καθορισμένες διευθύνσεις λογαριασμών που επιτρέπουν ασφαλή υπογραφή
  προγράμματος. Κατανοήστε την παραγωγή PDA, τα κανονικά bumps και πώς να
  δημιουργήσετε λογαριασμούς PDA.
---

Μια [διεύθυνση λογαριασμού](/docs/core/accounts#account-address) της Solana
δείχνει στην τοποθεσία του λογαριασμού στο blockchain. Πολλές διευθύνσεις
λογαριασμών είναι το δημόσιο κλειδί ενός keypair, οπότε το αντίστοιχο ιδιωτικό
κλειδί χρησιμοποιείται για την υπογραφή συναλλαγών που αφορούν τον λογαριασμό.

Μια χρήσιμη εναλλακτική λύση στη διεύθυνση δημόσιου κλειδιού είναι μια διεύθυνση
προερχόμενη από πρόγραμμα (PDA). Οι PDAs παρέχουν μια εύκολη μέθοδο για
αποθήκευση, αντιστοίχιση και ανάκτηση της κατάστασης του προγράμματος. Μια PDA
είναι μια διεύθυνση που δημιουργείται καθοριστικά χρησιμοποιώντας ένα
αναγνωριστικό προγράμματος και έναν συνδυασμό προαιρετικών προκαθορισμένων
εισόδων. Οι PDAs μοιάζουν με διευθύνσεις δημόσιου κλειδιού, αλλά δεν έχουν
αντίστοιχο ιδιωτικό κλειδί.

Το περιβάλλον εκτέλεσης της Solana επιτρέπει στα προγράμματα να υπογράφουν για
PDAs χωρίς να χρειάζεται ιδιωτικό κλειδί. Η χρήση μιας PDA εξαλείφει την ανάγκη
παρακολούθησης της διεύθυνσης του λογαριασμού. Αντίθετα, μπορείτε να ανακαλέσετε
τις συγκεκριμένες εισόδους που χρησιμοποιήθηκαν για την παραγωγή της PDA. (Για
να μάθετε πώς τα προγράμματα χρησιμοποιούν PDAs για υπογραφή, δείτε την ενότητα
[Διασταυρούμενες Κλήσεις Προγραμμάτων](/docs/core/cpi).)

## Υπόβαθρο

Τα
[keypairs](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/keypair/src/lib.rs#L26)
της Solana είναι σημεία στην [καμπύλη Ed25519](https://ed25519.cr.yp.to/)
(κρυπτογραφία ελλειπτικής καμπύλης). Αποτελούνται από ένα δημόσιο κλειδί και ένα
ιδιωτικό κλειδί. Το δημόσιο κλειδί γίνεται η διεύθυνση του λογαριασμού, και το
ιδιωτικό κλειδί χρησιμοποιείται για τη δημιουργία έγκυρης
[υπογραφής](/docs/core/transactions#signatures) για τον λογαριασμό.

![Δύο λογαριασμοί με διευθύνσεις πάνω στην καμπύλη](/assets/docs/core/pda/address-on-curve.svg)

Μια PDA σκόπιμα παράγεται ώστε να βρίσκεται εκτός της καμπύλης Ed25519. Αυτό
σημαίνει ότι δεν έχει έγκυρο αντίστοιχο ιδιωτικό κλειδί και δεν μπορεί να
εκτελέσει κρυπτογραφικές λειτουργίες. (Όπως η παροχή υπογραφής.) Ωστόσο, η
Solana επιτρέπει στα προγράμματα να υπογράφουν για PDAs χωρίς να χρειάζεται
ιδιωτικό κλειδί.

![Διεύθυνση Εκτός Καμπύλης](/assets/docs/core/pda/address-off-curve.svg)

Μπορείτε να σκεφτείτε τα PDAs ως έναν τρόπο δημιουργίας δομών τύπου hashmap στην
αλυσίδα χρησιμοποιώντας ένα προκαθορισμένο σύνολο εισόδων. (Για παράδειγμα,
συμβολοσειρές, αριθμούς και άλλες διευθύνσεις λογαριασμών.)

![Program Derived Address](/assets/docs/core/pda/pda.svg)

## Παραγωγή ενός PDA

Πριν δημιουργήσετε έναν λογαριασμό με ένα PDA, πρέπει πρώτα να παράγετε τη
διεύθυνση. Η παραγωγή ενός PDA _δεν_ δημιουργεί αυτόματα έναν λογαριασμό στην
αλυσίδα σε αυτή τη διεύθυνση— ο λογαριασμός πρέπει να δημιουργηθεί ρητά μέσω του
προγράμματος που χρησιμοποιείται για την παραγωγή του PDA. Μπορείτε να σκεφτείτε
ένα PDA σαν μια διεύθυνση σε έναν χάρτη: το γεγονός ότι υπάρχει μια διεύθυνση
δεν σημαίνει ότι έχει κατασκευαστεί κάτι εκεί.

Τα Solana SDKs υποστηρίζουν τη δημιουργία PDA με τις συναρτήσεις που φαίνονται
στον παρακάτω πίνακα. Κάθε συνάρτηση λαμβάνει τις ακόλουθες εισόδους:

- **Program ID**: Η διεύθυνση του προγράμματος που χρησιμοποιείται για την
  παραγωγή του PDA. Αυτό το πρόγραμμα μπορεί να υπογράψει εκ μέρους του PDA.
- **Optional seeds**: Προκαθορισμένες είσοδοι, όπως συμβολοσειρές, αριθμοί ή
  άλλες διευθύνσεις λογαριασμών.

| SDK                            | Συνάρτηση                                                                                                                        |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| `@solana/kit` (Typescript)     | [`getProgramDerivedAddress`](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L157) |
| `@solana/web3.js` (Typescript) | [`findProgramAddressSync`](https://github.com/solana-foundation/solana-web3.js/blob/v1.98.0/src/publickey.ts#L212)               |
| `solana_sdk` (Rust)            | [`find_program_address`](https://github.com/anza-xyz/solana-sdk/blob/sdk%40v2.2.2/pubkey/src/lib.rs#L617)                        |

Η συνάρτηση χρησιμοποιεί το program ID και τα προαιρετικά seeds, και στη
συνέχεια επαναλαμβάνει τις τιμές bump για να προσπαθήσει να δημιουργήσει μια
έγκυρη διεύθυνση προγράμματος. Η επανάληψη των τιμών bump ξεκινά από το 255 και
μειώνεται κατά 1 μέχρι να βρεθεί ένα έγκυρο PDA. Αφού βρεθεί ένα έγκυρο PDA, η
συνάρτηση επιστρέφει το PDA και το bump seed.

<Callout>
  Το bump seed είναι ένα επιπλέον byte που προστίθεται στα προαιρετικά seeds για
  να διασφαλιστεί ότι δημιουργείται μια έγκυρη διεύθυνση εκτός καμπύλης.
</Callout>

![Παραγωγή PDA](/assets/docs/core/pda/pda-derivation.svg)

### Κανονικό bump

Το bump seed είναι ένα επιπλέον byte που προστίθεται στα προαιρετικά seeds. Η
συνάρτηση παραγωγής επαναλαμβάνει τις τιμές bump, ξεκινώντας από το 255 και
μειώνοντας κατά 1, μέχρι μια τιμή να παράγει μια έγκυρη διεύθυνση εκτός
καμπύλης. Η πρώτη τιμή που παράγει μια έγκυρη διεύθυνση εκτός καμπύλης
ονομάζεται "κανονικό bump".

Τα παρακάτω παραδείγματα δείχνουν την παραγωγή PDA χρησιμοποιώντας όλα τα πιθανά
bump seeds (255 έως 0):

<Callout type="info">
  Το παράδειγμα Kit δεν συμπεριλαμβάνεται επειδή η συνάρτηση
  [createProgramDerivedAddress](https://github.com/anza-xyz/kit/blob/v2.1.0/packages/addresses/src/program-derived-address.ts#L101)
  δεν εξάγεται.
</Callout>

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programId = new PublicKey("11111111111111111111111111111111");
const optionalSeed = "helloWorld";

// Loop through all bump seeds (255 down to 0)
for (let bump = 255; bump >= 0; bump--) {
  try {
    const PDA = PublicKey.createProgramAddressSync(
      [Buffer.from(optionalSeed), Buffer.from([bump])],
      programId
    );
    console.log("bump " + bump + ": " + PDA);
  } catch (error) {
    console.log("bump " + bump + ": " + error);
  }
}
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_id = Pubkey::from_str("11111111111111111111111111111111")?;
    let optional_seed = b"helloWorld";

    // Loop through all bump seeds (255 down to 0)
    for bump in (0..=255).rev() {
        match Pubkey::create_program_address(&[optional_seed.as_ref(), &[bump]], &program_id) {
            Ok(pda) => println!("bump {}: {}", bump, pda),
            Err(err) => println!("bump {}: {}", bump, err),
        }
    }

    Ok(())
}
```

</CodeTabs>

<CodeTabs>

```sh !! title="Expected TS Output"
bump 255: Error: Invalid seeds, address must fall off the curve
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Error: Invalid seeds, address must fall off the curve
...
// remaining bump outputs
```

```sh !! title="Expected Rust Output"
bump 255: Provided seeds do not result in a valid address
bump 254: 46GZzzetjCURsdFPb7rcnspbEMnCBXe9kpjrsZAkKb6X
bump 253: GBNWBGxKmdcd7JrMnBdZke9Fumj9sir4rpbruwEGmR4y
bump 252: THfBMgduMonjaNsCisKa7Qz2cBoG1VCUYHyso7UXYHH
bump 251: EuRrNqJAofo7y3Jy6MGvF7eZAYegqYTwH2dnLCwDDGdP
bump 250: Provided seeds do not result in a valid address
...
// remaining bump outputs
```

</CodeTabs>

Σε αυτό το παράδειγμα, το πρώτο bump seed προκαλεί σφάλμα. Το πρώτο bump seed
που παράγει ένα έγκυρο PDA είναι το 254. Τα bump seeds 253-251 επίσης παράγουν
μοναδικά, έγκυρα PDAs.

Αυτό σημαίνει ότι δεδομένων των ίδιων προαιρετικών seeds και `programId`, ένα
bump seed με διαφορετική τιμή μπορεί ακόμα να παράγει ένα έγκυρο PDA.

<Callout type="warn">
  Πάντα να συμπεριλαμβάνετε ελέγχους ασφαλείας για να διασφαλίσετε ότι ένα PDA
  που περνάει στο πρόγραμμα παράγεται από το κανονικό bump. Η αποτυχία να το
  κάνετε αυτό μπορεί να εισαγάγει ευπάθειες που επιτρέπουν σε μη αναμενόμενους
  λογαριασμούς να χρησιμοποιηθούν στις εντολές του προγράμματος. Είναι καλή
  πρακτική να χρησιμοποιείτε μόνο το κανονικό bump κατά την παραγωγή PDAs.
</Callout>

### Παραδείγματα

Τα παρακάτω παραδείγματα παράγουν ένα PDA χρησιμοποιώντας τα Solana SDKs. Κάντε
κλικ στο **&#9655; Run** για να εκτελέσετε τον κώδικα.

#### Παραγωγή PDA με ένα string seed

Το παρακάτω παράδειγμα παράγει ένα PDA χρησιμοποιώντας ένα program ID και ένα
προαιρετικό string seed.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import { Address, getProgramDerivedAddress } from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus
const seeds = ["helloWorld"];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus
const seeds = [Buffer.from("helloWorld")];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let seeds: &[&[u8]] = &[b"helloWorld"];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Παραγωγή PDA με seed διεύθυνσης

Το παρακάτω παράδειγμα παράγει ένα PDA χρησιμοποιώντας ένα αναγνωριστικό
προγράμματος και ένα προαιρετικό seed διεύθυνσης.

<CodeTabs storage="pda-examples"flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:4)
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");

// !focus(1:3)
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

#### Παραγωγή PDA με πολλαπλά seeds

Το παρακάτω παράδειγμα παράγει ένα PDA χρησιμοποιώντας ένα αναγνωριστικό
προγράμματος και πολλαπλά προαιρετικά seeds.

<CodeTabs storage="pda-examples" flags="r">

```ts !! title="Kit"
import {
  Address,
  getAddressEncoder,
  getProgramDerivedAddress
} from "@solana/kit";

const programAddress = "11111111111111111111111111111111" as Address;
// !focus(1:5)
const optionalSeedString = "helloWorld";
const addressEncoder = getAddressEncoder();
const optionalSeedAddress = addressEncoder.encode(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka" as Address
);
const seeds = [optionalSeedString, optionalSeedAddress];
const [pda, bump] = await getProgramDerivedAddress({
  programAddress,
  seeds
});

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```ts !! title="Legacy"
import { PublicKey } from "@solana/web3.js";

const programAddress = new PublicKey("11111111111111111111111111111111");
// !focus(1:4)
const optionalSeedString = "helloWorld";
const optionalSeedAddress = new PublicKey(
  "B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka"
);
const seeds = [Buffer.from(optionalSeedString), optionalSeedAddress.toBuffer()];
const [pda, bump] = await PublicKey.findProgramAddressSync(
  seeds,
  programAddress
);

console.log(`PDA: ${pda}`);
console.log(`Bump: ${bump}`);
```

```rs !! title="Rust"
use solana_sdk::pubkey::Pubkey;
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let program_address = Pubkey::from_str("11111111111111111111111111111111")?;
    // !focus(1:2)
    let optional_seed_bytes = b"helloWorld";
    let optional_seed_address = Pubkey::from_str("B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka")?;
    let seeds: &[&[u8]] = &[optional_seed_bytes, optional_seed_address.as_ref()];
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_address);

    println!("PDA: {}", pda);
    println!("Bump: {}", bump);
    Ok(())
}
```

</CodeTabs>

## Δημιουργία λογαριασμού PDA

<WithMentions>

Το παρακάτω παράδειγμα χρησιμοποιεί το
[Anchor framework](https://www.anchor-lang.com/docs) για να δημιουργήσει έναν
νέο λογαριασμό με διεύθυνση που προέρχεται από πρόγραμμα. Το πρόγραμμα
περιλαμβάνει μία μόνο εντολή [`initialize`](mention:initialize) για τη
δημιουργία του νέου λογαριασμού, ο οποίος θα αποθηκεύσει τη
[διεύθυνση χρήστη](mention:user-address) και το [bump seed](mention:bump) που
χρησιμοποιήθηκε για την παραγωγή του PDA.

```rs title="Program"
use anchor_lang::prelude::*;

declare_id!("75GJVCJNhaukaa2vCCqhreY31gaphv7XTScBChmr1ueR");

#[program]
pub mod pda_account {
    use super::*;

    // !mention initialize
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account_data = &mut ctx.accounts.pda_account;
        // store the address of the `user`
        // !mark
        // !mention user-address
        account_data.user = *ctx.accounts.user.key;
        // store the canonical bumpd
        // !mark
        // !mention bump
        account_data.bump = ctx.bumps.pda_account;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    // !mention user-address
    pub user: Signer<'info>,

    #[account(
        init,
        // define the seeds to derive the PDA
        // !mark
        // !mention user-address
        seeds = [b"data", user.key().as_ref()],
        // use the canonical bump
        // !mark
        // !mention bump
        bump,
        payer = user,
        space = 8 + DataAccount::INIT_SPACE
    )]
    pub pda_account: Account<'info, DataAccount>,
    pub system_program: Program<'info, System>,
}

#[account]
#[derive(InitSpace)]
pub struct DataAccount {
    // !mark
    // !mention user-address
    pub user: Pubkey,
    // !mark
    // !mention bump
    pub bump: u8,
}
```

</WithMentions>

<WithMentions>

Ο περιορισμός [`init`](mention:init) υποδεικνύει στο Anchor να
[καλέσει το System Program](/docs/core/programs#the-system-program) για να
δημιουργήσει έναν νέο λογαριασμό χρησιμοποιώντας το PDA ως διεύθυνση. Τα
[seeds](mention:seeds) που χρησιμοποιούνται για τη δημιουργία του PDA είναι:

- Η διεύθυνση του λογαριασμού χρήστη που παρέχεται στην εντολή
- Η σταθερή συμβολοσειρά: "data"
- Το κανονικό [bump seed](mention:bump)

Σε αυτό το παράδειγμα, ο περιορισμός bump δεν έχει ανατεθεί τιμή, επομένως το
Anchor θα χρησιμοποιήσει τη `find_program_address` για να παράγει το PDA και να
βρει το bump.

```rust title="pda_account"
#[account(
    // !mention init
    init,
    // !mention seeds
    seeds = [b"data", user.key().as_ref()],
    // !mention bump
    bump,
    payer = user,
    space = 8 + DataAccount::INIT_SPACE
)]
pub pda_account: Account<'info, DataAccount>,
```

</WithMentions>

<WithMentions>

Το παρακάτω αρχείο δοκιμών περιέχει μια συναλλαγή που καλεί την εντολή
[`initialize`](mention:initialize) για να δημιουργήσει έναν νέο λογαριασμό με
διεύθυνση που προέρχεται από πρόγραμμα. Το αρχείο περιέχει κώδικα για την
[παραγωγή του PDA](mention:pda).

Το παράδειγμα δείχνει επίσης πώς να [ανακτήσετε](mention:fetch) το νέο
λογαριασμό που θα δημιουργηθεί.

```ts title="Test"
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PdaAccount } from "../target/types/pda_account";
import { PublicKey } from "@solana/web3.js";

describe("pda-account", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.PdaAccount as Program<PdaAccount>;
  const user = provider.wallet as anchor.Wallet;

  // !mention(1:5) pda
  // Derive the PDA address using the seeds specified on the program
  const [PDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("data"), user.publicKey.toBuffer()],
    program.programId
  );

  it("Is initialized!", async () => {
    const transactionSignature = await program.methods
      // !mention initialize
      .initialize()
      .accounts({
        user: user.publicKey
      })
      .rpc();

    console.log("Transaction Signature:", transactionSignature);
  });

  it("Fetch Account", async () => {
    // !mention fetch
    const pdaAccount = await program.account.dataAccount.fetch(PDA);
    console.log(JSON.stringify(pdaAccount, null, 2));
  });
});
```

</WithMentions>

<Callout type="warn">
  Εάν καλέσετε την εντολή `initialize` ξανά με την ίδια διεύθυνση `user` ως
  seed, η συναλλαγή θα αποτύχει. Αυτό συμβαίνει επειδή υπάρχει ήδη λογαριασμός
  στην παραγόμενη διεύθυνση.
</Callout>
