---
title: Δημιουργία ενός Token Mint
description:
  Μάθετε πώς να δημιουργήσετε ένα token mint με την επέκταση Confidential
  Transfer.
---

## Πώς να δημιουργήσετε ένα mint με την επέκταση Confidential Transfer

Η επέκταση Confidential Transfer επιτρέπει ιδιωτικές μεταφορές token
προσθέτοντας επιπλέον κατάσταση στο mint account. Αυτή η ενότητα εξηγεί πώς να
δημιουργήσετε ένα token mint με αυτή την επέκταση ενεργοποιημένη.

Το παρακάτω διάγραμμα δείχνει τα βήματα που εμπλέκονται στη δημιουργία ενός mint
με την επέκταση Confidential Transfer:

```mermaid title="Create Mint with Confidential Transfer Extension"
sequenceDiagram
    participant Payer as Wallet
    participant Token22 as Token Extensions Program
    participant Mint as Mint Account

    Payer->>Token22: create_mint <br>(with Confidential Transfer Extension)
    activate Token22
    Token22-->>Mint: Initialize mint with extension data
    deactivate Token22
```

### Κατάσταση Confidential Transfer Mint

Η επέκταση προσθέτει την κατάσταση
[ConfidentialTransferMint](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/extension/confidential_transfer/mod.rs#L48-L69)
στο mint account:

```rust title="Confidential Mint State"
#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq, Pod, Zeroable)]
pub struct ConfidentialTransferMint {
    /// Authority to modify the `ConfidentialTransferMint` configuration and to
    /// approve new accounts (if `auto_approve_new_accounts` is true)
    ///
    /// The legacy Token Multisig account is not supported as the authority
    pub authority: OptionalNonZeroPubkey,

    /// Indicate if newly configured accounts must be approved by the
    /// `authority` before they may be used by the user.
    ///
    /// * If `true`, no approval is required and new accounts may be used
    ///   immediately
    /// * If `false`, the authority must approve newly configured accounts (see
    ///   `ConfidentialTransferInstruction::ConfigureAccount`)
    pub auto_approve_new_accounts: PodBool,

    /// Authority to decode any transfer amount in a confidential transfer.
    pub auditor_elgamal_pubkey: OptionalNonZeroElGamalPubkey,
}
```

Το _rs`ConfidentialTransferMint`_ περιέχει τρία πεδία διαμόρφωσης:

- **authority**: Ο λογαριασμός που έχει άδεια να αλλάξει τις ρυθμίσεις
  confidential transfer για το mint και να εγκρίνει νέους εμπιστευτικούς
  λογαριασμούς εάν η αυτόματη έγκριση είναι απενεργοποιημένη.

- **auto_approve_new_accounts**: Όταν οριστεί ως true, οι χρήστες μπορούν να
  δημιουργήσουν token accounts με ενεργοποιημένες τις εμπιστευτικές μεταφορές
  από προεπιλογή. Όταν είναι false, η αρχή πρέπει να εγκρίνει κάθε νέο token
  account πριν μπορέσει να χρησιμοποιηθεί για εμπιστευτικές μεταφορές.

- **auditor_elgamal_pubkey**: Ένας προαιρετικός ελεγκτής που μπορεί να
  αποκρυπτογραφήσει ποσά μεταφοράς σε εμπιστευτικές συναλλαγές, παρέχοντας έναν
  μηχανισμό συμμόρφωσης διατηρώντας παράλληλα την ιδιωτικότητα από το ευρύ
  κοινό.

### Απαιτούμενες Οδηγίες

Η δημιουργία ενός mint με ενεργοποιημένο το Confidential Transfer απαιτεί τρεις
οδηγίες σε μία μόνο συναλλαγή:

1. **Δημιουργία του Mint Account**: Καλέστε την οδηγία _rs`CreateAccount`_ του
   System Program για να δημιουργήσετε το mint account.

2. **Αρχικοποίηση της Επέκτασης Confidential Transfer**: Καλέστε την οδηγία
   [ConfidentialTransferInstruction::InitializeMint](https://github.com/solana-program/token-2022/blob/efd0c957fefbd79882d77df5fb2dac88c001249c/program/src/extension/confidential_transfer/processor.rs#L48)
   του Token Extensions Program για να διαμορφώσετε την κατάσταση
   _rs`ConfidentialTransferMint`_ για το mint.

3. **Αρχικοποίηση του Mint**: Καλέστε την οδηγία
   _rs`Instruction::InitializeMint`_ του Token Extensions Program για να
   αρχικοποιήσετε την τυπική κατάσταση του mint.

Ενώ θα μπορούσατε να γράψετε αυτές τις οδηγίες χειροκίνητα, το crate
`spl_token_client` παρέχει μια μέθοδο `create_mint` που δημιουργεί και στέλνει
μια συναλλαγή με όλες τις τρεις οδηγίες σε μία μόνο κλήση συνάρτησης, όπως
φαίνεται στο παράδειγμα παρακάτω.

### Παράδειγμα κώδικα

Ο παρακάτω κώδικας δείχνει πώς να δημιουργήσετε ένα νόμισμα με την επέκταση
Confidential Transfer.

Για να εκτελέσετε το παράδειγμα, ξεκινήστε έναν τοπικό validator με το Token
Extensions Program κλωνοποιημένο από το mainnet χρησιμοποιώντας την ακόλουθη
εντολή. Πρέπει να έχετε εγκατεστημένο το Solana CLI για να ξεκινήσετε τον τοπικό
validator.

```terminal
$ solana-test-validator --clone-upgradeable-program TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb --url https://api.mainnet-beta.solana.com -r
```

```terminal
$ solana-test-validator --clone-upgradeable-program TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb --url https://api.mainnet.solana.com -r
```

<CodeTabs flags="r">

```rust !! title="main.rs"
use anyhow::{Context, Result};
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
};
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    spl_token_2022::id as token_2022_program_id,
    token::{ExtensionInitializationParams, Token},
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local test validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    // Load the default Solana CLI keypair to use as the fee payer
    // This will be the wallet paying for the transaction fees
    // Use Arc to prevent multiple clones of the keypair
    let payer = Arc::new(load_keypair()?);
    println!("Using payer: {}", payer.pubkey());

    // Generate a new keypair to use as the address of the token mint
    let mint = Keypair::new();
    println!("Mint keypair generated: {}", mint.pubkey());

    // Set up program client for Token client
    let program_client =
        ProgramRpcClient::new(Arc::new(rpc_client), ProgramRpcClientSendTransaction);

    // Number of decimals for the mint
    let decimals = 9;

    // Create a token client for the Token-2022 program
    // This provides high-level methods for token operations
    let token = Token::new(
        Arc::new(program_client),
        &token_2022_program_id(), // Use the Token-2022 program (newer version with extensions)
        &mint.pubkey(),           // Address of the new token mint
        Some(decimals),           // Number of decimal places
        payer.clone(),            // Fee payer for transactions (cloning Arc, not keypair)
    );

    // Create extension initialization parameters
    // The ConfidentialTransferMint extension enables confidential (private) transfers of tokens
    let extension_initialization_params =
        vec![ExtensionInitializationParams::ConfidentialTransferMint {
            authority: Some(payer.pubkey()), // Authority that can modify confidential transfer settings
            auto_approve_new_accounts: true, // Automatically approve new confidential accounts
            auditor_elgamal_pubkey: None,    // Optional auditor ElGamal public key
        }];

    // Create and initialize the mint with the ConfidentialTransferMint extension
    // This sends a transaction to create the new token mint
    let transaction_signature = token
        .create_mint(
            &payer.pubkey(),                 // Mint authority - can mint new tokens
            Some(&payer.pubkey()),           // Freeze authority - can freeze token accounts
            extension_initialization_params, // Add the ConfidentialTransferMint extension
            &[&mint],                        // Mint keypair needed as signer
        )
        .await?;

    // Print results for user verification
    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}

// Load the keypair from the default Solana CLI keypair path (~/.config/solana/id.json)
// This enables using the same wallet as the Solana CLI tools
fn load_keypair() -> Result<Keypair> {
    // Get the default keypair path
    let keypair_path = dirs::home_dir()
        .context("Could not find home directory")?
        .join(".config/solana/id.json");

    // Read the keypair file directly into bytes using serde_json
    // The keypair file is a JSON array of bytes
    let file = std::fs::File::open(&keypair_path)?;
    let keypair_bytes: Vec<u8> = serde_json::from_reader(file)?;

    // Create keypair from the loaded bytes
    // This converts the byte array into a keypair
    let keypair = Keypair::from_bytes(&keypair_bytes)?;

    Ok(keypair)
}
```

```toml !! title="Cargo.toml"
[package]
name = "confidential-transfer"
version = "0.1.0"
edition = "2021"

[dependencies]
[package]
name = "confidential-transfer"
version = "0.1.0"
edition = "2021"

[dependencies]
solana-client = "2.2.2"
solana-sdk = "2.2.2"
spl-associated-token-account = "6.0.0"
spl-token-client = "0.14.0"
spl-token-confidential-transfer-proof-extraction = "0.2.1"
spl-token-confidential-transfer-proof-generation = "0.3.0"

anyhow = "1.0.95"
dirs = "6.0.0"
serde_json = "1.0.135"
tokio = { version = "1.44.2", features = ["full"] }
```

</CodeTabs>

```rust !! title="main.rs"
use anyhow::{Context, Result};
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::{Keypair, Signer},
};
use spl_token_client::{
    client::{ProgramRpcClient, ProgramRpcClientSendTransaction},
    spl_token_2022::id as token_2022_program_id,
    token::{ExtensionInitializationParams, Token},
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<()> {
    // Create connection to local test validator
    let rpc_client = RpcClient::new_with_commitment(
        String::from("http://localhost:8899"),
        CommitmentConfig::confirmed(),
    );

    // Load the default Solana CLI keypair to use as the fee payer
    // This will be the wallet paying for the transaction fees
    // Use Arc to prevent multiple clones of the keypair
    let payer = Arc::new(load_keypair()?);
    println!("Using payer: {}", payer.pubkey());

    // Generate a new keypair to use as the address of the token mint
    let mint = Keypair::new();
    println!("Mint keypair generated: {}", mint.pubkey());

    // Set up program client for Token client
    let program_client =
        ProgramRpcClient::new(Arc::new(rpc_client), ProgramRpcClientSendTransaction);

    // Number of decimals for the mint
    let decimals = 9;

    // Create a token client for the Token-2022 program
    // This provides high-level methods for token operations
    let token = Token::new(
        Arc::new(program_client),
        &token_2022_program_id(), // Use the Token-2022 program (newer version with extensions)
        &mint.pubkey(),           // Address of the new token mint
        Some(decimals),           // Number of decimal places
        payer.clone(),            // Fee payer for transactions (cloning Arc, not keypair)
    );

    // Create extension initialization parameters
    // The ConfidentialTransferMint extension enables confidential (private) transfers of tokens
    let extension_initialization_params =
        vec![ExtensionInitializationParams::ConfidentialTransferMint {
            authority: Some(payer.pubkey()), // Authority that can modify confidential transfer settings
            auto_approve_new_accounts: true, // Automatically approve new confidential accounts
            auditor_elgamal_pubkey: None,    // Optional auditor ElGamal public key
        }];

    // Create and initialize the mint with the ConfidentialTransferMint extension
    // This sends a transaction to create the new token mint
    let transaction_signature = token
        .create_mint(
            &payer.pubkey(),                 // Mint authority - can mint new tokens
            Some(&payer.pubkey()),           // Freeze authority - can freeze token accounts
            extension_initialization_params, // Add the ConfidentialTransferMint extension
            &[&mint],                        // Mint keypair needed as signer
        )
        .await?;

    // Print results for user verification
    println!("Mint Address: {}", mint.pubkey());
    println!("Transaction Signature: {}", transaction_signature);

    Ok(())
}

// Load the keypair from the default Solana CLI keypair path (~/.config/solana/id.json)
// This enables using the same wallet as the Solana CLI tools
fn load_keypair() -> Result<Keypair> {
    // Get the default keypair path
    let keypair_path = dirs::home_dir()
        .context("Could not find home directory")?
        .join(".config/solana/id.json");

    // Read the keypair file directly into bytes using serde_json
    // The keypair file is a JSON array of bytes
    let file = std::fs::File::open(&keypair_path)?;
    let keypair_bytes: Vec<u8> = serde_json::from_reader(file)?;

    // Create keypair from the loaded bytes
    // This converts the byte array into a keypair
    let keypair = Keypair::from_bytes(&keypair_bytes)?;

    Ok(keypair)
}
```
